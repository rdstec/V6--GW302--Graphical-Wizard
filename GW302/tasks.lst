   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"tasks.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.prvIdleTask,"ax",%progbits
  18              		.align	2
  19              		.code	16
  20              		.thumb_func
  22              	prvIdleTask:
  23              	.LFB26:
  24              		.file 1 "tasks.c"
   1:tasks.c       **** /*
   2:tasks.c       ****     FreeRTOS V6.1.0 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:tasks.c       **** 
   4:tasks.c       ****     ***************************************************************************
   5:tasks.c       ****     *                                                                         *
   6:tasks.c       ****     * If you are:                                                             *
   7:tasks.c       ****     *                                                                         *
   8:tasks.c       ****     *    + New to FreeRTOS,                                                   *
   9:tasks.c       ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:tasks.c       ****     *    + Looking for basic training,                                        *
  11:tasks.c       ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:tasks.c       ****     *                                                                         *
  13:tasks.c       ****     * then take a look at the FreeRTOS books - available as PDF or paperback  *
  14:tasks.c       ****     *                                                                         *
  15:tasks.c       ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:tasks.c       ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:tasks.c       ****     *                                                                         *
  18:tasks.c       ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:tasks.c       ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:tasks.c       ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:tasks.c       ****     * exceptional circumstances).  Thank you for your support!                *
  22:tasks.c       ****     *                                                                         *
  23:tasks.c       ****     ***************************************************************************
  24:tasks.c       **** 
  25:tasks.c       ****     This file is part of the FreeRTOS distribution.
  26:tasks.c       **** 
  27:tasks.c       ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:tasks.c       ****     the terms of the GNU General Public License (version 2) as published by the
  29:tasks.c       ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:tasks.c       ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:tasks.c       ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:tasks.c       ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:tasks.c       ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:tasks.c       ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:tasks.c       ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:tasks.c       ****     more details. You should have received a copy of the GNU General Public
  37:tasks.c       ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:tasks.c       ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:tasks.c       ****     by writing to Richard Barry, contact details for whom are available on the
  40:tasks.c       ****     FreeRTOS WEB site.
  41:tasks.c       **** 
  42:tasks.c       ****     1 tab == 4 spaces!
  43:tasks.c       **** 
  44:tasks.c       ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:tasks.c       ****     contact details.
  46:tasks.c       **** 
  47:tasks.c       ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:tasks.c       ****     critical systems.
  49:tasks.c       **** 
  50:tasks.c       ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:tasks.c       ****     licensing and training services.
  52:tasks.c       **** */
  53:tasks.c       **** 
  54:tasks.c       **** 
  55:tasks.c       **** #include <stdio.h>
  56:tasks.c       **** #include <stdlib.h>
  57:tasks.c       **** #include <string.h>
  58:tasks.c       **** 
  59:tasks.c       **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:tasks.c       **** all the API functions to use the MPU wrappers.  That should only be done when
  61:tasks.c       **** task.h is included from an application file. */
  62:tasks.c       **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:tasks.c       **** 
  64:tasks.c       **** #include "FreeRTOS.h"
  65:tasks.c       **** #include "task.h"
  66:tasks.c       **** #include "StackMacros.h"
  67:tasks.c       **** 
  68:tasks.c       **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  69:tasks.c       **** 
  70:tasks.c       **** /*
  71:tasks.c       ****  * Macro to define the amount of stack available to the idle task.
  72:tasks.c       ****  */
  73:tasks.c       **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  74:tasks.c       **** 
  75:tasks.c       **** /*
  76:tasks.c       ****  * Task control block.  A task control block (TCB) is allocated to each task,
  77:tasks.c       ****  * and stores the context of the task.
  78:tasks.c       ****  */
  79:tasks.c       **** typedef struct tskTaskControlBlock
  80:tasks.c       **** {
  81:tasks.c       **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  82:tasks.c       **** 
  83:tasks.c       **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  84:tasks.c       **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  85:tasks.c       **** 	#endif	
  86:tasks.c       **** 	
  87:tasks.c       **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  88:tasks.c       **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  89:tasks.c       **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  90:tasks.c       **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  91:tasks.c       **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  92:tasks.c       **** 
  93:tasks.c       **** 	#if ( portSTACK_GROWTH > 0 )
  94:tasks.c       **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  95:tasks.c       **** 	#endif
  96:tasks.c       **** 
  97:tasks.c       **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  98:tasks.c       **** 		unsigned portBASE_TYPE uxCriticalNesting;
  99:tasks.c       **** 	#endif
 100:tasks.c       **** 
 101:tasks.c       **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 102:tasks.c       **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 103:tasks.c       **** 	#endif
 104:tasks.c       **** 
 105:tasks.c       **** 	#if ( configUSE_MUTEXES == 1 )
 106:tasks.c       **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 107:tasks.c       **** 	#endif
 108:tasks.c       **** 
 109:tasks.c       **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 110:tasks.c       **** 		pdTASK_HOOK_CODE pxTaskTag;
 111:tasks.c       **** 	#endif
 112:tasks.c       **** 
 113:tasks.c       **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 114:tasks.c       **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 115:tasks.c       **** 	#endif
 116:tasks.c       **** 
 117:tasks.c       **** } tskTCB;
 118:tasks.c       **** 
 119:tasks.c       **** 
 120:tasks.c       **** /*
 121:tasks.c       ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 122:tasks.c       ****  * than file scope.
 123:tasks.c       ****  */
 124:tasks.c       **** #ifdef portREMOVE_STATIC_QUALIFIER
 125:tasks.c       **** 	#define static
 126:tasks.c       **** #endif
 127:tasks.c       **** 
 128:tasks.c       **** /*lint -e956 */
 129:tasks.c       **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 130:tasks.c       **** 
 131:tasks.c       **** /* Lists for ready and blocked tasks. --------------------*/
 132:tasks.c       **** 
 133:tasks.c       **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 134:tasks.c       **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 135:tasks.c       **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 136:tasks.c       **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 137:tasks.c       **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 138:tasks.c       **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 139:tasks.c       **** 
 140:tasks.c       **** #if ( INCLUDE_vTaskDelete == 1 )
 141:tasks.c       **** 
 142:tasks.c       **** 	PRIVILEGED_DATA static volatile xList xTasksWaitingTermination;		/*< Tasks that have been deleted 
 143:tasks.c       **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 144:tasks.c       **** 
 145:tasks.c       **** #endif
 146:tasks.c       **** 
 147:tasks.c       **** #if ( INCLUDE_vTaskSuspend == 1 )
 148:tasks.c       **** 
 149:tasks.c       **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 150:tasks.c       **** 
 151:tasks.c       **** #endif
 152:tasks.c       **** 
 153:tasks.c       **** /* File private variables. --------------------------------*/
 154:tasks.c       **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 155:tasks.c       **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0;
 156:tasks.c       **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 157:tasks.c       **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 158:tasks.c       **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 159:tasks.c       **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 160:tasks.c       **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 161:tasks.c       **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 162:tasks.c       **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 163:tasks.c       **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0;
 164:tasks.c       **** 
 165:tasks.c       **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 166:tasks.c       **** 
 167:tasks.c       **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 168:tasks.c       **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 169:tasks.c       **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 170:tasks.c       **** 
 171:tasks.c       **** #endif
 172:tasks.c       **** 
 173:tasks.c       **** /* Debugging and trace facilities private variables and macros. ------------*/
 174:tasks.c       **** 
 175:tasks.c       **** /*
 176:tasks.c       ****  * The value used to fill the stack of a task when the task is created.  This
 177:tasks.c       ****  * is used purely for checking the high water mark for tasks.
 178:tasks.c       ****  */
 179:tasks.c       **** #define tskSTACK_FILL_BYTE	( 0xa5 )
 180:tasks.c       **** 
 181:tasks.c       **** /*
 182:tasks.c       ****  * Macros used by vListTask to indicate which state a task is in.
 183:tasks.c       ****  */
 184:tasks.c       **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 185:tasks.c       **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 186:tasks.c       **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 187:tasks.c       **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 188:tasks.c       **** 
 189:tasks.c       **** /*
 190:tasks.c       ****  * Macros and private variables used by the trace facility.
 191:tasks.c       ****  */
 192:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
 193:tasks.c       **** 
 194:tasks.c       **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 195:tasks.c       **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 196:tasks.c       **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 197:tasks.c       **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 198:tasks.c       **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 199:tasks.c       **** 	static unsigned portBASE_TYPE uxPreviousTask = 255;
 200:tasks.c       **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 201:tasks.c       **** 
 202:tasks.c       **** #endif
 203:tasks.c       **** 
 204:tasks.c       **** /*-----------------------------------------------------------*/
 205:tasks.c       **** 
 206:tasks.c       **** /*
 207:tasks.c       ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 208:tasks.c       ****  * shows which task is running when and is very useful as a debugging tool.
 209:tasks.c       ****  * As this macro is called each context switch it is a good idea to undefine
 210:tasks.c       ****  * it if not using the facility.
 211:tasks.c       ****  */
 212:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
 213:tasks.c       **** 
 214:tasks.c       **** 	#define vWriteTraceToBuffer()																				\
 215:tasks.c       **** 	{																											\
 216:tasks.c       **** 		if( xTracing )																							\
 217:tasks.c       **** 		{																										\
 218:tasks.c       **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )													\
 219:tasks.c       **** 			{																									\
 220:tasks.c       **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )							\
 221:tasks.c       **** 				{																								\
 222:tasks.c       **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;													\
 223:tasks.c       **** 					*( unsigned long * ) (( unsigned long )pcTraceBuffer) = ( unsigned long ) xTickCount;		\
 224:tasks.c       **** 					pcTraceBuffer += sizeof( unsigned long );													\
 225:tasks.c       **** 					*( unsigned long * ) (( unsigned long )pcTraceBuffer) = ( unsigned long ) uxPreviousTask;	\
 226:tasks.c       **** 					pcTraceBuffer += sizeof( unsigned long );													\
 227:tasks.c       **** 				}																								\
 228:tasks.c       **** 				else																							\
 229:tasks.c       **** 				{																								\
 230:tasks.c       **** 					xTracing = pdFALSE;																			\
 231:tasks.c       **** 				}																								\
 232:tasks.c       **** 			}																									\
 233:tasks.c       **** 		}																										\
 234:tasks.c       **** 	}
 235:tasks.c       **** 
 236:tasks.c       **** #else
 237:tasks.c       **** 
 238:tasks.c       **** 	#define vWriteTraceToBuffer()
 239:tasks.c       **** 
 240:tasks.c       **** #endif
 241:tasks.c       **** /*-----------------------------------------------------------*/
 242:tasks.c       **** 
 243:tasks.c       **** /*
 244:tasks.c       ****  * Place the task represented by pxTCB into the appropriate ready queue for
 245:tasks.c       ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 246:tasks.c       ****  * that if the task being inserted is at the same priority as the currently
 247:tasks.c       ****  * executing task, then it will only be rescheduled after the currently
 248:tasks.c       ****  * executing task has been rescheduled.
 249:tasks.c       ****  */
 250:tasks.c       **** #define prvAddTaskToReadyQueue( pxTCB )																			\
 251:tasks.c       **** {																												\
 252:tasks.c       **** 	if( pxTCB->uxPriority > uxTopReadyPriority )																\
 253:tasks.c       **** 	{																											\
 254:tasks.c       **** 		uxTopReadyPriority = pxTCB->uxPriority;																	\
 255:tasks.c       **** 	}																											\
 256:tasks.c       **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListIte
 257:tasks.c       **** }
 258:tasks.c       **** /*-----------------------------------------------------------*/
 259:tasks.c       **** 
 260:tasks.c       **** /*
 261:tasks.c       ****  * Macro that looks at the list of tasks that are currently delayed to see if
 262:tasks.c       ****  * any require waking.
 263:tasks.c       ****  *
 264:tasks.c       ****  * Tasks are stored in the queue in the order of their wake time - meaning
 265:tasks.c       ****  * once one tasks has been found whose timer has not expired we need not look
 266:tasks.c       ****  * any further down the list.
 267:tasks.c       ****  */
 268:tasks.c       **** #define prvCheckDelayedTasks()																						\
 269:tasks.c       **** {																													\
 270:tasks.c       **** register tskTCB *pxTCB;																								\
 271:tasks.c       **** 																													\
 272:tasks.c       **** 	while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ) ) != NULL )						\
 273:tasks.c       **** 	{																												\
 274:tasks.c       **** 		if( xTickCount < listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) ) )									\
 275:tasks.c       **** 		{																											\
 276:tasks.c       **** 			break;																									\
 277:tasks.c       **** 		}																											\
 278:tasks.c       **** 		vListRemove( &( pxTCB->xGenericListItem ) );																\
 279:tasks.c       **** 		/* Is the task waiting on an event also? */																	\
 280:tasks.c       **** 		if( pxTCB->xEventListItem.pvContainer )																		\
 281:tasks.c       **** 		{																											\
 282:tasks.c       **** 			vListRemove( &( pxTCB->xEventListItem ) );																\
 283:tasks.c       **** 		}																											\
 284:tasks.c       **** 		prvAddTaskToReadyQueue( pxTCB );																			\
 285:tasks.c       **** 	}																												\
 286:tasks.c       **** }
 287:tasks.c       **** /*-----------------------------------------------------------*/
 288:tasks.c       **** 
 289:tasks.c       **** /*
 290:tasks.c       ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 291:tasks.c       ****  * where NULL is used to indicate that the handle of the currently executing
 292:tasks.c       ****  * task should be used in place of the parameter.  This macro simply checks to
 293:tasks.c       ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 294:tasks.c       ****  */
 295:tasks.c       **** #define prvGetTCBFromHandle( pxHandle ) ( ( pxHandle == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskT
 296:tasks.c       **** 
 297:tasks.c       **** 
 298:tasks.c       **** /* File private functions. --------------------------------*/
 299:tasks.c       **** 
 300:tasks.c       **** /*
 301:tasks.c       ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 302:tasks.c       ****  * into the TCB structure.
 303:tasks.c       ****  */
 304:tasks.c       **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 305:tasks.c       **** 
 306:tasks.c       **** /*
 307:tasks.c       ****  * Utility to ready all the lists used by the scheduler.  This is called
 308:tasks.c       ****  * automatically upon the creation of the first task.
 309:tasks.c       ****  */
 310:tasks.c       **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 311:tasks.c       **** 
 312:tasks.c       **** /*
 313:tasks.c       ****  * The idle task, which as all tasks is implemented as a never ending loop.
 314:tasks.c       ****  * The idle task is automatically created and added to the ready lists upon
 315:tasks.c       ****  * creation of the first user task.
 316:tasks.c       ****  *
 317:tasks.c       ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 318:tasks.c       ****  * language extensions.  The equivalent prototype for this function is:
 319:tasks.c       ****  *
 320:tasks.c       ****  * void prvIdleTask( void *pvParameters );
 321:tasks.c       ****  *
 322:tasks.c       ****  */
 323:tasks.c       **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 324:tasks.c       **** 
 325:tasks.c       **** /*
 326:tasks.c       ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 327:tasks.c       ****  * including the stack pointed to by the TCB.
 328:tasks.c       ****  *
 329:tasks.c       ****  * This does not free memory allocated by the task itself (i.e. memory
 330:tasks.c       ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 331:tasks.c       ****  */
 332:tasks.c       **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
 333:tasks.c       **** 
 334:tasks.c       **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 335:tasks.c       **** 
 336:tasks.c       **** #endif
 337:tasks.c       **** 
 338:tasks.c       **** /*
 339:tasks.c       ****  * Used only by the idle task.  This checks to see if anything has been placed
 340:tasks.c       ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 341:tasks.c       ****  * and its TCB deleted.
 342:tasks.c       ****  */
 343:tasks.c       **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 344:tasks.c       **** 
 345:tasks.c       **** /*
 346:tasks.c       ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 347:tasks.c       ****  * allocation was successful.
 348:tasks.c       ****  */
 349:tasks.c       **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 350:tasks.c       **** 
 351:tasks.c       **** /*
 352:tasks.c       ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 353:tasks.c       ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 354:tasks.c       ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 355:tasks.c       ****  * within just that list.
 356:tasks.c       ****  *
 357:tasks.c       ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 358:tasks.c       ****  * NORMAL APPLICATION CODE.
 359:tasks.c       ****  */
 360:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
 361:tasks.c       **** 
 362:tasks.c       **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 363:tasks.c       **** 
 364:tasks.c       **** #endif
 365:tasks.c       **** 
 366:tasks.c       **** /*
 367:tasks.c       ****  * When a task is created, the stack of the task is filled with a known value.
 368:tasks.c       ****  * This function determines the 'high water mark' of the task stack by
 369:tasks.c       ****  * determining how much of the stack remains at the original preset value.
 370:tasks.c       ****  */
 371:tasks.c       **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 372:tasks.c       **** 
 373:tasks.c       **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 374:tasks.c       **** 
 375:tasks.c       **** #endif
 376:tasks.c       **** 
 377:tasks.c       **** 
 378:tasks.c       **** /*lint +e956 */
 379:tasks.c       **** 
 380:tasks.c       **** 
 381:tasks.c       **** 
 382:tasks.c       **** /*-----------------------------------------------------------
 383:tasks.c       ****  * TASK CREATION API documented in task.h
 384:tasks.c       ****  *----------------------------------------------------------*/
 385:tasks.c       **** 
 386:tasks.c       **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 387:tasks.c       **** {
 388:tasks.c       **** signed portBASE_TYPE xReturn;
 389:tasks.c       **** tskTCB * pxNewTCB;
 390:tasks.c       **** 
 391:tasks.c       **** 	/* Allocate the memory required by the TCB and stack for the new task,
 392:tasks.c       **** 	checking that the allocation was successful. */
 393:tasks.c       **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 394:tasks.c       **** 
 395:tasks.c       **** 	if( pxNewTCB != NULL )
 396:tasks.c       **** 	{
 397:tasks.c       **** 		portSTACK_TYPE *pxTopOfStack;
 398:tasks.c       **** 
 399:tasks.c       **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 400:tasks.c       **** 			/* Should the task be created in privileged mode? */
 401:tasks.c       **** 			portBASE_TYPE xRunPrivileged;
 402:tasks.c       **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0x00 )
 403:tasks.c       **** 			{
 404:tasks.c       **** 				xRunPrivileged = pdTRUE;
 405:tasks.c       **** 			}
 406:tasks.c       **** 			else
 407:tasks.c       **** 			{
 408:tasks.c       **** 				xRunPrivileged = pdFALSE;
 409:tasks.c       **** 			}
 410:tasks.c       **** 			uxPriority &= ~portPRIVILEGE_BIT;
 411:tasks.c       **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 412:tasks.c       **** 
 413:tasks.c       **** 		/* Calculate the top of stack address.  This depends on whether the
 414:tasks.c       **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 415:tasks.c       **** 		portSTACK_GROWTH is used to make the result positive or negative as
 416:tasks.c       **** 		required by the port. */
 417:tasks.c       **** 		#if( portSTACK_GROWTH < 0 )
 418:tasks.c       **** 		{
 419:tasks.c       **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 420:tasks.c       **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~
 421:tasks.c       **** 		}
 422:tasks.c       **** 		#else
 423:tasks.c       **** 		{
 424:tasks.c       **** 			pxTopOfStack = pxNewTCB->pxStack;
 425:tasks.c       **** 
 426:tasks.c       **** 			/* If we want to use stack checking on architectures that use
 427:tasks.c       **** 			a positive stack growth direction then we also need to store the
 428:tasks.c       **** 			other extreme of the stack space. */
 429:tasks.c       **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 430:tasks.c       **** 		}
 431:tasks.c       **** 		#endif
 432:tasks.c       **** 
 433:tasks.c       **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 434:tasks.c       **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 435:tasks.c       **** 
 436:tasks.c       **** 		/* Initialize the TCB stack to look as if the task was already running,
 437:tasks.c       **** 		but had been interrupted by the scheduler.  The return address is set
 438:tasks.c       **** 		to the start of the task function. Once the stack has been initialised
 439:tasks.c       **** 		the	top of stack variable is updated. */
 440:tasks.c       **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 441:tasks.c       **** 		{
 442:tasks.c       **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 443:tasks.c       **** 		}
 444:tasks.c       **** 		#else
 445:tasks.c       **** 		{
 446:tasks.c       **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 447:tasks.c       **** 		}
 448:tasks.c       **** 		#endif
 449:tasks.c       **** 
 450:tasks.c       **** 		if( ( void * ) pxCreatedTask != NULL )
 451:tasks.c       **** 		{
 452:tasks.c       **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 453:tasks.c       **** 			task can use this as a handle to delete the task later if
 454:tasks.c       **** 			required.*/
 455:tasks.c       **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 456:tasks.c       **** 		}
 457:tasks.c       **** 		
 458:tasks.c       **** 		/* We are going to manipulate the task queues to add this task to a
 459:tasks.c       **** 		ready list, so must make sure no interrupts occur. */
 460:tasks.c       **** 		portENTER_CRITICAL();
 461:tasks.c       **** 		{
 462:tasks.c       **** 			uxCurrentNumberOfTasks++;
 463:tasks.c       **** 			if( pxCurrentTCB == NULL )
 464:tasks.c       **** 			{
 465:tasks.c       **** 				/* There are no other tasks, or all the other tasks are in
 466:tasks.c       **** 				the suspended state - make this the current task. */
 467:tasks.c       **** 				pxCurrentTCB =  pxNewTCB;
 468:tasks.c       **** 
 469:tasks.c       **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 470:tasks.c       **** 				{
 471:tasks.c       **** 					/* This is the first task to be created so do the preliminary
 472:tasks.c       **** 					initialisation required.  We will not recover if this call
 473:tasks.c       **** 					fails, but we will report the failure. */
 474:tasks.c       **** 					prvInitialiseTaskLists();
 475:tasks.c       **** 				}
 476:tasks.c       **** 			}
 477:tasks.c       **** 			else
 478:tasks.c       **** 			{
 479:tasks.c       **** 				/* If the scheduler is not already running, make this task the
 480:tasks.c       **** 				current task if it is the highest priority task to be created
 481:tasks.c       **** 				so far. */
 482:tasks.c       **** 				if( xSchedulerRunning == pdFALSE )
 483:tasks.c       **** 				{
 484:tasks.c       **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 485:tasks.c       **** 					{
 486:tasks.c       **** 						pxCurrentTCB = pxNewTCB;
 487:tasks.c       **** 					}
 488:tasks.c       **** 				}
 489:tasks.c       **** 			}
 490:tasks.c       **** 
 491:tasks.c       **** 			/* Remember the top priority to make context switching faster.  Use
 492:tasks.c       **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 493:tasks.c       **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 494:tasks.c       **** 			{
 495:tasks.c       **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 496:tasks.c       **** 			}
 497:tasks.c       **** 
 498:tasks.c       **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 499:tasks.c       **** 			{
 500:tasks.c       **** 				/* Add a counter into the TCB for tracing only. */
 501:tasks.c       **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 502:tasks.c       **** 			}
 503:tasks.c       **** 			#endif
 504:tasks.c       **** 			uxTaskNumber++;
 505:tasks.c       **** 
 506:tasks.c       **** 			prvAddTaskToReadyQueue( pxNewTCB );
 507:tasks.c       **** 
 508:tasks.c       **** 			xReturn = pdPASS;
 509:tasks.c       **** 			traceTASK_CREATE( pxNewTCB );
 510:tasks.c       **** 		}
 511:tasks.c       **** 		portEXIT_CRITICAL();
 512:tasks.c       **** 	}
 513:tasks.c       **** 	else
 514:tasks.c       **** 	{
 515:tasks.c       **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 516:tasks.c       **** 		traceTASK_CREATE_FAILED( pxNewTCB );
 517:tasks.c       **** 	}
 518:tasks.c       **** 
 519:tasks.c       **** 	if( xReturn == pdPASS )
 520:tasks.c       **** 	{
 521:tasks.c       **** 		if( xSchedulerRunning != pdFALSE )
 522:tasks.c       **** 		{
 523:tasks.c       **** 			/* If the created task is of a higher priority than the current task
 524:tasks.c       **** 			then it should run now. */
 525:tasks.c       **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 526:tasks.c       **** 			{
 527:tasks.c       **** 				portYIELD_WITHIN_API();
 528:tasks.c       **** 			}
 529:tasks.c       **** 		}
 530:tasks.c       **** 	}
 531:tasks.c       **** 
 532:tasks.c       **** 	return xReturn;
 533:tasks.c       **** }
 534:tasks.c       **** /*-----------------------------------------------------------*/
 535:tasks.c       **** 
 536:tasks.c       **** #if ( INCLUDE_vTaskDelete == 1 )
 537:tasks.c       **** 
 538:tasks.c       **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 539:tasks.c       **** 	{
 540:tasks.c       **** 	tskTCB *pxTCB;
 541:tasks.c       **** 
 542:tasks.c       **** 		portENTER_CRITICAL();
 543:tasks.c       **** 		{
 544:tasks.c       **** 			/* Ensure a yield is performed if the current task is being
 545:tasks.c       **** 			deleted. */
 546:tasks.c       **** 			if( pxTaskToDelete == pxCurrentTCB )
 547:tasks.c       **** 			{
 548:tasks.c       **** 				pxTaskToDelete = NULL;
 549:tasks.c       **** 			}
 550:tasks.c       **** 
 551:tasks.c       **** 			/* If null is passed in here then we are deleting ourselves. */
 552:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 553:tasks.c       **** 
 554:tasks.c       **** 			/* Remove task from the ready list and place in the	termination list.
 555:tasks.c       **** 			This will stop the task from be scheduled.  The idle task will check
 556:tasks.c       **** 			the termination list and free up any memory allocated by the
 557:tasks.c       **** 			scheduler for the TCB and stack. */
 558:tasks.c       **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 559:tasks.c       **** 
 560:tasks.c       **** 			/* Is the task waiting on an event also? */
 561:tasks.c       **** 			if( pxTCB->xEventListItem.pvContainer )
 562:tasks.c       **** 			{
 563:tasks.c       **** 				vListRemove( &( pxTCB->xEventListItem ) );
 564:tasks.c       **** 			}
 565:tasks.c       **** 
 566:tasks.c       **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 567:tasks.c       **** 
 568:tasks.c       **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 569:tasks.c       **** 			there is a task that has been deleted and that it should therefore
 570:tasks.c       **** 			check the xTasksWaitingTermination list. */
 571:tasks.c       **** 			++uxTasksDeleted;
 572:tasks.c       **** 
 573:tasks.c       **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 574:tasks.c       **** 			can detect that the task lists need re-generating. */
 575:tasks.c       **** 			uxTaskNumber++;
 576:tasks.c       **** 
 577:tasks.c       **** 			traceTASK_DELETE( pxTCB );
 578:tasks.c       **** 		}
 579:tasks.c       **** 		portEXIT_CRITICAL();
 580:tasks.c       **** 
 581:tasks.c       **** 		/* Force a reschedule if we have just deleted the current task. */
 582:tasks.c       **** 		if( xSchedulerRunning != pdFALSE )
 583:tasks.c       **** 		{
 584:tasks.c       **** 			if( ( void * ) pxTaskToDelete == NULL )
 585:tasks.c       **** 			{
 586:tasks.c       **** 				portYIELD_WITHIN_API();
 587:tasks.c       **** 			}
 588:tasks.c       **** 		}
 589:tasks.c       **** 	}
 590:tasks.c       **** 
 591:tasks.c       **** #endif
 592:tasks.c       **** 
 593:tasks.c       **** 
 594:tasks.c       **** 
 595:tasks.c       **** 
 596:tasks.c       **** 
 597:tasks.c       **** 
 598:tasks.c       **** /*-----------------------------------------------------------
 599:tasks.c       ****  * TASK CONTROL API documented in task.h
 600:tasks.c       ****  *----------------------------------------------------------*/
 601:tasks.c       **** 
 602:tasks.c       **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 603:tasks.c       **** 
 604:tasks.c       **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 605:tasks.c       **** 	{
 606:tasks.c       **** 	portTickType xTimeToWake;
 607:tasks.c       **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 608:tasks.c       **** 
 609:tasks.c       **** 		vTaskSuspendAll();
 610:tasks.c       **** 		{
 611:tasks.c       **** 			/* Generate the tick time at which the task wants to wake. */
 612:tasks.c       **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 613:tasks.c       **** 
 614:tasks.c       **** 			if( xTickCount < *pxPreviousWakeTime )
 615:tasks.c       **** 			{
 616:tasks.c       **** 				/* The tick count has overflowed since this function was
 617:tasks.c       **** 				lasted called.  In this case the only time we should ever
 618:tasks.c       **** 				actually delay is if the wake time has also	overflowed,
 619:tasks.c       **** 				and the wake time is greater than the tick time.  When this
 620:tasks.c       **** 				is the case it is as if neither time had overflowed. */
 621:tasks.c       **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 622:tasks.c       **** 				{
 623:tasks.c       **** 					xShouldDelay = pdTRUE;
 624:tasks.c       **** 				}
 625:tasks.c       **** 			}
 626:tasks.c       **** 			else
 627:tasks.c       **** 			{
 628:tasks.c       **** 				/* The tick time has not overflowed.  In this case we will
 629:tasks.c       **** 				delay if either the wake time has overflowed, and/or the
 630:tasks.c       **** 				tick time is less than the wake time. */
 631:tasks.c       **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 632:tasks.c       **** 				{
 633:tasks.c       **** 					xShouldDelay = pdTRUE;
 634:tasks.c       **** 				}
 635:tasks.c       **** 			}
 636:tasks.c       **** 
 637:tasks.c       **** 			/* Update the wake time ready for the next call. */
 638:tasks.c       **** 			*pxPreviousWakeTime = xTimeToWake;
 639:tasks.c       **** 
 640:tasks.c       **** 			if( xShouldDelay )
 641:tasks.c       **** 			{
 642:tasks.c       **** 				traceTASK_DELAY_UNTIL();
 643:tasks.c       **** 
 644:tasks.c       **** 				/* We must remove ourselves from the ready list before adding
 645:tasks.c       **** 				ourselves to the blocked list as the same list item is used for
 646:tasks.c       **** 				both lists. */
 647:tasks.c       **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 648:tasks.c       **** 
 649:tasks.c       **** 				/* The list item will be inserted in wake time order. */
 650:tasks.c       **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 651:tasks.c       **** 
 652:tasks.c       **** 				if( xTimeToWake < xTickCount )
 653:tasks.c       **** 				{
 654:tasks.c       **** 					/* Wake time has overflowed.  Place this item in the
 655:tasks.c       **** 					overflow list. */
 656:tasks.c       **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 657:tasks.c       **** 				}
 658:tasks.c       **** 				else
 659:tasks.c       **** 				{
 660:tasks.c       **** 					/* The wake time has not overflowed, so we can use the
 661:tasks.c       **** 					current block list. */
 662:tasks.c       **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 663:tasks.c       **** 				}
 664:tasks.c       **** 			}
 665:tasks.c       **** 		}
 666:tasks.c       **** 		xAlreadyYielded = xTaskResumeAll();
 667:tasks.c       **** 
 668:tasks.c       **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 669:tasks.c       **** 		have put ourselves to sleep. */
 670:tasks.c       **** 		if( !xAlreadyYielded )
 671:tasks.c       **** 		{
 672:tasks.c       **** 			portYIELD_WITHIN_API();
 673:tasks.c       **** 		}
 674:tasks.c       **** 	}
 675:tasks.c       **** 
 676:tasks.c       **** #endif
 677:tasks.c       **** /*-----------------------------------------------------------*/
 678:tasks.c       **** 
 679:tasks.c       **** #if ( INCLUDE_vTaskDelay == 1 )
 680:tasks.c       **** 
 681:tasks.c       **** 	void vTaskDelay( portTickType xTicksToDelay )
 682:tasks.c       **** 	{
 683:tasks.c       **** 	portTickType xTimeToWake;
 684:tasks.c       **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 685:tasks.c       **** 
 686:tasks.c       **** 		/* A delay time of zero just forces a reschedule. */
 687:tasks.c       **** 		if( xTicksToDelay > ( portTickType ) 0 )
 688:tasks.c       **** 		{
 689:tasks.c       **** 			vTaskSuspendAll();
 690:tasks.c       **** 			{
 691:tasks.c       **** 				traceTASK_DELAY();
 692:tasks.c       **** 
 693:tasks.c       **** 				/* A task that is removed from the event list while the
 694:tasks.c       **** 				scheduler is suspended will not get placed in the ready
 695:tasks.c       **** 				list or removed from the blocked list until the scheduler
 696:tasks.c       **** 				is resumed.
 697:tasks.c       **** 
 698:tasks.c       **** 				This task cannot be in an event list as it is the currently
 699:tasks.c       **** 				executing task. */
 700:tasks.c       **** 
 701:tasks.c       **** 				/* Calculate the time to wake - this may overflow but this is
 702:tasks.c       **** 				not a problem. */
 703:tasks.c       **** 				xTimeToWake = xTickCount + xTicksToDelay;
 704:tasks.c       **** 
 705:tasks.c       **** 				/* We must remove ourselves from the ready list before adding
 706:tasks.c       **** 				ourselves to the blocked list as the same list item is used for
 707:tasks.c       **** 				both lists. */
 708:tasks.c       **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 709:tasks.c       **** 
 710:tasks.c       **** 				/* The list item will be inserted in wake time order. */
 711:tasks.c       **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 712:tasks.c       **** 
 713:tasks.c       **** 				if( xTimeToWake < xTickCount )
 714:tasks.c       **** 				{
 715:tasks.c       **** 					/* Wake time has overflowed.  Place this item in the
 716:tasks.c       **** 					overflow list. */
 717:tasks.c       **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 718:tasks.c       **** 				}
 719:tasks.c       **** 				else
 720:tasks.c       **** 				{
 721:tasks.c       **** 					/* The wake time has not overflowed, so we can use the
 722:tasks.c       **** 					current block list. */
 723:tasks.c       **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 724:tasks.c       **** 				}
 725:tasks.c       **** 			}
 726:tasks.c       **** 			xAlreadyYielded = xTaskResumeAll();
 727:tasks.c       **** 		}
 728:tasks.c       **** 
 729:tasks.c       **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 730:tasks.c       **** 		have put ourselves to sleep. */
 731:tasks.c       **** 		if( !xAlreadyYielded )
 732:tasks.c       **** 		{
 733:tasks.c       **** 			portYIELD_WITHIN_API();
 734:tasks.c       **** 		}
 735:tasks.c       **** 	}
 736:tasks.c       **** 
 737:tasks.c       **** #endif
 738:tasks.c       **** /*-----------------------------------------------------------*/
 739:tasks.c       **** 
 740:tasks.c       **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 741:tasks.c       **** 
 742:tasks.c       **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 743:tasks.c       **** 	{
 744:tasks.c       **** 	tskTCB *pxTCB;
 745:tasks.c       **** 	unsigned portBASE_TYPE uxReturn;
 746:tasks.c       **** 
 747:tasks.c       **** 		portENTER_CRITICAL();
 748:tasks.c       **** 		{
 749:tasks.c       **** 			/* If null is passed in here then we are changing the
 750:tasks.c       **** 			priority of the calling function. */
 751:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 752:tasks.c       **** 			uxReturn = pxTCB->uxPriority;
 753:tasks.c       **** 		}
 754:tasks.c       **** 		portEXIT_CRITICAL();
 755:tasks.c       **** 
 756:tasks.c       **** 		return uxReturn;
 757:tasks.c       **** 	}
 758:tasks.c       **** 
 759:tasks.c       **** #endif
 760:tasks.c       **** /*-----------------------------------------------------------*/
 761:tasks.c       **** 
 762:tasks.c       **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 763:tasks.c       **** 
 764:tasks.c       **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 765:tasks.c       **** 	{
 766:tasks.c       **** 	tskTCB *pxTCB;
 767:tasks.c       **** 	unsigned portBASE_TYPE uxCurrentPriority, xYieldRequired = pdFALSE;
 768:tasks.c       **** 
 769:tasks.c       **** 		/* Ensure the new priority is valid. */
 770:tasks.c       **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 771:tasks.c       **** 		{
 772:tasks.c       **** 			uxNewPriority = configMAX_PRIORITIES - 1;
 773:tasks.c       **** 		}
 774:tasks.c       **** 
 775:tasks.c       **** 		portENTER_CRITICAL();
 776:tasks.c       **** 		{
 777:tasks.c       **** 			if( pxTask == pxCurrentTCB )
 778:tasks.c       **** 			{
 779:tasks.c       **** 				pxTask = NULL;
 780:tasks.c       **** 			}
 781:tasks.c       **** 
 782:tasks.c       **** 			/* If null is passed in here then we are changing the
 783:tasks.c       **** 			priority of the calling function. */
 784:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 785:tasks.c       **** 
 786:tasks.c       **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 787:tasks.c       **** 
 788:tasks.c       **** 			#if ( configUSE_MUTEXES == 1 )
 789:tasks.c       **** 			{
 790:tasks.c       **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 791:tasks.c       **** 			}
 792:tasks.c       **** 			#else
 793:tasks.c       **** 			{
 794:tasks.c       **** 				uxCurrentPriority = pxTCB->uxPriority;
 795:tasks.c       **** 			}
 796:tasks.c       **** 			#endif
 797:tasks.c       **** 
 798:tasks.c       **** 			if( uxCurrentPriority != uxNewPriority )
 799:tasks.c       **** 			{
 800:tasks.c       **** 				/* The priority change may have readied a task of higher
 801:tasks.c       **** 				priority than the calling task. */
 802:tasks.c       **** 				if( uxNewPriority > uxCurrentPriority )
 803:tasks.c       **** 				{
 804:tasks.c       **** 					if( pxTask != NULL )
 805:tasks.c       **** 					{
 806:tasks.c       **** 						/* The priority of another task is being raised.  If we
 807:tasks.c       **** 						were raising the priority of the currently running task
 808:tasks.c       **** 						there would be no need to switch as it must have already
 809:tasks.c       **** 						been the highest priority task. */
 810:tasks.c       **** 						xYieldRequired = pdTRUE;
 811:tasks.c       **** 					}
 812:tasks.c       **** 				}
 813:tasks.c       **** 				else if( pxTask == NULL )
 814:tasks.c       **** 				{
 815:tasks.c       **** 					/* Setting our own priority down means there may now be another
 816:tasks.c       **** 					task of higher priority that is ready to execute. */
 817:tasks.c       **** 					xYieldRequired = pdTRUE;
 818:tasks.c       **** 				}
 819:tasks.c       **** 
 820:tasks.c       **** 
 821:tasks.c       **** 
 822:tasks.c       **** 				#if ( configUSE_MUTEXES == 1 )
 823:tasks.c       **** 				{
 824:tasks.c       **** 					/* Only change the priority being used if the task is not
 825:tasks.c       **** 					currently using an inherited priority. */
 826:tasks.c       **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 827:tasks.c       **** 					{
 828:tasks.c       **** 						pxTCB->uxPriority = uxNewPriority;
 829:tasks.c       **** 					}
 830:tasks.c       **** 
 831:tasks.c       **** 					/* The base priority gets set whatever. */
 832:tasks.c       **** 					pxTCB->uxBasePriority = uxNewPriority;
 833:tasks.c       **** 				}
 834:tasks.c       **** 				#else
 835:tasks.c       **** 				{
 836:tasks.c       **** 					pxTCB->uxPriority = uxNewPriority;
 837:tasks.c       **** 				}
 838:tasks.c       **** 				#endif
 839:tasks.c       **** 
 840:tasks.c       **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 841:tasks.c       **** 
 842:tasks.c       **** 				/* If the task is in the blocked or suspended list we need do
 843:tasks.c       **** 				nothing more than change it's priority variable. However, if
 844:tasks.c       **** 				the task is in a ready list it needs to be removed and placed
 845:tasks.c       **** 				in the queue appropriate to its new priority. */
 846:tasks.c       **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 847:tasks.c       **** 				{
 848:tasks.c       **** 					/* The task is currently in its ready list - remove before adding
 849:tasks.c       **** 					it to it's new ready list.  As we are in a critical section we
 850:tasks.c       **** 					can do this even if the scheduler is suspended. */
 851:tasks.c       **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 852:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 853:tasks.c       **** 				}
 854:tasks.c       **** 
 855:tasks.c       **** 				if( xYieldRequired == pdTRUE )
 856:tasks.c       **** 				{
 857:tasks.c       **** 					portYIELD_WITHIN_API();
 858:tasks.c       **** 				}
 859:tasks.c       **** 			}
 860:tasks.c       **** 		}
 861:tasks.c       **** 		portEXIT_CRITICAL();
 862:tasks.c       **** 	}
 863:tasks.c       **** 
 864:tasks.c       **** #endif
 865:tasks.c       **** /*-----------------------------------------------------------*/
 866:tasks.c       **** 
 867:tasks.c       **** #if ( INCLUDE_vTaskSuspend == 1 )
 868:tasks.c       **** 
 869:tasks.c       **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 870:tasks.c       **** 	{
 871:tasks.c       **** 	tskTCB *pxTCB;
 872:tasks.c       **** 
 873:tasks.c       **** 		portENTER_CRITICAL();
 874:tasks.c       **** 		{
 875:tasks.c       **** 			/* Ensure a yield is performed if the current task is being
 876:tasks.c       **** 			suspended. */
 877:tasks.c       **** 			if( pxTaskToSuspend == pxCurrentTCB )
 878:tasks.c       **** 			{
 879:tasks.c       **** 				pxTaskToSuspend = NULL;
 880:tasks.c       **** 			}
 881:tasks.c       **** 
 882:tasks.c       **** 			/* If null is passed in here then we are suspending ourselves. */
 883:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 884:tasks.c       **** 
 885:tasks.c       **** 			traceTASK_SUSPEND( pxTCB );
 886:tasks.c       **** 
 887:tasks.c       **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 888:tasks.c       **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 889:tasks.c       **** 
 890:tasks.c       **** 			/* Is the task waiting on an event also? */
 891:tasks.c       **** 			if( pxTCB->xEventListItem.pvContainer )
 892:tasks.c       **** 			{
 893:tasks.c       **** 				vListRemove( &( pxTCB->xEventListItem ) );
 894:tasks.c       **** 			}
 895:tasks.c       **** 
 896:tasks.c       **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 897:tasks.c       **** 		}
 898:tasks.c       **** 		portEXIT_CRITICAL();
 899:tasks.c       **** 
 900:tasks.c       **** 		if( ( void * ) pxTaskToSuspend == NULL )
 901:tasks.c       **** 		{
 902:tasks.c       **** 			if( xSchedulerRunning != pdFALSE )
 903:tasks.c       **** 			{
 904:tasks.c       **** 				/* We have just suspended the current task. */
 905:tasks.c       **** 				portYIELD_WITHIN_API();
 906:tasks.c       **** 			}
 907:tasks.c       **** 			else
 908:tasks.c       **** 			{
 909:tasks.c       **** 				/* The scheduler is not running, but the task that was pointed
 910:tasks.c       **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 911:tasks.c       **** 				must be adjusted to point to a different task. */
 912:tasks.c       **** 				if( uxCurrentNumberOfTasks == 1 )
 913:tasks.c       **** 				{
 914:tasks.c       **** 					/* No other tasks are defined, so set pxCurrentTCB back to
 915:tasks.c       **** 					NULL so when the next task is created pxCurrentTCB will
 916:tasks.c       **** 					be set to point to it no matter what its relative priority
 917:tasks.c       **** 					is. */
 918:tasks.c       **** 					pxCurrentTCB = NULL;
 919:tasks.c       **** 				}
 920:tasks.c       **** 				else
 921:tasks.c       **** 				{
 922:tasks.c       **** 					vTaskSwitchContext();
 923:tasks.c       **** 				}
 924:tasks.c       **** 			}
 925:tasks.c       **** 		}
 926:tasks.c       **** 	}
 927:tasks.c       **** 
 928:tasks.c       **** #endif
 929:tasks.c       **** /*-----------------------------------------------------------*/
 930:tasks.c       **** 
 931:tasks.c       **** #if ( INCLUDE_vTaskSuspend == 1 )
 932:tasks.c       **** 
 933:tasks.c       **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 934:tasks.c       **** 	{
 935:tasks.c       **** 	portBASE_TYPE xReturn = pdFALSE;
 936:tasks.c       **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 937:tasks.c       **** 
 938:tasks.c       **** 		/* Is the task we are attempting to resume actually in the
 939:tasks.c       **** 		suspended list? */
 940:tasks.c       **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 941:tasks.c       **** 		{
 942:tasks.c       **** 			/* Has the task already been resumed from within an ISR? */
 943:tasks.c       **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 944:tasks.c       **** 			{
 945:tasks.c       **** 				/* Is it in the suspended list because it is in the
 946:tasks.c       **** 				Suspended state?  It is possible to be in the suspended
 947:tasks.c       **** 				list because it is blocked on a task with no timeout
 948:tasks.c       **** 				specified. */
 949:tasks.c       **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 950:tasks.c       **** 				{
 951:tasks.c       **** 					xReturn = pdTRUE;
 952:tasks.c       **** 				}
 953:tasks.c       **** 			}
 954:tasks.c       **** 		}
 955:tasks.c       **** 
 956:tasks.c       **** 		return xReturn;
 957:tasks.c       **** 	}
 958:tasks.c       **** 
 959:tasks.c       **** #endif
 960:tasks.c       **** /*-----------------------------------------------------------*/
 961:tasks.c       **** 
 962:tasks.c       **** #if ( INCLUDE_vTaskSuspend == 1 )
 963:tasks.c       **** 
 964:tasks.c       **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 965:tasks.c       **** 	{
 966:tasks.c       **** 	tskTCB *pxTCB;
 967:tasks.c       **** 
 968:tasks.c       **** 		/* Remove the task from whichever list it is currently in, and place
 969:tasks.c       **** 		it in the ready list. */
 970:tasks.c       **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 971:tasks.c       **** 
 972:tasks.c       **** 		/* The parameter cannot be NULL as it is impossible to resume the
 973:tasks.c       **** 		currently executing task. */
 974:tasks.c       **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 975:tasks.c       **** 		{
 976:tasks.c       **** 			portENTER_CRITICAL();
 977:tasks.c       **** 			{
 978:tasks.c       **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 979:tasks.c       **** 				{
 980:tasks.c       **** 					traceTASK_RESUME( pxTCB );
 981:tasks.c       **** 
 982:tasks.c       **** 					/* As we are in a critical section we can access the ready
 983:tasks.c       **** 					lists even if the scheduler is suspended. */
 984:tasks.c       **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 985:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 986:tasks.c       **** 
 987:tasks.c       **** 					/* We may have just resumed a higher priority task. */
 988:tasks.c       **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 989:tasks.c       **** 					{
 990:tasks.c       **** 						/* This yield may not cause the task just resumed to run, but
 991:tasks.c       **** 						will leave the lists in the correct state for the next yield. */
 992:tasks.c       **** 						portYIELD_WITHIN_API();
 993:tasks.c       **** 					}
 994:tasks.c       **** 				}
 995:tasks.c       **** 			}
 996:tasks.c       **** 			portEXIT_CRITICAL();
 997:tasks.c       **** 		}
 998:tasks.c       **** 	}
 999:tasks.c       **** 
1000:tasks.c       **** #endif
1001:tasks.c       **** 
1002:tasks.c       **** /*-----------------------------------------------------------*/
1003:tasks.c       **** 
1004:tasks.c       **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1005:tasks.c       **** 
1006:tasks.c       **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1007:tasks.c       **** 	{
1008:tasks.c       **** 	portBASE_TYPE xYieldRequired = pdFALSE;
1009:tasks.c       **** 	tskTCB *pxTCB;
1010:tasks.c       **** 
1011:tasks.c       **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
1012:tasks.c       **** 
1013:tasks.c       **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1014:tasks.c       **** 		{
1015:tasks.c       **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
1016:tasks.c       **** 
1017:tasks.c       **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1018:tasks.c       **** 			{
1019:tasks.c       **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
1020:tasks.c       **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
1021:tasks.c       **** 				prvAddTaskToReadyQueue( pxTCB );
1022:tasks.c       **** 			}
1023:tasks.c       **** 			else
1024:tasks.c       **** 			{
1025:tasks.c       **** 				/* We cannot access the delayed or ready lists, so will hold this
1026:tasks.c       **** 				task pending until the scheduler is resumed, at which point a
1027:tasks.c       **** 				yield will be performed if necessary. */
1028:tasks.c       **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1029:tasks.c       **** 			}
1030:tasks.c       **** 		}
1031:tasks.c       **** 
1032:tasks.c       **** 		return xYieldRequired;
1033:tasks.c       **** 	}
1034:tasks.c       **** 
1035:tasks.c       **** #endif
1036:tasks.c       **** 
1037:tasks.c       **** 
1038:tasks.c       **** 
1039:tasks.c       **** 
1040:tasks.c       **** /*-----------------------------------------------------------
1041:tasks.c       ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1042:tasks.c       ****  *----------------------------------------------------------*/
1043:tasks.c       **** 
1044:tasks.c       **** 
1045:tasks.c       **** void vTaskStartScheduler( void )
1046:tasks.c       **** {
1047:tasks.c       **** portBASE_TYPE xReturn;
1048:tasks.c       **** 
1049:tasks.c       **** 	/* Add the idle task at the lowest priority. */
1050:tasks.c       **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
1051:tasks.c       **** 
1052:tasks.c       **** 	if( xReturn == pdPASS )
1053:tasks.c       **** 	{
1054:tasks.c       **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1055:tasks.c       **** 		before or during the call to xPortStartScheduler().  The stacks of
1056:tasks.c       **** 		the created tasks contain a status word with interrupts switched on
1057:tasks.c       **** 		so interrupts will automatically get re-enabled when the first task
1058:tasks.c       **** 		starts to run.
1059:tasks.c       **** 
1060:tasks.c       **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1061:tasks.c       **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1062:tasks.c       **** 		portDISABLE_INTERRUPTS();
1063:tasks.c       **** 
1064:tasks.c       **** 		xSchedulerRunning = pdTRUE;
1065:tasks.c       **** 		xTickCount = ( portTickType ) 0;
1066:tasks.c       **** 
1067:tasks.c       **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1068:tasks.c       **** 		macro must be defined to configure the timer/counter used to generate
1069:tasks.c       **** 		the run time counter time base. */
1070:tasks.c       **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1071:tasks.c       **** 
1072:tasks.c       **** 		/* Setting up the timer tick is hardware specific and thus in the
1073:tasks.c       **** 		portable interface. */
1074:tasks.c       **** 		if( xPortStartScheduler() )
1075:tasks.c       **** 		{
1076:tasks.c       **** 			/* Should not reach here as if the scheduler is running the
1077:tasks.c       **** 			function will not return. */
1078:tasks.c       **** 		}
1079:tasks.c       **** 		else
1080:tasks.c       **** 		{
1081:tasks.c       **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1082:tasks.c       **** 		}
1083:tasks.c       **** 	}
1084:tasks.c       **** }
1085:tasks.c       **** /*-----------------------------------------------------------*/
1086:tasks.c       **** 
1087:tasks.c       **** void vTaskEndScheduler( void )
1088:tasks.c       **** {
1089:tasks.c       **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1090:tasks.c       **** 	routine so the original ISRs can be restored if necessary.  The port
1091:tasks.c       **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1092:tasks.c       **** 	portDISABLE_INTERRUPTS();
1093:tasks.c       **** 	xSchedulerRunning = pdFALSE;
1094:tasks.c       **** 	vPortEndScheduler();
1095:tasks.c       **** }
1096:tasks.c       **** /*----------------------------------------------------------*/
1097:tasks.c       **** 
1098:tasks.c       **** void vTaskSuspendAll( void )
1099:tasks.c       **** {
1100:tasks.c       **** 	/* A critical section is not required as the variable is of type
1101:tasks.c       **** 	portBASE_TYPE. */
1102:tasks.c       **** 	++uxSchedulerSuspended;
1103:tasks.c       **** }
1104:tasks.c       **** /*----------------------------------------------------------*/
1105:tasks.c       **** 
1106:tasks.c       **** signed portBASE_TYPE xTaskResumeAll( void )
1107:tasks.c       **** {
1108:tasks.c       **** register tskTCB *pxTCB;
1109:tasks.c       **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1110:tasks.c       **** 
1111:tasks.c       **** 	/* It is possible that an ISR caused a task to be removed from an event
1112:tasks.c       **** 	list while the scheduler was suspended.  If this was the case then the
1113:tasks.c       **** 	removed task will have been added to the xPendingReadyList.  Once the
1114:tasks.c       **** 	scheduler has been resumed it is safe to move all the pending ready
1115:tasks.c       **** 	tasks from this list into their appropriate ready list. */
1116:tasks.c       **** 	portENTER_CRITICAL();
1117:tasks.c       **** 	{
1118:tasks.c       **** 		--uxSchedulerSuspended;
1119:tasks.c       **** 
1120:tasks.c       **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1121:tasks.c       **** 		{
1122:tasks.c       **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
1123:tasks.c       **** 			{
1124:tasks.c       **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1125:tasks.c       **** 
1126:tasks.c       **** 				/* Move any readied tasks from the pending list into the
1127:tasks.c       **** 				appropriate ready list. */
1128:tasks.c       **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
1129:tasks.c       **** 				{
1130:tasks.c       **** 					vListRemove( &( pxTCB->xEventListItem ) );
1131:tasks.c       **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1132:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
1133:tasks.c       **** 
1134:tasks.c       **** 					/* If we have moved a task that has a priority higher than
1135:tasks.c       **** 					the current task then we should yield. */
1136:tasks.c       **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1137:tasks.c       **** 					{
1138:tasks.c       **** 						xYieldRequired = pdTRUE;
1139:tasks.c       **** 					}
1140:tasks.c       **** 				}
1141:tasks.c       **** 
1142:tasks.c       **** 				/* If any ticks occurred while the scheduler was suspended then
1143:tasks.c       **** 				they should be processed now.  This ensures the tick count does not
1144:tasks.c       **** 				slip, and that any delayed tasks are resumed at the correct time. */
1145:tasks.c       **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1146:tasks.c       **** 				{
1147:tasks.c       **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1148:tasks.c       **** 					{
1149:tasks.c       **** 						vTaskIncrementTick();
1150:tasks.c       **** 						--uxMissedTicks;
1151:tasks.c       **** 					}
1152:tasks.c       **** 
1153:tasks.c       **** 					/* As we have processed some ticks it is appropriate to yield
1154:tasks.c       **** 					to ensure the highest priority task that is ready to run is
1155:tasks.c       **** 					the task actually running. */
1156:tasks.c       **** 					#if configUSE_PREEMPTION == 1
1157:tasks.c       **** 					{
1158:tasks.c       **** 						xYieldRequired = pdTRUE;
1159:tasks.c       **** 					}
1160:tasks.c       **** 					#endif
1161:tasks.c       **** 				}
1162:tasks.c       **** 
1163:tasks.c       **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1164:tasks.c       **** 				{
1165:tasks.c       **** 					xAlreadyYielded = pdTRUE;
1166:tasks.c       **** 					xMissedYield = pdFALSE;
1167:tasks.c       **** 					portYIELD_WITHIN_API();
1168:tasks.c       **** 				}
1169:tasks.c       **** 			}
1170:tasks.c       **** 		}
1171:tasks.c       **** 	}
1172:tasks.c       **** 	portEXIT_CRITICAL();
1173:tasks.c       **** 
1174:tasks.c       **** 	return xAlreadyYielded;
1175:tasks.c       **** }
1176:tasks.c       **** 
1177:tasks.c       **** 
1178:tasks.c       **** 
1179:tasks.c       **** 
1180:tasks.c       **** 
1181:tasks.c       **** 
1182:tasks.c       **** /*-----------------------------------------------------------
1183:tasks.c       ****  * PUBLIC TASK UTILITIES documented in task.h
1184:tasks.c       ****  *----------------------------------------------------------*/
1185:tasks.c       **** 
1186:tasks.c       **** 
1187:tasks.c       **** 
1188:tasks.c       **** portTickType xTaskGetTickCount( void )
1189:tasks.c       **** {
1190:tasks.c       **** portTickType xTicks;
1191:tasks.c       **** 
1192:tasks.c       **** 	/* Critical section required if running on a 16 bit processor. */
1193:tasks.c       **** 	portENTER_CRITICAL();
1194:tasks.c       **** 	{
1195:tasks.c       **** 		xTicks = xTickCount;
1196:tasks.c       **** 	}
1197:tasks.c       **** 	portEXIT_CRITICAL();
1198:tasks.c       **** 
1199:tasks.c       **** 	return xTicks;
1200:tasks.c       **** }
1201:tasks.c       **** /*-----------------------------------------------------------*/
1202:tasks.c       **** 
1203:tasks.c       **** portTickType xTaskGetTickCountFromISR( void )
1204:tasks.c       **** {
1205:tasks.c       **** 	return xTickCount;
1206:tasks.c       **** }
1207:tasks.c       **** /*-----------------------------------------------------------*/
1208:tasks.c       **** 
1209:tasks.c       **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1210:tasks.c       **** {
1211:tasks.c       **** 	/* A critical section is not required because the variables are of type
1212:tasks.c       **** 	portBASE_TYPE. */
1213:tasks.c       **** 	return uxCurrentNumberOfTasks;
1214:tasks.c       **** }
1215:tasks.c       **** /*-----------------------------------------------------------*/
1216:tasks.c       **** 
1217:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
1218:tasks.c       **** 
1219:tasks.c       **** 	void vTaskList( signed char *pcWriteBuffer )
1220:tasks.c       **** 	{
1221:tasks.c       **** 	unsigned portBASE_TYPE uxQueue;
1222:tasks.c       **** 
1223:tasks.c       **** 		/* This is a VERY costly function that should be used for debug only.
1224:tasks.c       **** 		It leaves interrupts disabled for a LONG time. */
1225:tasks.c       **** 
1226:tasks.c       **** 		vTaskSuspendAll();
1227:tasks.c       **** 		{
1228:tasks.c       **** 			/* Run through all the lists that could potentially contain a TCB and
1229:tasks.c       **** 			report the task name, state and stack high water mark. */
1230:tasks.c       **** 
1231:tasks.c       **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1232:tasks.c       **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1233:tasks.c       **** 
1234:tasks.c       **** 			uxQueue = uxTopUsedPriority + 1;
1235:tasks.c       **** 
1236:tasks.c       **** 			do
1237:tasks.c       **** 			{
1238:tasks.c       **** 				uxQueue--;
1239:tasks.c       **** 
1240:tasks.c       **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1241:tasks.c       **** 				{
1242:tasks.c       **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1243:tasks.c       **** 				}
1244:tasks.c       **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1245:tasks.c       **** 
1246:tasks.c       **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1247:tasks.c       **** 			{
1248:tasks.c       **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1249:tasks.c       **** 			}
1250:tasks.c       **** 
1251:tasks.c       **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1252:tasks.c       **** 			{
1253:tasks.c       **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1254:tasks.c       **** 			}
1255:tasks.c       **** 
1256:tasks.c       **** 			#if( INCLUDE_vTaskDelete == 1 )
1257:tasks.c       **** 			{
1258:tasks.c       **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1259:tasks.c       **** 				{
1260:tasks.c       **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_
1261:tasks.c       **** 				}
1262:tasks.c       **** 			}
1263:tasks.c       **** 			#endif
1264:tasks.c       **** 
1265:tasks.c       **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1266:tasks.c       **** 			{
1267:tasks.c       **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1268:tasks.c       **** 				{
1269:tasks.c       **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
1270:tasks.c       **** 				}
1271:tasks.c       **** 			}
1272:tasks.c       **** 			#endif
1273:tasks.c       **** 		}
1274:tasks.c       **** 		xTaskResumeAll();
1275:tasks.c       **** 	}
1276:tasks.c       **** 
1277:tasks.c       **** #endif
1278:tasks.c       **** /*----------------------------------------------------------*/
1279:tasks.c       **** 
1280:tasks.c       **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1281:tasks.c       **** 
1282:tasks.c       **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1283:tasks.c       **** 	{
1284:tasks.c       **** 	unsigned portBASE_TYPE uxQueue;
1285:tasks.c       **** 	unsigned long ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1286:tasks.c       **** 
1287:tasks.c       **** 		/* This is a VERY costly function that should be used for debug only.
1288:tasks.c       **** 		It leaves interrupts disabled for a LONG time. */
1289:tasks.c       **** 
1290:tasks.c       **** 		vTaskSuspendAll();
1291:tasks.c       **** 		{
1292:tasks.c       **** 			/* Run through all the lists that could potentially contain a TCB,
1293:tasks.c       **** 			generating a table of run timer percentages in the provided
1294:tasks.c       **** 			buffer. */
1295:tasks.c       **** 
1296:tasks.c       **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1297:tasks.c       **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1298:tasks.c       **** 
1299:tasks.c       **** 			uxQueue = uxTopUsedPriority + 1;
1300:tasks.c       **** 
1301:tasks.c       **** 			do
1302:tasks.c       **** 			{
1303:tasks.c       **** 				uxQueue--;
1304:tasks.c       **** 
1305:tasks.c       **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1306:tasks.c       **** 				{
1307:tasks.c       **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1308:tasks.c       **** 				}
1309:tasks.c       **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1310:tasks.c       **** 
1311:tasks.c       **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1312:tasks.c       **** 			{
1313:tasks.c       **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1314:tasks.c       **** 			}
1315:tasks.c       **** 
1316:tasks.c       **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1317:tasks.c       **** 			{
1318:tasks.c       **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1319:tasks.c       **** 			}
1320:tasks.c       **** 
1321:tasks.c       **** 			#if ( INCLUDE_vTaskDelete == 1 )
1322:tasks.c       **** 			{
1323:tasks.c       **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1324:tasks.c       **** 				{
1325:tasks.c       **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, u
1326:tasks.c       **** 				}
1327:tasks.c       **** 			}
1328:tasks.c       **** 			#endif
1329:tasks.c       **** 
1330:tasks.c       **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1331:tasks.c       **** 			{
1332:tasks.c       **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1333:tasks.c       **** 				{
1334:tasks.c       **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, ulTotal
1335:tasks.c       **** 				}
1336:tasks.c       **** 			}
1337:tasks.c       **** 			#endif
1338:tasks.c       **** 		}
1339:tasks.c       **** 		xTaskResumeAll();
1340:tasks.c       **** 	}
1341:tasks.c       **** 
1342:tasks.c       **** #endif
1343:tasks.c       **** /*----------------------------------------------------------*/
1344:tasks.c       **** 
1345:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
1346:tasks.c       **** 
1347:tasks.c       **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1348:tasks.c       **** 	{
1349:tasks.c       **** 		portENTER_CRITICAL();
1350:tasks.c       **** 		{
1351:tasks.c       **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1352:tasks.c       **** 			pcTraceBufferStart = pcBuffer;
1353:tasks.c       **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1354:tasks.c       **** 			xTracing = pdTRUE;
1355:tasks.c       **** 		}
1356:tasks.c       **** 		portEXIT_CRITICAL();
1357:tasks.c       **** 	}
1358:tasks.c       **** 
1359:tasks.c       **** #endif
1360:tasks.c       **** /*----------------------------------------------------------*/
1361:tasks.c       **** 
1362:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
1363:tasks.c       **** 
1364:tasks.c       **** 	unsigned long ulTaskEndTrace( void )
1365:tasks.c       **** 	{
1366:tasks.c       **** 	unsigned long ulBufferLength;
1367:tasks.c       **** 
1368:tasks.c       **** 		portENTER_CRITICAL();
1369:tasks.c       **** 			xTracing = pdFALSE;
1370:tasks.c       **** 		portEXIT_CRITICAL();
1371:tasks.c       **** 
1372:tasks.c       **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1373:tasks.c       **** 
1374:tasks.c       **** 		return ulBufferLength;
1375:tasks.c       **** 	}
1376:tasks.c       **** 
1377:tasks.c       **** #endif
1378:tasks.c       **** 
1379:tasks.c       **** 
1380:tasks.c       **** 
1381:tasks.c       **** /*-----------------------------------------------------------
1382:tasks.c       ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1383:tasks.c       ****  * documented in task.h
1384:tasks.c       ****  *----------------------------------------------------------*/
1385:tasks.c       **** 
1386:tasks.c       **** 
1387:tasks.c       **** void vTaskIncrementTick( void )
1388:tasks.c       **** {
1389:tasks.c       **** 	/* Called by the portable layer each time a tick interrupt occurs.
1390:tasks.c       **** 	Increments the tick then checks to see if the new tick value will cause any
1391:tasks.c       **** 	tasks to be unblocked. */
1392:tasks.c       **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1393:tasks.c       **** 	{
1394:tasks.c       **** 		++xTickCount;
1395:tasks.c       **** 		if( xTickCount == ( portTickType ) 0 )
1396:tasks.c       **** 		{
1397:tasks.c       **** 			xList *pxTemp;
1398:tasks.c       **** 
1399:tasks.c       **** 			/* Tick count has overflowed so we need to swap the delay lists.
1400:tasks.c       **** 			If there are any items in pxDelayedTaskList here then there is
1401:tasks.c       **** 			an error! */
1402:tasks.c       **** 			pxTemp = pxDelayedTaskList;
1403:tasks.c       **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1404:tasks.c       **** 			pxOverflowDelayedTaskList = pxTemp;
1405:tasks.c       **** 			xNumOfOverflows++;
1406:tasks.c       **** 		}
1407:tasks.c       **** 
1408:tasks.c       **** 		/* See if this tick has made a timeout expire. */
1409:tasks.c       **** 		prvCheckDelayedTasks();
1410:tasks.c       **** 	}
1411:tasks.c       **** 	else
1412:tasks.c       **** 	{
1413:tasks.c       **** 		++uxMissedTicks;
1414:tasks.c       **** 
1415:tasks.c       **** 		/* The tick hook gets called at regular intervals, even if the
1416:tasks.c       **** 		scheduler is locked. */
1417:tasks.c       **** 		#if ( configUSE_TICK_HOOK == 1 )
1418:tasks.c       **** 		{
1419:tasks.c       **** 			extern void vApplicationTickHook( void );
1420:tasks.c       **** 
1421:tasks.c       **** 			vApplicationTickHook();
1422:tasks.c       **** 		}
1423:tasks.c       **** 		#endif
1424:tasks.c       **** 	}
1425:tasks.c       **** 
1426:tasks.c       **** 	#if ( configUSE_TICK_HOOK == 1 )
1427:tasks.c       **** 	{
1428:tasks.c       **** 		extern void vApplicationTickHook( void );
1429:tasks.c       **** 
1430:tasks.c       **** 		/* Guard against the tick hook being called when the missed tick
1431:tasks.c       **** 		count is being unwound (when the scheduler is being unlocked. */
1432:tasks.c       **** 		if( uxMissedTicks == 0 )
1433:tasks.c       **** 		{
1434:tasks.c       **** 			vApplicationTickHook();
1435:tasks.c       **** 		}
1436:tasks.c       **** 	}
1437:tasks.c       **** 	#endif
1438:tasks.c       **** 
1439:tasks.c       **** 	traceTASK_INCREMENT_TICK( xTickCount );
1440:tasks.c       **** }
1441:tasks.c       **** /*-----------------------------------------------------------*/
1442:tasks.c       **** 
1443:tasks.c       **** #if ( ( INCLUDE_vTaskCleanUpResources == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1444:tasks.c       **** 
1445:tasks.c       **** 	void vTaskCleanUpResources( void )
1446:tasks.c       **** 	{
1447:tasks.c       **** 	unsigned short usQueue;
1448:tasks.c       **** 	volatile tskTCB *pxTCB;
1449:tasks.c       **** 
1450:tasks.c       **** 		usQueue = ( unsigned short ) uxTopUsedPriority + ( unsigned short ) 1;
1451:tasks.c       **** 
1452:tasks.c       **** 		/* Remove any TCB's from the ready queues. */
1453:tasks.c       **** 		do
1454:tasks.c       **** 		{
1455:tasks.c       **** 			usQueue--;
1456:tasks.c       **** 
1457:tasks.c       **** 			while( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
1458:tasks.c       **** 			{
1459:tasks.c       **** 				listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &( pxReadyTasksLists[ usQueue ] ) );
1460:tasks.c       **** 				vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1461:tasks.c       **** 
1462:tasks.c       **** 				prvDeleteTCB( ( tskTCB * ) pxTCB );
1463:tasks.c       **** 			}
1464:tasks.c       **** 		}while( usQueue > ( unsigned short ) tskIDLE_PRIORITY );
1465:tasks.c       **** 
1466:tasks.c       **** 		/* Remove any TCB's from the delayed queue. */
1467:tasks.c       **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList1 ) )
1468:tasks.c       **** 		{
1469:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList1 );
1470:tasks.c       **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1471:tasks.c       **** 
1472:tasks.c       **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1473:tasks.c       **** 		}
1474:tasks.c       **** 
1475:tasks.c       **** 		/* Remove any TCB's from the overflow delayed queue. */
1476:tasks.c       **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList2 ) )
1477:tasks.c       **** 		{
1478:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList2 );
1479:tasks.c       **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1480:tasks.c       **** 
1481:tasks.c       **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1482:tasks.c       **** 		}
1483:tasks.c       **** 
1484:tasks.c       **** 		while( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1485:tasks.c       **** 		{
1486:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
1487:tasks.c       **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1488:tasks.c       **** 
1489:tasks.c       **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1490:tasks.c       **** 		}
1491:tasks.c       **** 	}
1492:tasks.c       **** 
1493:tasks.c       **** #endif
1494:tasks.c       **** /*-----------------------------------------------------------*/
1495:tasks.c       **** 
1496:tasks.c       **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1497:tasks.c       **** 
1498:tasks.c       **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxTagValue )
1499:tasks.c       **** 	{
1500:tasks.c       **** 	tskTCB *xTCB;
1501:tasks.c       **** 
1502:tasks.c       **** 		/* If xTask is NULL then we are setting our own task hook. */
1503:tasks.c       **** 		if( xTask == NULL )
1504:tasks.c       **** 		{
1505:tasks.c       **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1506:tasks.c       **** 		}
1507:tasks.c       **** 		else
1508:tasks.c       **** 		{
1509:tasks.c       **** 			xTCB = ( tskTCB * ) xTask;
1510:tasks.c       **** 		}
1511:tasks.c       **** 
1512:tasks.c       **** 		/* Save the hook function in the TCB.  A critical section is required as
1513:tasks.c       **** 		the value can be accessed from an interrupt. */
1514:tasks.c       **** 		portENTER_CRITICAL();
1515:tasks.c       **** 			xTCB->pxTaskTag = pxTagValue;
1516:tasks.c       **** 		portEXIT_CRITICAL();
1517:tasks.c       **** 	}
1518:tasks.c       **** 
1519:tasks.c       **** #endif
1520:tasks.c       **** /*-----------------------------------------------------------*/
1521:tasks.c       **** 
1522:tasks.c       **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1523:tasks.c       **** 
1524:tasks.c       **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1525:tasks.c       **** 	{
1526:tasks.c       **** 	tskTCB *xTCB;
1527:tasks.c       **** 	pdTASK_HOOK_CODE xReturn;
1528:tasks.c       **** 
1529:tasks.c       **** 		/* If xTask is NULL then we are setting our own task hook. */
1530:tasks.c       **** 		if( xTask == NULL )
1531:tasks.c       **** 		{
1532:tasks.c       **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1533:tasks.c       **** 		}
1534:tasks.c       **** 		else
1535:tasks.c       **** 		{
1536:tasks.c       **** 			xTCB = ( tskTCB * ) xTask;
1537:tasks.c       **** 		}
1538:tasks.c       **** 
1539:tasks.c       **** 		/* Save the hook function in the TCB.  A critical section is required as
1540:tasks.c       **** 		the value can be accessed from an interrupt. */
1541:tasks.c       **** 		portENTER_CRITICAL();
1542:tasks.c       **** 			xReturn = xTCB->pxTaskTag;
1543:tasks.c       **** 		portEXIT_CRITICAL();
1544:tasks.c       **** 
1545:tasks.c       **** 		return xReturn;
1546:tasks.c       **** 	}
1547:tasks.c       **** 
1548:tasks.c       **** #endif
1549:tasks.c       **** /*-----------------------------------------------------------*/
1550:tasks.c       **** 
1551:tasks.c       **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1552:tasks.c       **** 
1553:tasks.c       **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1554:tasks.c       **** 	{
1555:tasks.c       **** 	tskTCB *xTCB;
1556:tasks.c       **** 	portBASE_TYPE xReturn;
1557:tasks.c       **** 
1558:tasks.c       **** 		/* If xTask is NULL then we are calling our own task hook. */
1559:tasks.c       **** 		if( xTask == NULL )
1560:tasks.c       **** 		{
1561:tasks.c       **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1562:tasks.c       **** 		}
1563:tasks.c       **** 		else
1564:tasks.c       **** 		{
1565:tasks.c       **** 			xTCB = ( tskTCB * ) xTask;
1566:tasks.c       **** 		}
1567:tasks.c       **** 
1568:tasks.c       **** 		if( xTCB->pxTaskTag != NULL )
1569:tasks.c       **** 		{
1570:tasks.c       **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1571:tasks.c       **** 		}
1572:tasks.c       **** 		else
1573:tasks.c       **** 		{
1574:tasks.c       **** 			xReturn = pdFAIL;
1575:tasks.c       **** 		}
1576:tasks.c       **** 
1577:tasks.c       **** 		return xReturn;
1578:tasks.c       **** 	}
1579:tasks.c       **** 
1580:tasks.c       **** #endif
1581:tasks.c       **** /*-----------------------------------------------------------*/
1582:tasks.c       **** 
1583:tasks.c       **** void vTaskSwitchContext( void )
1584:tasks.c       **** {
1585:tasks.c       **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1586:tasks.c       **** 	{
1587:tasks.c       **** 		/* The scheduler is currently suspended - do not allow a context
1588:tasks.c       **** 		switch. */
1589:tasks.c       **** 		xMissedYield = pdTRUE;
1590:tasks.c       **** 		return;
1591:tasks.c       **** 	}
1592:tasks.c       **** 
1593:tasks.c       **** 	traceTASK_SWITCHED_OUT();
1594:tasks.c       **** 
1595:tasks.c       **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1596:tasks.c       **** 	{
1597:tasks.c       **** 		unsigned long ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1598:tasks.c       **** 
1599:tasks.c       **** 			/* Add the amount of time the task has been running to the accumulated
1600:tasks.c       **** 			time so far.  The time the task started running was stored in
1601:tasks.c       **** 			ulTaskSwitchedInTime.  Note that there is no overflow protection here
1602:tasks.c       **** 			so count values are only valid until the timer overflows.  Generally
1603:tasks.c       **** 			this will be about 1 hour assuming a 1uS timer increment. */
1604:tasks.c       **** 			pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1605:tasks.c       **** 			ulTaskSwitchedInTime = ulTempCounter;
1606:tasks.c       **** 	}
1607:tasks.c       **** 	#endif
1608:tasks.c       **** 
1609:tasks.c       **** 	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1610:tasks.c       **** 	taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1611:tasks.c       **** 
1612:tasks.c       **** 	/* Find the highest priority queue that contains ready tasks. */
1613:tasks.c       **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1614:tasks.c       **** 	{
1615:tasks.c       **** 		--uxTopReadyPriority;
1616:tasks.c       **** 	}
1617:tasks.c       **** 
1618:tasks.c       **** 	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1619:tasks.c       **** 	same priority get an equal share of the processor time. */
1620:tasks.c       **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
1621:tasks.c       **** 
1622:tasks.c       **** 	traceTASK_SWITCHED_IN();
1623:tasks.c       **** 	vWriteTraceToBuffer();
1624:tasks.c       **** }
1625:tasks.c       **** /*-----------------------------------------------------------*/
1626:tasks.c       **** 
1627:tasks.c       **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1628:tasks.c       **** {
1629:tasks.c       **** portTickType xTimeToWake;
1630:tasks.c       **** 
1631:tasks.c       **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1632:tasks.c       **** 	SCHEDULER SUSPENDED. */
1633:tasks.c       **** 
1634:tasks.c       **** 	/* Place the event list item of the TCB in the appropriate event list.
1635:tasks.c       **** 	This is placed in the list in priority order so the highest priority task
1636:tasks.c       **** 	is the first to be woken by the event. */
1637:tasks.c       **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1638:tasks.c       **** 
1639:tasks.c       **** 	/* We must remove ourselves from the ready list before adding ourselves
1640:tasks.c       **** 	to the blocked list as the same list item is used for both lists.  We have
1641:tasks.c       **** 	exclusive access to the ready lists as the scheduler is locked. */
1642:tasks.c       **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1643:tasks.c       **** 
1644:tasks.c       **** 
1645:tasks.c       **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1646:tasks.c       **** 	{
1647:tasks.c       **** 		if( xTicksToWait == portMAX_DELAY )
1648:tasks.c       **** 		{
1649:tasks.c       **** 			/* Add ourselves to the suspended task list instead of a delayed task
1650:tasks.c       **** 			list to ensure we are not woken by a timing event.  We will block
1651:tasks.c       **** 			indefinitely. */
1652:tasks.c       **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1653:tasks.c       **** 		}
1654:tasks.c       **** 		else
1655:tasks.c       **** 		{
1656:tasks.c       **** 			/* Calculate the time at which the task should be woken if the event does
1657:tasks.c       **** 			not occur.  This may overflow but this doesn't matter. */
1658:tasks.c       **** 			xTimeToWake = xTickCount + xTicksToWait;
1659:tasks.c       **** 
1660:tasks.c       **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1661:tasks.c       **** 
1662:tasks.c       **** 			if( xTimeToWake < xTickCount )
1663:tasks.c       **** 			{
1664:tasks.c       **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1665:tasks.c       **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1666:tasks.c       **** 			}
1667:tasks.c       **** 			else
1668:tasks.c       **** 			{
1669:tasks.c       **** 				/* The wake time has not overflowed, so we can use the current block list. */
1670:tasks.c       **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1671:tasks.c       **** 			}
1672:tasks.c       **** 		}
1673:tasks.c       **** 	}
1674:tasks.c       **** 	#else
1675:tasks.c       **** 	{
1676:tasks.c       **** 			/* Calculate the time at which the task should be woken if the event does
1677:tasks.c       **** 			not occur.  This may overflow but this doesn't matter. */
1678:tasks.c       **** 			xTimeToWake = xTickCount + xTicksToWait;
1679:tasks.c       **** 
1680:tasks.c       **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1681:tasks.c       **** 
1682:tasks.c       **** 			if( xTimeToWake < xTickCount )
1683:tasks.c       **** 			{
1684:tasks.c       **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1685:tasks.c       **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1686:tasks.c       **** 			}
1687:tasks.c       **** 			else
1688:tasks.c       **** 			{
1689:tasks.c       **** 				/* The wake time has not overflowed, so we can use the current block list. */
1690:tasks.c       **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1691:tasks.c       **** 			}
1692:tasks.c       **** 	}
1693:tasks.c       **** 	#endif
1694:tasks.c       **** }
1695:tasks.c       **** /*-----------------------------------------------------------*/
1696:tasks.c       **** 
1697:tasks.c       **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1698:tasks.c       **** {
1699:tasks.c       **** tskTCB *pxUnblockedTCB;
1700:tasks.c       **** portBASE_TYPE xReturn;
1701:tasks.c       **** 
1702:tasks.c       **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1703:tasks.c       **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1704:tasks.c       **** 
1705:tasks.c       **** 	/* The event list is sorted in priority order, so we can remove the
1706:tasks.c       **** 	first in the list, remove the TCB from the delayed list, and add
1707:tasks.c       **** 	it to the ready list.
1708:tasks.c       **** 
1709:tasks.c       **** 	If an event is for a queue that is locked then this function will never
1710:tasks.c       **** 	get called - the lock count on the queue will get modified instead.  This
1711:tasks.c       **** 	means we can always expect exclusive access to the event list here. */
1712:tasks.c       **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1713:tasks.c       **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
1714:tasks.c       **** 
1715:tasks.c       **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1716:tasks.c       **** 	{
1717:tasks.c       **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1718:tasks.c       **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1719:tasks.c       **** 	}
1720:tasks.c       **** 	else
1721:tasks.c       **** 	{
1722:tasks.c       **** 		/* We cannot access the delayed or ready lists, so will hold this
1723:tasks.c       **** 		task pending until the scheduler is resumed. */
1724:tasks.c       **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1725:tasks.c       **** 	}
1726:tasks.c       **** 
1727:tasks.c       **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1728:tasks.c       **** 	{
1729:tasks.c       **** 		/* Return true if the task removed from the event list has
1730:tasks.c       **** 		a higher priority than the calling task.  This allows
1731:tasks.c       **** 		the calling task to know if it should force a context
1732:tasks.c       **** 		switch now. */
1733:tasks.c       **** 		xReturn = pdTRUE;
1734:tasks.c       **** 	}
1735:tasks.c       **** 	else
1736:tasks.c       **** 	{
1737:tasks.c       **** 		xReturn = pdFALSE;
1738:tasks.c       **** 	}
1739:tasks.c       **** 
1740:tasks.c       **** 	return xReturn;
1741:tasks.c       **** }
1742:tasks.c       **** /*-----------------------------------------------------------*/
1743:tasks.c       **** 
1744:tasks.c       **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1745:tasks.c       **** {
1746:tasks.c       **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
1747:tasks.c       **** 	pxTimeOut->xTimeOnEntering = xTickCount;
1748:tasks.c       **** }
1749:tasks.c       **** /*-----------------------------------------------------------*/
1750:tasks.c       **** 
1751:tasks.c       **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1752:tasks.c       **** {
1753:tasks.c       **** portBASE_TYPE xReturn;
1754:tasks.c       **** 
1755:tasks.c       **** 	portENTER_CRITICAL();
1756:tasks.c       **** 	{
1757:tasks.c       **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1758:tasks.c       **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1759:tasks.c       **** 			the maximum block time then the task should block indefinitely, and
1760:tasks.c       **** 			therefore never time out. */
1761:tasks.c       **** 			if( *pxTicksToWait == portMAX_DELAY )
1762:tasks.c       **** 			{
1763:tasks.c       **** 				xReturn = pdFALSE;
1764:tasks.c       **** 			}
1765:tasks.c       **** 			else /* We are not blocking indefinitely, perform the checks below. */
1766:tasks.c       **** 		#endif
1767:tasks.c       **** 
1768:tasks.c       **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
1769:tasks.c       **** 		{
1770:tasks.c       **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1771:tasks.c       **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1772:tasks.c       **** 			It must have wrapped all the way around and gone past us again. This
1773:tasks.c       **** 			passed since vTaskSetTimeout() was called. */
1774:tasks.c       **** 			xReturn = pdTRUE;
1775:tasks.c       **** 		}
1776:tasks.c       **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
1777:tasks.c       **** 		{
1778:tasks.c       **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1779:tasks.c       **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
1780:tasks.c       **** 			vTaskSetTimeOutState( pxTimeOut );
1781:tasks.c       **** 			xReturn = pdFALSE;
1782:tasks.c       **** 		}
1783:tasks.c       **** 		else
1784:tasks.c       **** 		{
1785:tasks.c       **** 			xReturn = pdTRUE;
1786:tasks.c       **** 		}
1787:tasks.c       **** 	}
1788:tasks.c       **** 	portEXIT_CRITICAL();
1789:tasks.c       **** 
1790:tasks.c       **** 	return xReturn;
1791:tasks.c       **** }
1792:tasks.c       **** /*-----------------------------------------------------------*/
1793:tasks.c       **** 
1794:tasks.c       **** void vTaskMissedYield( void )
1795:tasks.c       **** {
1796:tasks.c       **** 	xMissedYield = pdTRUE;
1797:tasks.c       **** }
1798:tasks.c       **** 
1799:tasks.c       **** /*
1800:tasks.c       ****  * -----------------------------------------------------------
1801:tasks.c       ****  * The Idle task.
1802:tasks.c       ****  * ----------------------------------------------------------
1803:tasks.c       ****  *
1804:tasks.c       ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1805:tasks.c       ****  * language extensions.  The equivalent prototype for this function is:
1806:tasks.c       ****  *
1807:tasks.c       ****  * void prvIdleTask( void *pvParameters );
1808:tasks.c       ****  *
1809:tasks.c       ****  */
1810:tasks.c       **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1811:tasks.c       **** {
  25              		.loc 1 1811 0
  26              		.cfi_startproc
  27              	.LVL0:
  28 0000 00B5     		push	{lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 4
  31              		.cfi_offset 14, -4
1812:tasks.c       **** 	/* Stop warnings. */
1813:tasks.c       **** 	( void ) pvParameters;
1814:tasks.c       **** 
1815:tasks.c       **** 	for( ;; )
1816:tasks.c       **** 	{
1817:tasks.c       **** 		/* See if any tasks have been deleted. */
1818:tasks.c       **** 		prvCheckTasksWaitingTermination();
1819:tasks.c       **** 
1820:tasks.c       **** 		#if ( configUSE_PREEMPTION == 0 )
1821:tasks.c       **** 		{
1822:tasks.c       **** 			/* If we are not using preemption we keep forcing a task switch to
1823:tasks.c       **** 			see if any other task has become available.  If we are using
1824:tasks.c       **** 			preemption we don't need to do this as any task becoming available
1825:tasks.c       **** 			will automatically get the processor anyway. */
1826:tasks.c       **** 			taskYIELD();
1827:tasks.c       **** 		}
1828:tasks.c       **** 		#endif
1829:tasks.c       **** 
1830:tasks.c       **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1831:tasks.c       **** 		{
1832:tasks.c       **** 			/* When using preemption tasks of equal priority will be
1833:tasks.c       **** 			timesliced.  If a task that is sharing the idle priority is ready
1834:tasks.c       **** 			to run then the idle task should yield before the end of the
1835:tasks.c       **** 			timeslice.
1836:tasks.c       **** 
1837:tasks.c       **** 			A critical region is not required here as we are just reading from
1838:tasks.c       **** 			the list, and an occasional incorrect value will not matter.  If
1839:tasks.c       **** 			the ready list at the idle priority contains more than one task
1840:tasks.c       **** 			then a task other than the idle task is ready to execute. */
1841:tasks.c       **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
  32              		.loc 1 1841 0
  33 0002 034A     		ldr	r2, .L6
  34              	.L5:
  35 0004 1368     		ldr	r3, [r2]
  36 0006 012B     		cmp	r3, #1
  37 0008 FCD9     		bls	.L5
1842:tasks.c       **** 			{
1843:tasks.c       **** 				taskYIELD();
  38              		.loc 1 1843 0
  39              	@ 1843 "tasks.c" 1
  40 000a 00DF     		SWI 0
  41              	@ 0 "" 2
  42              		.code	16
  43 000c FAE7     		b	.L5
  44              	.L7:
  45 000e C046     		.align	2
  46              	.L6:
  47 0010 00000000 		.word	.LANCHOR0
  48              		.cfi_endproc
  49              	.LFE26:
  51              		.section	.text.prvListTaskWithinSingleList,"ax",%progbits
  52              		.align	2
  53              		.code	16
  54              		.thumb_func
  56              	prvListTaskWithinSingleList:
  57              	.LFB31:
1844:tasks.c       **** 			}
1845:tasks.c       **** 		}
1846:tasks.c       **** 		#endif
1847:tasks.c       **** 
1848:tasks.c       **** 		#if ( configUSE_IDLE_HOOK == 1 )
1849:tasks.c       **** 		{
1850:tasks.c       **** 			extern void vApplicationIdleHook( void );
1851:tasks.c       **** 
1852:tasks.c       **** 			/* Call the user defined function from within the idle task.  This
1853:tasks.c       **** 			allows the application designer to add background functionality
1854:tasks.c       **** 			without the overhead of a separate task.
1855:tasks.c       **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1856:tasks.c       **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1857:tasks.c       **** 			vApplicationIdleHook();
1858:tasks.c       **** 		}
1859:tasks.c       **** 		#endif
1860:tasks.c       **** 	}
1861:tasks.c       **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1862:tasks.c       **** 
1863:tasks.c       **** 
1864:tasks.c       **** 
1865:tasks.c       **** 
1866:tasks.c       **** 
1867:tasks.c       **** 
1868:tasks.c       **** 
1869:tasks.c       **** /*-----------------------------------------------------------
1870:tasks.c       ****  * File private functions documented at the top of the file.
1871:tasks.c       ****  *----------------------------------------------------------*/
1872:tasks.c       **** 
1873:tasks.c       **** 
1874:tasks.c       **** 
1875:tasks.c       **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1876:tasks.c       **** {
1877:tasks.c       **** 	/* Store the function name in the TCB. */
1878:tasks.c       **** 	#if configMAX_TASK_NAME_LEN > 1
1879:tasks.c       **** 	{
1880:tasks.c       **** 		/* Don't bring strncpy into the build unnecessarily. */
1881:tasks.c       **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
1882:tasks.c       **** 	}
1883:tasks.c       **** 	#endif
1884:tasks.c       **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
1885:tasks.c       **** 
1886:tasks.c       **** 	/* This is used as an array index so must ensure it's not too large.  First
1887:tasks.c       **** 	remove the privilege bit if one is present. */
1888:tasks.c       **** 	if( uxPriority >= configMAX_PRIORITIES )
1889:tasks.c       **** 	{
1890:tasks.c       **** 		uxPriority = configMAX_PRIORITIES - 1;
1891:tasks.c       **** 	}
1892:tasks.c       **** 
1893:tasks.c       **** 	pxTCB->uxPriority = uxPriority;
1894:tasks.c       **** 	#if ( configUSE_MUTEXES == 1 )
1895:tasks.c       **** 	{
1896:tasks.c       **** 		pxTCB->uxBasePriority = uxPriority;
1897:tasks.c       **** 	}
1898:tasks.c       **** 	#endif
1899:tasks.c       **** 
1900:tasks.c       **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
1901:tasks.c       **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
1902:tasks.c       **** 
1903:tasks.c       **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1904:tasks.c       **** 	back to	the containing TCB from a generic item in a list. */
1905:tasks.c       **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
1906:tasks.c       **** 
1907:tasks.c       **** 	/* Event lists are always in priority order. */
1908:tasks.c       **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
1909:tasks.c       **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
1910:tasks.c       **** 
1911:tasks.c       **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1912:tasks.c       **** 	{
1913:tasks.c       **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0;
1914:tasks.c       **** 	}
1915:tasks.c       **** 	#endif
1916:tasks.c       **** 
1917:tasks.c       **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1918:tasks.c       **** 	{
1919:tasks.c       **** 		pxTCB->pxTaskTag = NULL;
1920:tasks.c       **** 	}
1921:tasks.c       **** 	#endif
1922:tasks.c       **** 
1923:tasks.c       **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1924:tasks.c       **** 	{
1925:tasks.c       **** 		pxTCB->ulRunTimeCounter = 0UL;
1926:tasks.c       **** 	}
1927:tasks.c       **** 	#endif
1928:tasks.c       **** 
1929:tasks.c       **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1930:tasks.c       **** 	{
1931:tasks.c       **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1932:tasks.c       **** 	}
1933:tasks.c       **** 	#else
1934:tasks.c       **** 	{
1935:tasks.c       **** 		( void ) xRegions;
1936:tasks.c       **** 		( void ) usStackDepth;
1937:tasks.c       **** 	}
1938:tasks.c       **** 	#endif
1939:tasks.c       **** }
1940:tasks.c       **** /*-----------------------------------------------------------*/
1941:tasks.c       **** 
1942:tasks.c       **** #if ( portUSING_MPU_WRAPPERS == 1 )
1943:tasks.c       **** 
1944:tasks.c       **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
1945:tasks.c       **** 	{
1946:tasks.c       **** 	tskTCB *pxTCB;
1947:tasks.c       **** 	
1948:tasks.c       **** 		if( xTaskToModify == pxCurrentTCB )
1949:tasks.c       **** 		{
1950:tasks.c       **** 			xTaskToModify = NULL;
1951:tasks.c       **** 		}
1952:tasks.c       **** 
1953:tasks.c       **** 		/* If null is passed in here then we are deleting ourselves. */
1954:tasks.c       **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
1955:tasks.c       **** 
1956:tasks.c       ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
1957:tasks.c       **** 	}
1958:tasks.c       **** 	/*-----------------------------------------------------------*/
1959:tasks.c       **** #endif
1960:tasks.c       **** 
1961:tasks.c       **** static void prvInitialiseTaskLists( void )
1962:tasks.c       **** {
1963:tasks.c       **** unsigned portBASE_TYPE uxPriority;
1964:tasks.c       **** 
1965:tasks.c       **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
1966:tasks.c       **** 	{
1967:tasks.c       **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
1968:tasks.c       **** 	}
1969:tasks.c       **** 
1970:tasks.c       **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
1971:tasks.c       **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
1972:tasks.c       **** 	vListInitialise( ( xList * ) &xPendingReadyList );
1973:tasks.c       **** 
1974:tasks.c       **** 	#if ( INCLUDE_vTaskDelete == 1 )
1975:tasks.c       **** 	{
1976:tasks.c       **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
1977:tasks.c       **** 	}
1978:tasks.c       **** 	#endif
1979:tasks.c       **** 
1980:tasks.c       **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1981:tasks.c       **** 	{
1982:tasks.c       **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
1983:tasks.c       **** 	}
1984:tasks.c       **** 	#endif
1985:tasks.c       **** 
1986:tasks.c       **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
1987:tasks.c       **** 	using list2. */
1988:tasks.c       **** 	pxDelayedTaskList = &xDelayedTaskList1;
1989:tasks.c       **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
1990:tasks.c       **** }
1991:tasks.c       **** /*-----------------------------------------------------------*/
1992:tasks.c       **** 
1993:tasks.c       **** static void prvCheckTasksWaitingTermination( void )
1994:tasks.c       **** {
1995:tasks.c       **** 	#if ( INCLUDE_vTaskDelete == 1 )
1996:tasks.c       **** 	{
1997:tasks.c       **** 		portBASE_TYPE xListIsEmpty;
1998:tasks.c       **** 
1999:tasks.c       **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2000:tasks.c       **** 		too often in the idle task. */
2001:tasks.c       **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
2002:tasks.c       **** 		{
2003:tasks.c       **** 			vTaskSuspendAll();
2004:tasks.c       **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2005:tasks.c       **** 			xTaskResumeAll();
2006:tasks.c       **** 
2007:tasks.c       **** 			if( !xListIsEmpty )
2008:tasks.c       **** 			{
2009:tasks.c       **** 				tskTCB *pxTCB;
2010:tasks.c       **** 
2011:tasks.c       **** 				portENTER_CRITICAL();
2012:tasks.c       **** 				{
2013:tasks.c       **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2014:tasks.c       **** 					vListRemove( &( pxTCB->xGenericListItem ) );
2015:tasks.c       **** 					--uxCurrentNumberOfTasks;
2016:tasks.c       **** 					--uxTasksDeleted;
2017:tasks.c       **** 				}
2018:tasks.c       **** 				portEXIT_CRITICAL();
2019:tasks.c       **** 
2020:tasks.c       **** 				prvDeleteTCB( pxTCB );
2021:tasks.c       **** 			}
2022:tasks.c       **** 		}
2023:tasks.c       **** 	}
2024:tasks.c       **** 	#endif
2025:tasks.c       **** }
2026:tasks.c       **** /*-----------------------------------------------------------*/
2027:tasks.c       **** 
2028:tasks.c       **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2029:tasks.c       **** {
2030:tasks.c       **** tskTCB *pxNewTCB;
2031:tasks.c       **** 
2032:tasks.c       **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2033:tasks.c       **** 	the implementation of the port malloc function. */
2034:tasks.c       **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
2035:tasks.c       **** 
2036:tasks.c       **** 	if( pxNewTCB != NULL )
2037:tasks.c       **** 	{
2038:tasks.c       **** 		/* Allocate space for the stack used by the task being created.
2039:tasks.c       **** 		The base of the stack memory stored in the TCB so the task can
2040:tasks.c       **** 		be deleted later if required. */
2041:tasks.c       **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
2042:tasks.c       **** 
2043:tasks.c       **** 		if( pxNewTCB->pxStack == NULL )
2044:tasks.c       **** 		{
2045:tasks.c       **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2046:tasks.c       **** 			vPortFree( pxNewTCB );
2047:tasks.c       **** 			pxNewTCB = NULL;
2048:tasks.c       **** 		}
2049:tasks.c       **** 		else
2050:tasks.c       **** 		{
2051:tasks.c       **** 			/* Just to help debugging. */
2052:tasks.c       **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
2053:tasks.c       **** 		}
2054:tasks.c       **** 	}
2055:tasks.c       **** 
2056:tasks.c       **** 	return pxNewTCB;
2057:tasks.c       **** }
2058:tasks.c       **** /*-----------------------------------------------------------*/
2059:tasks.c       **** 
2060:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
2061:tasks.c       **** 
2062:tasks.c       **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2063:tasks.c       **** 	{
  58              		.loc 1 2063 0
  59              		.cfi_startproc
  60              	.LVL1:
  61 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  62              	.LCFI1:
  63              		.cfi_def_cfa_offset 20
  64              		.cfi_offset 4, -20
  65              		.cfi_offset 5, -16
  66              		.cfi_offset 6, -12
  67              		.cfi_offset 7, -8
  68              		.cfi_offset 14, -4
  69 0002 5F46     		mov	r7, fp
  70 0004 5646     		mov	r6, sl
  71 0006 4D46     		mov	r5, r9
  72 0008 4446     		mov	r4, r8
  73 000a F0B4     		push	{r4, r5, r6, r7}
  74              	.LCFI2:
  75              		.cfi_def_cfa_offset 36
  76              		.cfi_offset 8, -36
  77              		.cfi_offset 9, -32
  78              		.cfi_offset 10, -28
  79              		.cfi_offset 11, -24
  80 000c 85B0     		sub	sp, sp, #20
  81              	.LCFI3:
  82              		.cfi_def_cfa_offset 56
  83 000e 8146     		mov	r9, r0
  84 0010 0D1C     		mov	r5, r1
  85 0012 9246     		mov	sl, r2
  86              	.LVL2:
  87              	.LBB6:
2064:tasks.c       **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2065:tasks.c       **** 	unsigned short usStackRemaining;
2066:tasks.c       **** 
2067:tasks.c       **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2068:tasks.c       **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
  88              		.loc 1 2068 0
  89 0014 4B68     		ldr	r3, [r1, #4]
  90 0016 5B68     		ldr	r3, [r3, #4]
  91 0018 4B60     		str	r3, [r1, #4]
  92 001a 0A1C     		mov	r2, r1
  93              	.LVL3:
  94 001c 0832     		add	r2, r2, #8
  95 001e 9342     		cmp	r3, r2
  96 0020 01D1     		bne	.L9
  97              		.loc 1 2068 0 is_stmt 0 discriminator 1
  98 0022 5B68     		ldr	r3, [r3, #4]
  99 0024 4B60     		str	r3, [r1, #4]
 100              	.L9:
 101              		.loc 1 2068 0 discriminator 2
 102 0026 6B68     		ldr	r3, [r5, #4]
 103 0028 DA68     		ldr	r2, [r3, #12]
 104 002a 9046     		mov	r8, r2
 105              	.LVL4:
 106              	.LBE6:
 107              	.LBB7:
2069:tasks.c       **** 		do
2070:tasks.c       **** 		{
2071:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 108              		.loc 1 2071 0 is_stmt 1 discriminator 2
 109 002c 2F1C     		mov	r7, r5
 110 002e 0837     		add	r7, r7, #8
 111              	.LBE7:
 112              	.LBB8:
 113              	.LBB9:
2072:tasks.c       **** 			#if ( portSTACK_GROWTH > 0 )
2073:tasks.c       **** 			{
2074:tasks.c       **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2075:tasks.c       **** 			}
2076:tasks.c       **** 			#else
2077:tasks.c       **** 			{
2078:tasks.c       **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2079:tasks.c       **** 			}
2080:tasks.c       **** 			#endif			
2081:tasks.c       **** 			
2082:tasks.c       **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2083:tasks.c       **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2084:tasks.c       **** 
2085:tasks.c       **** 		} while( pxNextTCB != pxFirstTCB );
2086:tasks.c       **** 	}
2087:tasks.c       **** 
2088:tasks.c       **** #endif
2089:tasks.c       **** /*-----------------------------------------------------------*/
2090:tasks.c       **** 
2091:tasks.c       **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2092:tasks.c       **** 
2093:tasks.c       **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2094:tasks.c       **** 	{
2095:tasks.c       **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2096:tasks.c       **** 	unsigned long ulStatsAsPercentage;
2097:tasks.c       **** 
2098:tasks.c       **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2099:tasks.c       **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2100:tasks.c       **** 		do
2101:tasks.c       **** 		{
2102:tasks.c       **** 			/* Get next TCB in from the list. */
2103:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2104:tasks.c       **** 
2105:tasks.c       **** 			/* Divide by zero check. */
2106:tasks.c       **** 			if( ulTotalRunTime > 0UL )
2107:tasks.c       **** 			{
2108:tasks.c       **** 				/* Has the task run at all? */
2109:tasks.c       **** 				if( pxNextTCB->ulRunTimeCounter == 0 )
2110:tasks.c       **** 				{
2111:tasks.c       **** 					/* The task has used no CPU time at all. */
2112:tasks.c       **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2113:tasks.c       **** 				}
2114:tasks.c       **** 				else
2115:tasks.c       **** 				{
2116:tasks.c       **** 					/* What percentage of the total run time as the task used?
2117:tasks.c       **** 					This will always be rounded down to the nearest integer. */
2118:tasks.c       **** 					ulStatsAsPercentage = ( 100UL * pxNextTCB->ulRunTimeCounter ) / ulTotalRunTime;
2119:tasks.c       **** 
2120:tasks.c       **** 					if( ulStatsAsPercentage > 0UL )
2121:tasks.c       **** 					{
2122:tasks.c       **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2123:tasks.c       **** 					}
2124:tasks.c       **** 					else
2125:tasks.c       **** 					{
2126:tasks.c       **** 						/* If the percentage is zero here then the task has
2127:tasks.c       **** 						consumed less than 1% of the total run time. */
2128:tasks.c       **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2129:tasks.c       **** 					}
2130:tasks.c       **** 				}
2131:tasks.c       **** 
2132:tasks.c       **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2133:tasks.c       **** 			}
2134:tasks.c       **** 
2135:tasks.c       **** 		} while( pxNextTCB != pxFirstTCB );
2136:tasks.c       **** 	}
2137:tasks.c       **** 
2138:tasks.c       **** #endif
2139:tasks.c       **** /*-----------------------------------------------------------*/
2140:tasks.c       **** 
2141:tasks.c       **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2142:tasks.c       **** 
2143:tasks.c       **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2144:tasks.c       **** 	{
2145:tasks.c       **** 	register unsigned short usCount = 0;
 114              		.loc 1 2145 0 discriminator 2
 115 0030 0023     		mov	r3, #0
 116 0032 9B46     		mov	fp, r3
 117              	.LBE9:
 118              	.LBE8:
2082:tasks.c       **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 119              		.loc 1 2082 0 discriminator 2
 120 0034 194E     		ldr	r6, .L17
 121              	.LVL5:
 122              	.L13:
 123              	.LBB11:
2071:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 124              		.loc 1 2071 0
 125 0036 6B68     		ldr	r3, [r5, #4]
 126 0038 5B68     		ldr	r3, [r3, #4]
 127 003a 6B60     		str	r3, [r5, #4]
 128 003c BB42     		cmp	r3, r7
 129 003e 01D1     		bne	.L10
2071:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 130              		.loc 1 2071 0 is_stmt 0 discriminator 1
 131 0040 5B68     		ldr	r3, [r3, #4]
 132 0042 6B60     		str	r3, [r5, #4]
 133              	.L10:
2071:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 134              		.loc 1 2071 0 discriminator 2
 135 0044 6B68     		ldr	r3, [r5, #4]
 136 0046 DC68     		ldr	r4, [r3, #12]
 137              	.LVL6:
 138              	.LBE11:
2078:tasks.c       **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 139              		.loc 1 2078 0 is_stmt 1 discriminator 2
 140 0048 216B     		ldr	r1, [r4, #48]
 141              	.LVL7:
 142              	.LBB12:
 143              	.LBB10:
2146:tasks.c       **** 
2147:tasks.c       **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 144              		.loc 1 2147 0 discriminator 2
 145 004a 0B78     		ldrb	r3, [r1]
 146 004c A52B     		cmp	r3, #165
 147 004e 08D1     		bne	.L14
 148              		.loc 1 2147 0 is_stmt 0
 149 0050 0B1C     		mov	r3, r1
 150              	.LVL8:
 151              	.L12:
2148:tasks.c       **** 		{
2149:tasks.c       **** 			pucStackByte -= portSTACK_GROWTH;
 152              		.loc 1 2149 0 is_stmt 1
 153 0052 0133     		add	r3, r3, #1
 154              	.LVL9:
2062:tasks.c       **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 155              		.loc 1 2062 0
 156 0054 5A1A     		sub	r2, r3, r1
 157 0056 1204     		lsl	r2, r2, #16
 158 0058 100C     		lsr	r0, r2, #16
 159              	.LVL10:
2147:tasks.c       **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 160              		.loc 1 2147 0
 161 005a 1A78     		ldrb	r2, [r3]
 162 005c A52A     		cmp	r2, #165
 163 005e F8D0     		beq	.L12
 164 0060 00E0     		b	.L11
 165              	.LVL11:
 166              	.L14:
2145:tasks.c       **** 	register unsigned short usCount = 0;
 167              		.loc 1 2145 0
 168 0062 5846     		mov	r0, fp
 169              	.LVL12:
 170              	.L11:
 171              	.LBE10:
 172              	.LBE12:
2082:tasks.c       **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 173              		.loc 1 2082 0
 174 0064 E36A     		ldr	r3, [r4, #44]
 175 0066 626C     		ldr	r2, [r4, #68]
 176 0068 0292     		str	r2, [sp, #8]
 177 006a 221C     		mov	r2, r4
 178 006c 3432     		add	r2, r2, #52
 179 006e 0093     		str	r3, [sp]
 180 0070 8008     		lsr	r0, r0, #2
 181              	.LVL13:
 182 0072 0190     		str	r0, [sp, #4]
 183 0074 301C     		mov	r0, r6
 184 0076 0A49     		ldr	r1, .L17+4
 185 0078 5346     		mov	r3, sl
 186 007a FFF7FEFF 		bl	sprintf
 187              	.LVL14:
2083:tasks.c       **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 188              		.loc 1 2083 0
 189 007e 4846     		mov	r0, r9
 190 0080 311C     		mov	r1, r6
 191 0082 FFF7FEFF 		bl	strcat
 192              	.LVL15:
2085:tasks.c       **** 		} while( pxNextTCB != pxFirstTCB );
 193              		.loc 1 2085 0
 194 0086 4445     		cmp	r4, r8
 195 0088 D5D1     		bne	.L13
2086:tasks.c       **** 	}
 196              		.loc 1 2086 0
 197 008a 05B0     		add	sp, sp, #20
 198              		@ sp needed for prologue
 199              	.LVL16:
 200              	.LVL17:
 201              	.LVL18:
 202              	.LVL19:
 203              	.LVL20:
 204 008c 3CBC     		pop	{r2, r3, r4, r5}
 205 008e 9046     		mov	r8, r2
 206 0090 9946     		mov	r9, r3
 207 0092 A246     		mov	sl, r4
 208 0094 AB46     		mov	fp, r5
 209 0096 F0BC     		pop	{r4, r5, r6, r7}
 210 0098 01BC     		pop	{r0}
 211 009a 0047     		bx	r0
 212              	.L18:
 213              		.align	2
 214              	.L17:
 215 009c 00000000 		.word	.LANCHOR1
 216 00a0 00000000 		.word	.LC4
 217              		.cfi_endproc
 218              	.LFE31:
 220              		.section	.text.xTaskGenericCreate,"ax",%progbits
 221              		.align	2
 222              		.global	xTaskGenericCreate
 223              		.code	16
 224              		.thumb_func
 226              	xTaskGenericCreate:
 227              	.LFB0:
 387:tasks.c       **** {
 228              		.loc 1 387 0
 229              		.cfi_startproc
 230              	.LVL21:
 231 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 232              	.LCFI4:
 233              		.cfi_def_cfa_offset 24
 234              		.cfi_offset 3, -24
 235              		.cfi_offset 4, -20
 236              		.cfi_offset 5, -16
 237              		.cfi_offset 6, -12
 238              		.cfi_offset 7, -8
 239              		.cfi_offset 14, -4
 240 0002 5F46     		mov	r7, fp
 241 0004 5646     		mov	r6, sl
 242 0006 C0B4     		push	{r6, r7}
 243              	.LCFI5:
 244              		.cfi_def_cfa_offset 32
 245              		.cfi_offset 10, -32
 246              		.cfi_offset 11, -28
 247 0008 061C     		mov	r6, r0
 248 000a 0F1C     		mov	r7, r1
 249 000c 151C     		mov	r5, r2
 250 000e 9A46     		mov	sl, r3
 251              	.LVL22:
 252              	.LBB20:
 253              	.LBB21:
2034:tasks.c       **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 254              		.loc 1 2034 0
 255 0010 4820     		mov	r0, #72
 256              	.LVL23:
 257 0012 FFF7FEFF 		bl	pvPortMalloc
 258              	.LVL24:
 259 0016 041C     		mov	r4, r0
 260              	.LVL25:
2036:tasks.c       **** 	if( pxNewTCB != NULL )
 261              		.loc 1 2036 0
 262 0018 0028     		cmp	r0, #0
 263 001a 00D1     		bne	.LCB253
 264 001c A5E0     		b	.L20	@long jump
 265              	.LCB253:
2041:tasks.c       **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 266              		.loc 1 2041 0
 267 001e 0A9A     		ldr	r2, [sp, #40]
 268 0020 002A     		cmp	r2, #0
 269 0022 00D0     		beq	.LCB256
 270 0024 9EE0     		b	.L21	@long jump
 271              	.LCB256:
 272 0026 A800     		lsl	r0, r5, #2
 273              	.LVL26:
 274 0028 FFF7FEFF 		bl	pvPortMalloc
 275              	.LVL27:
 276 002c 0A90     		str	r0, [sp, #40]
 277 002e 2063     		str	r0, [r4, #48]
2043:tasks.c       **** 		if( pxNewTCB->pxStack == NULL )
 278              		.loc 1 2043 0
 279 0030 0028     		cmp	r0, #0
 280 0032 03D1     		bne	.L22
2046:tasks.c       **** 			vPortFree( pxNewTCB );
 281              		.loc 1 2046 0
 282 0034 201C     		mov	r0, r4
 283 0036 FFF7FEFF 		bl	vPortFree
 284              	.LVL28:
 285 003a 96E0     		b	.L20
 286              	.LVL29:
 287              	.L22:
2052:tasks.c       **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 288              		.loc 1 2052 0
 289 003c AA00     		lsl	r2, r5, #2
 290 003e 0A98     		ldr	r0, [sp, #40]
 291 0040 A521     		mov	r1, #165
 292 0042 FFF7FEFF 		bl	memset
 293              	.LVL30:
 294              	.LBE21:
 295              	.LBE20:
 296              	.LBB23:
 419:tasks.c       **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 297              		.loc 1 419 0
 298 0046 6B1E     		sub	r3, r5, #1
 299 0048 9B00     		lsl	r3, r3, #2
 300 004a 226B     		ldr	r2, [r4, #48]
 301 004c D318     		add	r3, r2, r3
 302              	.LVL31:
 420:tasks.c       **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~
 303              		.loc 1 420 0
 304 004e 0722     		mov	r2, #7
 305 0050 9343     		bic	r3, r2
 306              	.LVL32:
 307 0052 9B46     		mov	fp, r3
 308              	.LVL33:
 309              	.LBB24:
 310              	.LBB25:
1881:tasks.c       **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 311              		.loc 1 1881 0
 312 0054 201C     		mov	r0, r4
 313 0056 3430     		add	r0, r0, #52
 314 0058 391C     		mov	r1, r7
 315 005a 1022     		mov	r2, #16
 316 005c FFF7FEFF 		bl	strncpy
 317              	.LVL34:
1884:tasks.c       **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 318              		.loc 1 1884 0
 319 0060 0022     		mov	r2, #0
 320 0062 4323     		mov	r3, #67
 321 0064 E254     		strb	r2, [r4, r3]
 322 0066 089D     		ldr	r5, [sp, #32]
 323              	.LVL35:
 324 0068 042D     		cmp	r5, #4
 325 006a 00D9     		bls	.L23
 326 006c 0425     		mov	r5, #4
 327              	.L23:
 328              	.LVL36:
1893:tasks.c       **** 	pxTCB->uxPriority = uxPriority;
 329              		.loc 1 1893 0
 330 006e E562     		str	r5, [r4, #44]
1900:tasks.c       **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 331              		.loc 1 1900 0
 332 0070 271D     		add	r7, r4, #4
 333              	.LVL37:
 334 0072 381C     		mov	r0, r7
 335 0074 FFF7FEFF 		bl	vListInitialiseItem
 336              	.LVL38:
1901:tasks.c       **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 337              		.loc 1 1901 0
 338 0078 201C     		mov	r0, r4
 339 007a 1830     		add	r0, r0, #24
 340 007c FFF7FEFF 		bl	vListInitialiseItem
 341              	.LVL39:
1905:tasks.c       **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 342              		.loc 1 1905 0
 343 0080 2461     		str	r4, [r4, #16]
1908:tasks.c       **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 344              		.loc 1 1908 0
 345 0082 0523     		mov	r3, #5
 346 0084 5D1B     		sub	r5, r3, r5
 347              	.LVL40:
 348 0086 A561     		str	r5, [r4, #24]
1909:tasks.c       **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 349              		.loc 1 1909 0
 350 0088 6462     		str	r4, [r4, #36]
 351              	.LBE25:
 352              	.LBE24:
 446:tasks.c       **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 353              		.loc 1 446 0
 354 008a 5846     		mov	r0, fp
 355 008c 311C     		mov	r1, r6
 356 008e 5246     		mov	r2, sl
 357 0090 FFF7FEFF 		bl	pxPortInitialiseStack
 358              	.LVL41:
 359 0094 2060     		str	r0, [r4]
 450:tasks.c       **** 		if( ( void * ) pxCreatedTask != NULL )
 360              		.loc 1 450 0
 361 0096 099B     		ldr	r3, [sp, #36]
 362 0098 002B     		cmp	r3, #0
 363 009a 00D0     		beq	.L24
 455:tasks.c       **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 364              		.loc 1 455 0
 365 009c 1C60     		str	r4, [r3]
 366              	.L24:
 460:tasks.c       **** 		portENTER_CRITICAL();
 367              		.loc 1 460 0
 368 009e FFF7FEFF 		bl	vPortEnterCritical
 369              	.LVL42:
 462:tasks.c       **** 			uxCurrentNumberOfTasks++;
 370              		.loc 1 462 0
 371 00a2 364B     		ldr	r3, .L35
 372 00a4 1A68     		ldr	r2, [r3]
 373 00a6 0132     		add	r2, r2, #1
 374 00a8 1A60     		str	r2, [r3]
 463:tasks.c       **** 			if( pxCurrentTCB == NULL )
 375              		.loc 1 463 0
 376 00aa 354B     		ldr	r3, .L35+4
 377 00ac 1B68     		ldr	r3, [r3]
 378 00ae 002B     		cmp	r3, #0
 379 00b0 23D1     		bne	.L25
 467:tasks.c       **** 				pxCurrentTCB =  pxNewTCB;
 380              		.loc 1 467 0
 381 00b2 334B     		ldr	r3, .L35+4
 382 00b4 1C60     		str	r4, [r3]
 469:tasks.c       **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 383              		.loc 1 469 0
 384 00b6 314B     		ldr	r3, .L35
 385 00b8 1B68     		ldr	r3, [r3]
 386 00ba 012B     		cmp	r3, #1
 387 00bc 29D1     		bne	.L26
 388 00be 0025     		mov	r5, #0
 389              	.LBB26:
 390              	.LBB27:
1967:tasks.c       **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 391              		.loc 1 1967 0
 392 00c0 304E     		ldr	r6, .L35+8
 393              	.LVL43:
 394              	.L27:
 395 00c2 A800     		lsl	r0, r5, #2
 396 00c4 4019     		add	r0, r0, r5
 397 00c6 8000     		lsl	r0, r0, #2
 398 00c8 3018     		add	r0, r6, r0
 399 00ca FFF7FEFF 		bl	vListInitialise
 400              	.LVL44:
1965:tasks.c       **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 401              		.loc 1 1965 0
 402 00ce 0135     		add	r5, r5, #1
 403              	.LVL45:
 404 00d0 052D     		cmp	r5, #5
 405 00d2 F6D1     		bne	.L27
1970:tasks.c       **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 406              		.loc 1 1970 0
 407 00d4 2C4E     		ldr	r6, .L35+12
 408 00d6 301C     		mov	r0, r6
 409 00d8 FFF7FEFF 		bl	vListInitialise
 410              	.LVL46:
1971:tasks.c       **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 411              		.loc 1 1971 0
 412 00dc 2B4D     		ldr	r5, .L35+16
 413              	.LVL47:
 414 00de 281C     		mov	r0, r5
 415 00e0 FFF7FEFF 		bl	vListInitialise
 416              	.LVL48:
1972:tasks.c       **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 417              		.loc 1 1972 0
 418 00e4 2A48     		ldr	r0, .L35+20
 419 00e6 FFF7FEFF 		bl	vListInitialise
 420              	.LVL49:
1982:tasks.c       **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 421              		.loc 1 1982 0
 422 00ea 2A48     		ldr	r0, .L35+24
 423 00ec FFF7FEFF 		bl	vListInitialise
 424              	.LVL50:
1988:tasks.c       **** 	pxDelayedTaskList = &xDelayedTaskList1;
 425              		.loc 1 1988 0
 426 00f0 294B     		ldr	r3, .L35+28
 427 00f2 1E60     		str	r6, [r3]
1989:tasks.c       **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 428              		.loc 1 1989 0
 429 00f4 294B     		ldr	r3, .L35+32
 430 00f6 1D60     		str	r5, [r3]
 431 00f8 0BE0     		b	.L26
 432              	.LVL51:
 433              	.L25:
 434              	.LBE27:
 435              	.LBE26:
 482:tasks.c       **** 				if( xSchedulerRunning == pdFALSE )
 436              		.loc 1 482 0
 437 00fa 294B     		ldr	r3, .L35+36
 438 00fc 1B68     		ldr	r3, [r3]
 439 00fe 002B     		cmp	r3, #0
 440 0100 07D1     		bne	.L26
 484:tasks.c       **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 441              		.loc 1 484 0
 442 0102 1F4B     		ldr	r3, .L35+4
 443 0104 1B68     		ldr	r3, [r3]
 444 0106 DB6A     		ldr	r3, [r3, #44]
 445 0108 089A     		ldr	r2, [sp, #32]
 446 010a 9A42     		cmp	r2, r3
 447 010c 01D3     		bcc	.L26
 486:tasks.c       **** 						pxCurrentTCB = pxNewTCB;
 448              		.loc 1 486 0
 449 010e 1C4B     		ldr	r3, .L35+4
 450 0110 1C60     		str	r4, [r3]
 451              	.LVL52:
 452              	.L26:
 493:tasks.c       **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 453              		.loc 1 493 0
 454 0112 E36A     		ldr	r3, [r4, #44]
 455 0114 234A     		ldr	r2, .L35+40
 456 0116 1268     		ldr	r2, [r2]
 457 0118 9342     		cmp	r3, r2
 458 011a 01D9     		bls	.L28
 495:tasks.c       **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 459              		.loc 1 495 0
 460 011c 214A     		ldr	r2, .L35+40
 461 011e 1360     		str	r3, [r2]
 462              	.L28:
 501:tasks.c       **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 463              		.loc 1 501 0
 464 0120 214D     		ldr	r5, .L35+44
 465 0122 2A68     		ldr	r2, [r5]
 466 0124 6264     		str	r2, [r4, #68]
 504:tasks.c       **** 			uxTaskNumber++;
 467              		.loc 1 504 0
 468 0126 0132     		add	r2, r2, #1
 469 0128 2A60     		str	r2, [r5]
 506:tasks.c       **** 			prvAddTaskToReadyQueue( pxNewTCB );
 470              		.loc 1 506 0
 471 012a 204A     		ldr	r2, .L35+48
 472 012c 1268     		ldr	r2, [r2]
 473 012e 9342     		cmp	r3, r2
 474 0130 01D9     		bls	.L29
 506:tasks.c       **** 			prvAddTaskToReadyQueue( pxNewTCB );
 475              		.loc 1 506 0 is_stmt 0 discriminator 1
 476 0132 1E4A     		ldr	r2, .L35+48
 477 0134 1360     		str	r3, [r2]
 478              	.L29:
 506:tasks.c       **** 			prvAddTaskToReadyQueue( pxNewTCB );
 479              		.loc 1 506 0 discriminator 2
 480 0136 9800     		lsl	r0, r3, #2
 481 0138 C318     		add	r3, r0, r3
 482 013a 9B00     		lsl	r3, r3, #2
 483 013c 1148     		ldr	r0, .L35+8
 484 013e C018     		add	r0, r0, r3
 485 0140 391C     		mov	r1, r7
 486 0142 FFF7FEFF 		bl	vListInsertEnd
 487              	.LVL53:
 511:tasks.c       **** 		portEXIT_CRITICAL();
 488              		.loc 1 511 0 is_stmt 1 discriminator 2
 489 0146 FFF7FEFF 		bl	vPortExitCritical
 490              	.LVL54:
 491              	.LBE23:
 521:tasks.c       **** 		if( xSchedulerRunning != pdFALSE )
 492              		.loc 1 521 0 discriminator 2
 493 014a 154B     		ldr	r3, .L35+36
 494 014c 1B68     		ldr	r3, [r3]
 508:tasks.c       **** 			xReturn = pdPASS;
 495              		.loc 1 508 0 discriminator 2
 496 014e 0120     		mov	r0, #1
 521:tasks.c       **** 		if( xSchedulerRunning != pdFALSE )
 497              		.loc 1 521 0 discriminator 2
 498 0150 002B     		cmp	r3, #0
 499 0152 0CD0     		beq	.L33
 525:tasks.c       **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 500              		.loc 1 525 0
 501 0154 0A4B     		ldr	r3, .L35+4
 502 0156 1B68     		ldr	r3, [r3]
 503 0158 DB6A     		ldr	r3, [r3, #44]
 504 015a 089A     		ldr	r2, [sp, #32]
 505 015c 9A42     		cmp	r2, r3
 506 015e 06D9     		bls	.L33
 527:tasks.c       **** 				portYIELD_WITHIN_API();
 507              		.loc 1 527 0
 508              	@ 527 "tasks.c" 1
 509 0160 00DF     		SWI 0
 510              	@ 0 "" 2
 511              		.code	16
 512 0162 04E0     		b	.L33
 513              	.LVL55:
 514              	.L21:
 515              	.LBB28:
 516              	.LBB22:
2041:tasks.c       **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 517              		.loc 1 2041 0
 518 0164 0A9B     		ldr	r3, [sp, #40]
 519 0166 0363     		str	r3, [r0, #48]
 520 0168 68E7     		b	.L22
 521              	.LVL56:
 522              	.L20:
 523              	.LBE22:
 524              	.LBE28:
 525              	.LBB29:
 515:tasks.c       **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 526              		.loc 1 515 0
 527 016a 0120     		mov	r0, #1
 528 016c 4042     		neg	r0, r0
 529              	.LVL57:
 530              	.L33:
 531              	.LBE29:
 533:tasks.c       **** }
 532              		.loc 1 533 0
 533              		@ sp needed for prologue
 534              	.LVL58:
 535 016e 0CBC     		pop	{r2, r3}
 536 0170 9246     		mov	sl, r2
 537 0172 9B46     		mov	fp, r3
 538 0174 F8BC     		pop	{r3, r4, r5, r6, r7}
 539 0176 02BC     		pop	{r1}
 540 0178 0847     		bx	r1
 541              	.L36:
 542 017a C046     		.align	2
 543              	.L35:
 544 017c 00000000 		.word	.LANCHOR2
 545 0180 00000000 		.word	.LANCHOR3
 546 0184 00000000 		.word	.LANCHOR0
 547 0188 00000000 		.word	.LANCHOR4
 548 018c 00000000 		.word	.LANCHOR5
 549 0190 00000000 		.word	.LANCHOR6
 550 0194 00000000 		.word	.LANCHOR7
 551 0198 00000000 		.word	.LANCHOR8
 552 019c 00000000 		.word	.LANCHOR9
 553 01a0 00000000 		.word	.LANCHOR10
 554 01a4 00000000 		.word	.LANCHOR11
 555 01a8 00000000 		.word	.LANCHOR12
 556 01ac 00000000 		.word	.LANCHOR13
 557              		.cfi_endproc
 558              	.LFE0:
 560              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 561              		.align	2
 562              		.global	uxTaskPriorityGet
 563              		.code	16
 564              		.thumb_func
 566              	uxTaskPriorityGet:
 567              	.LFB3:
 743:tasks.c       **** 	{
 568              		.loc 1 743 0
 569              		.cfi_startproc
 570              	.LVL59:
 571 0000 10B5     		push	{r4, lr}
 572              	.LCFI6:
 573              		.cfi_def_cfa_offset 8
 574              		.cfi_offset 4, -8
 575              		.cfi_offset 14, -4
 576 0002 041C     		mov	r4, r0
 747:tasks.c       **** 		portENTER_CRITICAL();
 577              		.loc 1 747 0
 578 0004 FFF7FEFF 		bl	vPortEnterCritical
 579              	.LVL60:
 751:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 580              		.loc 1 751 0
 581 0008 231C     		mov	r3, r4
 582 000a 002C     		cmp	r4, #0
 583 000c 01D1     		bne	.L38
 751:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 584              		.loc 1 751 0 is_stmt 0 discriminator 1
 585 000e 044B     		ldr	r3, .L40
 586 0010 1B68     		ldr	r3, [r3]
 587              	.L38:
 588              	.LVL61:
 752:tasks.c       **** 			uxReturn = pxTCB->uxPriority;
 589              		.loc 1 752 0 is_stmt 1 discriminator 3
 590 0012 DC6A     		ldr	r4, [r3, #44]
 591              	.LVL62:
 754:tasks.c       **** 		portEXIT_CRITICAL();
 592              		.loc 1 754 0 discriminator 3
 593 0014 FFF7FEFF 		bl	vPortExitCritical
 594              	.LVL63:
 757:tasks.c       **** 	}
 595              		.loc 1 757 0 discriminator 3
 596 0018 201C     		mov	r0, r4
 597              		@ sp needed for prologue
 598              	.LVL64:
 599 001a 10BC     		pop	{r4}
 600 001c 02BC     		pop	{r1}
 601 001e 0847     		bx	r1
 602              	.L41:
 603              		.align	2
 604              	.L40:
 605 0020 00000000 		.word	.LANCHOR3
 606              		.cfi_endproc
 607              	.LFE3:
 609              		.section	.text.vTaskPrioritySet,"ax",%progbits
 610              		.align	2
 611              		.global	vTaskPrioritySet
 612              		.code	16
 613              		.thumb_func
 615              	vTaskPrioritySet:
 616              	.LFB4:
 765:tasks.c       **** 	{
 617              		.loc 1 765 0
 618              		.cfi_startproc
 619              	.LVL65:
 620 0000 70B5     		push	{r4, r5, r6, lr}
 621              	.LCFI7:
 622              		.cfi_def_cfa_offset 16
 623              		.cfi_offset 4, -16
 624              		.cfi_offset 5, -12
 625              		.cfi_offset 6, -8
 626              		.cfi_offset 14, -4
 627 0002 051C     		mov	r5, r0
 628 0004 0C1C     		mov	r4, r1
 629              	.LVL66:
 630 0006 0429     		cmp	r1, #4
 631 0008 00D9     		bls	.L43
 632 000a 0424     		mov	r4, #4
 633              	.L43:
 634              	.LVL67:
 775:tasks.c       **** 		portENTER_CRITICAL();
 635              		.loc 1 775 0
 636 000c FFF7FEFF 		bl	vPortEnterCritical
 637              	.LVL68:
 777:tasks.c       **** 			if( pxTask == pxCurrentTCB )
 638              		.loc 1 777 0
 639 0010 1D4B     		ldr	r3, .L53
 640 0012 1B68     		ldr	r3, [r3]
 641 0014 9D42     		cmp	r5, r3
 642 0016 03D0     		beq	.L51
 784:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 643              		.loc 1 784 0
 644 0018 2E1C     		mov	r6, r5
 645 001a 002D     		cmp	r5, #0
 646 001c 03D1     		bne	.L45
 647 001e 00E0     		b	.L44
 648              	.L51:
 779:tasks.c       **** 				pxTask = NULL;
 649              		.loc 1 779 0
 650 0020 0025     		mov	r5, #0
 651              	.LVL69:
 652              	.L44:
 784:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 653              		.loc 1 784 0 discriminator 1
 654 0022 194B     		ldr	r3, .L53
 655 0024 1E68     		ldr	r6, [r3]
 656              	.L45:
 657              	.LVL70:
 794:tasks.c       **** 				uxCurrentPriority = pxTCB->uxPriority;
 658              		.loc 1 794 0 discriminator 3
 659 0026 F36A     		ldr	r3, [r6, #44]
 660              	.LVL71:
 798:tasks.c       **** 			if( uxCurrentPriority != uxNewPriority )
 661              		.loc 1 798 0 discriminator 3
 662 0028 A342     		cmp	r3, r4
 663 002a 27D0     		beq	.L46
 802:tasks.c       **** 				if( uxNewPriority > uxCurrentPriority )
 664              		.loc 1 802 0
 665 002c 02D2     		bcs	.L47
 810:tasks.c       **** 						xYieldRequired = pdTRUE;
 666              		.loc 1 810 0
 667 002e 6A1E     		sub	r2, r5, #1
 668 0030 9541     		sbc	r5, r5, r2
 669 0032 01E0     		b	.L48
 670              	.L47:
 671 0034 6A42     		neg	r2, r5
 672 0036 5541     		adc	r5, r5, r2
 673              	.L48:
 674              	.LVL72:
 836:tasks.c       **** 					pxTCB->uxPriority = uxNewPriority;
 675              		.loc 1 836 0
 676 0038 F462     		str	r4, [r6, #44]
 840:tasks.c       **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 677              		.loc 1 840 0
 678 003a 0522     		mov	r2, #5
 679 003c 141B     		sub	r4, r2, r4
 680              	.LVL73:
 681 003e B461     		str	r4, [r6, #24]
 846:tasks.c       **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 682              		.loc 1 846 0
 683 0040 9A00     		lsl	r2, r3, #2
 684 0042 D318     		add	r3, r2, r3
 685              	.LVL74:
 686 0044 9B00     		lsl	r3, r3, #2
 687 0046 114A     		ldr	r2, .L53+4
 688 0048 D318     		add	r3, r2, r3
 689 004a 7269     		ldr	r2, [r6, #20]
 690 004c 9A42     		cmp	r2, r3
 691 004e 12D1     		bne	.L49
 851:tasks.c       **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 692              		.loc 1 851 0
 693 0050 341D     		add	r4, r6, #4
 694 0052 201C     		mov	r0, r4
 695 0054 FFF7FEFF 		bl	vListRemove
 696              	.LVL75:
 852:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 697              		.loc 1 852 0
 698 0058 F36A     		ldr	r3, [r6, #44]
 699 005a 0D4A     		ldr	r2, .L53+8
 700 005c 1268     		ldr	r2, [r2]
 701 005e 9342     		cmp	r3, r2
 702 0060 01D9     		bls	.L50
 852:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 703              		.loc 1 852 0 is_stmt 0 discriminator 1
 704 0062 0B4A     		ldr	r2, .L53+8
 705 0064 1360     		str	r3, [r2]
 706              	.L50:
 852:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 707              		.loc 1 852 0 discriminator 2
 708 0066 9800     		lsl	r0, r3, #2
 709 0068 C318     		add	r3, r0, r3
 710 006a 9B00     		lsl	r3, r3, #2
 711 006c 0748     		ldr	r0, .L53+4
 712 006e C018     		add	r0, r0, r3
 713 0070 211C     		mov	r1, r4
 714 0072 FFF7FEFF 		bl	vListInsertEnd
 715              	.LVL76:
 716              	.L49:
 855:tasks.c       **** 				if( xYieldRequired == pdTRUE )
 717              		.loc 1 855 0 is_stmt 1
 718 0076 012D     		cmp	r5, #1
 719 0078 00D1     		bne	.L46
 857:tasks.c       **** 					portYIELD_WITHIN_API();
 720              		.loc 1 857 0
 721              	@ 857 "tasks.c" 1
 722 007a 00DF     		SWI 0
 723              	@ 0 "" 2
 724              	.LVL77:
 725              		.code	16
 726              	.L46:
 861:tasks.c       **** 		portEXIT_CRITICAL();
 727              		.loc 1 861 0
 728 007c FFF7FEFF 		bl	vPortExitCritical
 729              	.LVL78:
 862:tasks.c       **** 	}
 730              		.loc 1 862 0
 731              		@ sp needed for prologue
 732              	.LVL79:
 733 0080 70BC     		pop	{r4, r5, r6}
 734 0082 01BC     		pop	{r0}
 735 0084 0047     		bx	r0
 736              	.L54:
 737 0086 C046     		.align	2
 738              	.L53:
 739 0088 00000000 		.word	.LANCHOR3
 740 008c 00000000 		.word	.LANCHOR0
 741 0090 00000000 		.word	.LANCHOR13
 742              		.cfi_endproc
 743              	.LFE4:
 745              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 746              		.align	2
 747              		.global	xTaskIsTaskSuspended
 748              		.code	16
 749              		.thumb_func
 751              	xTaskIsTaskSuspended:
 752              	.LFB6:
 934:tasks.c       **** 	{
 753              		.loc 1 934 0
 754              		.cfi_startproc
 755              	.LVL80:
 756 0000 00B5     		push	{lr}
 757              	.LCFI8:
 758              		.cfi_def_cfa_offset 4
 759              		.cfi_offset 14, -4
 760 0002 031C     		mov	r3, r0
 761              	.LVL81:
 935:tasks.c       **** 	portBASE_TYPE xReturn = pdFALSE;
 762              		.loc 1 935 0
 763 0004 0020     		mov	r0, #0
 764              	.LVL82:
 940:tasks.c       **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 765              		.loc 1 940 0
 766 0006 074A     		ldr	r2, .L59
 767 0008 5969     		ldr	r1, [r3, #20]
 768 000a 9142     		cmp	r1, r2
 769 000c 07D1     		bne	.L56
 943:tasks.c       **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 770              		.loc 1 943 0
 771 000e 986A     		ldr	r0, [r3, #40]
 772 0010 054B     		ldr	r3, .L59+4
 773              	.LVL83:
 774 0012 9842     		cmp	r0, r3
 775 0014 02D0     		beq	.L58
 935:tasks.c       **** 	portBASE_TYPE xReturn = pdFALSE;
 776              		.loc 1 935 0
 777 0016 4342     		neg	r3, r0
 778 0018 5841     		adc	r0, r0, r3
 779 001a 00E0     		b	.L56
 780              	.L58:
 781 001c 0020     		mov	r0, #0
 782              	.L56:
 783              	.LVL84:
 957:tasks.c       **** 	}
 784              		.loc 1 957 0
 785              		@ sp needed for prologue
 786 001e 02BC     		pop	{r1}
 787 0020 0847     		bx	r1
 788              	.L60:
 789 0022 C046     		.align	2
 790              	.L59:
 791 0024 00000000 		.word	.LANCHOR7
 792 0028 00000000 		.word	.LANCHOR6
 793              		.cfi_endproc
 794              	.LFE6:
 796              		.section	.text.vTaskResume,"ax",%progbits
 797              		.align	2
 798              		.global	vTaskResume
 799              		.code	16
 800              		.thumb_func
 802              	vTaskResume:
 803              	.LFB7:
 965:tasks.c       **** 	{
 804              		.loc 1 965 0
 805              		.cfi_startproc
 806              	.LVL85:
 807 0000 38B5     		push	{r3, r4, r5, lr}
 808              	.LCFI9:
 809              		.cfi_def_cfa_offset 16
 810              		.cfi_offset 3, -16
 811              		.cfi_offset 4, -12
 812              		.cfi_offset 5, -8
 813              		.cfi_offset 14, -4
 814 0002 041C     		mov	r4, r0
 815              	.LVL86:
 974:tasks.c       **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 816              		.loc 1 974 0
 817 0004 0028     		cmp	r0, #0
 818 0006 26D0     		beq	.L61
 974:tasks.c       **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 819              		.loc 1 974 0 is_stmt 0 discriminator 1
 820 0008 144B     		ldr	r3, .L65
 821 000a 1B68     		ldr	r3, [r3]
 822 000c 9842     		cmp	r0, r3
 823 000e 22D0     		beq	.L61
 976:tasks.c       **** 			portENTER_CRITICAL();
 824              		.loc 1 976 0 is_stmt 1
 825 0010 FFF7FEFF 		bl	vPortEnterCritical
 826              	.LVL87:
 978:tasks.c       **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 827              		.loc 1 978 0
 828 0014 201C     		mov	r0, r4
 829 0016 FFF7FEFF 		bl	xTaskIsTaskSuspended
 830              	.LVL88:
 831 001a 0128     		cmp	r0, #1
 832 001c 19D1     		bne	.L63
 984:tasks.c       **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 833              		.loc 1 984 0
 834 001e 251D     		add	r5, r4, #4
 835 0020 281C     		mov	r0, r5
 836 0022 FFF7FEFF 		bl	vListRemove
 837              	.LVL89:
 985:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 838              		.loc 1 985 0
 839 0026 E36A     		ldr	r3, [r4, #44]
 840 0028 0D4A     		ldr	r2, .L65+4
 841 002a 1268     		ldr	r2, [r2]
 842 002c 9342     		cmp	r3, r2
 843 002e 01D9     		bls	.L64
 985:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 844              		.loc 1 985 0 is_stmt 0 discriminator 1
 845 0030 0B4A     		ldr	r2, .L65+4
 846 0032 1360     		str	r3, [r2]
 847              	.L64:
 985:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 848              		.loc 1 985 0 discriminator 2
 849 0034 9800     		lsl	r0, r3, #2
 850 0036 C318     		add	r3, r0, r3
 851 0038 9B00     		lsl	r3, r3, #2
 852 003a 0A48     		ldr	r0, .L65+8
 853 003c C018     		add	r0, r0, r3
 854 003e 291C     		mov	r1, r5
 855 0040 FFF7FEFF 		bl	vListInsertEnd
 856              	.LVL90:
 988:tasks.c       **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 857              		.loc 1 988 0 is_stmt 1 discriminator 2
 858 0044 054B     		ldr	r3, .L65
 859 0046 1B68     		ldr	r3, [r3]
 860 0048 E26A     		ldr	r2, [r4, #44]
 861 004a DB6A     		ldr	r3, [r3, #44]
 862 004c 9A42     		cmp	r2, r3
 863 004e 00D3     		bcc	.L63
 992:tasks.c       **** 						portYIELD_WITHIN_API();
 864              		.loc 1 992 0
 865              	@ 992 "tasks.c" 1
 866 0050 00DF     		SWI 0
 867              	@ 0 "" 2
 868              		.code	16
 869              	.L63:
 996:tasks.c       **** 			portEXIT_CRITICAL();
 870              		.loc 1 996 0
 871 0052 FFF7FEFF 		bl	vPortExitCritical
 872              	.LVL91:
 873              	.L61:
 998:tasks.c       **** 	}
 874              		.loc 1 998 0
 875              		@ sp needed for prologue
 876              	.LVL92:
 877 0056 38BC     		pop	{r3, r4, r5}
 878 0058 01BC     		pop	{r0}
 879 005a 0047     		bx	r0
 880              	.L66:
 881              		.align	2
 882              	.L65:
 883 005c 00000000 		.word	.LANCHOR3
 884 0060 00000000 		.word	.LANCHOR13
 885 0064 00000000 		.word	.LANCHOR0
 886              		.cfi_endproc
 887              	.LFE7:
 889              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 890              		.align	2
 891              		.global	xTaskResumeFromISR
 892              		.code	16
 893              		.thumb_func
 895              	xTaskResumeFromISR:
 896              	.LFB8:
1007:tasks.c       **** 	{
 897              		.loc 1 1007 0
 898              		.cfi_startproc
 899              	.LVL93:
 900 0000 70B5     		push	{r4, r5, r6, lr}
 901              	.LCFI10:
 902              		.cfi_def_cfa_offset 16
 903              		.cfi_offset 4, -16
 904              		.cfi_offset 5, -12
 905              		.cfi_offset 6, -8
 906              		.cfi_offset 14, -4
 907 0002 041C     		mov	r4, r0
 908              	.LVL94:
1013:tasks.c       **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 909              		.loc 1 1013 0
 910 0004 FFF7FEFF 		bl	xTaskIsTaskSuspended
 911              	.LVL95:
1008:tasks.c       **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 912              		.loc 1 1008 0
 913 0008 0025     		mov	r5, #0
1013:tasks.c       **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 914              		.loc 1 1013 0
 915 000a 0128     		cmp	r0, #1
 916 000c 23D1     		bne	.L68
1017:tasks.c       **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 917              		.loc 1 1017 0
 918 000e 144B     		ldr	r3, .L72
 919 0010 1B68     		ldr	r3, [r3]
 920 0012 002B     		cmp	r3, #0
 921 0014 19D1     		bne	.L69
1019:tasks.c       **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 922              		.loc 1 1019 0
 923 0016 134B     		ldr	r3, .L72+4
 924 0018 1B68     		ldr	r3, [r3]
 925 001a DB6A     		ldr	r3, [r3, #44]
 926 001c E26A     		ldr	r2, [r4, #44]
 927 001e 9A42     		cmp	r2, r3
 928 0020 6D41     		adc	r5, r5, r5
 929              	.LVL96:
1020:tasks.c       **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 930              		.loc 1 1020 0
 931 0022 261D     		add	r6, r4, #4
 932 0024 301C     		mov	r0, r6
 933 0026 FFF7FEFF 		bl	vListRemove
 934              	.LVL97:
1021:tasks.c       **** 				prvAddTaskToReadyQueue( pxTCB );
 935              		.loc 1 1021 0
 936 002a E36A     		ldr	r3, [r4, #44]
 937 002c 0E4A     		ldr	r2, .L72+8
 938 002e 1268     		ldr	r2, [r2]
 939 0030 9342     		cmp	r3, r2
 940 0032 01D9     		bls	.L70
1021:tasks.c       **** 				prvAddTaskToReadyQueue( pxTCB );
 941              		.loc 1 1021 0 is_stmt 0 discriminator 1
 942 0034 0C4A     		ldr	r2, .L72+8
 943 0036 1360     		str	r3, [r2]
 944              	.L70:
1021:tasks.c       **** 				prvAddTaskToReadyQueue( pxTCB );
 945              		.loc 1 1021 0 discriminator 2
 946 0038 9800     		lsl	r0, r3, #2
 947 003a C318     		add	r3, r0, r3
 948 003c 9B00     		lsl	r3, r3, #2
 949 003e 0B48     		ldr	r0, .L72+12
 950 0040 C018     		add	r0, r0, r3
 951 0042 311C     		mov	r1, r6
 952 0044 FFF7FEFF 		bl	vListInsertEnd
 953              	.LVL98:
 954 0048 05E0     		b	.L68
 955              	.LVL99:
 956              	.L69:
1028:tasks.c       **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 957              		.loc 1 1028 0 is_stmt 1
 958 004a 211C     		mov	r1, r4
 959 004c 1831     		add	r1, r1, #24
 960 004e 0848     		ldr	r0, .L72+16
 961 0050 FFF7FEFF 		bl	vListInsertEnd
 962              	.LVL100:
1008:tasks.c       **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 963              		.loc 1 1008 0
 964 0054 0025     		mov	r5, #0
 965              	.LVL101:
 966              	.L68:
1033:tasks.c       **** 	}
 967              		.loc 1 1033 0
 968 0056 281C     		mov	r0, r5
 969              		@ sp needed for prologue
 970              	.LVL102:
 971              	.LVL103:
 972 0058 70BC     		pop	{r4, r5, r6}
 973 005a 02BC     		pop	{r1}
 974 005c 0847     		bx	r1
 975              	.L73:
 976 005e C046     		.align	2
 977              	.L72:
 978 0060 00000000 		.word	.LANCHOR14
 979 0064 00000000 		.word	.LANCHOR3
 980 0068 00000000 		.word	.LANCHOR13
 981 006c 00000000 		.word	.LANCHOR0
 982 0070 00000000 		.word	.LANCHOR6
 983              		.cfi_endproc
 984              	.LFE8:
 986              		.section	.text.vTaskStartScheduler,"ax",%progbits
 987              		.align	2
 988              		.global	vTaskStartScheduler
 989              		.code	16
 990              		.thumb_func
 992              	vTaskStartScheduler:
 993              	.LFB9:
1046:tasks.c       **** {
 994              		.loc 1 1046 0
 995              		.cfi_startproc
 996 0000 00B5     		push	{lr}
 997              	.LCFI11:
 998              		.cfi_def_cfa_offset 4
 999              		.cfi_offset 14, -4
 1000 0002 85B0     		sub	sp, sp, #20
 1001              	.LCFI12:
 1002              		.cfi_def_cfa_offset 24
1050:tasks.c       **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
 1003              		.loc 1 1050 0
 1004 0004 0023     		mov	r3, #0
 1005 0006 0093     		str	r3, [sp]
 1006 0008 0193     		str	r3, [sp, #4]
 1007 000a 0293     		str	r3, [sp, #8]
 1008 000c 0393     		str	r3, [sp, #12]
 1009 000e 0A48     		ldr	r0, .L76
 1010 0010 0A49     		ldr	r1, .L76+4
 1011 0012 6422     		mov	r2, #100
 1012 0014 FFF7FEFF 		bl	xTaskGenericCreate
 1013              	.LVL104:
1052:tasks.c       **** 	if( xReturn == pdPASS )
 1014              		.loc 1 1052 0
 1015 0018 0128     		cmp	r0, #1
 1016 001a 09D1     		bne	.L74
1062:tasks.c       **** 		portDISABLE_INTERRUPTS();
 1017              		.loc 1 1062 0
 1018 001c FFF7FEFF 		bl	vPortDisableInterruptsFromThumb
 1019              	.LVL105:
1064:tasks.c       **** 		xSchedulerRunning = pdTRUE;
 1020              		.loc 1 1064 0
 1021 0020 0122     		mov	r2, #1
 1022 0022 074B     		ldr	r3, .L76+8
 1023 0024 1A60     		str	r2, [r3]
1065:tasks.c       **** 		xTickCount = ( portTickType ) 0;
 1024              		.loc 1 1065 0
 1025 0026 0022     		mov	r2, #0
 1026 0028 064B     		ldr	r3, .L76+12
 1027 002a 1A60     		str	r2, [r3]
1074:tasks.c       **** 		if( xPortStartScheduler() )
 1028              		.loc 1 1074 0
 1029 002c FFF7FEFF 		bl	xPortStartScheduler
 1030              	.LVL106:
 1031              	.L74:
1084:tasks.c       **** }
 1032              		.loc 1 1084 0
 1033 0030 05B0     		add	sp, sp, #20
 1034              		@ sp needed for prologue
 1035 0032 01BC     		pop	{r0}
 1036 0034 0047     		bx	r0
 1037              	.L77:
 1038 0036 C046     		.align	2
 1039              	.L76:
 1040 0038 00000000 		.word	prvIdleTask
 1041 003c 14000000 		.word	.LC34
 1042 0040 00000000 		.word	.LANCHOR10
 1043 0044 00000000 		.word	.LANCHOR15
 1044              		.cfi_endproc
 1045              	.LFE9:
 1047              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1048              		.align	2
 1049              		.global	vTaskEndScheduler
 1050              		.code	16
 1051              		.thumb_func
 1053              	vTaskEndScheduler:
 1054              	.LFB10:
1088:tasks.c       **** {
 1055              		.loc 1 1088 0
 1056              		.cfi_startproc
 1057 0000 08B5     		push	{r3, lr}
 1058              	.LCFI13:
 1059              		.cfi_def_cfa_offset 8
 1060              		.cfi_offset 3, -8
 1061              		.cfi_offset 14, -4
1092:tasks.c       **** 	portDISABLE_INTERRUPTS();
 1062              		.loc 1 1092 0
 1063 0002 FFF7FEFF 		bl	vPortDisableInterruptsFromThumb
 1064              	.LVL107:
1093:tasks.c       **** 	xSchedulerRunning = pdFALSE;
 1065              		.loc 1 1093 0
 1066 0006 0022     		mov	r2, #0
 1067 0008 034B     		ldr	r3, .L79
 1068 000a 1A60     		str	r2, [r3]
1094:tasks.c       **** 	vPortEndScheduler();
 1069              		.loc 1 1094 0
 1070 000c FFF7FEFF 		bl	vPortEndScheduler
 1071              	.LVL108:
1095:tasks.c       **** }
 1072              		.loc 1 1095 0
 1073              		@ sp needed for prologue
 1074 0010 08BC     		pop	{r3}
 1075 0012 01BC     		pop	{r0}
 1076 0014 0047     		bx	r0
 1077              	.L80:
 1078 0016 C046     		.align	2
 1079              	.L79:
 1080 0018 00000000 		.word	.LANCHOR10
 1081              		.cfi_endproc
 1082              	.LFE10:
 1084              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1085              		.align	2
 1086              		.global	vTaskSuspendAll
 1087              		.code	16
 1088              		.thumb_func
 1090              	vTaskSuspendAll:
 1091              	.LFB11:
1099:tasks.c       **** {
 1092              		.loc 1 1099 0
 1093              		.cfi_startproc
1102:tasks.c       **** 	++uxSchedulerSuspended;
 1094              		.loc 1 1102 0
 1095 0000 024B     		ldr	r3, .L82
 1096 0002 1A68     		ldr	r2, [r3]
 1097 0004 0132     		add	r2, r2, #1
 1098 0006 1A60     		str	r2, [r3]
1103:tasks.c       **** }
 1099              		.loc 1 1103 0
 1100              		@ sp needed for prologue
 1101 0008 7047     		bx	lr
 1102              	.L83:
 1103 000a C046     		.align	2
 1104              	.L82:
 1105 000c 00000000 		.word	.LANCHOR14
 1106              		.cfi_endproc
 1107              	.LFE11:
 1109              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1110              		.align	2
 1111              		.global	xTaskGetTickCount
 1112              		.code	16
 1113              		.thumb_func
 1115              	xTaskGetTickCount:
 1116              	.LFB13:
1189:tasks.c       **** {
 1117              		.loc 1 1189 0
 1118              		.cfi_startproc
 1119 0000 10B5     		push	{r4, lr}
 1120              	.LCFI14:
 1121              		.cfi_def_cfa_offset 8
 1122              		.cfi_offset 4, -8
 1123              		.cfi_offset 14, -4
1193:tasks.c       **** 	portENTER_CRITICAL();
 1124              		.loc 1 1193 0
 1125 0002 FFF7FEFF 		bl	vPortEnterCritical
 1126              	.LVL109:
1195:tasks.c       **** 		xTicks = xTickCount;
 1127              		.loc 1 1195 0
 1128 0006 044B     		ldr	r3, .L85
 1129 0008 1C68     		ldr	r4, [r3]
 1130              	.LVL110:
1197:tasks.c       **** 	portEXIT_CRITICAL();
 1131              		.loc 1 1197 0
 1132 000a FFF7FEFF 		bl	vPortExitCritical
 1133              	.LVL111:
1200:tasks.c       **** }
 1134              		.loc 1 1200 0
 1135 000e 201C     		mov	r0, r4
 1136              		@ sp needed for prologue
 1137              	.LVL112:
 1138 0010 10BC     		pop	{r4}
 1139 0012 02BC     		pop	{r1}
 1140 0014 0847     		bx	r1
 1141              	.L86:
 1142 0016 C046     		.align	2
 1143              	.L85:
 1144 0018 00000000 		.word	.LANCHOR15
 1145              		.cfi_endproc
 1146              	.LFE13:
 1148              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1149              		.align	2
 1150              		.global	xTaskGetTickCountFromISR
 1151              		.code	16
 1152              		.thumb_func
 1154              	xTaskGetTickCountFromISR:
 1155              	.LFB14:
1204:tasks.c       **** {
 1156              		.loc 1 1204 0
 1157              		.cfi_startproc
1205:tasks.c       **** 	return xTickCount;
 1158              		.loc 1 1205 0
 1159 0000 014B     		ldr	r3, .L88
 1160 0002 1868     		ldr	r0, [r3]
1206:tasks.c       **** }
 1161              		.loc 1 1206 0
 1162              		@ sp needed for prologue
 1163 0004 7047     		bx	lr
 1164              	.L89:
 1165 0006 C046     		.align	2
 1166              	.L88:
 1167 0008 00000000 		.word	.LANCHOR15
 1168              		.cfi_endproc
 1169              	.LFE14:
 1171              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1172              		.align	2
 1173              		.global	uxTaskGetNumberOfTasks
 1174              		.code	16
 1175              		.thumb_func
 1177              	uxTaskGetNumberOfTasks:
 1178              	.LFB15:
1210:tasks.c       **** {
 1179              		.loc 1 1210 0
 1180              		.cfi_startproc
1213:tasks.c       **** 	return uxCurrentNumberOfTasks;
 1181              		.loc 1 1213 0
 1182 0000 014B     		ldr	r3, .L91
 1183 0002 1868     		ldr	r0, [r3]
1214:tasks.c       **** }
 1184              		.loc 1 1214 0
 1185              		@ sp needed for prologue
 1186 0004 7047     		bx	lr
 1187              	.L92:
 1188 0006 C046     		.align	2
 1189              	.L91:
 1190 0008 00000000 		.word	.LANCHOR2
 1191              		.cfi_endproc
 1192              	.LFE15:
 1194              		.section	.text.vTaskStartTrace,"ax",%progbits
 1195              		.align	2
 1196              		.global	vTaskStartTrace
 1197              		.code	16
 1198              		.thumb_func
 1200              	vTaskStartTrace:
 1201              	.LFB17:
1348:tasks.c       **** 	{
 1202              		.loc 1 1348 0
 1203              		.cfi_startproc
 1204              	.LVL113:
 1205 0000 38B5     		push	{r3, r4, r5, lr}
 1206              	.LCFI15:
 1207              		.cfi_def_cfa_offset 16
 1208              		.cfi_offset 3, -16
 1209              		.cfi_offset 4, -12
 1210              		.cfi_offset 5, -8
 1211              		.cfi_offset 14, -4
 1212 0002 041C     		mov	r4, r0
 1213 0004 0D1C     		mov	r5, r1
1349:tasks.c       **** 		portENTER_CRITICAL();
 1214              		.loc 1 1349 0
 1215 0006 FFF7FEFF 		bl	vPortEnterCritical
 1216              	.LVL114:
1351:tasks.c       **** 			pcTraceBuffer = ( signed char * )pcBuffer;
 1217              		.loc 1 1351 0
 1218 000a 084B     		ldr	r3, .L94
 1219 000c 1C60     		str	r4, [r3]
1352:tasks.c       **** 			pcTraceBufferStart = pcBuffer;
 1220              		.loc 1 1352 0
 1221 000e 084B     		ldr	r3, .L94+4
 1222 0010 1C60     		str	r4, [r3]
1353:tasks.c       **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
 1223              		.loc 1 1353 0
 1224 0012 083D     		sub	r5, r5, #8
 1225              	.LVL115:
 1226 0014 6419     		add	r4, r4, r5
 1227              	.LVL116:
 1228 0016 074B     		ldr	r3, .L94+8
 1229 0018 1C60     		str	r4, [r3]
1354:tasks.c       **** 			xTracing = pdTRUE;
 1230              		.loc 1 1354 0
 1231 001a 0122     		mov	r2, #1
 1232 001c 064B     		ldr	r3, .L94+12
 1233 001e 1A60     		str	r2, [r3]
1356:tasks.c       **** 		portEXIT_CRITICAL();
 1234              		.loc 1 1356 0
 1235 0020 FFF7FEFF 		bl	vPortExitCritical
 1236              	.LVL117:
1357:tasks.c       **** 	}
 1237              		.loc 1 1357 0
 1238              		@ sp needed for prologue
 1239              	.LVL118:
 1240 0024 38BC     		pop	{r3, r4, r5}
 1241 0026 01BC     		pop	{r0}
 1242 0028 0047     		bx	r0
 1243              	.L95:
 1244 002a C046     		.align	2
 1245              	.L94:
 1246 002c 00000000 		.word	.LANCHOR16
 1247 0030 00000000 		.word	.LANCHOR17
 1248 0034 00000000 		.word	.LANCHOR18
 1249 0038 00000000 		.word	.LANCHOR19
 1250              		.cfi_endproc
 1251              	.LFE17:
 1253              		.section	.text.ulTaskEndTrace,"ax",%progbits
 1254              		.align	2
 1255              		.global	ulTaskEndTrace
 1256              		.code	16
 1257              		.thumb_func
 1259              	ulTaskEndTrace:
 1260              	.LFB18:
1365:tasks.c       **** 	{
 1261              		.loc 1 1365 0
 1262              		.cfi_startproc
 1263 0000 08B5     		push	{r3, lr}
 1264              	.LCFI16:
 1265              		.cfi_def_cfa_offset 8
 1266              		.cfi_offset 3, -8
 1267              		.cfi_offset 14, -4
1368:tasks.c       **** 		portENTER_CRITICAL();
 1268              		.loc 1 1368 0
 1269 0002 FFF7FEFF 		bl	vPortEnterCritical
 1270              	.LVL119:
1369:tasks.c       **** 			xTracing = pdFALSE;
 1271              		.loc 1 1369 0
 1272 0006 0022     		mov	r2, #0
 1273 0008 054B     		ldr	r3, .L97
 1274 000a 1A60     		str	r2, [r3]
1370:tasks.c       **** 		portEXIT_CRITICAL();
 1275              		.loc 1 1370 0
 1276 000c FFF7FEFF 		bl	vPortExitCritical
 1277              	.LVL120:
1372:tasks.c       **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
 1278              		.loc 1 1372 0
 1279 0010 044B     		ldr	r3, .L97+4
 1280 0012 1868     		ldr	r0, [r3]
 1281              	.LVL121:
 1282 0014 044B     		ldr	r3, .L97+8
 1283 0016 1B68     		ldr	r3, [r3]
 1284 0018 C01A     		sub	r0, r0, r3
 1285              	.LVL122:
1375:tasks.c       **** 	}
 1286              		.loc 1 1375 0
 1287              		@ sp needed for prologue
 1288 001a 08BC     		pop	{r3}
 1289 001c 02BC     		pop	{r1}
 1290 001e 0847     		bx	r1
 1291              	.L98:
 1292              		.align	2
 1293              	.L97:
 1294 0020 00000000 		.word	.LANCHOR19
 1295 0024 00000000 		.word	.LANCHOR16
 1296 0028 00000000 		.word	.LANCHOR17
 1297              		.cfi_endproc
 1298              	.LFE18:
 1300              		.section	.text.vTaskIncrementTick,"ax",%progbits
 1301              		.align	2
 1302              		.global	vTaskIncrementTick
 1303              		.code	16
 1304              		.thumb_func
 1306              	vTaskIncrementTick:
 1307              	.LFB19:
1388:tasks.c       **** {
 1308              		.loc 1 1388 0
 1309              		.cfi_startproc
 1310 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1311              	.LCFI17:
 1312              		.cfi_def_cfa_offset 20
 1313              		.cfi_offset 4, -20
 1314              		.cfi_offset 5, -16
 1315              		.cfi_offset 6, -12
 1316              		.cfi_offset 7, -8
 1317              		.cfi_offset 14, -4
 1318 0002 4746     		mov	r7, r8
 1319 0004 80B4     		push	{r7}
 1320              	.LCFI18:
 1321              		.cfi_def_cfa_offset 24
 1322              		.cfi_offset 8, -24
1392:tasks.c       **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1323              		.loc 1 1392 0
 1324 0006 264B     		ldr	r3, .L108
 1325 0008 1B68     		ldr	r3, [r3]
 1326 000a 002B     		cmp	r3, #0
 1327 000c 3ED1     		bne	.L100
1394:tasks.c       **** 		++xTickCount;
 1328              		.loc 1 1394 0
 1329 000e 254B     		ldr	r3, .L108+4
 1330 0010 1A68     		ldr	r2, [r3]
 1331 0012 0132     		add	r2, r2, #1
 1332 0014 1A60     		str	r2, [r3]
1395:tasks.c       **** 		if( xTickCount == ( portTickType ) 0 )
 1333              		.loc 1 1395 0
 1334 0016 1B68     		ldr	r3, [r3]
 1335 0018 002B     		cmp	r3, #0
 1336 001a 29D1     		bne	.L102
 1337              	.LBB30:
1402:tasks.c       **** 			pxTemp = pxDelayedTaskList;
 1338              		.loc 1 1402 0
 1339 001c 224A     		ldr	r2, .L108+8
 1340 001e 1168     		ldr	r1, [r2]
 1341              	.LVL123:
1403:tasks.c       **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1342              		.loc 1 1403 0
 1343 0020 224B     		ldr	r3, .L108+12
 1344 0022 1868     		ldr	r0, [r3]
 1345 0024 1060     		str	r0, [r2]
1404:tasks.c       **** 			pxOverflowDelayedTaskList = pxTemp;
 1346              		.loc 1 1404 0
 1347 0026 1960     		str	r1, [r3]
1405:tasks.c       **** 			xNumOfOverflows++;
 1348              		.loc 1 1405 0
 1349 0028 214B     		ldr	r3, .L108+16
 1350 002a 1A68     		ldr	r2, [r3]
 1351 002c 0132     		add	r2, r2, #1
 1352 002e 1A60     		str	r2, [r3]
 1353 0030 1EE0     		b	.L102
 1354              	.LVL124:
 1355              	.L106:
 1356              	.LBE30:
 1357              	.LBB31:
1409:tasks.c       **** 		prvCheckDelayedTasks();
 1358              		.loc 1 1409 0 discriminator 10
 1359 0032 3B68     		ldr	r3, [r7]
 1360 0034 6268     		ldr	r2, [r4, #4]
 1361 0036 9A42     		cmp	r2, r3
 1362 0038 2CD8     		bhi	.L99
1409:tasks.c       **** 		prvCheckDelayedTasks();
 1363              		.loc 1 1409 0 is_stmt 0 discriminator 2
 1364 003a 251D     		add	r5, r4, #4
 1365 003c 281C     		mov	r0, r5
 1366 003e FFF7FEFF 		bl	vListRemove
 1367              	.LVL125:
 1368 0042 A36A     		ldr	r3, [r4, #40]
 1369 0044 002B     		cmp	r3, #0
 1370 0046 03D0     		beq	.L104
1409:tasks.c       **** 		prvCheckDelayedTasks();
 1371              		.loc 1 1409 0 discriminator 3
 1372 0048 201C     		mov	r0, r4
 1373 004a 1830     		add	r0, r0, #24
 1374 004c FFF7FEFF 		bl	vListRemove
 1375              	.LVL126:
 1376              	.L104:
1409:tasks.c       **** 		prvCheckDelayedTasks();
 1377              		.loc 1 1409 0 discriminator 4
 1378 0050 E36A     		ldr	r3, [r4, #44]
 1379 0052 184A     		ldr	r2, .L108+20
 1380 0054 1268     		ldr	r2, [r2]
 1381 0056 9342     		cmp	r3, r2
 1382 0058 01D9     		bls	.L105
1409:tasks.c       **** 		prvCheckDelayedTasks();
 1383              		.loc 1 1409 0 discriminator 5
 1384 005a 164A     		ldr	r2, .L108+20
 1385 005c 1360     		str	r3, [r2]
 1386              	.L105:
1409:tasks.c       **** 		prvCheckDelayedTasks();
 1387              		.loc 1 1409 0 discriminator 6
 1388 005e 9800     		lsl	r0, r3, #2
 1389 0060 C318     		add	r3, r0, r3
 1390 0062 9B00     		lsl	r3, r3, #2
 1391 0064 1448     		ldr	r0, .L108+24
 1392 0066 C018     		add	r0, r0, r3
 1393 0068 291C     		mov	r1, r5
 1394 006a FFF7FEFF 		bl	vListInsertEnd
 1395              	.LVL127:
 1396 006e 02E0     		b	.L107
 1397              	.LVL128:
 1398              	.L102:
1409:tasks.c       **** 		prvCheckDelayedTasks();
 1399              		.loc 1 1409 0 discriminator 1
 1400 0070 0D4E     		ldr	r6, .L108+8
 1401 0072 B046     		mov	r8, r6
 1402 0074 0B4F     		ldr	r7, .L108+4
 1403              	.L107:
 1404 0076 3368     		ldr	r3, [r6]
 1405 0078 1B68     		ldr	r3, [r3]
 1406 007a 002B     		cmp	r3, #0
 1407 007c 0AD0     		beq	.L99
1409:tasks.c       **** 		prvCheckDelayedTasks();
 1408              		.loc 1 1409 0 discriminator 7
 1409 007e 4246     		mov	r2, r8
 1410 0080 1368     		ldr	r3, [r2]
 1411 0082 DB68     		ldr	r3, [r3, #12]
 1412 0084 DC68     		ldr	r4, [r3, #12]
 1413              	.LVL129:
 1414 0086 002C     		cmp	r4, #0
 1415 0088 D3D1     		bne	.L106
 1416 008a 03E0     		b	.L99
 1417              	.LVL130:
 1418              	.L100:
 1419              	.LBE31:
1413:tasks.c       **** 		++uxMissedTicks;
 1420              		.loc 1 1413 0 is_stmt 1
 1421 008c 0B4B     		ldr	r3, .L108+28
 1422 008e 1A68     		ldr	r2, [r3]
 1423 0090 0132     		add	r2, r2, #1
 1424 0092 1A60     		str	r2, [r3]
 1425              	.L99:
1440:tasks.c       **** }
 1426              		.loc 1 1440 0
 1427              		@ sp needed for prologue
 1428 0094 04BC     		pop	{r2}
 1429 0096 9046     		mov	r8, r2
 1430 0098 F0BC     		pop	{r4, r5, r6, r7}
 1431 009a 01BC     		pop	{r0}
 1432 009c 0047     		bx	r0
 1433              	.L109:
 1434 009e C046     		.align	2
 1435              	.L108:
 1436 00a0 00000000 		.word	.LANCHOR14
 1437 00a4 00000000 		.word	.LANCHOR15
 1438 00a8 00000000 		.word	.LANCHOR8
 1439 00ac 00000000 		.word	.LANCHOR9
 1440 00b0 00000000 		.word	.LANCHOR20
 1441 00b4 00000000 		.word	.LANCHOR13
 1442 00b8 00000000 		.word	.LANCHOR0
 1443 00bc 00000000 		.word	.LANCHOR21
 1444              		.cfi_endproc
 1445              	.LFE19:
 1447              		.section	.text.xTaskResumeAll,"ax",%progbits
 1448              		.align	2
 1449              		.global	xTaskResumeAll
 1450              		.code	16
 1451              		.thumb_func
 1453              	xTaskResumeAll:
 1454              	.LFB12:
1107:tasks.c       **** {
 1455              		.loc 1 1107 0
 1456              		.cfi_startproc
 1457 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1458              	.LCFI19:
 1459              		.cfi_def_cfa_offset 24
 1460              		.cfi_offset 3, -24
 1461              		.cfi_offset 4, -20
 1462              		.cfi_offset 5, -16
 1463              		.cfi_offset 6, -12
 1464              		.cfi_offset 7, -8
 1465              		.cfi_offset 14, -4
 1466 0002 4F46     		mov	r7, r9
 1467 0004 4646     		mov	r6, r8
 1468 0006 C0B4     		push	{r6, r7}
 1469              	.LCFI20:
 1470              		.cfi_def_cfa_offset 32
 1471              		.cfi_offset 8, -32
 1472              		.cfi_offset 9, -28
 1473              	.LVL131:
1116:tasks.c       **** 	portENTER_CRITICAL();
 1474              		.loc 1 1116 0
 1475 0008 FFF7FEFF 		bl	vPortEnterCritical
 1476              	.LVL132:
1118:tasks.c       **** 		--uxSchedulerSuspended;
 1477              		.loc 1 1118 0
 1478 000c 2F4B     		ldr	r3, .L130
 1479 000e 1A68     		ldr	r2, [r3]
 1480 0010 013A     		sub	r2, r2, #1
 1481 0012 1A60     		str	r2, [r3]
1120:tasks.c       **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1482              		.loc 1 1120 0
 1483 0014 1B68     		ldr	r3, [r3]
1109:tasks.c       **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1484              		.loc 1 1109 0
 1485 0016 0024     		mov	r4, #0
1120:tasks.c       **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1486              		.loc 1 1120 0
 1487 0018 002B     		cmp	r3, #0
 1488 001a 4ED1     		bne	.L111
1122:tasks.c       **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 1489              		.loc 1 1122 0
 1490 001c 2C4B     		ldr	r3, .L130+4
 1491 001e 1B68     		ldr	r3, [r3]
 1492 0020 A046     		mov	r8, r4
 1493 0022 002B     		cmp	r3, #0
 1494 0024 1FD1     		bne	.L126
 1495 0026 48E0     		b	.L111
 1496              	.LVL133:
 1497              	.L116:
 1498              	.LBB32:
1130:tasks.c       **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1499              		.loc 1 1130 0
 1500 0028 201C     		mov	r0, r4
 1501 002a 1830     		add	r0, r0, #24
 1502 002c FFF7FEFF 		bl	vListRemove
 1503              	.LVL134:
1131:tasks.c       **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1504              		.loc 1 1131 0
 1505 0030 251D     		add	r5, r4, #4
 1506 0032 281C     		mov	r0, r5
 1507 0034 FFF7FEFF 		bl	vListRemove
 1508              	.LVL135:
1132:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 1509              		.loc 1 1132 0
 1510 0038 E36A     		ldr	r3, [r4, #44]
 1511 003a 3A68     		ldr	r2, [r7]
 1512 003c 9342     		cmp	r3, r2
 1513 003e 01D9     		bls	.L113
1132:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 1514              		.loc 1 1132 0 is_stmt 0 discriminator 1
 1515 0040 244A     		ldr	r2, .L130+8
 1516 0042 1360     		str	r3, [r2]
 1517              	.L113:
1132:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 1518              		.loc 1 1132 0 discriminator 2
 1519 0044 9800     		lsl	r0, r3, #2
 1520 0046 C318     		add	r3, r0, r3
 1521 0048 9B00     		lsl	r3, r3, #2
 1522 004a 2348     		ldr	r0, .L130+12
 1523 004c C018     		add	r0, r0, r3
 1524 004e 291C     		mov	r1, r5
 1525 0050 FFF7FEFF 		bl	vListInsertEnd
 1526              	.LVL136:
1136:tasks.c       **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1527              		.loc 1 1136 0 is_stmt 1 discriminator 2
 1528 0054 214B     		ldr	r3, .L130+16
 1529 0056 1B68     		ldr	r3, [r3]
 1530 0058 E26A     		ldr	r2, [r4, #44]
 1531 005a DB6A     		ldr	r3, [r3, #44]
 1532 005c 9A42     		cmp	r2, r3
 1533 005e 05D3     		bcc	.L129
1138:tasks.c       **** 						xYieldRequired = pdTRUE;
 1534              		.loc 1 1138 0
 1535 0060 0123     		mov	r3, #1
 1536 0062 9846     		mov	r8, r3
 1537              	.LVL137:
 1538 0064 02E0     		b	.L129
 1539              	.LVL138:
 1540              	.L126:
1128:tasks.c       **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 1541              		.loc 1 1128 0 discriminator 1
 1542 0066 1E4E     		ldr	r6, .L130+20
 1543 0068 B146     		mov	r9, r6
1132:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 1544              		.loc 1 1132 0 discriminator 1
 1545 006a 1A4F     		ldr	r7, .L130+8
 1546              	.L129:
 1547              	.LVL139:
1128:tasks.c       **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 1548              		.loc 1 1128 0 discriminator 1
 1549 006c 3368     		ldr	r3, [r6]
 1550 006e 002B     		cmp	r3, #0
 1551 0070 04D0     		beq	.L115
 1552 0072 4A46     		mov	r2, r9
 1553 0074 D368     		ldr	r3, [r2, #12]
 1554 0076 DC68     		ldr	r4, [r3, #12]
 1555              	.LVL140:
 1556 0078 002C     		cmp	r4, #0
 1557 007a D5D1     		bne	.L116
 1558              	.LVL141:
 1559              	.L115:
1145:tasks.c       **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1560              		.loc 1 1145 0
 1561 007c 194B     		ldr	r3, .L130+24
 1562 007e 1B68     		ldr	r3, [r3]
 1563 0080 002B     		cmp	r3, #0
 1564 0082 0DD0     		beq	.L117
1147:tasks.c       **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1565              		.loc 1 1147 0 discriminator 1
 1566 0084 174B     		ldr	r3, .L130+24
 1567 0086 1B68     		ldr	r3, [r3]
 1568 0088 002B     		cmp	r3, #0
 1569 008a 11D0     		beq	.L120
1150:tasks.c       **** 						--uxMissedTicks;
 1570              		.loc 1 1150 0
 1571 008c 154C     		ldr	r4, .L130+24
 1572              	.L127:
1149:tasks.c       **** 						vTaskIncrementTick();
 1573              		.loc 1 1149 0
 1574 008e FFF7FEFF 		bl	vTaskIncrementTick
 1575              	.LVL142:
1150:tasks.c       **** 						--uxMissedTicks;
 1576              		.loc 1 1150 0
 1577 0092 2368     		ldr	r3, [r4]
 1578 0094 013B     		sub	r3, r3, #1
 1579 0096 2360     		str	r3, [r4]
1147:tasks.c       **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1580              		.loc 1 1147 0
 1581 0098 2368     		ldr	r3, [r4]
 1582 009a 002B     		cmp	r3, #0
 1583 009c F7D1     		bne	.L127
 1584 009e 07E0     		b	.L120
 1585              	.L117:
1163:tasks.c       **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1586              		.loc 1 1163 0
 1587 00a0 4346     		mov	r3, r8
 1588 00a2 012B     		cmp	r3, #1
 1589 00a4 04D0     		beq	.L120
 1590              	.LVL143:
1163:tasks.c       **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1591              		.loc 1 1163 0 is_stmt 0 discriminator 1
 1592 00a6 104B     		ldr	r3, .L130+28
 1593              	.LVL144:
 1594 00a8 1B68     		ldr	r3, [r3]
1109:tasks.c       **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1595              		.loc 1 1109 0 is_stmt 1 discriminator 1
 1596 00aa 0024     		mov	r4, #0
1163:tasks.c       **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1597              		.loc 1 1163 0 discriminator 1
 1598 00ac 012B     		cmp	r3, #1
 1599 00ae 04D1     		bne	.L111
 1600              	.L120:
 1601              	.LVL145:
1166:tasks.c       **** 					xMissedYield = pdFALSE;
 1602              		.loc 1 1166 0
 1603 00b0 0022     		mov	r2, #0
 1604 00b2 0D4B     		ldr	r3, .L130+28
 1605 00b4 1A60     		str	r2, [r3]
1167:tasks.c       **** 					portYIELD_WITHIN_API();
 1606              		.loc 1 1167 0
 1607              	@ 1167 "tasks.c" 1
 1608 00b6 00DF     		SWI 0
 1609              	@ 0 "" 2
1165:tasks.c       **** 					xAlreadyYielded = pdTRUE;
 1610              		.loc 1 1165 0
 1611              		.code	16
 1612 00b8 0124     		mov	r4, #1
 1613              	.LVL146:
 1614              	.L111:
 1615              	.LBE32:
1172:tasks.c       **** 	portEXIT_CRITICAL();
 1616              		.loc 1 1172 0
 1617 00ba FFF7FEFF 		bl	vPortExitCritical
 1618              	.LVL147:
1175:tasks.c       **** }
 1619              		.loc 1 1175 0
 1620 00be 201C     		mov	r0, r4
 1621              		@ sp needed for prologue
 1622              	.LVL148:
 1623 00c0 0CBC     		pop	{r2, r3}
 1624 00c2 9046     		mov	r8, r2
 1625 00c4 9946     		mov	r9, r3
 1626 00c6 F8BC     		pop	{r3, r4, r5, r6, r7}
 1627 00c8 02BC     		pop	{r1}
 1628 00ca 0847     		bx	r1
 1629              	.L131:
 1630              		.align	2
 1631              	.L130:
 1632 00cc 00000000 		.word	.LANCHOR14
 1633 00d0 00000000 		.word	.LANCHOR2
 1634 00d4 00000000 		.word	.LANCHOR13
 1635 00d8 00000000 		.word	.LANCHOR0
 1636 00dc 00000000 		.word	.LANCHOR3
 1637 00e0 00000000 		.word	.LANCHOR6
 1638 00e4 00000000 		.word	.LANCHOR21
 1639 00e8 00000000 		.word	.LANCHOR22
 1640              		.cfi_endproc
 1641              	.LFE12:
 1643              		.section	.text.vTaskList,"ax",%progbits
 1644              		.align	2
 1645              		.global	vTaskList
 1646              		.code	16
 1647              		.thumb_func
 1649              	vTaskList:
 1650              	.LFB16:
1220:tasks.c       **** 	{
 1651              		.loc 1 1220 0
 1652              		.cfi_startproc
 1653              	.LVL149:
 1654 0000 70B5     		push	{r4, r5, r6, lr}
 1655              	.LCFI21:
 1656              		.cfi_def_cfa_offset 16
 1657              		.cfi_offset 4, -16
 1658              		.cfi_offset 5, -12
 1659              		.cfi_offset 6, -8
 1660              		.cfi_offset 14, -4
 1661 0002 051C     		mov	r5, r0
1226:tasks.c       **** 		vTaskSuspendAll();
 1662              		.loc 1 1226 0
 1663 0004 FFF7FEFF 		bl	vTaskSuspendAll
 1664              	.LVL150:
1231:tasks.c       **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
 1665              		.loc 1 1231 0
 1666 0008 0023     		mov	r3, #0
 1667 000a 2B70     		strb	r3, [r5]
1232:tasks.c       **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 1668              		.loc 1 1232 0
 1669 000c 281C     		mov	r0, r5
 1670 000e FFF7FEFF 		bl	strlen
 1671              	.LVL151:
 1672 0012 2818     		add	r0, r5, r0
 1673 0014 1E49     		ldr	r1, .L139
 1674 0016 0322     		mov	r2, #3
 1675 0018 FFF7FEFF 		bl	memcpy
 1676              	.LVL152:
1234:tasks.c       **** 			uxQueue = uxTopUsedPriority + 1;
 1677              		.loc 1 1234 0
 1678 001c 1D4B     		ldr	r3, .L139+4
 1679 001e 1C68     		ldr	r4, [r3]
 1680 0020 0134     		add	r4, r4, #1
 1681              	.LVL153:
1240:tasks.c       **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 1682              		.loc 1 1240 0
 1683 0022 1D4E     		ldr	r6, .L139+8
 1684              	.L134:
1238:tasks.c       **** 				uxQueue--;
 1685              		.loc 1 1238 0
 1686 0024 013C     		sub	r4, r4, #1
 1687              	.LVL154:
1240:tasks.c       **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 1688              		.loc 1 1240 0
 1689 0026 A300     		lsl	r3, r4, #2
 1690 0028 1B19     		add	r3, r3, r4
 1691 002a 9B00     		lsl	r3, r3, #2
 1692 002c 9B59     		ldr	r3, [r3, r6]
 1693 002e 002B     		cmp	r3, #0
 1694 0030 08D0     		beq	.L133
1242:tasks.c       **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 1695              		.loc 1 1242 0
 1696 0032 A100     		lsl	r1, r4, #2
 1697 0034 0919     		add	r1, r1, r4
 1698 0036 8900     		lsl	r1, r1, #2
 1699 0038 174B     		ldr	r3, .L139+8
 1700 003a 5918     		add	r1, r3, r1
 1701 003c 281C     		mov	r0, r5
 1702 003e 5222     		mov	r2, #82
 1703 0040 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1704              	.LVL155:
 1705              	.L133:
1244:tasks.c       **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 1706              		.loc 1 1244 0
 1707 0044 002C     		cmp	r4, #0
 1708 0046 EDD1     		bne	.L134
1246:tasks.c       **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
 1709              		.loc 1 1246 0
 1710 0048 144B     		ldr	r3, .L139+12
 1711 004a 1B68     		ldr	r3, [r3]
 1712 004c 1B68     		ldr	r3, [r3]
 1713 004e 002B     		cmp	r3, #0
 1714 0050 05D0     		beq	.L135
1248:tasks.c       **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 1715              		.loc 1 1248 0
 1716 0052 124B     		ldr	r3, .L139+12
 1717 0054 1968     		ldr	r1, [r3]
 1718 0056 281C     		mov	r0, r5
 1719 0058 4222     		mov	r2, #66
 1720 005a FFF7FEFF 		bl	prvListTaskWithinSingleList
 1721              	.LVL156:
 1722              	.L135:
1251:tasks.c       **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
 1723              		.loc 1 1251 0
 1724 005e 104B     		ldr	r3, .L139+16
 1725 0060 1B68     		ldr	r3, [r3]
 1726 0062 1B68     		ldr	r3, [r3]
 1727 0064 002B     		cmp	r3, #0
 1728 0066 05D0     		beq	.L136
1253:tasks.c       **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 1729              		.loc 1 1253 0
 1730 0068 0D4B     		ldr	r3, .L139+16
 1731 006a 1968     		ldr	r1, [r3]
 1732 006c 281C     		mov	r0, r5
 1733 006e 4222     		mov	r2, #66
 1734 0070 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1735              	.LVL157:
 1736              	.L136:
1267:tasks.c       **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
 1737              		.loc 1 1267 0
 1738 0074 0B4B     		ldr	r3, .L139+20
 1739 0076 1B68     		ldr	r3, [r3]
 1740 0078 002B     		cmp	r3, #0
 1741 007a 04D0     		beq	.L137
1269:tasks.c       **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
 1742              		.loc 1 1269 0
 1743 007c 281C     		mov	r0, r5
 1744 007e 0949     		ldr	r1, .L139+20
 1745 0080 5322     		mov	r2, #83
 1746 0082 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1747              	.LVL158:
 1748              	.L137:
1274:tasks.c       **** 		xTaskResumeAll();
 1749              		.loc 1 1274 0
 1750 0086 FFF7FEFF 		bl	xTaskResumeAll
 1751              	.LVL159:
1275:tasks.c       **** 	}
 1752              		.loc 1 1275 0
 1753              		@ sp needed for prologue
 1754              	.LVL160:
 1755              	.LVL161:
 1756 008a 70BC     		pop	{r4, r5, r6}
 1757 008c 01BC     		pop	{r0}
 1758 008e 0047     		bx	r0
 1759              	.L140:
 1760              		.align	2
 1761              	.L139:
 1762 0090 1C000000 		.word	.LC66
 1763 0094 00000000 		.word	.LANCHOR11
 1764 0098 00000000 		.word	.LANCHOR0
 1765 009c 00000000 		.word	.LANCHOR8
 1766 00a0 00000000 		.word	.LANCHOR9
 1767 00a4 00000000 		.word	.LANCHOR7
 1768              		.cfi_endproc
 1769              	.LFE16:
 1771              		.section	.text.vTaskDelay,"ax",%progbits
 1772              		.align	2
 1773              		.global	vTaskDelay
 1774              		.code	16
 1775              		.thumb_func
 1777              	vTaskDelay:
 1778              	.LFB2:
 682:tasks.c       **** 	{
 1779              		.loc 1 682 0
 1780              		.cfi_startproc
 1781              	.LVL162:
 1782 0000 70B5     		push	{r4, r5, r6, lr}
 1783              	.LCFI22:
 1784              		.cfi_def_cfa_offset 16
 1785              		.cfi_offset 4, -16
 1786              		.cfi_offset 5, -12
 1787              		.cfi_offset 6, -8
 1788              		.cfi_offset 14, -4
 1789 0002 041C     		mov	r4, r0
 1790              	.LVL163:
 687:tasks.c       **** 		if( xTicksToDelay > ( portTickType ) 0 )
 1791              		.loc 1 687 0
 1792 0004 0028     		cmp	r0, #0
 1793 0006 21D0     		beq	.L142
 689:tasks.c       **** 			vTaskSuspendAll();
 1794              		.loc 1 689 0
 1795 0008 FFF7FEFF 		bl	vTaskSuspendAll
 1796              	.LVL164:
 703:tasks.c       **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1797              		.loc 1 703 0
 1798 000c 114D     		ldr	r5, .L146
 1799 000e 2B68     		ldr	r3, [r5]
 1800 0010 E418     		add	r4, r4, r3
 1801              	.LVL165:
 708:tasks.c       **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1802              		.loc 1 708 0
 1803 0012 114E     		ldr	r6, .L146+4
 1804 0014 3068     		ldr	r0, [r6]
 1805 0016 0430     		add	r0, r0, #4
 1806 0018 FFF7FEFF 		bl	vListRemove
 1807              	.LVL166:
 711:tasks.c       **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 1808              		.loc 1 711 0
 1809 001c 3368     		ldr	r3, [r6]
 1810 001e 5C60     		str	r4, [r3, #4]
 713:tasks.c       **** 				if( xTimeToWake < xTickCount )
 1811              		.loc 1 713 0
 1812 0020 2B68     		ldr	r3, [r5]
 1813 0022 9C42     		cmp	r4, r3
 1814 0024 07D2     		bcs	.L143
 717:tasks.c       **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 1815              		.loc 1 717 0
 1816 0026 0D4B     		ldr	r3, .L146+8
 1817 0028 1868     		ldr	r0, [r3]
 1818 002a 0B4B     		ldr	r3, .L146+4
 1819 002c 1968     		ldr	r1, [r3]
 1820 002e 0431     		add	r1, r1, #4
 1821 0030 FFF7FEFF 		bl	vListInsert
 1822              	.LVL167:
 1823 0034 06E0     		b	.L144
 1824              	.L143:
 723:tasks.c       **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 1825              		.loc 1 723 0
 1826 0036 0A4B     		ldr	r3, .L146+12
 1827 0038 1868     		ldr	r0, [r3]
 1828 003a 074B     		ldr	r3, .L146+4
 1829 003c 1968     		ldr	r1, [r3]
 1830 003e 0431     		add	r1, r1, #4
 1831 0040 FFF7FEFF 		bl	vListInsert
 1832              	.LVL168:
 1833              	.L144:
 726:tasks.c       **** 			xAlreadyYielded = xTaskResumeAll();
 1834              		.loc 1 726 0
 1835 0044 FFF7FEFF 		bl	xTaskResumeAll
 1836              	.LVL169:
 731:tasks.c       **** 		if( !xAlreadyYielded )
 1837              		.loc 1 731 0
 1838 0048 0028     		cmp	r0, #0
 1839 004a 00D1     		bne	.L141
 1840              	.LVL170:
 1841              	.L142:
 733:tasks.c       **** 			portYIELD_WITHIN_API();
 1842              		.loc 1 733 0
 1843              	@ 733 "tasks.c" 1
 1844 004c 00DF     		SWI 0
 1845              	@ 0 "" 2
 1846              		.code	16
 1847              	.L141:
 735:tasks.c       **** 	}
 1848              		.loc 1 735 0
 1849              		@ sp needed for prologue
 1850 004e 70BC     		pop	{r4, r5, r6}
 1851 0050 01BC     		pop	{r0}
 1852 0052 0047     		bx	r0
 1853              	.L147:
 1854              		.align	2
 1855              	.L146:
 1856 0054 00000000 		.word	.LANCHOR15
 1857 0058 00000000 		.word	.LANCHOR3
 1858 005c 00000000 		.word	.LANCHOR9
 1859 0060 00000000 		.word	.LANCHOR8
 1860              		.cfi_endproc
 1861              	.LFE2:
 1863              		.section	.text.vTaskDelayUntil,"ax",%progbits
 1864              		.align	2
 1865              		.global	vTaskDelayUntil
 1866              		.code	16
 1867              		.thumb_func
 1869              	vTaskDelayUntil:
 1870              	.LFB1:
 605:tasks.c       **** 	{
 1871              		.loc 1 605 0
 1872              		.cfi_startproc
 1873              	.LVL171:
 1874 0000 38B5     		push	{r3, r4, r5, lr}
 1875              	.LCFI23:
 1876              		.cfi_def_cfa_offset 16
 1877              		.cfi_offset 3, -16
 1878              		.cfi_offset 4, -12
 1879              		.cfi_offset 5, -8
 1880              		.cfi_offset 14, -4
 1881 0002 051C     		mov	r5, r0
 1882 0004 0C1C     		mov	r4, r1
 1883              	.LVL172:
 609:tasks.c       **** 		vTaskSuspendAll();
 1884              		.loc 1 609 0
 1885 0006 FFF7FEFF 		bl	vTaskSuspendAll
 1886              	.LVL173:
 612:tasks.c       **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1887              		.loc 1 612 0
 1888 000a 2B68     		ldr	r3, [r5]
 1889 000c E418     		add	r4, r4, r3
 1890              	.LVL174:
 614:tasks.c       **** 			if( xTickCount < *pxPreviousWakeTime )
 1891              		.loc 1 614 0
 1892 000e 1D4A     		ldr	r2, .L156
 1893 0010 1268     		ldr	r2, [r2]
 1894 0012 9342     		cmp	r3, r2
 1895 0014 07D9     		bls	.L149
 621:tasks.c       **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 1896              		.loc 1 621 0
 1897 0016 A342     		cmp	r3, r4
 1898 0018 2ED9     		bls	.L150
 621:tasks.c       **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 1899              		.loc 1 621 0 is_stmt 0 discriminator 1
 1900 001a 1A4B     		ldr	r3, .L156
 1901 001c 1B68     		ldr	r3, [r3]
 1902              	.LVL175:
 638:tasks.c       **** 			*pxPreviousWakeTime = xTimeToWake;
 1903              		.loc 1 638 0 is_stmt 1 discriminator 1
 1904 001e 2C60     		str	r4, [r5]
 640:tasks.c       **** 			if( xShouldDelay )
 1905              		.loc 1 640 0 discriminator 1
 1906 0020 9C42     		cmp	r4, r3
 1907 0022 21D9     		bls	.L152
 1908 0024 06E0     		b	.L151
 1909              	.LVL176:
 1910              	.L149:
 631:tasks.c       **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1911              		.loc 1 631 0
 1912 0026 A342     		cmp	r3, r4
 1913 0028 24D8     		bhi	.L153
 631:tasks.c       **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1914              		.loc 1 631 0 is_stmt 0 discriminator 1
 1915 002a 164B     		ldr	r3, .L156
 1916 002c 1B68     		ldr	r3, [r3]
 1917 002e 9C42     		cmp	r4, r3
 1918 0030 20D8     		bhi	.L153
 1919 0032 21E0     		b	.L150
 1920              	.LVL177:
 1921              	.L151:
 647:tasks.c       **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1922              		.loc 1 647 0 is_stmt 1
 1923 0034 144D     		ldr	r5, .L156+4
 1924              	.LVL178:
 1925 0036 2868     		ldr	r0, [r5]
 1926 0038 0430     		add	r0, r0, #4
 1927 003a FFF7FEFF 		bl	vListRemove
 1928              	.LVL179:
 650:tasks.c       **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 1929              		.loc 1 650 0
 1930 003e 2B68     		ldr	r3, [r5]
 1931 0040 5C60     		str	r4, [r3, #4]
 652:tasks.c       **** 				if( xTimeToWake < xTickCount )
 1932              		.loc 1 652 0
 1933 0042 104B     		ldr	r3, .L156
 1934 0044 1B68     		ldr	r3, [r3]
 1935 0046 9C42     		cmp	r4, r3
 1936 0048 07D2     		bcs	.L154
 656:tasks.c       **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 1937              		.loc 1 656 0
 1938 004a 104B     		ldr	r3, .L156+8
 1939 004c 1868     		ldr	r0, [r3]
 1940 004e 0E4B     		ldr	r3, .L156+4
 1941 0050 1968     		ldr	r1, [r3]
 1942 0052 0431     		add	r1, r1, #4
 1943 0054 FFF7FEFF 		bl	vListInsert
 1944              	.LVL180:
 1945 0058 06E0     		b	.L152
 1946              	.L154:
 662:tasks.c       **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 1947              		.loc 1 662 0
 1948 005a 0D4B     		ldr	r3, .L156+12
 1949 005c 1868     		ldr	r0, [r3]
 1950 005e 0A4B     		ldr	r3, .L156+4
 1951 0060 1968     		ldr	r1, [r3]
 1952 0062 0431     		add	r1, r1, #4
 1953 0064 FFF7FEFF 		bl	vListInsert
 1954              	.LVL181:
 1955              	.L152:
 666:tasks.c       **** 		xAlreadyYielded = xTaskResumeAll();
 1956              		.loc 1 666 0
 1957 0068 FFF7FEFF 		bl	xTaskResumeAll
 1958              	.LVL182:
 670:tasks.c       **** 		if( !xAlreadyYielded )
 1959              		.loc 1 670 0
 1960 006c 0028     		cmp	r0, #0
 1961 006e 05D1     		bne	.L148
 672:tasks.c       **** 			portYIELD_WITHIN_API();
 1962              		.loc 1 672 0
 1963              	@ 672 "tasks.c" 1
 1964 0070 00DF     		SWI 0
 1965              	@ 0 "" 2
 1966              		.code	16
 1967 0072 03E0     		b	.L148
 1968              	.LVL183:
 1969              	.L153:
 638:tasks.c       **** 			*pxPreviousWakeTime = xTimeToWake;
 1970              		.loc 1 638 0
 1971 0074 2C60     		str	r4, [r5]
 1972 0076 DDE7     		b	.L151
 1973              	.LVL184:
 1974              	.L150:
 1975 0078 2C60     		str	r4, [r5]
 1976 007a F5E7     		b	.L152
 1977              	.LVL185:
 1978              	.L148:
 674:tasks.c       **** 	}
 1979              		.loc 1 674 0
 1980              		@ sp needed for prologue
 1981              	.LVL186:
 1982 007c 38BC     		pop	{r3, r4, r5}
 1983 007e 01BC     		pop	{r0}
 1984 0080 0047     		bx	r0
 1985              	.L157:
 1986 0082 C046     		.align	2
 1987              	.L156:
 1988 0084 00000000 		.word	.LANCHOR15
 1989 0088 00000000 		.word	.LANCHOR3
 1990 008c 00000000 		.word	.LANCHOR9
 1991 0090 00000000 		.word	.LANCHOR8
 1992              		.cfi_endproc
 1993              	.LFE1:
 1995              		.section	.text.vTaskSwitchContext,"ax",%progbits
 1996              		.align	2
 1997              		.global	vTaskSwitchContext
 1998              		.code	16
 1999              		.thumb_func
 2001              	vTaskSwitchContext:
 2002              	.LFB20:
1584:tasks.c       **** {
 2003              		.loc 1 1584 0
 2004              		.cfi_startproc
 2005 0000 00B5     		push	{lr}
 2006              	.LCFI24:
 2007              		.cfi_def_cfa_offset 4
 2008              		.cfi_offset 14, -4
1585:tasks.c       **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2009              		.loc 1 1585 0
 2010 0002 2E4B     		ldr	r3, .L167
 2011 0004 1B68     		ldr	r3, [r3]
 2012 0006 002B     		cmp	r3, #0
 2013 0008 09D1     		bne	.L159
1613:tasks.c       **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2014              		.loc 1 1613 0 discriminator 1
 2015 000a 2D4B     		ldr	r3, .L167+4
 2016 000c 1B68     		ldr	r3, [r3]
 2017 000e 9A00     		lsl	r2, r3, #2
 2018 0010 D318     		add	r3, r2, r3
 2019 0012 9B00     		lsl	r3, r3, #2
 2020 0014 2B4A     		ldr	r2, .L167+8
 2021 0016 9B58     		ldr	r3, [r3, r2]
 2022 0018 002B     		cmp	r3, #0
 2023 001a 04D0     		beq	.L160
 2024 001c 0FE0     		b	.L161
 2025              	.L159:
1589:tasks.c       **** 		xMissedYield = pdTRUE;
 2026              		.loc 1 1589 0
 2027 001e 0122     		mov	r2, #1
 2028 0020 294B     		ldr	r3, .L167+12
 2029 0022 1A60     		str	r2, [r3]
1590:tasks.c       **** 		return;
 2030              		.loc 1 1590 0
 2031 0024 47E0     		b	.L158
 2032              	.L160:
1615:tasks.c       **** 		--uxTopReadyPriority;
 2033              		.loc 1 1615 0
 2034 0026 264B     		ldr	r3, .L167+4
1613:tasks.c       **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2035              		.loc 1 1613 0
 2036 0028 2648     		ldr	r0, .L167+8
 2037              	.L165:
1615:tasks.c       **** 		--uxTopReadyPriority;
 2038              		.loc 1 1615 0
 2039 002a 1A68     		ldr	r2, [r3]
 2040 002c 013A     		sub	r2, r2, #1
 2041 002e 1A60     		str	r2, [r3]
1613:tasks.c       **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2042              		.loc 1 1613 0
 2043 0030 1A68     		ldr	r2, [r3]
 2044 0032 9100     		lsl	r1, r2, #2
 2045 0034 8A18     		add	r2, r1, r2
 2046 0036 9200     		lsl	r2, r2, #2
 2047 0038 1258     		ldr	r2, [r2, r0]
 2048 003a 002A     		cmp	r2, #0
 2049 003c F5D0     		beq	.L165
 2050              	.L161:
 2051              	.LBB33:
1620:tasks.c       **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2052              		.loc 1 1620 0
 2053 003e 204B     		ldr	r3, .L167+4
 2054 0040 1B68     		ldr	r3, [r3]
 2055 0042 9A00     		lsl	r2, r3, #2
 2056 0044 D318     		add	r3, r2, r3
 2057 0046 9B00     		lsl	r3, r3, #2
 2058 0048 1E4A     		ldr	r2, .L167+8
 2059 004a D318     		add	r3, r2, r3
 2060              	.LVL187:
 2061 004c 5A68     		ldr	r2, [r3, #4]
 2062 004e 5268     		ldr	r2, [r2, #4]
 2063 0050 5A60     		str	r2, [r3, #4]
 2064 0052 191C     		mov	r1, r3
 2065 0054 0831     		add	r1, r1, #8
 2066 0056 8A42     		cmp	r2, r1
 2067 0058 01D1     		bne	.L163
1620:tasks.c       **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2068              		.loc 1 1620 0 is_stmt 0 discriminator 1
 2069 005a 5268     		ldr	r2, [r2, #4]
 2070 005c 5A60     		str	r2, [r3, #4]
 2071              	.L163:
1620:tasks.c       **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2072              		.loc 1 1620 0 discriminator 2
 2073 005e 5B68     		ldr	r3, [r3, #4]
 2074              	.LVL188:
 2075 0060 DA68     		ldr	r2, [r3, #12]
 2076 0062 1A4B     		ldr	r3, .L167+16
 2077 0064 1A60     		str	r2, [r3]
 2078              	.LBE33:
1623:tasks.c       **** 	vWriteTraceToBuffer();
 2079              		.loc 1 1623 0 is_stmt 1 discriminator 2
 2080 0066 1A4B     		ldr	r3, .L167+20
 2081 0068 1B68     		ldr	r3, [r3]
 2082 006a 002B     		cmp	r3, #0
 2083 006c 23D0     		beq	.L158
1623:tasks.c       **** 	vWriteTraceToBuffer();
 2084              		.loc 1 1623 0 is_stmt 0 discriminator 1
 2085 006e 174B     		ldr	r3, .L167+16
 2086 0070 1B68     		ldr	r3, [r3]
 2087 0072 5A6C     		ldr	r2, [r3, #68]
 2088 0074 174B     		ldr	r3, .L167+24
 2089 0076 1B68     		ldr	r3, [r3]
 2090 0078 9A42     		cmp	r2, r3
 2091 007a 1CD0     		beq	.L158
1623:tasks.c       **** 	vWriteTraceToBuffer();
 2092              		.loc 1 1623 0 discriminator 2
 2093 007c 164B     		ldr	r3, .L167+28
 2094 007e 1B68     		ldr	r3, [r3]
 2095 0080 0833     		add	r3, r3, #8
 2096 0082 164A     		ldr	r2, .L167+32
 2097 0084 1268     		ldr	r2, [r2]
 2098 0086 9A42     		cmp	r2, r3
 2099 0088 12D9     		bls	.L164
1623:tasks.c       **** 	vWriteTraceToBuffer();
 2100              		.loc 1 1623 0 discriminator 3
 2101 008a 104B     		ldr	r3, .L167+16
 2102 008c 1B68     		ldr	r3, [r3]
 2103 008e 5A6C     		ldr	r2, [r3, #68]
 2104 0090 104B     		ldr	r3, .L167+24
 2105 0092 1A60     		str	r2, [r3]
 2106 0094 104B     		ldr	r3, .L167+28
 2107 0096 1968     		ldr	r1, [r3]
 2108              	.LVL189:
 2109 0098 1148     		ldr	r0, .L167+36
 2110 009a 0068     		ldr	r0, [r0]
 2111 009c 0860     		str	r0, [r1]
 2112 009e 1968     		ldr	r1, [r3]
 2113 00a0 0431     		add	r1, r1, #4
 2114 00a2 1960     		str	r1, [r3]
 2115 00a4 1968     		ldr	r1, [r3]
 2116 00a6 0A60     		str	r2, [r1]
 2117 00a8 1A68     		ldr	r2, [r3]
 2118 00aa 0432     		add	r2, r2, #4
 2119 00ac 1A60     		str	r2, [r3]
 2120 00ae 02E0     		b	.L158
 2121              	.LVL190:
 2122              	.L164:
1623:tasks.c       **** 	vWriteTraceToBuffer();
 2123              		.loc 1 1623 0 discriminator 4
 2124 00b0 0022     		mov	r2, #0
 2125 00b2 074B     		ldr	r3, .L167+20
 2126 00b4 1A60     		str	r2, [r3]
 2127              	.LVL191:
 2128              	.L158:
1624:tasks.c       **** }
 2129              		.loc 1 1624 0 is_stmt 1
 2130              		@ sp needed for prologue
 2131 00b6 01BC     		pop	{r0}
 2132 00b8 0047     		bx	r0
 2133              	.L168:
 2134 00ba C046     		.align	2
 2135              	.L167:
 2136 00bc 00000000 		.word	.LANCHOR14
 2137 00c0 00000000 		.word	.LANCHOR13
 2138 00c4 00000000 		.word	.LANCHOR0
 2139 00c8 00000000 		.word	.LANCHOR22
 2140 00cc 00000000 		.word	.LANCHOR3
 2141 00d0 00000000 		.word	.LANCHOR19
 2142 00d4 00000000 		.word	.LANCHOR23
 2143 00d8 00000000 		.word	.LANCHOR16
 2144 00dc 00000000 		.word	.LANCHOR18
 2145 00e0 00000000 		.word	.LANCHOR15
 2146              		.cfi_endproc
 2147              	.LFE20:
 2149              		.section	.text.vTaskSuspend,"ax",%progbits
 2150              		.align	2
 2151              		.global	vTaskSuspend
 2152              		.code	16
 2153              		.thumb_func
 2155              	vTaskSuspend:
 2156              	.LFB5:
 870:tasks.c       **** 	{
 2157              		.loc 1 870 0
 2158              		.cfi_startproc
 2159              	.LVL192:
 2160 0000 70B5     		push	{r4, r5, r6, lr}
 2161              	.LCFI25:
 2162              		.cfi_def_cfa_offset 16
 2163              		.cfi_offset 4, -16
 2164              		.cfi_offset 5, -12
 2165              		.cfi_offset 6, -8
 2166              		.cfi_offset 14, -4
 2167 0002 041C     		mov	r4, r0
 873:tasks.c       **** 		portENTER_CRITICAL();
 2168              		.loc 1 873 0
 2169 0004 FFF7FEFF 		bl	vPortEnterCritical
 2170              	.LVL193:
 877:tasks.c       **** 			if( pxTaskToSuspend == pxCurrentTCB )
 2171              		.loc 1 877 0
 2172 0008 184B     		ldr	r3, .L178
 2173 000a 1B68     		ldr	r3, [r3]
 2174 000c 9C42     		cmp	r4, r3
 2175 000e 03D0     		beq	.L176
 883:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 2176              		.loc 1 883 0
 2177 0010 251C     		mov	r5, r4
 2178 0012 002C     		cmp	r4, #0
 2179 0014 03D1     		bne	.L171
 2180 0016 00E0     		b	.L170
 2181              	.L176:
 879:tasks.c       **** 				pxTaskToSuspend = NULL;
 2182              		.loc 1 879 0
 2183 0018 0024     		mov	r4, #0
 2184              	.LVL194:
 2185              	.L170:
 883:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 2186              		.loc 1 883 0 discriminator 1
 2187 001a 144B     		ldr	r3, .L178
 2188 001c 1D68     		ldr	r5, [r3]
 2189              	.L171:
 2190              	.LVL195:
 888:tasks.c       **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 2191              		.loc 1 888 0 discriminator 3
 2192 001e 2E1D     		add	r6, r5, #4
 2193 0020 301C     		mov	r0, r6
 2194 0022 FFF7FEFF 		bl	vListRemove
 2195              	.LVL196:
 891:tasks.c       **** 			if( pxTCB->xEventListItem.pvContainer )
 2196              		.loc 1 891 0 discriminator 3
 2197 0026 AB6A     		ldr	r3, [r5, #40]
 2198 0028 002B     		cmp	r3, #0
 2199 002a 03D0     		beq	.L172
 893:tasks.c       **** 				vListRemove( &( pxTCB->xEventListItem ) );
 2200              		.loc 1 893 0
 2201 002c 281C     		mov	r0, r5
 2202 002e 1830     		add	r0, r0, #24
 2203 0030 FFF7FEFF 		bl	vListRemove
 2204              	.LVL197:
 2205              	.L172:
 896:tasks.c       **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 2206              		.loc 1 896 0
 2207 0034 0E48     		ldr	r0, .L178+4
 2208 0036 311C     		mov	r1, r6
 2209 0038 FFF7FEFF 		bl	vListInsertEnd
 2210              	.LVL198:
 898:tasks.c       **** 		portEXIT_CRITICAL();
 2211              		.loc 1 898 0
 2212 003c FFF7FEFF 		bl	vPortExitCritical
 2213              	.LVL199:
 900:tasks.c       **** 		if( ( void * ) pxTaskToSuspend == NULL )
 2214              		.loc 1 900 0
 2215 0040 002C     		cmp	r4, #0
 2216 0042 0FD1     		bne	.L169
 902:tasks.c       **** 			if( xSchedulerRunning != pdFALSE )
 2217              		.loc 1 902 0
 2218 0044 0B4B     		ldr	r3, .L178+8
 2219 0046 1B68     		ldr	r3, [r3]
 2220 0048 002B     		cmp	r3, #0
 2221 004a 01D0     		beq	.L174
 905:tasks.c       **** 				portYIELD_WITHIN_API();
 2222              		.loc 1 905 0
 2223              	@ 905 "tasks.c" 1
 2224 004c 00DF     		SWI 0
 2225              	@ 0 "" 2
 2226              		.code	16
 2227 004e 09E0     		b	.L169
 2228              	.L174:
 912:tasks.c       **** 				if( uxCurrentNumberOfTasks == 1 )
 2229              		.loc 1 912 0
 2230 0050 094B     		ldr	r3, .L178+12
 2231 0052 1B68     		ldr	r3, [r3]
 2232 0054 012B     		cmp	r3, #1
 2233 0056 03D1     		bne	.L175
 918:tasks.c       **** 					pxCurrentTCB = NULL;
 2234              		.loc 1 918 0
 2235 0058 0022     		mov	r2, #0
 2236 005a 044B     		ldr	r3, .L178
 2237 005c 1A60     		str	r2, [r3]
 2238 005e 01E0     		b	.L169
 2239              	.L175:
 922:tasks.c       **** 					vTaskSwitchContext();
 2240              		.loc 1 922 0
 2241 0060 FFF7FEFF 		bl	vTaskSwitchContext
 2242              	.LVL200:
 2243              	.L169:
 926:tasks.c       **** 	}
 2244              		.loc 1 926 0
 2245              		@ sp needed for prologue
 2246              	.LVL201:
 2247              	.LVL202:
 2248 0064 70BC     		pop	{r4, r5, r6}
 2249 0066 01BC     		pop	{r0}
 2250 0068 0047     		bx	r0
 2251              	.L179:
 2252 006a C046     		.align	2
 2253              	.L178:
 2254 006c 00000000 		.word	.LANCHOR3
 2255 0070 00000000 		.word	.LANCHOR7
 2256 0074 00000000 		.word	.LANCHOR10
 2257 0078 00000000 		.word	.LANCHOR2
 2258              		.cfi_endproc
 2259              	.LFE5:
 2261              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2262              		.align	2
 2263              		.global	vTaskPlaceOnEventList
 2264              		.code	16
 2265              		.thumb_func
 2267              	vTaskPlaceOnEventList:
 2268              	.LFB21:
1628:tasks.c       **** {
 2269              		.loc 1 1628 0
 2270              		.cfi_startproc
 2271              	.LVL203:
 2272 0000 38B5     		push	{r3, r4, r5, lr}
 2273              	.LCFI26:
 2274              		.cfi_def_cfa_offset 16
 2275              		.cfi_offset 3, -16
 2276              		.cfi_offset 4, -12
 2277              		.cfi_offset 5, -8
 2278              		.cfi_offset 14, -4
 2279 0002 0D1C     		mov	r5, r1
1637:tasks.c       **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2280              		.loc 1 1637 0
 2281 0004 164C     		ldr	r4, .L184
 2282 0006 2168     		ldr	r1, [r4]
 2283              	.LVL204:
 2284 0008 1831     		add	r1, r1, #24
 2285 000a FFF7FEFF 		bl	vListInsert
 2286              	.LVL205:
1642:tasks.c       **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2287              		.loc 1 1642 0
 2288 000e 2068     		ldr	r0, [r4]
 2289 0010 0430     		add	r0, r0, #4
 2290 0012 FFF7FEFF 		bl	vListRemove
 2291              	.LVL206:
1647:tasks.c       **** 		if( xTicksToWait == portMAX_DELAY )
 2292              		.loc 1 1647 0
 2293 0016 6B1C     		add	r3, r5, #1
 2294 0018 06D1     		bne	.L181
1652:tasks.c       **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2295              		.loc 1 1652 0
 2296 001a 114B     		ldr	r3, .L184
 2297 001c 1968     		ldr	r1, [r3]
 2298 001e 0431     		add	r1, r1, #4
 2299 0020 1048     		ldr	r0, .L184+4
 2300 0022 FFF7FEFF 		bl	vListInsertEnd
 2301              	.LVL207:
 2302 0026 17E0     		b	.L180
 2303              	.L181:
1658:tasks.c       **** 			xTimeToWake = xTickCount + xTicksToWait;
 2304              		.loc 1 1658 0
 2305 0028 0F4B     		ldr	r3, .L184+8
 2306 002a 1A68     		ldr	r2, [r3]
 2307 002c AD18     		add	r5, r5, r2
 2308              	.LVL208:
1660:tasks.c       **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2309              		.loc 1 1660 0
 2310 002e 0C4A     		ldr	r2, .L184
 2311 0030 1268     		ldr	r2, [r2]
 2312 0032 5560     		str	r5, [r2, #4]
1662:tasks.c       **** 			if( xTimeToWake < xTickCount )
 2313              		.loc 1 1662 0
 2314 0034 1B68     		ldr	r3, [r3]
 2315 0036 9D42     		cmp	r5, r3
 2316 0038 07D2     		bcs	.L183
1665:tasks.c       **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
 2317              		.loc 1 1665 0
 2318 003a 0C4B     		ldr	r3, .L184+12
 2319 003c 1868     		ldr	r0, [r3]
 2320 003e 084B     		ldr	r3, .L184
 2321 0040 1968     		ldr	r1, [r3]
 2322 0042 0431     		add	r1, r1, #4
 2323 0044 FFF7FEFF 		bl	vListInsert
 2324              	.LVL209:
 2325 0048 06E0     		b	.L180
 2326              	.L183:
1670:tasks.c       **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
 2327              		.loc 1 1670 0
 2328 004a 094B     		ldr	r3, .L184+16
 2329 004c 1868     		ldr	r0, [r3]
 2330 004e 044B     		ldr	r3, .L184
 2331 0050 1968     		ldr	r1, [r3]
 2332 0052 0431     		add	r1, r1, #4
 2333 0054 FFF7FEFF 		bl	vListInsert
 2334              	.LVL210:
 2335              	.L180:
1694:tasks.c       **** }
 2336              		.loc 1 1694 0
 2337              		@ sp needed for prologue
 2338 0058 38BC     		pop	{r3, r4, r5}
 2339 005a 01BC     		pop	{r0}
 2340 005c 0047     		bx	r0
 2341              	.L185:
 2342 005e C046     		.align	2
 2343              	.L184:
 2344 0060 00000000 		.word	.LANCHOR3
 2345 0064 00000000 		.word	.LANCHOR7
 2346 0068 00000000 		.word	.LANCHOR15
 2347 006c 00000000 		.word	.LANCHOR9
 2348 0070 00000000 		.word	.LANCHOR8
 2349              		.cfi_endproc
 2350              	.LFE21:
 2352              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2353              		.align	2
 2354              		.global	xTaskRemoveFromEventList
 2355              		.code	16
 2356              		.thumb_func
 2358              	xTaskRemoveFromEventList:
 2359              	.LFB22:
1698:tasks.c       **** {
 2360              		.loc 1 1698 0
 2361              		.cfi_startproc
 2362              	.LVL211:
 2363 0000 38B5     		push	{r3, r4, r5, lr}
 2364              	.LCFI27:
 2365              		.cfi_def_cfa_offset 16
 2366              		.cfi_offset 3, -16
 2367              		.cfi_offset 4, -12
 2368              		.cfi_offset 5, -8
 2369              		.cfi_offset 14, -4
1712:tasks.c       **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2370              		.loc 1 1712 0
 2371 0002 0368     		ldr	r3, [r0]
 2372 0004 0024     		mov	r4, #0
 2373 0006 002B     		cmp	r3, #0
 2374 0008 01D0     		beq	.L187
1712:tasks.c       **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2375              		.loc 1 1712 0 is_stmt 0 discriminator 1
 2376 000a C368     		ldr	r3, [r0, #12]
 2377 000c DC68     		ldr	r4, [r3, #12]
 2378              	.L187:
 2379              	.LVL212:
1713:tasks.c       **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2380              		.loc 1 1713 0 is_stmt 1 discriminator 3
 2381 000e 251C     		mov	r5, r4
 2382 0010 1835     		add	r5, r5, #24
 2383 0012 281C     		mov	r0, r5
 2384              	.LVL213:
 2385 0014 FFF7FEFF 		bl	vListRemove
 2386              	.LVL214:
1715:tasks.c       **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2387              		.loc 1 1715 0 discriminator 3
 2388 0018 124B     		ldr	r3, .L192
 2389 001a 1B68     		ldr	r3, [r3]
 2390 001c 002B     		cmp	r3, #0
 2391 001e 13D1     		bne	.L188
1717:tasks.c       **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2392              		.loc 1 1717 0
 2393 0020 251D     		add	r5, r4, #4
 2394 0022 281C     		mov	r0, r5
 2395 0024 FFF7FEFF 		bl	vListRemove
 2396              	.LVL215:
1718:tasks.c       **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2397              		.loc 1 1718 0
 2398 0028 E36A     		ldr	r3, [r4, #44]
 2399 002a 0F4A     		ldr	r2, .L192+4
 2400 002c 1268     		ldr	r2, [r2]
 2401 002e 9342     		cmp	r3, r2
 2402 0030 01D9     		bls	.L189
1718:tasks.c       **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2403              		.loc 1 1718 0 is_stmt 0 discriminator 1
 2404 0032 0D4A     		ldr	r2, .L192+4
 2405 0034 1360     		str	r3, [r2]
 2406              	.L189:
1718:tasks.c       **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2407              		.loc 1 1718 0 discriminator 2
 2408 0036 9800     		lsl	r0, r3, #2
 2409 0038 C318     		add	r3, r0, r3
 2410 003a 9B00     		lsl	r3, r3, #2
 2411 003c 0B48     		ldr	r0, .L192+8
 2412 003e C018     		add	r0, r0, r3
 2413 0040 291C     		mov	r1, r5
 2414 0042 FFF7FEFF 		bl	vListInsertEnd
 2415              	.LVL216:
 2416 0046 03E0     		b	.L190
 2417              	.L188:
1724:tasks.c       **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2418              		.loc 1 1724 0 is_stmt 1
 2419 0048 0948     		ldr	r0, .L192+12
 2420 004a 291C     		mov	r1, r5
 2421 004c FFF7FEFF 		bl	vListInsertEnd
 2422              	.LVL217:
 2423              	.L190:
1727:tasks.c       **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2424              		.loc 1 1727 0
 2425 0050 084B     		ldr	r3, .L192+16
 2426 0052 1B68     		ldr	r3, [r3]
 2427              	.LVL218:
 2428 0054 E26A     		ldr	r2, [r4, #44]
 2429 0056 DB6A     		ldr	r3, [r3, #44]
 2430              	.LVL219:
 2431 0058 0020     		mov	r0, #0
 2432 005a 9A42     		cmp	r2, r3
 2433 005c 4041     		adc	r0, r0, r0
1741:tasks.c       **** }
 2434              		.loc 1 1741 0
 2435              		@ sp needed for prologue
 2436              	.LVL220:
 2437 005e 38BC     		pop	{r3, r4, r5}
 2438 0060 02BC     		pop	{r1}
 2439 0062 0847     		bx	r1
 2440              	.L193:
 2441              		.align	2
 2442              	.L192:
 2443 0064 00000000 		.word	.LANCHOR14
 2444 0068 00000000 		.word	.LANCHOR13
 2445 006c 00000000 		.word	.LANCHOR0
 2446 0070 00000000 		.word	.LANCHOR6
 2447 0074 00000000 		.word	.LANCHOR3
 2448              		.cfi_endproc
 2449              	.LFE22:
 2451              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2452              		.align	2
 2453              		.global	vTaskSetTimeOutState
 2454              		.code	16
 2455              		.thumb_func
 2457              	vTaskSetTimeOutState:
 2458              	.LFB23:
1745:tasks.c       **** {
 2459              		.loc 1 1745 0
 2460              		.cfi_startproc
 2461              	.LVL221:
1746:tasks.c       **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2462              		.loc 1 1746 0
 2463 0000 034B     		ldr	r3, .L195
 2464 0002 1B68     		ldr	r3, [r3]
 2465 0004 0360     		str	r3, [r0]
1747:tasks.c       **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2466              		.loc 1 1747 0
 2467 0006 034B     		ldr	r3, .L195+4
 2468 0008 1B68     		ldr	r3, [r3]
 2469 000a 4360     		str	r3, [r0, #4]
1748:tasks.c       **** }
 2470              		.loc 1 1748 0
 2471              		@ sp needed for prologue
 2472 000c 7047     		bx	lr
 2473              	.L196:
 2474 000e C046     		.align	2
 2475              	.L195:
 2476 0010 00000000 		.word	.LANCHOR20
 2477 0014 00000000 		.word	.LANCHOR15
 2478              		.cfi_endproc
 2479              	.LFE23:
 2481              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2482              		.align	2
 2483              		.global	xTaskCheckForTimeOut
 2484              		.code	16
 2485              		.thumb_func
 2487              	xTaskCheckForTimeOut:
 2488              	.LFB24:
1752:tasks.c       **** {
 2489              		.loc 1 1752 0
 2490              		.cfi_startproc
 2491              	.LVL222:
 2492 0000 70B5     		push	{r4, r5, r6, lr}
 2493              	.LCFI28:
 2494              		.cfi_def_cfa_offset 16
 2495              		.cfi_offset 4, -16
 2496              		.cfi_offset 5, -12
 2497              		.cfi_offset 6, -8
 2498              		.cfi_offset 14, -4
 2499 0002 041C     		mov	r4, r0
 2500 0004 0E1C     		mov	r6, r1
1755:tasks.c       **** 	portENTER_CRITICAL();
 2501              		.loc 1 1755 0
 2502 0006 FFF7FEFF 		bl	vPortEnterCritical
 2503              	.LVL223:
1761:tasks.c       **** 			if( *pxTicksToWait == portMAX_DELAY )
 2504              		.loc 1 1761 0
 2505 000a 3368     		ldr	r3, [r6]
 2506 000c 591C     		add	r1, r3, #1
 2507 000e 1BD0     		beq	.L200
1768:tasks.c       **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2508              		.loc 1 1768 0
 2509 0010 114A     		ldr	r2, .L203
 2510 0012 1268     		ldr	r2, [r2]
 2511 0014 2168     		ldr	r1, [r4]
 2512 0016 9142     		cmp	r1, r2
 2513 0018 05D0     		beq	.L199
1768:tasks.c       **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2514              		.loc 1 1768 0 is_stmt 0 discriminator 1
 2515 001a 104A     		ldr	r2, .L203+4
 2516 001c 1268     		ldr	r2, [r2]
1774:tasks.c       **** 			xReturn = pdTRUE;
 2517              		.loc 1 1774 0 is_stmt 1 discriminator 1
 2518 001e 0125     		mov	r5, #1
1768:tasks.c       **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2519              		.loc 1 1768 0 discriminator 1
 2520 0020 6168     		ldr	r1, [r4, #4]
 2521 0022 9142     		cmp	r1, r2
 2522 0024 11D9     		bls	.L198
 2523              	.L199:
1776:tasks.c       **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2524              		.loc 1 1776 0
 2525 0026 0D4A     		ldr	r2, .L203+4
 2526 0028 1168     		ldr	r1, [r2]
 2527 002a 6268     		ldr	r2, [r4, #4]
 2528 002c 891A     		sub	r1, r1, r2
1785:tasks.c       **** 			xReturn = pdTRUE;
 2529              		.loc 1 1785 0
 2530 002e 0125     		mov	r5, #1
1776:tasks.c       **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2531              		.loc 1 1776 0
 2532 0030 8B42     		cmp	r3, r1
 2533 0032 0AD9     		bls	.L198
1779:tasks.c       **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2534              		.loc 1 1779 0
 2535 0034 0949     		ldr	r1, .L203+4
 2536 0036 0968     		ldr	r1, [r1]
 2537 0038 521A     		sub	r2, r2, r1
 2538 003a D318     		add	r3, r2, r3
 2539 003c 3360     		str	r3, [r6]
1780:tasks.c       **** 			vTaskSetTimeOutState( pxTimeOut );
 2540              		.loc 1 1780 0
 2541 003e 201C     		mov	r0, r4
 2542 0040 FFF7FEFF 		bl	vTaskSetTimeOutState
 2543              	.LVL224:
1781:tasks.c       **** 			xReturn = pdFALSE;
 2544              		.loc 1 1781 0
 2545 0044 0025     		mov	r5, #0
 2546 0046 00E0     		b	.L198
 2547              	.LVL225:
 2548              	.L200:
1763:tasks.c       **** 				xReturn = pdFALSE;
 2549              		.loc 1 1763 0
 2550 0048 0025     		mov	r5, #0
 2551              	.L198:
 2552              	.LVL226:
1788:tasks.c       **** 	portEXIT_CRITICAL();
 2553              		.loc 1 1788 0
 2554 004a FFF7FEFF 		bl	vPortExitCritical
 2555              	.LVL227:
1791:tasks.c       **** }
 2556              		.loc 1 1791 0
 2557 004e 281C     		mov	r0, r5
 2558              		@ sp needed for prologue
 2559              	.LVL228:
 2560              	.LVL229:
 2561              	.LVL230:
 2562 0050 70BC     		pop	{r4, r5, r6}
 2563 0052 02BC     		pop	{r1}
 2564 0054 0847     		bx	r1
 2565              	.L204:
 2566 0056 C046     		.align	2
 2567              	.L203:
 2568 0058 00000000 		.word	.LANCHOR20
 2569 005c 00000000 		.word	.LANCHOR15
 2570              		.cfi_endproc
 2571              	.LFE24:
 2573              		.section	.text.vTaskMissedYield,"ax",%progbits
 2574              		.align	2
 2575              		.global	vTaskMissedYield
 2576              		.code	16
 2577              		.thumb_func
 2579              	vTaskMissedYield:
 2580              	.LFB25:
1795:tasks.c       **** {
 2581              		.loc 1 1795 0
 2582              		.cfi_startproc
1796:tasks.c       **** 	xMissedYield = pdTRUE;
 2583              		.loc 1 1796 0
 2584 0000 0122     		mov	r2, #1
 2585 0002 014B     		ldr	r3, .L206
 2586 0004 1A60     		str	r2, [r3]
1797:tasks.c       **** }
 2587              		.loc 1 1797 0
 2588              		@ sp needed for prologue
 2589 0006 7047     		bx	lr
 2590              	.L207:
 2591              		.align	2
 2592              	.L206:
 2593 0008 00000000 		.word	.LANCHOR22
 2594              		.cfi_endproc
 2595              	.LFE25:
 2597              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 2598              		.align	2
 2599              		.global	xTaskGetCurrentTaskHandle
 2600              		.code	16
 2601              		.thumb_func
 2603              	xTaskGetCurrentTaskHandle:
 2604              	.LFB33:
2150:tasks.c       **** 			usCount++;
2151:tasks.c       **** 		}
2152:tasks.c       **** 
2153:tasks.c       **** 		usCount /= sizeof( portSTACK_TYPE );
2154:tasks.c       **** 
2155:tasks.c       **** 		return usCount;
2156:tasks.c       **** 	}
2157:tasks.c       **** 
2158:tasks.c       **** #endif
2159:tasks.c       **** /*-----------------------------------------------------------*/
2160:tasks.c       **** 
2161:tasks.c       **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2162:tasks.c       **** 
2163:tasks.c       **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2164:tasks.c       **** 	{
2165:tasks.c       **** 	tskTCB *pxTCB;
2166:tasks.c       **** 	unsigned char *pcEndOfStack;
2167:tasks.c       **** 	unsigned portBASE_TYPE uxReturn;
2168:tasks.c       **** 
2169:tasks.c       **** 		pxTCB = prvGetTCBFromHandle( xTask );
2170:tasks.c       **** 
2171:tasks.c       **** 		#if portSTACK_GROWTH < 0
2172:tasks.c       **** 		{
2173:tasks.c       **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2174:tasks.c       **** 		}
2175:tasks.c       **** 		#else
2176:tasks.c       **** 		{
2177:tasks.c       **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2178:tasks.c       **** 		}
2179:tasks.c       **** 		#endif
2180:tasks.c       **** 
2181:tasks.c       **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2182:tasks.c       **** 
2183:tasks.c       **** 		return uxReturn;
2184:tasks.c       **** 	}
2185:tasks.c       **** 
2186:tasks.c       **** #endif
2187:tasks.c       **** /*-----------------------------------------------------------*/
2188:tasks.c       **** 
2189:tasks.c       **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
2190:tasks.c       **** 
2191:tasks.c       **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2192:tasks.c       **** 	{
2193:tasks.c       **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2194:tasks.c       **** 		the task to free any memory allocated at the application level. */
2195:tasks.c       **** 		vPortFreeAligned( pxTCB->pxStack );
2196:tasks.c       **** 		vPortFree( pxTCB );
2197:tasks.c       **** 	}
2198:tasks.c       **** 
2199:tasks.c       **** #endif
2200:tasks.c       **** 
2201:tasks.c       **** 
2202:tasks.c       **** /*-----------------------------------------------------------*/
2203:tasks.c       **** 
2204:tasks.c       **** #if ( INCLUDE_xTaskGetCurrentTaskHandle == 1 )
2205:tasks.c       **** 
2206:tasks.c       **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2207:tasks.c       **** 	{
 2605              		.loc 1 2207 0
 2606              		.cfi_startproc
2208:tasks.c       **** 	xTaskHandle xReturn;
2209:tasks.c       **** 
2210:tasks.c       **** 		/* A critical section is not required as this is not called from
2211:tasks.c       **** 		an interrupt and the current TCB will always be the same for any
2212:tasks.c       **** 		individual execution thread. */
2213:tasks.c       **** 		xReturn = pxCurrentTCB;
 2607              		.loc 1 2213 0
 2608 0000 014B     		ldr	r3, .L209
 2609 0002 1868     		ldr	r0, [r3]
 2610              	.LVL231:
2214:tasks.c       **** 
2215:tasks.c       **** 		return xReturn;
2216:tasks.c       **** 	}
 2611              		.loc 1 2216 0
 2612              		@ sp needed for prologue
 2613 0004 7047     		bx	lr
 2614              	.L210:
 2615 0006 C046     		.align	2
 2616              	.L209:
 2617 0008 00000000 		.word	.LANCHOR3
 2618              		.cfi_endproc
 2619              	.LFE33:
 2621              		.global	pxCurrentTCB
 2622              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 2623              		.align	2
 2624              		.set	.LANCHOR13,. + 0
 2627              	uxTopReadyPriority:
 2628 0000 00000000 		.space	4
 2629              		.section	.bss.xTickCount,"aw",%nobits
 2630              		.align	2
 2631              		.set	.LANCHOR15,. + 0
 2634              	xTickCount:
 2635 0000 00000000 		.space	4
 2636              		.section	.bss.pxReadyTasksLists,"aw",%nobits
 2637              		.align	2
 2638              		.set	.LANCHOR0,. + 0
 2641              	pxReadyTasksLists:
 2642 0000 00000000 		.space	100
 2642      00000000 
 2642      00000000 
 2642      00000000 
 2642      00000000 
 2643              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
 2644              		.align	2
 2645              		.set	.LANCHOR9,. + 0
 2648              	pxOverflowDelayedTaskList:
 2649 0000 00000000 		.space	4
 2650              		.section	.bss.xTracing,"aw",%nobits
 2651              		.align	2
 2652              		.set	.LANCHOR19,. + 0
 2655              	xTracing:
 2656 0000 00000000 		.space	4
 2657              		.section	.bss.pxDelayedTaskList,"aw",%nobits
 2658              		.align	2
 2659              		.set	.LANCHOR8,. + 0
 2662              	pxDelayedTaskList:
 2663 0000 00000000 		.space	4
 2664              		.section	.bss.xPendingReadyList,"aw",%nobits
 2665              		.align	2
 2666              		.set	.LANCHOR6,. + 0
 2669              	xPendingReadyList:
 2670 0000 00000000 		.space	20
 2670      00000000 
 2670      00000000 
 2670      00000000 
 2670      00000000 
 2671              		.section	.bss.xSchedulerRunning,"aw",%nobits
 2672              		.align	2
 2673              		.set	.LANCHOR10,. + 0
 2676              	xSchedulerRunning:
 2677 0000 00000000 		.space	4
 2678              		.section	.bss.xMissedYield,"aw",%nobits
 2679              		.align	2
 2680              		.set	.LANCHOR22,. + 0
 2683              	xMissedYield:
 2684 0000 00000000 		.space	4
 2685              		.section	.bss.uxTaskNumber,"aw",%nobits
 2686              		.align	2
 2687              		.set	.LANCHOR12,. + 0
 2690              	uxTaskNumber:
 2691 0000 00000000 		.space	4
 2692              		.section	.bss.pcTraceBuffer,"aw",%nobits
 2693              		.align	2
 2694              		.set	.LANCHOR16,. + 0
 2697              	pcTraceBuffer:
 2698 0000 00000000 		.space	4
 2699              		.section	.rodata.str1.4,"aMS",%progbits,1
 2700              		.align	2
 2701              	.LC4:
 2702 0000 25730909 		.ascii	"%s\011\011%c\011%u\011%u\011%u\015\012\000"
 2702      25630925 
 2702      75092575 
 2702      0925750D 
 2702      0A00
 2703 0012 0000     		.space	2
 2704              	.LC34:
 2705 0014 49444C45 		.ascii	"IDLE\000"
 2705      00
 2706 0019 000000   		.space	3
 2707              	.LC66:
 2708 001c 0D0A00   		.ascii	"\015\012\000"
 2709 001f 00       		.section	.bss.pxCurrentTCB,"aw",%nobits
 2710              		.align	2
 2711              		.set	.LANCHOR3,. + 0
 2714              	pxCurrentTCB:
 2715 0000 00000000 		.space	4
 2716              		.section	.bss.pcStatusString,"aw",%nobits
 2717              		.align	2
 2718              		.set	.LANCHOR1,. + 0
 2721              	pcStatusString:
 2722 0000 00000000 		.space	50
 2722      00000000 
 2722      00000000 
 2722      00000000 
 2722      00000000 
 2723 0032 0000     		.section	.data.uxPreviousTask,"aw",%progbits
 2724              		.align	2
 2725              		.set	.LANCHOR23,. + 0
 2728              	uxPreviousTask:
 2729 0000 FF000000 		.word	255
 2730              		.section	.bss.xSuspendedTaskList,"aw",%nobits
 2731              		.align	2
 2732              		.set	.LANCHOR7,. + 0
 2735              	xSuspendedTaskList:
 2736 0000 00000000 		.space	20
 2736      00000000 
 2736      00000000 
 2736      00000000 
 2736      00000000 
 2737              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
 2738              		.align	2
 2739              		.set	.LANCHOR2,. + 0
 2742              	uxCurrentNumberOfTasks:
 2743 0000 00000000 		.space	4
 2744              		.section	.bss.xDelayedTaskList1,"aw",%nobits
 2745              		.align	2
 2746              		.set	.LANCHOR4,. + 0
 2749              	xDelayedTaskList1:
 2750 0000 00000000 		.space	20
 2750      00000000 
 2750      00000000 
 2750      00000000 
 2750      00000000 
 2751              		.section	.bss.xDelayedTaskList2,"aw",%nobits
 2752              		.align	2
 2753              		.set	.LANCHOR5,. + 0
 2756              	xDelayedTaskList2:
 2757 0000 00000000 		.space	20
 2757      00000000 
 2757      00000000 
 2757      00000000 
 2757      00000000 
 2758              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 2759              		.align	2
 2760              		.set	.LANCHOR14,. + 0
 2763              	uxSchedulerSuspended:
 2764 0000 00000000 		.space	4
 2765              		.section	.bss.uxMissedTicks,"aw",%nobits
 2766              		.align	2
 2767              		.set	.LANCHOR21,. + 0
 2770              	uxMissedTicks:
 2771 0000 00000000 		.space	4
 2772              		.section	.bss.pcTraceBufferStart,"aw",%nobits
 2773              		.align	2
 2774              		.set	.LANCHOR17,. + 0
 2777              	pcTraceBufferStart:
 2778 0000 00000000 		.space	4
 2779              		.section	.bss.pcTraceBufferEnd,"aw",%nobits
 2780              		.align	2
 2781              		.set	.LANCHOR18,. + 0
 2784              	pcTraceBufferEnd:
 2785 0000 00000000 		.space	4
 2786              		.section	.bss.xNumOfOverflows,"aw",%nobits
 2787              		.align	2
 2788              		.set	.LANCHOR20,. + 0
 2791              	xNumOfOverflows:
 2792 0000 00000000 		.space	4
 2793              		.section	.bss.uxTopUsedPriority,"aw",%nobits
 2794              		.align	2
 2795              		.set	.LANCHOR11,. + 0
 2798              	uxTopUsedPriority:
 2799 0000 00000000 		.space	4
 2800              		.text
 2801              	.Letext0:
 2802              		.file 2 "c:\\gnuarm-471_eabi\\bin\\../lib/gcc/arm-none-eabi/4.7.1/include/stddef.h"
 2803              		.file 3 "./include/projdefs.h"
 2804              		.file 4 "./portmacro.h"
 2805              		.file 5 "./include/list.h"
 2806              		.file 6 "./include/task.h"
 2807              		.file 7 "c:/gnuarm-471_eabi/lib/gcc/../../arm-none-eabi/sys-include/stdio.h"
 2808              		.file 8 "c:/gnuarm-471_eabi/lib/gcc/../../arm-none-eabi/sys-include/string.h"
 2809              		.file 9 "./include/portable.h"
 2810              		.file 10 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
  C:\Temp\ccGzLr80.s:18     .text.prvIdleTask:00000000 $t
  C:\Temp\ccGzLr80.s:22     .text.prvIdleTask:00000000 prvIdleTask
  C:\Temp\ccGzLr80.s:47     .text.prvIdleTask:00000010 $d
  C:\Temp\ccGzLr80.s:52     .text.prvListTaskWithinSingleList:00000000 $t
  C:\Temp\ccGzLr80.s:56     .text.prvListTaskWithinSingleList:00000000 prvListTaskWithinSingleList
  C:\Temp\ccGzLr80.s:215    .text.prvListTaskWithinSingleList:0000009c $d
  C:\Temp\ccGzLr80.s:221    .text.xTaskGenericCreate:00000000 $t
  C:\Temp\ccGzLr80.s:226    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
  C:\Temp\ccGzLr80.s:544    .text.xTaskGenericCreate:0000017c $d
  C:\Temp\ccGzLr80.s:561    .text.uxTaskPriorityGet:00000000 $t
  C:\Temp\ccGzLr80.s:566    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
  C:\Temp\ccGzLr80.s:605    .text.uxTaskPriorityGet:00000020 $d
  C:\Temp\ccGzLr80.s:610    .text.vTaskPrioritySet:00000000 $t
  C:\Temp\ccGzLr80.s:615    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
  C:\Temp\ccGzLr80.s:739    .text.vTaskPrioritySet:00000088 $d
  C:\Temp\ccGzLr80.s:746    .text.xTaskIsTaskSuspended:00000000 $t
  C:\Temp\ccGzLr80.s:751    .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
  C:\Temp\ccGzLr80.s:791    .text.xTaskIsTaskSuspended:00000024 $d
  C:\Temp\ccGzLr80.s:797    .text.vTaskResume:00000000 $t
  C:\Temp\ccGzLr80.s:802    .text.vTaskResume:00000000 vTaskResume
  C:\Temp\ccGzLr80.s:883    .text.vTaskResume:0000005c $d
  C:\Temp\ccGzLr80.s:890    .text.xTaskResumeFromISR:00000000 $t
  C:\Temp\ccGzLr80.s:895    .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
  C:\Temp\ccGzLr80.s:978    .text.xTaskResumeFromISR:00000060 $d
  C:\Temp\ccGzLr80.s:987    .text.vTaskStartScheduler:00000000 $t
  C:\Temp\ccGzLr80.s:992    .text.vTaskStartScheduler:00000000 vTaskStartScheduler
  C:\Temp\ccGzLr80.s:1040   .text.vTaskStartScheduler:00000038 $d
  C:\Temp\ccGzLr80.s:1048   .text.vTaskEndScheduler:00000000 $t
  C:\Temp\ccGzLr80.s:1053   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
  C:\Temp\ccGzLr80.s:1080   .text.vTaskEndScheduler:00000018 $d
  C:\Temp\ccGzLr80.s:1085   .text.vTaskSuspendAll:00000000 $t
  C:\Temp\ccGzLr80.s:1090   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
  C:\Temp\ccGzLr80.s:1105   .text.vTaskSuspendAll:0000000c $d
  C:\Temp\ccGzLr80.s:1110   .text.xTaskGetTickCount:00000000 $t
  C:\Temp\ccGzLr80.s:1115   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
  C:\Temp\ccGzLr80.s:1144   .text.xTaskGetTickCount:00000018 $d
  C:\Temp\ccGzLr80.s:1149   .text.xTaskGetTickCountFromISR:00000000 $t
  C:\Temp\ccGzLr80.s:1154   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
  C:\Temp\ccGzLr80.s:1167   .text.xTaskGetTickCountFromISR:00000008 $d
  C:\Temp\ccGzLr80.s:1172   .text.uxTaskGetNumberOfTasks:00000000 $t
  C:\Temp\ccGzLr80.s:1177   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
  C:\Temp\ccGzLr80.s:1190   .text.uxTaskGetNumberOfTasks:00000008 $d
  C:\Temp\ccGzLr80.s:1195   .text.vTaskStartTrace:00000000 $t
  C:\Temp\ccGzLr80.s:1200   .text.vTaskStartTrace:00000000 vTaskStartTrace
  C:\Temp\ccGzLr80.s:1246   .text.vTaskStartTrace:0000002c $d
  C:\Temp\ccGzLr80.s:1254   .text.ulTaskEndTrace:00000000 $t
  C:\Temp\ccGzLr80.s:1259   .text.ulTaskEndTrace:00000000 ulTaskEndTrace
  C:\Temp\ccGzLr80.s:1294   .text.ulTaskEndTrace:00000020 $d
  C:\Temp\ccGzLr80.s:1301   .text.vTaskIncrementTick:00000000 $t
  C:\Temp\ccGzLr80.s:1306   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
  C:\Temp\ccGzLr80.s:1436   .text.vTaskIncrementTick:000000a0 $d
  C:\Temp\ccGzLr80.s:1448   .text.xTaskResumeAll:00000000 $t
  C:\Temp\ccGzLr80.s:1453   .text.xTaskResumeAll:00000000 xTaskResumeAll
  C:\Temp\ccGzLr80.s:1632   .text.xTaskResumeAll:000000cc $d
  C:\Temp\ccGzLr80.s:1644   .text.vTaskList:00000000 $t
  C:\Temp\ccGzLr80.s:1649   .text.vTaskList:00000000 vTaskList
  C:\Temp\ccGzLr80.s:1762   .text.vTaskList:00000090 $d
  C:\Temp\ccGzLr80.s:1772   .text.vTaskDelay:00000000 $t
  C:\Temp\ccGzLr80.s:1777   .text.vTaskDelay:00000000 vTaskDelay
  C:\Temp\ccGzLr80.s:1856   .text.vTaskDelay:00000054 $d
  C:\Temp\ccGzLr80.s:1864   .text.vTaskDelayUntil:00000000 $t
  C:\Temp\ccGzLr80.s:1869   .text.vTaskDelayUntil:00000000 vTaskDelayUntil
  C:\Temp\ccGzLr80.s:1988   .text.vTaskDelayUntil:00000084 $d
  C:\Temp\ccGzLr80.s:1996   .text.vTaskSwitchContext:00000000 $t
  C:\Temp\ccGzLr80.s:2001   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
  C:\Temp\ccGzLr80.s:2136   .text.vTaskSwitchContext:000000bc $d
  C:\Temp\ccGzLr80.s:2150   .text.vTaskSuspend:00000000 $t
  C:\Temp\ccGzLr80.s:2155   .text.vTaskSuspend:00000000 vTaskSuspend
  C:\Temp\ccGzLr80.s:2254   .text.vTaskSuspend:0000006c $d
  C:\Temp\ccGzLr80.s:2262   .text.vTaskPlaceOnEventList:00000000 $t
  C:\Temp\ccGzLr80.s:2267   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
  C:\Temp\ccGzLr80.s:2344   .text.vTaskPlaceOnEventList:00000060 $d
  C:\Temp\ccGzLr80.s:2353   .text.xTaskRemoveFromEventList:00000000 $t
  C:\Temp\ccGzLr80.s:2358   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
  C:\Temp\ccGzLr80.s:2443   .text.xTaskRemoveFromEventList:00000064 $d
  C:\Temp\ccGzLr80.s:2452   .text.vTaskSetTimeOutState:00000000 $t
  C:\Temp\ccGzLr80.s:2457   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
  C:\Temp\ccGzLr80.s:2476   .text.vTaskSetTimeOutState:00000010 $d
  C:\Temp\ccGzLr80.s:2482   .text.xTaskCheckForTimeOut:00000000 $t
  C:\Temp\ccGzLr80.s:2487   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
  C:\Temp\ccGzLr80.s:2568   .text.xTaskCheckForTimeOut:00000058 $d
  C:\Temp\ccGzLr80.s:2574   .text.vTaskMissedYield:00000000 $t
  C:\Temp\ccGzLr80.s:2579   .text.vTaskMissedYield:00000000 vTaskMissedYield
  C:\Temp\ccGzLr80.s:2593   .text.vTaskMissedYield:00000008 $d
  C:\Temp\ccGzLr80.s:2598   .text.xTaskGetCurrentTaskHandle:00000000 $t
  C:\Temp\ccGzLr80.s:2603   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
  C:\Temp\ccGzLr80.s:2617   .text.xTaskGetCurrentTaskHandle:00000008 $d
  C:\Temp\ccGzLr80.s:2714   .bss.pxCurrentTCB:00000000 pxCurrentTCB
  C:\Temp\ccGzLr80.s:2623   .bss.uxTopReadyPriority:00000000 $d
  C:\Temp\ccGzLr80.s:2627   .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
  C:\Temp\ccGzLr80.s:2630   .bss.xTickCount:00000000 $d
  C:\Temp\ccGzLr80.s:2634   .bss.xTickCount:00000000 xTickCount
  C:\Temp\ccGzLr80.s:2637   .bss.pxReadyTasksLists:00000000 $d
  C:\Temp\ccGzLr80.s:2641   .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
  C:\Temp\ccGzLr80.s:2644   .bss.pxOverflowDelayedTaskList:00000000 $d
  C:\Temp\ccGzLr80.s:2648   .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
  C:\Temp\ccGzLr80.s:2651   .bss.xTracing:00000000 $d
  C:\Temp\ccGzLr80.s:2655   .bss.xTracing:00000000 xTracing
  C:\Temp\ccGzLr80.s:2658   .bss.pxDelayedTaskList:00000000 $d
  C:\Temp\ccGzLr80.s:2662   .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
  C:\Temp\ccGzLr80.s:2665   .bss.xPendingReadyList:00000000 $d
  C:\Temp\ccGzLr80.s:2669   .bss.xPendingReadyList:00000000 xPendingReadyList
  C:\Temp\ccGzLr80.s:2672   .bss.xSchedulerRunning:00000000 $d
  C:\Temp\ccGzLr80.s:2676   .bss.xSchedulerRunning:00000000 xSchedulerRunning
  C:\Temp\ccGzLr80.s:2679   .bss.xMissedYield:00000000 $d
  C:\Temp\ccGzLr80.s:2683   .bss.xMissedYield:00000000 xMissedYield
  C:\Temp\ccGzLr80.s:2686   .bss.uxTaskNumber:00000000 $d
  C:\Temp\ccGzLr80.s:2690   .bss.uxTaskNumber:00000000 uxTaskNumber
  C:\Temp\ccGzLr80.s:2693   .bss.pcTraceBuffer:00000000 $d
  C:\Temp\ccGzLr80.s:2697   .bss.pcTraceBuffer:00000000 pcTraceBuffer
  C:\Temp\ccGzLr80.s:2700   .rodata.str1.4:00000000 $d
  C:\Temp\ccGzLr80.s:2710   .bss.pxCurrentTCB:00000000 $d
  C:\Temp\ccGzLr80.s:2717   .bss.pcStatusString:00000000 $d
  C:\Temp\ccGzLr80.s:2721   .bss.pcStatusString:00000000 pcStatusString
  C:\Temp\ccGzLr80.s:2724   .data.uxPreviousTask:00000000 $d
  C:\Temp\ccGzLr80.s:2728   .data.uxPreviousTask:00000000 uxPreviousTask
  C:\Temp\ccGzLr80.s:2731   .bss.xSuspendedTaskList:00000000 $d
  C:\Temp\ccGzLr80.s:2735   .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
  C:\Temp\ccGzLr80.s:2738   .bss.uxCurrentNumberOfTasks:00000000 $d
  C:\Temp\ccGzLr80.s:2742   .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
  C:\Temp\ccGzLr80.s:2745   .bss.xDelayedTaskList1:00000000 $d
  C:\Temp\ccGzLr80.s:2749   .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
  C:\Temp\ccGzLr80.s:2752   .bss.xDelayedTaskList2:00000000 $d
  C:\Temp\ccGzLr80.s:2756   .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
  C:\Temp\ccGzLr80.s:2759   .bss.uxSchedulerSuspended:00000000 $d
  C:\Temp\ccGzLr80.s:2763   .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
  C:\Temp\ccGzLr80.s:2766   .bss.uxMissedTicks:00000000 $d
  C:\Temp\ccGzLr80.s:2770   .bss.uxMissedTicks:00000000 uxMissedTicks
  C:\Temp\ccGzLr80.s:2773   .bss.pcTraceBufferStart:00000000 $d
  C:\Temp\ccGzLr80.s:2777   .bss.pcTraceBufferStart:00000000 pcTraceBufferStart
  C:\Temp\ccGzLr80.s:2780   .bss.pcTraceBufferEnd:00000000 $d
  C:\Temp\ccGzLr80.s:2784   .bss.pcTraceBufferEnd:00000000 pcTraceBufferEnd
  C:\Temp\ccGzLr80.s:2787   .bss.xNumOfOverflows:00000000 $d
  C:\Temp\ccGzLr80.s:2791   .bss.xNumOfOverflows:00000000 xNumOfOverflows
  C:\Temp\ccGzLr80.s:2794   .bss.uxTopUsedPriority:00000000 $d
  C:\Temp\ccGzLr80.s:2798   .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.e755308d0f97ac5a4d77c88bfa88161b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.95dee4059009fe3ab635a191bb73dc66
                           .group:00000000 wm4.stdio.h.31.f48311dde756a2aec27351b58a280fb9
                           .group:00000000 wm4.stddef.h.187.9e651b6b8b16e149c1353259404973ea
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4._default_types.h.6.1dbd2e581fd590860c7c17f21d147e91
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.349.31f4c5baff3fa2689010b32028da9c47
                           .group:00000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:00000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:00000000 wm4.stddef.h.40.cf962ebbec441b3ac67502735f0765db
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.4c41f90a958351ce40b14103f7ff82ee
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.63.dfdea6580b080784d08faace69b6ed76
                           .group:00000000 wm4.stdlib.h.13.603ed7eb09a1561ab06840b7c0fcff58
                           .group:00000000 wm4.stddef.h.161.e50ff8a9d5d1abbc15641da28ac571bf
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.c69c7609933ff56d59c757cec2d13230
                           .group:00000000 wm4.cdefs.h.45.6b392759c8a421d1199268021d4987e3
                           .group:00000000 wm4.string.h.118.0034ce03f0efcb6576b1b96865c749d5
                           .group:00000000 wm4.projdefs.h.55.cdae9ead80b5a2ac004f41bb277aad45
                           .group:00000000 wm4.FreeRTOSConfig.h.55.21a0bf6949661856eb9bd458ca526d69
                           .group:00000000 wm4.portmacro.h.78.312ea2a2591c2c784e5cb239eea0b39c
                           .group:00000000 wm4.portable.h.311.02653c2286cc0addcb8e7b32211fdde5
                           .group:00000000 wm4.mpu_wrappers.h.55.46a4a008a193040c38098e9a5f07ff9d
                           .group:00000000 wm4.FreeRTOS.h.136.ac0125896626c2d69b79b44ea315652b
                           .group:00000000 wm4.list.h.90.ffdb657f66139f74e2982d5a33457923
                           .group:00000000 wm4.task.h.75.6c9adf28cb16a37dd5593a2f9c33f128
                           .group:00000000 wm4.StackMacros.h.55.6d32da70bba937a3f8476e3b9d518421

UNDEFINED SYMBOLS
sprintf
strcat
pvPortMalloc
vPortFree
memset
strncpy
vListInitialiseItem
pxPortInitialiseStack
vPortEnterCritical
vListInitialise
vListInsertEnd
vPortExitCritical
vListRemove
vPortDisableInterruptsFromThumb
xPortStartScheduler
vPortEndScheduler
strlen
memcpy
vListInsert
