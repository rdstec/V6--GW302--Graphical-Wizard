   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"functions.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.ClockDisplay,"ax",%progbits
  18              		.align	2
  19              		.global	ClockDisplay
  20              		.code	16
  21              		.thumb_func
  23              	ClockDisplay:
  24              	.LFB376:
  25              		.file 1 "functions.c"
   1:functions.c   **** // -----------------------------------------------------------
   2:functions.c   **** // Software:         GW302 - McHale V6 Fixed Chamber Round Baler
   3:functions.c   **** // C Source File:    functions.c
   4:functions.c   **** // Description:      Graphic Wizard Display Related File
   5:functions.c   **** // -----------------------------------------------------------
   6:functions.c   **** 
   7:functions.c   **** 
   8:functions.c   **** // Include Standard files
   9:functions.c   **** #include "Board.h"
  10:functions.c   **** 
  11:functions.c   **** #include "string.h"
  12:functions.c   **** #include "stdlib.h"
  13:functions.c   **** #include "stdio.h"
  14:functions.c   **** #include "math.h"
  15:functions.c   **** 
  16:functions.c   **** 
  17:functions.c   **** #ifdef WINDOWS
  18:functions.c   ****  // function not available in borland builder
  19:functions.c   ****  float cosf( float x ) { return cos( x ); }
  20:functions.c   ****  float sinf( float x ) { return sin( x ); }
  21:functions.c   ****  float atoff( const char *s ) { return atof( s ); }
  22:functions.c   **** #endif
  23:functions.c   **** 
  24:functions.c   **** // global variables
  25:functions.c   **** // -----------------------------------------------------------
  26:functions.c   **** // constants
  27:functions.c   **** unsigned char const binHex[16] =
  28:functions.c   ****  { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
  29:functions.c   **** unsigned char const * const DayofWeek[7] =
  30:functions.c   ****  { "Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat" };
  31:functions.c   **** unsigned char const * const MonthofYear[13] =
  32:functions.c   ****  { "---", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
  33:functions.c   **** unsigned char const Store[10] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J' };
  34:functions.c   **** unsigned char const UCkey[] = " ÀÁÂÃÄÅÆABCÇDEÈÉÊËFGHIÌÍÎÏÐJKLMNÑOÒÓÔÕÖØPQRSTUÙÚÛÜVWXYÝßZÞ";
  35:functions.c   **** unsigned char const LCkey[] = " aàáâãäåæbcçdeèéêëfghiìíîïðjklmnñoòóôõöøpqrstuùúûüvwxyýÿzþ";
  36:functions.c   **** unsigned char const NCkey[] = "0123456789.+-±!#¢£$";
  37:functions.c   **** /*    
  38:functions.c   ****     "!\"#$%&'()*+,-./:;<=>?@[\\]^_`"
  39:functions.c   ****     "{|}~ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿"
  40:functions.c   ****     "0123456789"
  41:functions.c   ****     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  42:functions.c   ****     "abcdefghijklmnopqrstuvwxyz"
  43:functions.c   ****     "ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß"
  44:functions.c   ****     "àáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
  45:functions.c   **** */
  46:functions.c   **** //unsigned char const * const RotateShaft[4] = { SeedshaftOff, SEEDSHAFT, SEEDSHAFT2, SEEDSHAFT1 };
  47:functions.c   **** unsigned char const * const ip_status[2] = { SWOPEN, SWCLOSED };
  48:functions.c   **** unsigned char const * const op_status[2] = { BUTTON04, BUTTON01 };
  49:functions.c   **** 
  50:functions.c   **** 
  51:functions.c   **** // Programmable Factors (Array)                                          
  52:functions.c   **** 
  53:functions.c   **** // Machine Menu                                                 Step size,      Minimum,      Maxim
  54:functions.c   **** unsigned char const PF_GW302_BaleProfile[PF_DIM]            = {         1,  BP_PRESET_A,  BP_PRESET
  55:functions.c   **** unsigned char const PF_GW302_BaleDiameter[PF_DIM]           = {         1,           60,          1
  56:functions.c   **** unsigned char const PF_GW302_CoreDiameter[PF_DIM]           = {         1,           60,          1
  57:functions.c   **** unsigned char const PF_GW302_BaleDensity[PF_DIM]            = {         1,            1,           
  58:functions.c   **** unsigned char const PF_GW302_CoreDensity[PF_DIM]            = {         1,            1,           
  59:functions.c   **** float const         PF_GW302_NetLayers[PF_DIM]              = {       0.1,          1.5,          6
  60:functions.c   **** unsigned long int const PF_GW302_BaleTotal[PF_DIM]          = {      1UL,          0UL,        9999
  61:functions.c   **** unsigned char const PF_GW302_BaleStore[PF_DIM]              = {        1,            0,  MAX_STORES
  62:functions.c   **** // LubeCounter      // Moved to preserved run-time totals   = PF_GW302_LubeAlarm[PF_DIM] for range 
  63:functions.c   **** unsigned long int const PF_GW302_GrandBaleTotal[PF_DIM]     = {       1UL,          0UL,     999999
  64:functions.c   **** float const         PF_GW302_DiaPotZero[PF_DIM]             = {    PF_fNA,       PF_fNA,       PF_f
  65:functions.c   **** signed char const   PF_GW302_DiameterCorrection[PF_DIM]     = {         1,          -20,          +
  66:functions.c   **** unsigned char const PF_GW302_BaleShapeIndicator[PF_DIM]     = {         1,      BSI_OFF,     BSI_BE
  67:functions.c   **** float const         PF_GW302_BaleShapeIndicatorZero[PF_DIM] = {    PF_fNA,          0.0,          9
  68:functions.c   **** float const         PF_GW302_TotalNetMetres[PF_DIM]         = {    PF_fNA,          0.0,       9999
  69:functions.c   **** unsigned char const PF_GW302_PreWarningBeep[PF_DIM]         = {         1,            1,          1
  70:functions.c   **** float const         PF_GW302_NetDelay[PF_DIM]               = {       0.1,          0.0,          5
  71:functions.c   **** unsigned char const PF_GW302_NetTwineOption[PF_DIM]         = {         1,       TO_NET,     TO_TWI
  72:functions.c   ****   
  73:functions.c   **** // Technician Menu - Baler Full Page 1/2                        Step size,   Minimum,   Maximum,   
  74:functions.c   **** unsigned short int const PF_GW302_LubeAlarm[PF_DIM]         = {         1,         0,       999,   
  75:functions.c   **** float const              PF_GW302_PresDeadband[PF_DIM]      = {      0.01,      0.00,      9.99,   
  76:functions.c   **** float const              PF_GW302_NetSpeed[PF_DIM]          = {       0.1,       0.0,      99.0,   
  77:functions.c   **** float const              PF_GW302_PresSwDelay[PF_DIM]       = {       0.1,       0.0,       9.9,   
  78:functions.c   **** float const              PF_GW302_DoorClosed[PF_DIM]        = {       0.1,       0.0,       9.9,   
  79:functions.c   **** unsigned char const      PF_GW302_BaleSizeFactor[PF_DIM]    = {         1,       100,       250,   
  80:functions.c   **** 
  81:functions.c   **** // Technician Menu - Baler Full Page 2/2                  Step size,   Minimum,   Maximum,   Defaul
  82:functions.c   **** float const         PF_GW302_FillPotRange[PF_DIM]     = {      0.01,      0.00,      9.99,      1.0
  83:functions.c   **** float const         PF_GW302_FillPotIgnore[PF_DIM]    = {      0.01,      0.00,      9.99,      0.2
  84:functions.c   **** unsigned char const PF_GW302_EngageDiameter[PF_DIM]   = {         1,         0,       100,        9
  85:functions.c   **** unsigned char const PF_GW302_BaleIndicator[PF_DIM]    = {         1,  BI_STEER,   BI_FILL,  BI_STEE
  86:functions.c   **** float const         PF_GW302_RollerDelay[PF_DIM]      = {       0.1,       0.0,       9.9,       0.
  87:functions.c   ****   
  88:functions.c   **** // Technician Menu - Netting Setup Page 1/2               Step size,   Minimum,   Maximum,   Defaul
  89:functions.c   **** float const         PF_GW302_NetOn[PF_DIM]            = {       0.1,       0.0,       9.9,       3.
  90:functions.c   **** unsigned char const PF_GW302_NetCutPulse[PF_DIM]      = {         1,         0,        99,        4
  91:functions.c   **** float const         PF_GW302_NetCutTime[PF_DIM]       = {       0.1,       0.0,       9.9,       6.
  92:functions.c   **** float const         PF_GW302_MinDiaPulsPerLay[PF_DIM] = {       0.1,       0.0,     999.9,      38.
  93:functions.c   **** float const         PF_GW302_MaxDiaPulsPerLay[PF_DIM] = {       0.1,       0.0,     999.9,     108.
  94:functions.c   **** float const         PF_GW302_NetFactor[PF_DIM]        = {       0.1,       0.0,       9.9,       1.
  95:functions.c   **** float const         PF_GW302_NoNetPulse[PF_DIM]       = {       0.1,       0.0,       9.9,       4.
  96:functions.c   **** unsigned char const PF_GW302_PreNetPulse[PF_DIM]      = {         1,         0,        99,         
  97:functions.c   **** 
  98:functions.c   **** // Technician Menu - Netting Setup Page 2/2               Step size,   Minimum,   Maximum,   Defaul
  99:functions.c   **** unsigned char const PF_GW302_NetSystem[PF_DIM]        = {         1,   NS_BEAK, NS_ROLLER, NS_ROLLE
 100:functions.c   **** unsigned char const PF_GW302_BeakEngage[PF_DIM]       = {         1,         0,        99,         
 101:functions.c   **** unsigned char const PF_GW302_TwineOption[PF_DIM]      = {         1,   TO_OFF,  	TO_ON, 	  TO_OFF }
 102:functions.c   **** 
 103:functions.c   **** // Technician Menu - Diameter Setup                                 Step size,   Minimum,   Maximum
 104:functions.c   **** unsigned char const PF_GW302_DiameterMin[PF_DIM]                = {         1,         0,       100
 105:functions.c   **** unsigned char const PF_GW302_DiameterMax[PF_DIM]                = {         1,         0,       100
 106:functions.c   **** float const         PF_GW302_DiaCorrection[PF_DIM]              = {      0.01,      0.00,      0.20
 107:functions.c   **** unsigned char const PF_GW302_BaleDiaSmoothingFactor[PF_DIM]     = {         1,         1,       100
 108:functions.c   **** unsigned char const PF_GW302_DensityPresSmoothingFactor[PF_DIM] = {         1,         1,       100
 109:functions.c   **** unsigned char const PF_GW302_BaleShapeSmoothingFactor[PF_DIM]   = {         1,         1,       100
 110:functions.c   **** unsigned char const PF_GW302_KnifePresSmoothingFactor[PF_DIM]   = {         1,         1,       100
 111:functions.c   ****  
 112:functions.c   **** // Technician Menu - Density Setup Page 1/2    Step size,   Minimum,   Maximum,   Default
 113:functions.c   **** float const PF_GW302_Density1[PF_DIM]      = {      0.01,      0.00,     10.00,      0.00 }; // V -
 114:functions.c   **** float const PF_GW302_Density2[PF_DIM]      = {      0.01,      0.00,     10.00,      0.80 }; // V -
 115:functions.c   **** float const PF_GW302_Density3[PF_DIM]      = {      0.01,      0.00,     10.00,      1.20 }; // V -
 116:functions.c   **** float const PF_GW302_Density4[PF_DIM]      = {      0.01,      0.00,     10.00,      1.60 }; // V -
 117:functions.c   **** float const PF_GW302_Density5[PF_DIM]      = {      0.01,      0.00,     10.00,      2.00 }; // V -
 118:functions.c   **** float const PF_GW302_Density6[PF_DIM]      = {      0.01,      0.00,     10.00,      2.40 }; // V -
 119:functions.c   **** 
 120:functions.c   **** // Technician Menu - Density Setup Page 2/2    Step size,   Minimum,   Maximum,   Default
 121:functions.c   **** float const PF_GW302_Density7[PF_DIM]      = {      0.01,      0.00,     10.00,      2.80 }; // V -
 122:functions.c   **** float const PF_GW302_Density8[PF_DIM]      = {      0.01,      0.00,     10.00,      3.20 }; // V -
 123:functions.c   **** float const PF_GW302_Density9[PF_DIM]      = {      0.01,      0.00,     10.00,      3.60 }; // V -
 124:functions.c   **** float const PF_GW302_Density10[PF_DIM]     = {      0.01,      0.00,     10.00,      4.00 }; // V -
 125:functions.c   **** 
 126:functions.c   **** // Technician Menu - Knives Setup              Step size,   Minimum,   Maximum,   Default
 127:functions.c   **** float const PF_GW302_KnifePressure[PF_DIM] = {      0.01,      0.00,      9.99,      0.90 }; // V
 128:functions.c   **** float const PF_GW302_KnifePresWarn[PF_DIM] = {      0.01,      0.00,      9.99,      1.30 }; // V -
 129:functions.c   **** float const PF_GW302_DiverterDelay[PF_DIM] = {       0.1,       0.0,       9.9,       0.2 }; // s -
 130:functions.c   ****   
 131:functions.c   **** // Technician Menu - Formation 2                            Step size,   Minimum,   Maximum,   Defa
 132:functions.c   **** unsigned char const PF_GW302_FormationDensity[PF_DIM]   = {         1,         1,        10,    PF_
 133:functions.c   **** unsigned char const PF_GW302_FormationDiameter[PF_DIM]  = {         1,         0,       100,    PF_
 134:functions.c   **** unsigned char const PF_GW302_Formation2Density[PF_DIM]  = {         1,         1,        10,    PF_
 135:functions.c   **** unsigned char const PF_GW302_Formation2Diameter[PF_DIM] = {         1,         0,       100,    PF_
 136:functions.c   **** 
 137:functions.c   **** // Diagnostics - Digital Inputs                               Step size,      Minimum,     Maximum,
 138:functions.c   **** unsigned char const PF_GW302_ChoppingKnivesFitted[PF_DIM] = {         1, CKF_DISABLED, CKF_ENABLED,
 139:functions.c   **** 
 140:functions.c   **** 
 141:functions.c   **** // Bale Profile defaults                             Preset =     A    B    C    D    E
 142:functions.c   **** unsigned char const PresetCoreDiameter[BP_PRESET_MAX]       = {  70,  70,  70,  90,  90 }; // Core 
 143:functions.c   **** unsigned char const PresetCoreDensity[BP_PRESET_MAX]        = {   9,   8,   7,   3,   1 }; // Core 
 144:functions.c   **** unsigned char const PresetBaleDiameter[BP_PRESET_MAX]       = { 125, 125, 125, 125, 125 }; // Bale 
 145:functions.c   **** unsigned char const PresetBaleDensity[BP_PRESET_MAX]        = {  10,   9,   8,   4,   2 }; // Bale 
 146:functions.c   **** unsigned char const PresetFormationDiameter[BP_PRESET_MAX]  = {   0,   0,   0,   0,   0 }; // Forma
 147:functions.c   **** unsigned char const PresetFormationDensity[BP_PRESET_MAX]   = {  10,  10,  10,   5,   5 }; // Forma
 148:functions.c   **** unsigned char const PresetFormation2Diameter[BP_PRESET_MAX] = {   0,   0,   0,   0,   0 }; // Forma
 149:functions.c   **** unsigned char const PresetFormation2Density[BP_PRESET_MAX]  = {  10,  10,  10,   5,   5 }; // Forma
 150:functions.c   **** float const PresetNetLayers[BP_PRESET_MAX]                  = { 3.5, 3.0, 2.5, 4.2, 4.2 }; // Net L
 151:functions.c   **** 
 152:functions.c   **** 
 153:functions.c   **** // Bale/Core Density ID     =    1    2    3    4    5    6    7    8    9    10
 154:functions.c   **** unsigned char const Bar[10] = {  0,  40,  60,  80, 100, 120, 140, 160, 180,  200 };
 155:functions.c   **** 
 156:functions.c   **** 
 157:functions.c   **** /*
 158:functions.c   **** struct PinWin {
 159:functions.c   ****   unsigned short int PinNumber;
 160:functions.c   ****   void (*PinWindow)(unsigned int);
 161:functions.c   ****   };
 162:functions.c   **** */
 163:functions.c   **** struct PinWin const PinOption = {
 164:functions.c   ****        PINTECH1, screen141
 165:functions.c   **** };
 166:functions.c   **** 
 167:functions.c   **** // language string pointer
 168:functions.c   **** char const * const *ptText;
 169:functions.c   ****  
 170:functions.c   **** 
 171:functions.c   **** // Zeroed
 172:functions.c   **** unsigned char buffer[GRAPHICS_SIZE+128];
 173:functions.c   **** unsigned char adm[GRAPHICS_SIZE];
 174:functions.c   **** unsigned char startup, selection, escape, leaf, windowdepth, nextwindow;
 175:functions.c   **** unsigned char deftime, reverttime, looptime, offtime, half_second, AutoMan;
 176:functions.c   **** unsigned char swrel;
 177:functions.c   **** unsigned char DisableChoppingKnivesWarnings;
 178:functions.c   **** unsigned char ContinueOnKeyRelease;
 179:functions.c   **** unsigned char StartAutoNet;
 180:functions.c   **** 
 181:functions.c   **** float BaleDiaVolts;
 182:functions.c   **** float DensityPresVolts;
 183:functions.c   **** float BaleShapeVolts;
 184:functions.c   **** float KnifePresVolts;
 185:functions.c   **** 
 186:functions.c   **** float SupplyVolts;
 187:functions.c   **** 
 188:functions.c   **** unsigned char Kniv1_IPClosed;
 189:functions.c   **** 
 190:functions.c   **** unsigned int SeqOpOn, SeqOpOff, KeyOpOn, KeyOpOff;
 191:functions.c   **** 
 192:functions.c   **** float DiaTargetVolts;    // V
 193:functions.c   **** 
 194:functions.c   **** float DiaMinVolts;       // V
 195:functions.c   **** float DiaMaxVolts;       // V
 196:functions.c   **** 
 197:functions.c   **** float DiaMinExtDisplayPercent;    // 0.0 - 100.0 % of extended display range from PotZero to DiaMax
 198:functions.c   **** float DiaTargetExtDisplayPercent; // 0.0 - 100.0 % of extended display range from PotZero to DiaMax
 199:functions.c   **** float BaleDiaExtDisplayPercent;   // 0.0 - 100.0 % of extended display range from PotZero to DiaMax
 200:functions.c   **** 
 201:functions.c   **** float DiaFormationVolts;                  // V
 202:functions.c   **** float DiaFormation2Volts;                 // V
 203:functions.c   **** float DiaCoreVolts;                       // V
 204:functions.c   **** float DiaEngageVolts;                     // V
 205:functions.c   **** float DiaPreWarnVolts;                    // V
 206:functions.c   **** 
 207:functions.c   **** float DensityBaleVolts;                   // V
 208:functions.c   **** float DensityCoreVolts;                   // V
 209:functions.c   **** float DensityFormation2Volts;             // V
 210:functions.c   **** float DensityFormationVolts;              // V
 211:functions.c   **** 
 212:functions.c   **** unsigned char DensityPressureTooHigh;     // 0 / 1
 213:functions.c   **** 
 214:functions.c   **** void (*window)( unsigned int );
 215:functions.c   **** 
 216:functions.c   **** struct sdPreviousWindow PreviousWindow[MAX_WINDOWDEPTH];
 217:functions.c   **** 
 218:functions.c   **** unsigned int key;
 219:functions.c   **** unsigned char savecal, editing, valuechanged, number[16];
 220:functions.c   **** unsigned char SavecalDelayWithinMenus;
 221:functions.c   **** unsigned char SavecalDelayOnMainDisplay;
 222:functions.c   **** 
 223:functions.c   **** unsigned char ClockRam[16];
 224:functions.c   **** unsigned char RunFactorStatus, PowerSwitchedOff;
 225:functions.c   **** unsigned char buzz_count;
 226:functions.c   **** 
 227:functions.c   **** unsigned long int BaleDiaVoltsTotAccumMultSamples;     // V
 228:functions.c   **** unsigned long int DensityPresVoltsTotAccumMultSamples; // V
 229:functions.c   **** unsigned long int BaleShapeVoltsTotAccumMultSamples;   // V
 230:functions.c   **** unsigned long int KnifePresVoltsTotAccumMultSamples;   // V
 231:functions.c   **** 
 232:functions.c   **** unsigned int TC1_interrupt_count;
 233:functions.c   **** unsigned int EOC7_interrupt_count;
 234:functions.c   **** unsigned short int f0count, f6count;
 235:functions.c   **** unsigned int f0time, f6time;
 236:functions.c   **** unsigned char newf6; 
 237:functions.c   **** unsigned int TC1_millisec_count;
 238:functions.c   **** unsigned int buzz_length, off_length;
 239:functions.c   **** unsigned char AllTime;
 240:functions.c   **** unsigned int TC1_count0;
 241:functions.c   **** unsigned char Stage, DelayTime, BeepDelay;
 242:functions.c   **** unsigned char stagecomp, knivesdelay, cont_beep;
 243:functions.c   **** unsigned char target_bale_dia_reached_cont_beep;
 244:functions.c   **** unsigned char pre_warning_cont_beep;
 245:functions.c   **** unsigned char start_chamber_open_delay_cont_beep;
 246:functions.c   **** unsigned char end_chamber_open_delay_cont_beep;
 247:functions.c   **** 
 248:functions.c   **** unsigned int cal_speed_pulses;
 249:functions.c   **** unsigned long int NetPulseCount; // Pulses
 250:functions.c   **** #ifdef DEVELOP // Testing pulse counting
 251:functions.c   **** unsigned long int Saved_NetPulseCount; // Pulses
 252:functions.c   **** unsigned long int SavedPreNetPulseCount; // Pulses
 253:functions.c   **** unsigned long int TargetPreNetPulseCount; // Pulses
 254:functions.c   **** unsigned long int SavedBeakEngagePulseCount; // Pulses
 255:functions.c   **** #endif
 256:functions.c   **** unsigned long int BeakEngagePulseCount; // Pulses
 257:functions.c   **** unsigned long int NetPulseCountPrev; // Pulses
 258:functions.c   **** unsigned long int NewNetPulses; // Pulses
 259:functions.c   **** unsigned long int NetMetresPulseCount; // Pulses
 260:functions.c   **** float NetMetresAppliedForCount; // m
 261:functions.c   **** float NetPulseFrequency; // Hz
 262:functions.c   **** float NetPulsesPerLayer; // Pulses/layer
 263:functions.c   **** unsigned short int TargetNetPulses; // Pulses
 264:functions.c   **** 
 265:functions.c   **** unsigned char SequenceInProgress; 
 266:functions.c   **** 
 267:functions.c   **** unsigned char OP2OnDelayTime, OP2OffDelayTime;
 268:functions.c   **** unsigned char OP7OffDelayTime;
 269:functions.c   **** unsigned char OP8OnDelayTime, OP8OffDelayTime;
 270:functions.c   **** unsigned char NetWarningDelayTime;
 271:functions.c   **** 
 272:functions.c   **** unsigned char NetWarningOn;  // Check Net Error (AKA Net Warning) On/Off switch
 273:functions.c   **** 
 274:functions.c   **** unsigned char RollEngageTurnedOn; // OP5 Roller Engage Solenoid (AKA Pre Net Position) turned on
 275:functions.c   **** unsigned char SavedRollEngageTurnedOn; // Saved when IP3 opens in AUTO mode
 276:functions.c   **** unsigned char NetWarningDisabledWhileIP3OpenInAutoMode;
 277:functions.c   **** unsigned char NettingStartBeepsDisabledWhileIP3OpenInAutoMode; // Including Pre Warning & Net Delay
 278:functions.c   **** unsigned char RollerTimer = 255;      // OP5 Roller Engage Solenoid (AKA Pre Net Position) turned o
 279:functions.c   **** 
 280:functions.c   **** unsigned char RollEngageTurnedOnInManMode; // OP5 Roller Engage Solenoid (AKA Pre Net Position) tur
 281:functions.c   **** 
 282:functions.c   **** unsigned char ChoppingKnives1WarningOn; // Chopping knives position 1 Warning On/Off switch
 283:functions.c   **** 
 284:functions.c   **** unsigned char ChamberClosedDelayTime; // Door Closed
 285:functions.c   **** 
 286:functions.c   **** unsigned char BalerFullDelayTime;     // applies to MAN mode only -- Set to Net Delay
 287:functions.c   **** 
 288:functions.c   **** unsigned char ChamberOpenDelayTime;   // applies to MAN mode only
 289:functions.c   **** 
 290:functions.c   **** unsigned char ChamberOpenBeepDelay;   // applies to AUTO mode only
 291:functions.c   **** 
 292:functions.c   **** unsigned char BaleKickerStatus;                // Bale Kicker Down/Up flags
 293:functions.c   **** unsigned char BaleDiameterStatusInManMode;     // Bale Diameter Below/Above Engage Diameter (in MAN
 294:functions.c   **** unsigned char ChamberStatus;                   // Chamber Closed/Open flags
 295:functions.c   **** 
 296:functions.c   **** unsigned char OP8OnCount;             // Count for Density Release Solenoid (OP8) on after Chamber 
 297:functions.c   **** 
 298:functions.c   **** unsigned char IP4PulsesStoppedCount;        // Count for Net Pulses (on IP4) to stop after Target P
 299:functions.c   **** unsigned long int NetPulseCountAtLastCheck; // Pulses -- Similar NetPulseCountPrev to but used in a
 300:functions.c   **** 
 301:functions.c   **** unsigned char DrivingArrowBeepsDisabled;    // Driving Arrow Beeps turned off/on
 302:functions.c   **** 
 303:functions.c   **** unsigned char DensityControlFunctionActive;                 // Density Control Function (based on T
 304:functions.c   **** unsigned char NetPulseCheckingEnabled;                      // Checking for no pulses on IP4 (for N
 305:functions.c   **** unsigned char OP5TurnedOnAfterBeakEngagePulsesEnabled;      // Turning on Roller Engage Solenoid (O
 306:functions.c   **** unsigned char SavedOP5TurnedOnAfterBeakEngagePulsesEnabled; // Saved when IP3 opens in AUTO mode
 307:functions.c   **** 
 308:functions.c   **** #ifdef DEVELOP // Testing memory
 309:functions.c   **** unsigned char TestOutputReadMemAllocFail;  // flag set in SPI1FlashRead() -- brought out for testin
 310:functions.c   **** unsigned char TestOutputWriteMemAllocFail; // flag set in SPI1FlashWrite() -- brought out for testi
 311:functions.c   **** #endif
 312:functions.c   **** 
 313:functions.c   **** //unsigned long int forward_speed_buffer[6]; // removed on removing contents of functions in CANtes
 314:functions.c   **** //float mcm_forward_speed, local_forward_speed; // removed on removing contents of functions in CAN
 315:functions.c   **** 
 316:functions.c   **** //unsigned char use_simulated_speed;  // removed on removing contents of functions in CANtest.c
 317:functions.c   **** unsigned char tl_target_count[2], tl_confimation_delay[2]; // TC4_irq_handler
 318:functions.c   **** //unsigned char prestart_status;  // removed on removing contents of functions in CANtest.c
 319:functions.c   **** 
 320:functions.c   **** // to be placed in non volatile storage - check factor/runtime split
 321:functions.c   **** struct mcm_struct mcm[MAX_MCM];
 322:functions.c   **** #if 0 // Removed
 323:functions.c   **** struct prodt product[MAX_MCM][MAX_PRODUCTS];
 324:functions.c   **** #endif
 325:functions.c   **** 
 326:functions.c   **** #ifdef WINDOWS
 327:functions.c   ****  unsigned char Sam7A3sfr[0x4000];
 328:functions.c   **** #endif
 329:functions.c   **** 
 330:functions.c   **** // runtime variables for serial flash save held in this structure
 331:functions.c   **** #ifndef WINDOWS
 332:functions.c   ****  union PreservedRuntimeToChar pRun __attribute__((section(".IRamNV")));
 333:functions.c   **** #else 
 334:functions.c   ****  union PreservedRuntimeToChar pRun;
 335:functions.c   **** #endif
 336:functions.c   **** 
 337:functions.c   **** // factors for serial flash save held in this structure
 338:functions.c   **** #ifndef WINDOWS
 339:functions.c   ****  union PreservedFactorsToChar pFac __attribute__((section(".IRamNV")));
 340:functions.c   **** #else
 341:functions.c   ****  union PreservedFactorsToChar pFac;
 342:functions.c   **** #endif 
 343:functions.c   **** // -----------------------------------------------------------
 344:functions.c   **** 
 345:functions.c   **** #ifdef SHOW_TIME
 346:functions.c   **** // -----------------------------------------------------------
 347:functions.c   **** // Function Name       : ClockDisplay
 348:functions.c   **** // -----------------------------------------------------------
 349:functions.c   **** void ClockDisplay( unsigned char icon  )
 350:functions.c   **** {
  26              		.loc 1 350 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 30B5     		push	{r4, r5, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 12
  32              		.cfi_offset 4, -12
  33              		.cfi_offset 5, -8
  34              		.cfi_offset 14, -4
  35 0002 8BB0     		sub	sp, sp, #44
  36              	.LCFI1:
  37              		.cfi_def_cfa_offset 56
 351:functions.c   **** 	unsigned char xp, yp, tstring[32];
 352:functions.c   **** 
 353:functions.c   **** 	if( icon == CL0CK_ICON_ON )
  38              		.loc 1 353 0
  39 0004 0128     		cmp	r0, #1
  40 0006 0BD1     		bne	.L4
 354:functions.c   **** 	{
 355:functions.c   **** 		xp = write_bitmap( adm, F1_CLK, 2, 2, OR ) + 3;
  41              		.loc 1 355 0
  42 0008 0223     		mov	r3, #2
  43 000a 0093     		str	r3, [sp]
  44 000c 1948     		ldr	r0, .L5
  45              	.LVL1:
  46 000e 1A49     		ldr	r1, .L5+4
  47 0010 0222     		mov	r2, #2
  48 0012 FFF7FEFF 		bl	write_bitmap
  49              	.LVL2:
  50 0016 C51C     		add	r5, r0, #3
  51 0018 2D06     		lsl	r5, r5, #24
  52 001a 2D0E     		lsr	r5, r5, #24
  53              	.LVL3:
 356:functions.c   **** 		yp = 2;
  54              		.loc 1 356 0
  55 001c 0224     		mov	r4, #2
  56 001e 01E0     		b	.L2
  57              	.LVL4:
  58              	.L4:
 357:functions.c   **** 	}
 358:functions.c   **** 	else // icon == CL0CK_ICON_OFF
 359:functions.c   **** 	{
 360:functions.c   **** 		xp = 3;
 361:functions.c   **** 		yp = 3;
  59              		.loc 1 361 0
  60 0020 0324     		mov	r4, #3
 360:functions.c   **** 		xp = 3;
  61              		.loc 1 360 0
  62 0022 0325     		mov	r5, #3
  63              	.LVL5:
  64              	.L2:
 362:functions.c   **** 	}
 363:functions.c   **** 
 364:functions.c   **** 	sprintf( tstring, "%02X:%02X", ClockRam[2], ClockRam[1] );
  65              		.loc 1 364 0
  66 0024 1549     		ldr	r1, .L5+8
  67 0026 8A78     		ldrb	r2, [r1, #2]
  68 0028 4B78     		ldrb	r3, [r1, #1]
  69 002a 02A8     		add	r0, sp, #8
  70 002c 1449     		ldr	r1, .L5+12
  71 002e FFF7FEFF 		bl	sprintf
  72              	.LVL6:
 365:functions.c   **** 	display_f1_text( tstring, TS5, xp, yp, FIXED ); // 5 wide
  73              		.loc 1 365 0
  74 0032 0023     		mov	r3, #0
  75 0034 0093     		str	r3, [sp]
  76 0036 02A8     		add	r0, sp, #8
  77 0038 0521     		mov	r1, #5
  78 003a 2A1C     		mov	r2, r5
  79 003c 231C     		mov	r3, r4
  80 003e FFF7FEFF 		bl	display_f1_text
  81              	.LVL7:
 366:functions.c   **** 
 367:functions.c   **** 
 368:functions.c   **** 	if( half_second )
  82              		.loc 1 368 0
  83 0042 104B     		ldr	r3, .L5+16
  84 0044 1B78     		ldrb	r3, [r3]
  85 0046 002B     		cmp	r3, #0
  86 0048 0FD0     		beq	.L1
 369:functions.c   **** 	{
 370:functions.c   **** 		draw_box( adm, xp + 12, yp, xp + 13, yp + 6,  CLEAR );
  87              		.loc 1 370 0
  88 004a 291C     		mov	r1, r5
  89 004c 0C31     		add	r1, r1, #12
  90 004e 0906     		lsl	r1, r1, #24
  91 0050 090E     		lsr	r1, r1, #24
  92 0052 2B1C     		mov	r3, r5
  93 0054 0D33     		add	r3, r3, #13
  94 0056 1B06     		lsl	r3, r3, #24
  95 0058 1B0E     		lsr	r3, r3, #24
  96 005a A21D     		add	r2, r4, #6
  97 005c 0092     		str	r2, [sp]
  98 005e 4022     		mov	r2, #64
  99 0060 0192     		str	r2, [sp, #4]
 100 0062 0448     		ldr	r0, .L5
 101 0064 221C     		mov	r2, r4
 102 0066 FFF7FEFF 		bl	draw_box
 103              	.LVL8:
 104              	.L1:
 371:functions.c   **** 	}
 372:functions.c   **** 
 373:functions.c   **** }
 105              		.loc 1 373 0
 106 006a 0BB0     		add	sp, sp, #44
 107              		@ sp needed for prologue
 108              	.LVL9:
 109              	.LVL10:
 110 006c 30BC     		pop	{r4, r5}
 111 006e 01BC     		pop	{r0}
 112 0070 0047     		bx	r0
 113              	.L6:
 114 0072 C046     		.align	2
 115              	.L5:
 116 0074 00000000 		.word	adm
 117 0078 00000000 		.word	F1_CLK
 118 007c 00000000 		.word	ClockRam
 119 0080 00000000 		.word	.LC3
 120 0084 00000000 		.word	half_second
 121              		.cfi_endproc
 122              	.LFE376:
 124              		.section	.text.CheckSumIt,"ax",%progbits
 125              		.align	2
 126              		.global	CheckSumIt
 127              		.code	16
 128              		.thumb_func
 130              	CheckSumIt:
 131              	.LFB377:
 374:functions.c   **** // -----------------------------------------------------------
 375:functions.c   **** #endif
 376:functions.c   **** 
 377:functions.c   **** // -----------------------------------------------------------
 378:functions.c   **** // Function Name       : CheckSumIt
 379:functions.c   **** // -----------------------------------------------------------
 380:functions.c   **** unsigned long int CheckSumIt( unsigned char *data, unsigned char *end )
 381:functions.c   **** {
 132              		.loc 1 381 0
 133              		.cfi_startproc
 134              	.LVL11:
 135 0000 00B5     		push	{lr}
 136              	.LCFI2:
 137              		.cfi_def_cfa_offset 4
 138              		.cfi_offset 14, -4
 139              	.LVL12:
 382:functions.c   **** 	unsigned long int ul;
 383:functions.c   **** 
 384:functions.c   **** 	for( ul = 0; data < end; data++ )
 140              		.loc 1 384 0
 141 0002 8842     		cmp	r0, r1
 142 0004 06D2     		bcs	.L10
 143              		.loc 1 384 0 is_stmt 0 discriminator 2
 144 0006 0023     		mov	r3, #0
 145              	.LVL13:
 146              	.L9:
 385:functions.c   **** 	{
 386:functions.c   **** 		ul += *data;
 147              		.loc 1 386 0 is_stmt 1 discriminator 2
 148 0008 0278     		ldrb	r2, [r0]
 149 000a 9B18     		add	r3, r3, r2
 150              	.LVL14:
 384:functions.c   **** 	for( ul = 0; data < end; data++ )
 151              		.loc 1 384 0 discriminator 2
 152 000c 0130     		add	r0, r0, #1
 153              	.LVL15:
 154 000e 8842     		cmp	r0, r1
 155 0010 FAD1     		bne	.L9
 156 0012 00E0     		b	.L8
 157              	.LVL16:
 158              	.L10:
 384:functions.c   **** 	for( ul = 0; data < end; data++ )
 159              		.loc 1 384 0 is_stmt 0
 160 0014 0023     		mov	r3, #0
 161              	.LVL17:
 162              	.L8:
 387:functions.c   **** 	}
 388:functions.c   **** 
 389:functions.c   **** 	ul = ~ul + 1;
 163              		.loc 1 389 0 is_stmt 1
 164 0016 5842     		neg	r0, r3
 165              	.LVL18:
 390:functions.c   **** 
 391:functions.c   **** 	return( ul );
 392:functions.c   **** }
 166              		.loc 1 392 0
 167              		@ sp needed for prologue
 168 0018 02BC     		pop	{r1}
 169 001a 0847     		bx	r1
 170              		.cfi_endproc
 171              	.LFE377:
 173              		.section	.text.SetDefaultFactors,"ax",%progbits
 174              		.align	2
 175              		.global	SetDefaultFactors
 176              		.code	16
 177              		.thumb_func
 179              	SetDefaultFactors:
 180              	.LFB378:
 393:functions.c   **** // -----------------------------------------------------------
 394:functions.c   **** 
 395:functions.c   **** #if 0 // mcF[MAX_MCM] & prF[MAX_MCM][MAX_PRODUCTS] removed from pFac.pf
 396:functions.c   **** // -----------------------------------------------------------
 397:functions.c   **** // Function Name       : SetFactorPointers
 398:functions.c   **** // Object              : set preserved non volatile memory pointers
 399:functions.c   **** // -----------------------------------------------------------
 400:functions.c   **** void SetFactorPointers( void )
 401:functions.c   **** {
 402:functions.c   **** 	struct mcm_struct *ptm;
 403:functions.c   **** 	struct prodt *ptp;
 404:functions.c   **** 	unsigned int i, j;
 405:functions.c   **** 
 406:functions.c   **** 	for( i = 0; i < MAX_MCM; i++ )
 407:functions.c   **** 	{
 408:functions.c   **** 		// set MCM defaults - for rarely changed non volatile factors
 409:functions.c   **** 		ptm = &mcm[i];
 410:functions.c   **** 		ptm->pF = &(pFac.pf.mcF[i]);
 411:functions.c   **** 		ptm->pR = &(pRun.pr.mcR[i]);
 412:functions.c   **** 
 413:functions.c   **** 		// set Product defaults - for rarely changed non volatile factors
 414:functions.c   **** 		for( j = 0; j < MAX_PRODUCTS; j++ )
 415:functions.c   **** 		{
 416:functions.c   **** 			ptp = &product[i][j];
 417:functions.c   **** 			ptp->pF = &(pFac.pf.prF[i][j]);
 418:functions.c   **** 			ptp->pR = &(pRun.pr.prR[i][j]);
 419:functions.c   **** 		}
 420:functions.c   **** 	}
 421:functions.c   **** 
 422:functions.c   **** }
 423:functions.c   **** // -----------------------------------------------------------
 424:functions.c   **** #endif
 425:functions.c   **** 
 426:functions.c   **** // -----------------------------------------------------------
 427:functions.c   **** // Function Name       : SetDefaultFactors
 428:functions.c   **** // Object              : reset power on defaults & save to flash
 429:functions.c   **** // -----------------------------------------------------------
 430:functions.c   **** void SetDefaultFactors( void )
 431:functions.c   **** {
 181              		.loc 1 431 0
 182              		.cfi_startproc
 183 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 184              	.LCFI3:
 185              		.cfi_def_cfa_offset 20
 186              		.cfi_offset 4, -20
 187              		.cfi_offset 5, -16
 188              		.cfi_offset 6, -12
 189              		.cfi_offset 7, -8
 190              		.cfi_offset 14, -4
 191 0002 5746     		mov	r7, sl
 192 0004 4E46     		mov	r6, r9
 193 0006 4546     		mov	r5, r8
 194 0008 E0B4     		push	{r5, r6, r7}
 195              	.LCFI4:
 196              		.cfi_def_cfa_offset 32
 197              		.cfi_offset 8, -32
 198              		.cfi_offset 9, -28
 199              		.cfi_offset 10, -24
 432:functions.c   **** 	char c;
 433:functions.c   **** 
 434:functions.c   **** 	ptText = TextString[pFac.pf.Lang];
 200              		.loc 1 434 0
 201 000a 8C4B     		ldr	r3, .L20
 202 000c 197B     		ldrb	r1, [r3, #12]
 203 000e 8900     		lsl	r1, r1, #2
 204 0010 8B4A     		ldr	r2, .L20+4
 205 0012 8958     		ldr	r1, [r1, r2]
 206 0014 8B4A     		ldr	r2, .L20+8
 207 0016 1160     		str	r1, [r2]
 435:functions.c   **** 
 436:functions.c   **** 
 437:functions.c   **** 	// set default Programmable Factors
 438:functions.c   **** 
 439:functions.c   **** 	if( pFac.pf.software_type != SOFTWARE ) // Value preserved between successive software versions
 208              		.loc 1 439 0
 209 0018 1A88     		ldrh	r2, [r3]
 210 001a 9723     		mov	r3, #151
 211 001c 5B00     		lsl	r3, r3, #1
 212 001e 9A42     		cmp	r2, r3
 213 0020 02D0     		beq	.L13
 440:functions.c   **** 		pFac.pf.GrandBaleTotal = PF_GW302_GrandBaleTotal[PF_DEF]; // bales
 214              		.loc 1 440 0
 215 0022 0022     		mov	r2, #0
 216 0024 854B     		ldr	r3, .L20
 217 0026 9A60     		str	r2, [r3, #8]
 218              	.L13:
 441:functions.c   **** 
 442:functions.c   **** 	pFac.pf.software_type = SOFTWARE;
 219              		.loc 1 442 0
 220 0028 8449     		ldr	r1, .L20
 221 002a 9723     		mov	r3, #151
 222 002c 5B00     		lsl	r3, r3, #1
 223 002e 0B80     		strh	r3, [r1]
 443:functions.c   **** 	pFac.pf.software_issue = ISSUE;
 224              		.loc 1 443 0
 225 0030 0123     		mov	r3, #1
 226 0032 4B80     		strh	r3, [r1, #2]
 444:functions.c   **** 	pFac.pf.software_revision = REVISION;
 227              		.loc 1 444 0
 228 0034 1723     		mov	r3, #23
 229 0036 8B80     		strh	r3, [r1, #4]
 445:functions.c   **** 
 446:functions.c   **** 	pFac.pf.Lang = 0;                  // Language set to English
 230              		.loc 1 446 0
 231 0038 0023     		mov	r3, #0
 232 003a 0B73     		strb	r3, [r1, #12]
 233              	.LVL19:
 234 003c 0B1C     		mov	r3, r1
 235 003e 1033     		add	r3, r3, #16
 430:functions.c   **** void SetDefaultFactors( void )
 236              		.loc 1 430 0
 237 0040 3831     		add	r1, r1, #56
 447:functions.c   **** 
 448:functions.c   **** 	for( c = 0; c < MAX_STORES; c++ )  // Bale Totals (in Bale Stores A to J) set to 0
 449:functions.c   **** 		pFac.pf.BaleTotal[c] = PF_GW302_BaleTotal[PF_DEF]; // bales
 238              		.loc 1 449 0
 239 0042 0022     		mov	r2, #0
 240              	.LVL20:
 241              	.L14:
 242              		.loc 1 449 0 is_stmt 0 discriminator 2
 243 0044 04C3     		stmia	r3!, {r2}
 448:functions.c   **** 	for( c = 0; c < MAX_STORES; c++ )  // Bale Totals (in Bale Stores A to J) set to 0
 244              		.loc 1 448 0 is_stmt 1 discriminator 2
 245 0046 8B42     		cmp	r3, r1
 246 0048 FCD1     		bne	.L14
 450:functions.c   **** 
 451:functions.c   **** 	pFac.pf.BaleStore = PF_GW302_BaleStore[PF_DEF]; // Bale Store ID set to A
 247              		.loc 1 451 0
 248 004a 7C49     		ldr	r1, .L20
 249 004c 0023     		mov	r3, #0
 250 004e 3822     		mov	r2, #56
 251 0050 8B54     		strb	r3, [r1, r2]
 452:functions.c   **** 
 453:functions.c   **** 	// pFac.pf.BaudRate -- Not set/used
 454:functions.c   **** 
 455:functions.c   **** 	// Machine Menu
 456:functions.c   **** 	pFac.pf.GW302_BaleProfile = PF_GW302_BaleProfile[PF_DEF]; // Preset A to E
 252              		.loc 1 456 0
 253 0052 3A22     		mov	r2, #58
 254 0054 8B54     		strb	r3, [r1, r2]
 255              	.LVL21:
 256 0056 7C48     		ldr	r0, .L20+12
 257 0058 5031     		add	r1, r1, #80
 430:functions.c   **** void SetDefaultFactors( void )
 258              		.loc 1 430 0
 259 005a 784A     		ldr	r2, .L20
 260 005c 9046     		mov	r8, r2
 457:functions.c   **** 	for( c = 0; c < BP_PRESET_MAX; c++ )  // Bale Profile defaults set for Presets A to E
 458:functions.c   **** 	{
 459:functions.c   **** 		pFac.pf.GW302_BaleDiameter[c] =  PresetBaleDiameter[c]; // cm
 261              		.loc 1 459 0
 262 005e 7B4C     		ldr	r4, .L20+16
 263 0060 A446     		mov	ip, r4
 460:functions.c   **** 		pFac.pf.GW302_CoreDiameter[c] =  PresetCoreDiameter[c]; // cm
 264              		.loc 1 460 0
 265 0062 7B4F     		ldr	r7, .L20+20
 461:functions.c   **** 		pFac.pf.GW302_BaleDensity[c]  =  PresetBaleDensity[c]; // ID
 266              		.loc 1 461 0
 267 0064 7B4E     		ldr	r6, .L20+24
 462:functions.c   **** 		pFac.pf.GW302_CoreDensity[c]  =  PresetCoreDensity[c]; // ID
 268              		.loc 1 462 0
 269 0066 7C4D     		ldr	r5, .L20+28
 270 0068 AA46     		mov	sl, r5
 271              	.LVL22:
 272              	.L15:
 430:functions.c   **** void SetDefaultFactors( void )
 273              		.loc 1 430 0 discriminator 2
 274 006a 4446     		mov	r4, r8
 275 006c E218     		add	r2, r4, r3
 276 006e 141C     		mov	r4, r2
 277 0070 3B34     		add	r4, r4, #59
 459:functions.c   **** 		pFac.pf.GW302_BaleDiameter[c] =  PresetBaleDiameter[c]; // cm
 278              		.loc 1 459 0 discriminator 2
 279 0072 6546     		mov	r5, ip
 280 0074 5D5D     		ldrb	r5, [r3, r5]
 281 0076 2570     		strb	r5, [r4]
 430:functions.c   **** void SetDefaultFactors( void )
 282              		.loc 1 430 0 discriminator 2
 283 0078 0534     		add	r4, r4, #5
 460:functions.c   **** 		pFac.pf.GW302_CoreDiameter[c] =  PresetCoreDiameter[c]; // cm
 284              		.loc 1 460 0 discriminator 2
 285 007a DD5D     		ldrb	r5, [r3, r7]
 286 007c 2570     		strb	r5, [r4]
 430:functions.c   **** void SetDefaultFactors( void )
 287              		.loc 1 430 0 discriminator 2
 288 007e 0534     		add	r4, r4, #5
 461:functions.c   **** 		pFac.pf.GW302_BaleDensity[c]  =  PresetBaleDensity[c]; // ID
 289              		.loc 1 461 0 discriminator 2
 290 0080 9D5D     		ldrb	r5, [r3, r6]
 291 0082 2570     		strb	r5, [r4]
 430:functions.c   **** void SetDefaultFactors( void )
 292              		.loc 1 430 0 discriminator 2
 293 0084 4A32     		add	r2, r2, #74
 294              		.loc 1 462 0 discriminator 2
 295 0086 5546     		mov	r5, sl
 296 0088 5C5D     		ldrb	r4, [r3, r5]
 297 008a 1470     		strb	r4, [r2]
 463:functions.c   **** 		pFac.pf.GW302_NetLayers[c]    =  PresetNetLayers[c]; // layers
 298              		.loc 1 463 0 discriminator 2
 299 008c 04C8     		ldmia	r0!, {r2}
 300 008e 04C1     		stmia	r1!, {r2}
 301 0090 0133     		add	r3, r3, #1
 457:functions.c   **** 	for( c = 0; c < BP_PRESET_MAX; c++ )  // Bale Profile defaults set for Presets A to E
 302              		.loc 1 457 0 discriminator 2
 303 0092 052B     		cmp	r3, #5
 304 0094 E9D1     		bne	.L15
 464:functions.c   **** 	}
 465:functions.c   **** 	// LubeCounter -- Moved to preserved run-time totals
 466:functions.c   **** 	// GrandBaleTotal -- Moved to early position in memory since value is to be preserved between succ
 467:functions.c   **** 	pFac.pf.GW302_DiaPotZero = PF_GW302_DiaPotZero[PF_DEF]; // V
 305              		.loc 1 467 0
 306 0096 694B     		ldr	r3, .L20
 307 0098 FE20     		mov	r0, #254
 308 009a 8005     		lsl	r0, r0, #22
 309 009c 5866     		str	r0, [r3, #100]
 468:functions.c   **** 	pFac.pf.GW302_DiameterCorrection = PF_GW302_DiameterCorrection[PF_DEF]; // cm
 310              		.loc 1 468 0
 311 009e 0022     		mov	r2, #0
 312 00a0 6821     		mov	r1, #104
 313 00a2 5A54     		strb	r2, [r3, r1]
 469:functions.c   **** 	pFac.pf.GW302_BaleShapeIndicator = PF_GW302_BaleShapeIndicator[PF_DEF]; // Off/On/Beep
 314              		.loc 1 469 0
 315 00a4 6921     		mov	r1, #105
 316 00a6 5A54     		strb	r2, [r3, r1]
 470:functions.c   **** 	pFac.pf.GW302_BaleShapeIndicatorZero = PF_GW302_BaleShapeIndicatorZero[PF_DEF]; // V
 317              		.loc 1 470 0
 318 00a8 6C49     		ldr	r1, .L20+32
 319 00aa D966     		str	r1, [r3, #108]
 471:functions.c   **** 	pFac.pf.GW302_TotalNetMetres = PF_GW302_TotalNetMetres[PF_DEF]; // m
 320              		.loc 1 471 0
 321 00ac 0021     		mov	r1, #0
 322 00ae 1967     		str	r1, [r3, #112]
 472:functions.c   **** 	pFac.pf.GW302_PreWarningBeep = PF_GW302_PreWarningBeep[PF_DEF]; // %
 323              		.loc 1 472 0
 324 00b0 5A25     		mov	r5, #90
 325 00b2 7424     		mov	r4, #116
 326 00b4 1D55     		strb	r5, [r3, r4]
 473:functions.c   **** 	pFac.pf.GW302_NetDelay = PF_GW302_NetDelay[PF_DEF]; // s
 327              		.loc 1 473 0
 328 00b6 8025     		mov	r5, #128
 329 00b8 ED05     		lsl	r5, r5, #23
 330 00ba 9D67     		str	r5, [r3, #120]
 474:functions.c   **** 
 475:functions.c   **** 	// Technician Menu - Baler Full
 476:functions.c   **** 	pFac.pf.GW302_LubeAlarm = PF_GW302_LubeAlarm[PF_DEF]; // bales
 331              		.loc 1 476 0
 332 00bc 9626     		mov	r6, #150
 333 00be 7600     		lsl	r6, r6, #1
 334 00c0 7E24     		mov	r4, #126
 335 00c2 1E53     		strh	r6, [r3, r4]
 477:functions.c   **** 	pFac.pf.GW302_PresDeadband = PF_GW302_PresDeadband[PF_DEF]; // V
 336              		.loc 1 477 0
 337 00c4 8024     		mov	r4, #128
 338 00c6 1951     		str	r1, [r3, r4]
 478:functions.c   **** 	pFac.pf.GW302_NetSpeed = PF_GW302_NetSpeed[PF_DEF]; // Hz
 339              		.loc 1 478 0
 340 00c8 654E     		ldr	r6, .L20+36
 341 00ca 8424     		mov	r4, #132
 342 00cc 1E51     		str	r6, [r3, r4]
 479:functions.c   **** 	pFac.pf.GW302_PresSwDelay = PF_GW302_PresSwDelay[PF_DEF]; // s
 343              		.loc 1 479 0
 344 00ce 654C     		ldr	r4, .L20+40
 345 00d0 8826     		mov	r6, #136
 346 00d2 9C51     		str	r4, [r3, r6]
 480:functions.c   **** 	pFac.pf.GW302_DoorClosed = PF_GW302_DoorClosed[PF_DEF]; // s
 347              		.loc 1 480 0
 348 00d4 FF27     		mov	r7, #255
 349 00d6 BF05     		lsl	r7, r7, #22
 350 00d8 8C26     		mov	r6, #140
 351 00da 9F51     		str	r7, [r3, r6]
 481:functions.c   **** 	pFac.pf.GW302_BaleSizeFactor = PF_GW302_BaleSizeFactor[PF_DEF];
 352              		.loc 1 481 0
 353 00dc DD27     		mov	r7, #221
 354 00de 9026     		mov	r6, #144
 355 00e0 9F55     		strb	r7, [r3, r6]
 482:functions.c   **** 	pFac.pf.GW302_FillPotRange = PF_GW302_FillPotRange[PF_DEF]; // V
 356              		.loc 1 482 0
 357 00e2 9426     		mov	r6, #148
 358 00e4 9851     		str	r0, [r3, r6]
 483:functions.c   **** 	pFac.pf.GW302_FillPotIgnore = PF_GW302_FillPotIgnore[PF_DEF]; // V
 359              		.loc 1 483 0
 360 00e6 FA27     		mov	r7, #250
 361 00e8 BF05     		lsl	r7, r7, #22
 362 00ea 9826     		mov	r6, #152
 363 00ec 9F51     		str	r7, [r3, r6]
 484:functions.c   **** 	pFac.pf.GW302_EngageDiameter = PF_GW302_EngageDiameter[PF_DEF]; // %
 364              		.loc 1 484 0
 365 00ee 5F27     		mov	r7, #95
 366 00f0 9C26     		mov	r6, #156
 367 00f2 9F55     		strb	r7, [r3, r6]
 485:functions.c   **** 	pFac.pf.GW302_BaleIndicator = PF_GW302_BaleIndicator[PF_DEF]; // Steer/Fill
 368              		.loc 1 485 0
 369 00f4 9D26     		mov	r6, #157
 370 00f6 9A55     		strb	r2, [r3, r6]
 486:functions.c   **** 	pFac.pf.GW302_RollerDelay = PF_GW302_RollerDelay[PF_DEF]; // s
 371              		.loc 1 486 0
 372 00f8 FC27     		mov	r7, #252
 373 00fa BF05     		lsl	r7, r7, #22
 374 00fc A026     		mov	r6, #160
 375 00fe 9F51     		str	r7, [r3, r6]
 487:functions.c   **** 
 488:functions.c   **** 	// Technician Menu - Netting Setup
 489:functions.c   **** 	pFac.pf.GW302_NetOn = PF_GW302_NetOn[PF_DEF]; // s
 376              		.loc 1 489 0
 377 0100 594F     		ldr	r7, .L20+44
 378 0102 A426     		mov	r6, #164
 379 0104 9F51     		str	r7, [r3, r6]
 490:functions.c   **** 	pFac.pf.GW302_NetCutPulse = PF_GW302_NetCutPulse[PF_DEF]; // pulses
 380              		.loc 1 490 0
 381 0106 2827     		mov	r7, #40
 382 0108 A826     		mov	r6, #168
 383 010a 9F55     		strb	r7, [r3, r6]
 491:functions.c   **** 	pFac.pf.GW302_NetCutTime = PF_GW302_NetCutTime[PF_DEF]; // s
 384              		.loc 1 491 0
 385 010c 574F     		ldr	r7, .L20+48
 386 010e AC26     		mov	r6, #172
 387 0110 9F51     		str	r7, [r3, r6]
 492:functions.c   **** 	pFac.pf.GW302_MinDiaPulsPerLay = PF_GW302_MinDiaPulsPerLay[PF_DEF]; // pulses/layer
 388              		.loc 1 492 0
 389 0112 574F     		ldr	r7, .L20+52
 390 0114 B026     		mov	r6, #176
 391 0116 9F51     		str	r7, [r3, r6]
 493:functions.c   **** 	pFac.pf.GW302_MaxDiaPulsPerLay = PF_GW302_MaxDiaPulsPerLay[PF_DEF]; // pulses/layer
 392              		.loc 1 493 0
 393 0118 564F     		ldr	r7, .L20+56
 394 011a B426     		mov	r6, #180
 395 011c 9F51     		str	r7, [r3, r6]
 494:functions.c   **** 	pFac.pf.GW302_NetFactor = PF_GW302_NetFactor[PF_DEF];
 396              		.loc 1 494 0
 397 011e B826     		mov	r6, #184
 398 0120 9851     		str	r0, [r3, r6]
 495:functions.c   **** 	pFac.pf.GW302_NoNetPulse = PF_GW302_NoNetPulse[PF_DEF]; // s
 399              		.loc 1 495 0
 400 0122 8120     		mov	r0, #129
 401 0124 C005     		lsl	r0, r0, #23
 402 0126 BC26     		mov	r6, #188
 403 0128 9851     		str	r0, [r3, r6]
 496:functions.c   **** 	pFac.pf.GW302_PreNetPulse = PF_GW302_PreNetPulse[PF_DEF]; // pulses
 404              		.loc 1 496 0
 405 012a 0227     		mov	r7, #2
 406 012c C026     		mov	r6, #192
 407 012e 9F55     		strb	r7, [r3, r6]
 497:functions.c   **** 	pFac.pf.GW302_NetSystem = PF_GW302_NetSystem[PF_DEF]; // Beak/Roller
 408              		.loc 1 497 0
 409 0130 0127     		mov	r7, #1
 410 0132 C126     		mov	r6, #193
 411 0134 9F55     		strb	r7, [r3, r6]
 498:functions.c   **** 	pFac.pf.GW302_BeakEngage = PF_GW302_BeakEngage[PF_DEF]; // pulses
 412              		.loc 1 498 0
 413 0136 0627     		mov	r7, #6
 414 0138 C226     		mov	r6, #194
 415 013a 9F55     		strb	r7, [r3, r6]
 499:functions.c   **** 	pFac.pf.GW302_TwineOption = PF_GW302_TwineOption[PF_DEF]; // Net option on or off
 416              		.loc 1 499 0
 417 013c C326     		mov	r6, #195
 418 013e 9A55     		strb	r2, [r3, r6]
 500:functions.c   **** 	pFac.pf.GW302_NetTwineOption = PF_GW302_NetTwineOption[PF_DEF]; // Net or twine
 419              		.loc 1 500 0
 420 0140 7C26     		mov	r6, #124
 421 0142 9A55     		strb	r2, [r3, r6]
 501:functions.c   **** 
 502:functions.c   **** 	// Technician Menu - Diameter Setup
 503:functions.c   **** 	pFac.pf.GW302_DiameterMin = PF_GW302_DiameterMin[PF_DEF]; // %
 422              		.loc 1 503 0
 423 0144 0826     		mov	r6, #8
 424 0146 C422     		mov	r2, #196
 425 0148 9E54     		strb	r6, [r3, r2]
 504:functions.c   **** 	pFac.pf.GW302_DiameterMax = PF_GW302_DiameterMax[PF_DEF]; // %
 426              		.loc 1 504 0
 427 014a 6426     		mov	r6, #100
 428 014c C522     		mov	r2, #197
 429 014e 9E54     		strb	r6, [r3, r2]
 505:functions.c   **** 	pFac.pf.GW302_DiaCorrection = PF_GW302_DiaCorrection[PF_DEF]; // V
 430              		.loc 1 505 0
 431 0150 494F     		ldr	r7, .L20+60
 432 0152 C822     		mov	r2, #200
 433 0154 9F50     		str	r7, [r3, r2]
 506:functions.c   **** 	pFac.pf.GW302_BaleDiaSmoothingFactor = PF_GW302_BaleDiaSmoothingFactor[PF_DEF]; // %
 434              		.loc 1 506 0
 435 0156 3222     		mov	r2, #50
 436 0158 CC27     		mov	r7, #204
 437 015a DA55     		strb	r2, [r3, r7]
 507:functions.c   **** 	pFac.pf.GW302_DensityPresSmoothingFactor = PF_GW302_DensityPresSmoothingFactor[PF_DEF]; // %
 438              		.loc 1 507 0
 439 015c CD27     		mov	r7, #205
 440 015e DE55     		strb	r6, [r3, r7]
 508:functions.c   **** 	pFac.pf.GW302_BaleShapeSmoothingFactor = PF_GW302_BaleShapeSmoothingFactor[PF_DEF]; // %
 441              		.loc 1 508 0
 442 0160 CE26     		mov	r6, #206
 443 0162 9A55     		strb	r2, [r3, r6]
 509:functions.c   **** 	pFac.pf.GW302_KnifePresSmoothingFactor = PF_GW302_KnifePresSmoothingFactor[PF_DEF]; // %
 444              		.loc 1 509 0
 445 0164 CF26     		mov	r6, #207
 446 0166 9A55     		strb	r2, [r3, r6]
 510:functions.c   **** 
 511:functions.c   **** 	// Technician Menu - Density Setup
 512:functions.c   **** 	pFac.pf.GW302_Density1 = PF_GW302_Density1[PF_DEF]; // V
 447              		.loc 1 512 0
 448 0168 D022     		mov	r2, #208
 449 016a 9950     		str	r1, [r3, r2]
 513:functions.c   **** 	pFac.pf.GW302_Density2 = PF_GW302_Density2[PF_DEF]; // V
 450              		.loc 1 513 0
 451 016c 4349     		ldr	r1, .L20+64
 452 016e D422     		mov	r2, #212
 453 0170 9950     		str	r1, [r3, r2]
 514:functions.c   **** 	pFac.pf.GW302_Density3 = PF_GW302_Density3[PF_DEF]; // V
 454              		.loc 1 514 0
 455 0172 4349     		ldr	r1, .L20+68
 456 0174 D822     		mov	r2, #216
 457 0176 9950     		str	r1, [r3, r2]
 515:functions.c   **** 	pFac.pf.GW302_Density4 = PF_GW302_Density4[PF_DEF]; // V
 458              		.loc 1 515 0
 459 0178 4249     		ldr	r1, .L20+72
 460 017a DC22     		mov	r2, #220
 461 017c 9950     		str	r1, [r3, r2]
 516:functions.c   **** 	pFac.pf.GW302_Density5 = PF_GW302_Density5[PF_DEF]; // V
 462              		.loc 1 516 0
 463 017e E022     		mov	r2, #224
 464 0180 9D50     		str	r5, [r3, r2]
 517:functions.c   **** 	pFac.pf.GW302_Density6 = PF_GW302_Density6[PF_DEF]; // V
 465              		.loc 1 517 0
 466 0182 4149     		ldr	r1, .L20+76
 467 0184 E422     		mov	r2, #228
 468 0186 9950     		str	r1, [r3, r2]
 518:functions.c   **** 	pFac.pf.GW302_Density7 = PF_GW302_Density7[PF_DEF]; // V
 469              		.loc 1 518 0
 470 0188 4049     		ldr	r1, .L20+80
 471 018a E822     		mov	r2, #232
 472 018c 9950     		str	r1, [r3, r2]
 519:functions.c   **** 	pFac.pf.GW302_Density8 = PF_GW302_Density8[PF_DEF]; // V
 473              		.loc 1 519 0
 474 018e 4049     		ldr	r1, .L20+84
 475 0190 EC22     		mov	r2, #236
 476 0192 9950     		str	r1, [r3, r2]
 520:functions.c   **** 	pFac.pf.GW302_Density9 = PF_GW302_Density9[PF_DEF]; // V
 477              		.loc 1 520 0
 478 0194 3F49     		ldr	r1, .L20+88
 479 0196 F022     		mov	r2, #240
 480 0198 9950     		str	r1, [r3, r2]
 521:functions.c   **** 	pFac.pf.GW302_Density10 = PF_GW302_Density10[PF_DEF]; // V
 481              		.loc 1 521 0
 482 019a F422     		mov	r2, #244
 483 019c 9850     		str	r0, [r3, r2]
 522:functions.c   **** 
 523:functions.c   **** 	// Technician Menu - Knives Setup
 524:functions.c   **** 	pFac.pf.GW302_KnifePressure = PF_GW302_KnifePressure[PF_DEF]; // V
 484              		.loc 1 524 0
 485 019e 3E49     		ldr	r1, .L20+92
 486 01a0 F822     		mov	r2, #248
 487 01a2 9950     		str	r1, [r3, r2]
 525:functions.c   **** 	pFac.pf.GW302_KnifePresWarn = PF_GW302_KnifePresWarn[PF_DEF]; // V
 488              		.loc 1 525 0
 489 01a4 3D49     		ldr	r1, .L20+96
 490 01a6 FC22     		mov	r2, #252
 491 01a8 9950     		str	r1, [r3, r2]
 526:functions.c   **** 	pFac.pf.GW302_DiverterDelay = PF_GW302_DiverterDelay[PF_DEF]; // s
 492              		.loc 1 526 0
 493 01aa 8022     		mov	r2, #128
 494 01ac 5200     		lsl	r2, r2, #1
 495 01ae 9C50     		str	r4, [r3, r2]
 496              	.LVL23:
 497 01b0 0023     		mov	r3, #0
 430:functions.c   **** void SetDefaultFactors( void )
 498              		.loc 1 430 0
 499 01b2 2248     		ldr	r0, .L20
 500 01b4 8446     		mov	ip, r0
 527:functions.c   **** 
 528:functions.c   **** 	// Technician Menu - Formation 2
 529:functions.c   **** 	for( c = 0; c < BP_PRESET_MAX; c++ )   // Bale Profile defaults set for Presets A to E
 530:functions.c   **** 	{
 531:functions.c   **** 		pFac.pf.GW302_FormationDensity[c]   = PresetFormationDensity[c]; // ID
 501              		.loc 1 531 0
 502 01b6 3A4F     		ldr	r7, .L20+100
 532:functions.c   **** 		pFac.pf.GW302_FormationDiameter[c]  = PresetFormationDiameter[c]; // %
 503              		.loc 1 532 0
 504 01b8 3A4E     		ldr	r6, .L20+104
 533:functions.c   **** 		pFac.pf.GW302_Formation2Density[c]  = PresetFormation2Density[c]; // ID
 505              		.loc 1 533 0
 506 01ba 3B4D     		ldr	r5, .L20+108
 534:functions.c   **** 		pFac.pf.GW302_Formation2Diameter[c] = PresetFormation2Diameter[c]; // %
 507              		.loc 1 534 0
 508 01bc 3B4C     		ldr	r4, .L20+112
 509              	.LVL24:
 510              	.L16:
 430:functions.c   **** void SetDefaultFactors( void )
 511              		.loc 1 430 0 discriminator 2
 512 01be 6146     		mov	r1, ip
 513 01c0 CA18     		add	r2, r1, r3
 514 01c2 511D     		add	r1, r2, #5
 515 01c4 FF31     		add	r1, r1, #255
 531:functions.c   **** 		pFac.pf.GW302_FormationDensity[c]   = PresetFormationDensity[c]; // ID
 516              		.loc 1 531 0 discriminator 2
 517 01c6 D85D     		ldrb	r0, [r3, r7]
 518 01c8 0870     		strb	r0, [r1]
 430:functions.c   **** void SetDefaultFactors( void )
 519              		.loc 1 430 0 discriminator 2
 520 01ca 3948     		ldr	r0, .L20+116
 521 01cc 1118     		add	r1, r2, r0
 532:functions.c   **** 		pFac.pf.GW302_FormationDiameter[c]  = PresetFormationDiameter[c]; // %
 522              		.loc 1 532 0 discriminator 2
 523 01ce 985D     		ldrb	r0, [r3, r6]
 524 01d0 0870     		strb	r0, [r1]
 430:functions.c   **** void SetDefaultFactors( void )
 525              		.loc 1 430 0 discriminator 2
 526 01d2 8720     		mov	r0, #135
 527 01d4 4000     		lsl	r0, r0, #1
 528 01d6 1118     		add	r1, r2, r0
 533:functions.c   **** 		pFac.pf.GW302_Formation2Density[c]  = PresetFormation2Density[c]; // ID
 529              		.loc 1 533 0 discriminator 2
 530 01d8 585D     		ldrb	r0, [r3, r5]
 531 01da 0870     		strb	r0, [r1]
 430:functions.c   **** void SetDefaultFactors( void )
 532              		.loc 1 430 0 discriminator 2
 533 01dc 1432     		add	r2, r2, #20
 534 01de FF32     		add	r2, r2, #255
 535              		.loc 1 534 0 discriminator 2
 536 01e0 195D     		ldrb	r1, [r3, r4]
 537 01e2 1170     		strb	r1, [r2]
 538 01e4 0133     		add	r3, r3, #1
 529:functions.c   **** 	for( c = 0; c < BP_PRESET_MAX; c++ )   // Bale Profile defaults set for Presets A to E
 539              		.loc 1 529 0 discriminator 2
 540 01e6 052B     		cmp	r3, #5
 541 01e8 E9D1     		bne	.L16
 535:functions.c   **** 	}
 536:functions.c   **** 
 537:functions.c   **** 	// Diagnostics - Digital Inputs
 538:functions.c   **** 	pFac.pf.GW302_ChoppingKnivesFitted = PF_GW302_ChoppingKnivesFitted[PF_DEF]; // Disabled/Enabled
 542              		.loc 1 538 0
 543 01ea 144C     		ldr	r4, .L20
 544 01ec 0022     		mov	r2, #0
 545 01ee 8C23     		mov	r3, #140
 546 01f0 5B00     		lsl	r3, r3, #1
 547 01f2 E254     		strb	r2, [r4, r3]
 539:functions.c   **** 
 540:functions.c   **** 	pFac.pf.CheckSum = CheckSumIt( &(pFac.ch[0]), (unsigned char *)&(pFac.pf.CheckSum) );
 548              		.loc 1 540 0
 549 01f4 8E22     		mov	r2, #142
 550 01f6 5200     		lsl	r2, r2, #1
 551 01f8 A118     		add	r1, r4, r2
 552 01fa 201C     		mov	r0, r4
 553 01fc FFF7FEFF 		bl	CheckSumIt
 554              	.LVL25:
 555 0200 8E23     		mov	r3, #142
 556 0202 5B00     		lsl	r3, r3, #1
 557 0204 E050     		str	r0, [r4, r3]
 541:functions.c   **** 
 542:functions.c   **** #ifndef WINDOWS
 543:functions.c   **** 	AT91C_BASE_PIOA->PIO_CODR = BUZZER;
 558              		.loc 1 543 0
 559 0206 2B4D     		ldr	r5, .L20+120
 560 0208 8026     		mov	r6, #128
 561 020a F601     		lsl	r6, r6, #7
 562 020c 6E63     		str	r6, [r5, #52]
 544:functions.c   **** 	//AT91C_BASE_PIOA->PIO_CODR = OUT5;
 545:functions.c   **** 
 546:functions.c   **** 	// write main factors to SPI1 Flash @ 0x000000
 547:functions.c   **** 	SPI1FlashWrite( SFC_PW, pFac_BASEADDRESS, &(pFac.ch[0]), sizeof(pFac.pf) );
 563              		.loc 1 547 0
 564 020e 9027     		mov	r7, #144
 565 0210 7F00     		lsl	r7, r7, #1
 566 0212 0A20     		mov	r0, #10
 567 0214 0021     		mov	r1, #0
 568 0216 221C     		mov	r2, r4
 569 0218 3B1C     		mov	r3, r7
 570 021a FFF7FEFF 		bl	SPI1FlashWrite
 571              	.LVL26:
 548:functions.c   **** 
 549:functions.c   **** 	// write backup factors to SPI1 Flash @ 0x000000 + 800h
 550:functions.c   **** 	SPI1FlashWrite( SFC_PW, pFac_BASEADDRESS+ 0x800, &(pFac.ch[0]), sizeof(pFac.pf) );
 572              		.loc 1 550 0
 573 021e 0A20     		mov	r0, #10
 574 0220 8021     		mov	r1, #128
 575 0222 0901     		lsl	r1, r1, #4
 576 0224 221C     		mov	r2, r4
 577 0226 3B1C     		mov	r3, r7
 578 0228 FFF7FEFF 		bl	SPI1FlashWrite
 579              	.LVL27:
 551:functions.c   **** 
 552:functions.c   **** 	AT91C_BASE_PIOA->PIO_SODR = BUZZER;
 580              		.loc 1 552 0
 581 022c 2E63     		str	r6, [r5, #48]
 553:functions.c   **** 	//AT91C_BASE_PIOA->PIO_SODR = OUT5;
 554:functions.c   **** #endif
 555:functions.c   **** }
 582              		.loc 1 555 0
 583              		@ sp needed for prologue
 584 022e 1CBC     		pop	{r2, r3, r4}
 585 0230 9046     		mov	r8, r2
 586 0232 9946     		mov	r9, r3
 587 0234 A246     		mov	sl, r4
 588 0236 F0BC     		pop	{r4, r5, r6, r7}
 589 0238 01BC     		pop	{r0}
 590 023a 0047     		bx	r0
 591              	.L21:
 592              		.align	2
 593              	.L20:
 594 023c 00000000 		.word	.LANCHOR0
 595 0240 00000000 		.word	TextString
 596 0244 00000000 		.word	ptText
 597 0248 00000000 		.word	.LANCHOR1
 598 024c 00000000 		.word	.LANCHOR2
 599 0250 00000000 		.word	.LANCHOR3
 600 0254 00000000 		.word	.LANCHOR4
 601 0258 00000000 		.word	.LANCHOR5
 602 025c 00002040 		.word	1075838976
 603 0260 00004842 		.word	1112014848
 604 0264 CDCC4C3E 		.word	1045220557
 605 0268 00004040 		.word	1077936128
 606 026c 0000C040 		.word	1086324736
 607 0270 00001842 		.word	1108869120
 608 0274 0000D842 		.word	1121452032
 609 0278 0AD7233C 		.word	1008981770
 610 027c CDCC4C3F 		.word	1061997773
 611 0280 9A99993F 		.word	1067030938
 612 0284 CDCCCC3F 		.word	1070386381
 613 0288 9A991940 		.word	1075419546
 614 028c 33333340 		.word	1077097267
 615 0290 CDCC4C40 		.word	1078774989
 616 0294 66666640 		.word	1080452710
 617 0298 6666663F 		.word	1063675494
 618 029c 6666A63F 		.word	1067869798
 619 02a0 00000000 		.word	.LANCHOR6
 620 02a4 00000000 		.word	.LANCHOR7
 621 02a8 00000000 		.word	.LANCHOR8
 622 02ac 00000000 		.word	.LANCHOR9
 623 02b0 09010000 		.word	265
 624 02b4 00F4FFFF 		.word	-3072
 625              		.cfi_endproc
 626              	.LFE378:
 628              		.section	.text.SetDefaultTotals,"ax",%progbits
 629              		.align	2
 630              		.global	SetDefaultTotals
 631              		.code	16
 632              		.thumb_func
 634              	SetDefaultTotals:
 635              	.LFB379:
 556:functions.c   **** // -----------------------------------------------------------
 557:functions.c   **** 
 558:functions.c   **** 
 559:functions.c   **** // -----------------------------------------------------------
 560:functions.c   **** // Function Name       : SetDefaultTotals
 561:functions.c   **** // Object              : reset power on defaults
 562:functions.c   **** // -----------------------------------------------------------
 563:functions.c   **** void SetDefaultTotals( void )
 564:functions.c   **** {
 636              		.loc 1 564 0
 637              		.cfi_startproc
 638 0000 70B5     		push	{r4, r5, r6, lr}
 639              	.LCFI5:
 640              		.cfi_def_cfa_offset 16
 641              		.cfi_offset 4, -16
 642              		.cfi_offset 5, -12
 643              		.cfi_offset 6, -8
 644              		.cfi_offset 14, -4
 565:functions.c   **** 	pRun.pr.Brightness[0] = DISPLAY_DEFAULT_DAY_BRIGHTNESS;
 645              		.loc 1 565 0
 646 0002 184C     		ldr	r4, .L23
 647 0004 2023     		mov	r3, #32
 648 0006 6422     		mov	r2, #100
 649 0008 E254     		strb	r2, [r4, r3]
 566:functions.c   **** 	pRun.pr.Contrast[0] = DISPLAY_DEFAULT_DAY_CONTRAST;
 650              		.loc 1 566 0
 651 000a 2821     		mov	r1, #40
 652 000c 2222     		mov	r2, #34
 653 000e A154     		strb	r1, [r4, r2]
 567:functions.c   **** 
 568:functions.c   **** 	pRun.pr.Brightness[1] = DISPLAY_DEFAULT_BRIGHTNESS;
 654              		.loc 1 568 0
 655 0010 4C21     		mov	r1, #76
 656 0012 2122     		mov	r2, #33
 657 0014 A154     		strb	r1, [r4, r2]
 569:functions.c   **** 	pRun.pr.Contrast[1] = DISPLAY_DEFAULT_CONTRAST;
 658              		.loc 1 569 0
 659 0016 2322     		mov	r2, #35
 660 0018 A354     		strb	r3, [r4, r2]
 570:functions.c   **** 
 571:functions.c   **** 	pRun.pr.DayNight = 0;
 661              		.loc 1 571 0
 662 001a 0023     		mov	r3, #0
 663 001c 2422     		mov	r2, #36
 664 001e A354     		strb	r3, [r4, r2]
 572:functions.c   **** 
 573:functions.c   **** 	pRun.pr.LubeCounter = PF_GW302_LubeAlarm[PF_DEF]; // bales
 665              		.loc 1 573 0
 666 0020 9622     		mov	r2, #150
 667 0022 5200     		lsl	r2, r2, #1
 668 0024 E284     		strh	r2, [r4, #38]
 574:functions.c   **** 
 575:functions.c   **** 	pRun.pr.PowerCount = 0;
 669              		.loc 1 575 0
 670 0026 2385     		strh	r3, [r4, #40]
 576:functions.c   **** 
 577:functions.c   **** 	pRun.pr.CheckSum = CheckSumIt( &(pRun.ch[0]), (unsigned char *)&(pRun.pr.CheckSum) );
 671              		.loc 1 577 0
 672 0028 251C     		mov	r5, r4
 673 002a 2035     		add	r5, r5, #32
 674 002c 211C     		mov	r1, r4
 675 002e 2C31     		add	r1, r1, #44
 676 0030 281C     		mov	r0, r5
 677 0032 FFF7FEFF 		bl	CheckSumIt
 678              	.LVL28:
 679 0036 E062     		str	r0, [r4, #44]
 578:functions.c   **** 
 579:functions.c   **** #ifndef WINDOWS
 580:functions.c   **** 	AT91C_BASE_PIOA->PIO_CODR = BUZZER;
 680              		.loc 1 580 0
 681 0038 0B4C     		ldr	r4, .L23+4
 682 003a 8026     		mov	r6, #128
 683 003c F601     		lsl	r6, r6, #7
 684 003e 6663     		str	r6, [r4, #52]
 581:functions.c   **** 	//AT91C_BASE_PIOA->PIO_CODR = OUT5;
 582:functions.c   **** 
 583:functions.c   **** 	// write runtime factors and totals to SPI1 Flash @ 0x001000
 584:functions.c   **** 	SPI1FlashWrite( SFC_PW, pRun_BASEADDRESS, &(pRun.ch[0]), sizeof(pRun.pr) );
 685              		.loc 1 584 0
 686 0040 0A20     		mov	r0, #10
 687 0042 8021     		mov	r1, #128
 688 0044 4901     		lsl	r1, r1, #5
 689 0046 2A1C     		mov	r2, r5
 690 0048 1023     		mov	r3, #16
 691 004a FFF7FEFF 		bl	SPI1FlashWrite
 692              	.LVL29:
 585:functions.c   **** 
 586:functions.c   **** 	// write runtime factors and totals to SPI1 Flash @ 0x001800
 587:functions.c   **** 	SPI1FlashWrite( SFC_PW, pRun_BASEADDRESS + 0x800, &(pRun.ch[0]), sizeof(pRun.pr) );
 693              		.loc 1 587 0
 694 004e 0A20     		mov	r0, #10
 695 0050 C021     		mov	r1, #192
 696 0052 4901     		lsl	r1, r1, #5
 697 0054 2A1C     		mov	r2, r5
 698 0056 1023     		mov	r3, #16
 699 0058 FFF7FEFF 		bl	SPI1FlashWrite
 700              	.LVL30:
 588:functions.c   **** 
 589:functions.c   **** 	AT91C_BASE_PIOA->PIO_SODR = BUZZER;
 701              		.loc 1 589 0
 702 005c 2663     		str	r6, [r4, #48]
 590:functions.c   **** 	//AT91C_BASE_PIOA->PIO_SODR = OUT5;
 591:functions.c   **** #endif
 592:functions.c   **** 
 593:functions.c   **** }
 703              		.loc 1 593 0
 704              		@ sp needed for prologue
 705 005e 70BC     		pop	{r4, r5, r6}
 706 0060 01BC     		pop	{r0}
 707 0062 0047     		bx	r0
 708              	.L24:
 709              		.align	2
 710              	.L23:
 711 0064 00010000 		.word	.LANCHOR10
 712 0068 00F4FFFF 		.word	-3072
 713              		.cfi_endproc
 714              	.LFE379:
 716              		.section	.text.SetStartupDefaults,"ax",%progbits
 717              		.align	2
 718              		.global	SetStartupDefaults
 719              		.code	16
 720              		.thumb_func
 722              	SetStartupDefaults:
 723              	.LFB380:
 594:functions.c   **** // -----------------------------------------------------------
 595:functions.c   **** 
 596:functions.c   **** 
 597:functions.c   **** // -----------------------------------------------------------
 598:functions.c   **** // Function Name       : SetStartupDefaults
 599:functions.c   **** // Object              : set global variables to power on values
 600:functions.c   **** // -----------------------------------------------------------
 601:functions.c   **** void SetStartupDefaults( void )
 602:functions.c   **** {    
 724              		.loc 1 602 0
 725              		.cfi_startproc
 726 0000 00B5     		push	{lr}
 727              	.LCFI6:
 728              		.cfi_def_cfa_offset 4
 729              		.cfi_offset 14, -4
 603:functions.c   **** 	ptText = TextString[pFac.pf.Lang];
 730              		.loc 1 603 0
 731 0002 104B     		ldr	r3, .L28
 732 0004 1A7B     		ldrb	r2, [r3, #12]
 733 0006 9200     		lsl	r2, r2, #2
 734 0008 0F4B     		ldr	r3, .L28+4
 735 000a D258     		ldr	r2, [r2, r3]
 736 000c 0F4B     		ldr	r3, .L28+8
 737 000e 1A60     		str	r2, [r3]
 604:functions.c   **** 	key = (~AT91C_BASE_PIOB->PIO_PDSR) & SW_MASK;
 738              		.loc 1 604 0
 739 0010 0F4B     		ldr	r3, .L28+12
 740 0012 DA6B     		ldr	r2, [r3, #60]
 741 0014 FF23     		mov	r3, #255
 742 0016 9B00     		lsl	r3, r3, #2
 743 0018 9343     		bic	r3, r2
 744 001a 0E4A     		ldr	r2, .L28+16
 745 001c 1360     		str	r3, [r2]
 605:functions.c   **** 	if( (key & ~(SW_NEW|SW_REP)) == SW_CU )
 746              		.loc 1 605 0
 747 001e 202B     		cmp	r3, #32
 748 0020 03D1     		bne	.L26
 606:functions.c   **** 		window = screen147;  // Technician Menu - Reset Defaults
 749              		.loc 1 606 0
 750 0022 0D4A     		ldr	r2, .L28+20
 751 0024 0D4B     		ldr	r3, .L28+24
 752 0026 1A60     		str	r2, [r3]
 753 0028 02E0     		b	.L27
 754              	.L26:
 607:functions.c   **** 	else
 608:functions.c   **** 		window = screen00;   // Startup Splash Screen
 755              		.loc 1 608 0
 756 002a 0D4A     		ldr	r2, .L28+28
 757 002c 0B4B     		ldr	r3, .L28+24
 758 002e 1A60     		str	r2, [r3]
 759              	.L27:
 609:functions.c   **** 
 610:functions.c   **** 	looptime = 0;
 760              		.loc 1 610 0
 761 0030 0023     		mov	r3, #0
 762 0032 0C4A     		ldr	r2, .L28+32
 763 0034 1370     		strb	r3, [r2]
 611:functions.c   **** 
 612:functions.c   **** 	AutoMan = 0;
 764              		.loc 1 612 0
 765 0036 0C4A     		ldr	r2, .L28+36
 766 0038 1370     		strb	r3, [r2]
 613:functions.c   **** 	SecondScreen = 0;
 767              		.loc 1 613 0
 768 003a 0C4A     		ldr	r2, .L28+40
 769 003c 1370     		strb	r3, [r2]
 614:functions.c   **** }
 770              		.loc 1 614 0
 771              		@ sp needed for prologue
 772 003e 01BC     		pop	{r0}
 773 0040 0047     		bx	r0
 774              	.L29:
 775 0042 C046     		.align	2
 776              	.L28:
 777 0044 00000000 		.word	.LANCHOR0
 778 0048 00000000 		.word	TextString
 779 004c 00000000 		.word	ptText
 780 0050 00F6FFFF 		.word	-2560
 781 0054 00000000 		.word	key
 782 0058 00000000 		.word	screen147
 783 005c 00000000 		.word	window
 784 0060 00000000 		.word	screen00
 785 0064 00000000 		.word	looptime
 786 0068 00000000 		.word	AutoMan
 787 006c 00000000 		.word	SecondScreen
 788              		.cfi_endproc
 789              	.LFE380:
 791              		.global	__aeabi_uidiv
 792              		.global	__aeabi_uidivmod
 793              		.section	.text.btobcd,"ax",%progbits
 794              		.align	2
 795              		.global	btobcd
 796              		.code	16
 797              		.thumb_func
 799              	btobcd:
 800              	.LFB381:
 615:functions.c   **** // -----------------------------------------------------------
 616:functions.c   **** 
 617:functions.c   **** 
 618:functions.c   **** // -----------------------------------------------------------
 619:functions.c   **** // Function Name       : btobcd
 620:functions.c   **** // -----------------------------------------------------------
 621:functions.c   **** unsigned char btobcd( unsigned char bin )
 622:functions.c   **** {
 801              		.loc 1 622 0
 802              		.cfi_startproc
 803              	.LVL31:
 804 0000 38B5     		push	{r3, r4, r5, lr}
 805              	.LCFI7:
 806              		.cfi_def_cfa_offset 16
 807              		.cfi_offset 3, -16
 808              		.cfi_offset 4, -12
 809              		.cfi_offset 5, -8
 810              		.cfi_offset 14, -4
 811 0002 041C     		mov	r4, r0
 623:functions.c   **** 	return( ((bin / 10) * 0x10) + (bin % 10) );
 812              		.loc 1 623 0
 813 0004 0A21     		mov	r1, #10
 814 0006 FFF7FEFF 		bl	__aeabi_uidiv
 815              	.LVL32:
 816 000a 0501     		lsl	r5, r0, #4
 817 000c 201C     		mov	r0, r4
 818 000e 0A21     		mov	r1, #10
 819 0010 FFF7FEFF 		bl	__aeabi_uidivmod
 820              	.LVL33:
 821 0014 6818     		add	r0, r5, r1
 822 0016 0006     		lsl	r0, r0, #24
 823 0018 000E     		lsr	r0, r0, #24
 624:functions.c   **** }
 824              		.loc 1 624 0
 825              		@ sp needed for prologue
 826 001a 38BC     		pop	{r3, r4, r5}
 827 001c 02BC     		pop	{r1}
 828 001e 0847     		bx	r1
 829              		.cfi_endproc
 830              	.LFE381:
 832              		.section	.text.bcdtob,"ax",%progbits
 833              		.align	2
 834              		.global	bcdtob
 835              		.code	16
 836              		.thumb_func
 838              	bcdtob:
 839              	.LFB382:
 625:functions.c   **** // -----------------------------------------------------------
 626:functions.c   **** 
 627:functions.c   **** 
 628:functions.c   **** // -----------------------------------------------------------
 629:functions.c   **** // Function Name       : bcdtob
 630:functions.c   **** // -----------------------------------------------------------
 631:functions.c   **** unsigned char bcdtob( unsigned char bcd )
 632:functions.c   **** {
 840              		.loc 1 632 0
 841              		.cfi_startproc
 842              	.LVL34:
 633:functions.c   **** 	return( ((bcd / 0x10) * 10) + (bcd % 0x10) );
 843              		.loc 1 633 0
 844 0000 0309     		lsr	r3, r0, #4
 845 0002 9A00     		lsl	r2, r3, #2
 846 0004 D318     		add	r3, r2, r3
 847 0006 5B00     		lsl	r3, r3, #1
 848 0008 0F22     		mov	r2, #15
 849 000a 1040     		and	r0, r2
 850              	.LVL35:
 851 000c 1818     		add	r0, r3, r0
 852 000e 0006     		lsl	r0, r0, #24
 853 0010 000E     		lsr	r0, r0, #24
 634:functions.c   **** }
 854              		.loc 1 634 0
 855              		@ sp needed for prologue
 856 0012 7047     		bx	lr
 857              		.cfi_endproc
 858              	.LFE382:
 860              		.global	__aeabi_idiv
 861              		.section	.text.SetOutputPWM,"ax",%progbits
 862              		.align	2
 863              		.global	SetOutputPWM
 864              		.code	16
 865              		.thumb_func
 867              	SetOutputPWM:
 868              	.LFB383:
 635:functions.c   **** // -----------------------------------------------------------
 636:functions.c   **** 
 637:functions.c   **** 
 638:functions.c   **** // -----------------------------------------------------------
 639:functions.c   **** // Function Name       : SetOutputPWM
 640:functions.c   **** // -----------------------------------------------------------
 641:functions.c   **** void SetOutputPWM( unsigned char output, unsigned short int freq, unsigned char duty )
 642:functions.c   **** {
 869              		.loc 1 642 0
 870              		.cfi_startproc
 871              	.LVL36:
 872 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 873              	.LCFI8:
 874              		.cfi_def_cfa_offset 20
 875              		.cfi_offset 4, -20
 876              		.cfi_offset 5, -16
 877              		.cfi_offset 6, -12
 878              		.cfi_offset 7, -8
 879              		.cfi_offset 14, -4
 880 0002 4F46     		mov	r7, r9
 881 0004 4646     		mov	r6, r8
 882 0006 C0B4     		push	{r6, r7}
 883              	.LCFI9:
 884              		.cfi_def_cfa_offset 28
 885              		.cfi_offset 8, -28
 886              		.cfi_offset 9, -24
 887 0008 89B0     		sub	sp, sp, #36
 888              	.LCFI10:
 889              		.cfi_def_cfa_offset 64
 890 000a 061C     		mov	r6, r0
 891 000c 8846     		mov	r8, r1
 892 000e 171C     		mov	r7, r2
 643:functions.c   **** #ifndef WINDOWS    
 644:functions.c   **** 	unsigned int const portpin[8] = { AT91C_PA18_PWM0, AT91C_PA19_PWM1, AT91C_PA20_PWM2, AT91C_PA21_PW
 893              		.loc 1 644 0
 894 0010 5E4C     		ldr	r4, .L43
 895 0012 6B46     		mov	r3, sp
 896 0014 07CC     		ldmia	r4!, {r0, r1, r2}
 897 0016 07C3     		stmia	r3!, {r0, r1, r2}
 898              	.LVL37:
 899 0018 07CC     		ldmia	r4!, {r0, r1, r2}
 900 001a 07C3     		stmia	r3!, {r0, r1, r2}
 901 001c 03CC     		ldmia	r4!, {r0, r1}
 902 001e 03C3     		stmia	r3!, {r0, r1}
 645:functions.c   **** #endif
 646:functions.c   **** 
 647:functions.c   **** 	static int status;
 648:functions.c   **** 	static unsigned char dutyLast[8];
 649:functions.c   **** 	static unsigned short int freqLast[8];
 650:functions.c   **** 
 651:functions.c   **** 	unsigned int mode, mul, period, channel;
 652:functions.c   **** 
 653:functions.c   **** 	channel = ((unsigned int)0x1 << output);
 903              		.loc 1 653 0
 904 0020 0123     		mov	r3, #1
 905 0022 B340     		lsl	r3, r3, r6
 906 0024 9946     		mov	r9, r3
 907              	.LVL38:
 654:functions.c   **** 
 655:functions.c   **** 	if( duty && freq )
 908              		.loc 1 655 0
 909 0026 002F     		cmp	r7, #0
 910 0028 00D1     		bne	.LCB752
 911 002a 97E0     		b	.L33	@long jump
 912              	.LCB752:
 913 002c 4246     		mov	r2, r8
 914 002e 002A     		cmp	r2, #0
 915 0030 00D1     		bne	.LCB758
 916 0032 93E0     		b	.L33	@long jump
 917              	.LCB758:
 656:functions.c   **** 	{
 657:functions.c   **** 		// reading ISR clears all bits, bits indicate new channel period has been achieved
 658:functions.c   **** 		status |= AT91C_BASE_PWMC->PWMC_ISR;
 918              		.loc 1 658 0
 919 0034 564B     		ldr	r3, .L43+4
 920              	.LVL39:
 921 0036 D969     		ldr	r1, [r3, #28]
 922 0038 564A     		ldr	r2, .L43+8
 923 003a 1068     		ldr	r0, [r2]
 924 003c 0143     		orr	r1, r0
 925 003e 1160     		str	r1, [r2]
 659:functions.c   **** 
 660:functions.c   **** 		// if not running or frequency change, calculate clock settings
 661:functions.c   **** 		if( !(AT91C_BASE_PWMC->PWMC_SR & channel) || (freqLast[output] != freq) || (dutyLast[output] != d
 926              		.loc 1 661 0
 927 0040 DB68     		ldr	r3, [r3, #12]
 928 0042 4A46     		mov	r2, r9
 929 0044 1342     		tst	r3, r2
 930 0046 08D0     		beq	.L34
 931              		.loc 1 661 0 is_stmt 0 discriminator 1
 932 0048 7200     		lsl	r2, r6, #1
 933 004a 534B     		ldr	r3, .L43+12
 934 004c D35A     		ldrh	r3, [r2, r3]
 935 004e 4345     		cmp	r3, r8
 936 0050 03D1     		bne	.L34
 937 0052 524B     		ldr	r3, .L43+16
 938 0054 9B5D     		ldrb	r3, [r3, r6]
 939 0056 BB42     		cmp	r3, r7
 940 0058 13D0     		beq	.L35
 941              	.L34:
 662:functions.c   **** 		{
 663:functions.c   **** 			// MCK = 47923200Hz
 664:functions.c   **** 			// prescaler x CPRD = MCK / freq
 665:functions.c   **** 			period = MCK / freq;
 942              		.loc 1 665 0 is_stmt 1
 943 005a 5148     		ldr	r0, .L43+20
 944 005c 4146     		mov	r1, r8
 945 005e FFF7FEFF 		bl	__aeabi_idiv
 946              	.LVL40:
 947 0062 8446     		mov	ip, r0
 948              	.LVL41:
 666:functions.c   **** 			mode = (period / 1048576); // 20 bit count max
 949              		.loc 1 666 0
 950 0064 050D     		lsr	r5, r0, #20
 951              	.LVL42:
 667:functions.c   **** 			if( mode )
 952              		.loc 1 667 0
 953 0066 10D0     		beq	.L36
 954 0068 0024     		mov	r4, #0
 955 006a 0121     		mov	r1, #1
 956              	.LVL43:
 957              	.L37:
 668:functions.c   **** 			{
 669:functions.c   **** 				period = 0;
 670:functions.c   **** 				mul = 1;
 671:functions.c   **** 				while( mode )
 672:functions.c   **** 				{
 673:functions.c   **** 					period++;
 958              		.loc 1 673 0
 959 006c 0134     		add	r4, r4, #1
 960              	.LVL44:
 674:functions.c   **** 					mode /= 2;
 961              		.loc 1 674 0
 962 006e 6D08     		lsr	r5, r5, #1
 963              	.LVL45:
 675:functions.c   **** 					mul *= 2;
 964              		.loc 1 675 0
 965 0070 4900     		lsl	r1, r1, #1
 966              	.LVL46:
 671:functions.c   **** 				while( mode )
 967              		.loc 1 671 0
 968 0072 002D     		cmp	r5, #0
 969 0074 FAD1     		bne	.L37
 970              	.LVL47:
 676:functions.c   **** 				}
 677:functions.c   **** 				mode = period; // 2 to the power of period is divider value
 678:functions.c   **** 				period = MCK / freq / mul;
 971              		.loc 1 678 0
 972 0076 6046     		mov	r0, ip
 973 0078 FFF7FEFF 		bl	__aeabi_uidiv
 974              	.LVL48:
 975 007c 8446     		mov	ip, r0
 976              	.LVL49:
 673:functions.c   **** 					period++;
 977              		.loc 1 673 0
 978 007e 251C     		mov	r5, r4
 979 0080 03E0     		b	.L36
 980              	.LVL50:
 981              	.L35:
 679:functions.c   **** 			}
 680:functions.c   **** 			/*mode |= AT91C_PWMC_CPOL;*/ // output starts high if set
 681:functions.c   **** 		}
 682:functions.c   **** 		else
 683:functions.c   **** 		{
 684:functions.c   **** 			status &= ~channel; // clear status for this channel if no change required
 982              		.loc 1 684 0
 983 0082 4B46     		mov	r3, r9
 984 0084 9943     		bic	r1, r3
 985 0086 434B     		ldr	r3, .L43+8
 986 0088 1960     		str	r1, [r3]
 987              	.L36:
 988              	.LVL51:
 685:functions.c   **** 		}
 686:functions.c   **** 
 687:functions.c   **** 		// if PWM not running
 688:functions.c   **** 		if( !(AT91C_BASE_PWMC->PWMC_SR & channel) )
 989              		.loc 1 688 0
 990 008a 414B     		ldr	r3, .L43+4
 991 008c DB68     		ldr	r3, [r3, #12]
 992 008e 4846     		mov	r0, r9
 993 0090 0342     		tst	r3, r0
 994 0092 20D1     		bne	.L38
 995              	.LVL52:
 689:functions.c   **** 		{
 690:functions.c   **** 			freqLast[output] = freq;
 996              		.loc 1 690 0
 997 0094 7200     		lsl	r2, r6, #1
 998 0096 404B     		ldr	r3, .L43+12
 999 0098 4146     		mov	r1, r8
 1000 009a D152     		strh	r1, [r2, r3]
 691:functions.c   **** 			dutyLast[output] = duty;
 1001              		.loc 1 691 0
 1002 009c 3F4B     		ldr	r3, .L43+16
 1003 009e 9F55     		strb	r7, [r3, r6]
 692:functions.c   **** 
 693:functions.c   **** 			// AT91F_PWMC_CfgChannel()
 694:functions.c   **** 			AT91C_BASE_PWMC->PWMC_CH[output].PWMC_CMR = mode;
 1004              		.loc 1 694 0
 1005 00a0 3B4C     		ldr	r4, .L43+4
 1006 00a2 331C     		mov	r3, r6
 1007 00a4 1033     		add	r3, r3, #16
 1008 00a6 5B01     		lsl	r3, r3, #5
 1009 00a8 9846     		mov	r8, r3
 1010 00aa 1D51     		str	r5, [r3, r4]
 695:functions.c   **** 			AT91C_BASE_PWMC->PWMC_CH[output].PWMC_CPRDR = period;
 1011              		.loc 1 695 0
 1012 00ac 7301     		lsl	r3, r6, #5
 1013 00ae 3D4A     		ldr	r2, .L43+24
 1014 00b0 9B18     		add	r3, r3, r2
 1015 00b2 6046     		mov	r0, ip
 1016              	.LVL53:
 1017 00b4 1860     		str	r0, [r3]
 696:functions.c   **** 			AT91C_BASE_PWMC->PWMC_CH[output].PWMC_CDTYR = period * duty / 100;
 1018              		.loc 1 696 0
 1019 00b6 6046     		mov	r0, ip
 1020 00b8 7843     		mul	r0, r7
 1021 00ba 6421     		mov	r1, #100
 1022 00bc FFF7FEFF 		bl	__aeabi_uidiv
 1023              	.LVL54:
 1024 00c0 231C     		mov	r3, r4
 1025 00c2 4344     		add	r3, r3, r8
 1026 00c4 5860     		str	r0, [r3, #4]
 697:functions.c   **** 
 698:functions.c   **** 			// AT91F_PWMC_StartChannel()
 699:functions.c   **** 			AT91C_BASE_PWMC->PWMC_ENA = channel;
 1027              		.loc 1 699 0
 1028 00c6 4A46     		mov	r2, r9
 1029 00c8 6260     		str	r2, [r4, #4]
 700:functions.c   **** 
 701:functions.c   **** 			// disable PIO mode
 702:functions.c   **** #ifndef WINDOWS
 703:functions.c   **** 			AT91F_PIO_Disable( AT91C_BASE_PIOA, portpin[output] );
 1030              		.loc 1 703 0
 1031 00ca B600     		lsl	r6, r6, #2
 1032 00cc 6B46     		mov	r3, sp
 1033 00ce F258     		ldr	r2, [r6, r3]
 1034              	.LVL55:
 1035              	.LBB8:
 1036              	.LBB9:
 1037              		.file 2 "./include/lib_AT91SAM7A3.h"
   1:./include/lib_AT91SAM7A3.h **** //* ----------------------------------------------------------------------------
   2:./include/lib_AT91SAM7A3.h **** //*         ATMEL Microcontroller Software Support  -  ROUSSET  -
   3:./include/lib_AT91SAM7A3.h **** //* ----------------------------------------------------------------------------
   4:./include/lib_AT91SAM7A3.h **** //* DISCLAIMER:  THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
   5:./include/lib_AT91SAM7A3.h **** //* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   6:./include/lib_AT91SAM7A3.h **** //* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
   7:./include/lib_AT91SAM7A3.h **** //* DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
   8:./include/lib_AT91SAM7A3.h **** //* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   9:./include/lib_AT91SAM7A3.h **** //* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  10:./include/lib_AT91SAM7A3.h **** //* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  11:./include/lib_AT91SAM7A3.h **** //* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  12:./include/lib_AT91SAM7A3.h **** //* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  13:./include/lib_AT91SAM7A3.h **** //* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  14:./include/lib_AT91SAM7A3.h **** //* ----------------------------------------------------------------------------
  15:./include/lib_AT91SAM7A3.h **** //* File Name           : lib_AT91SAM7A3.h
  16:./include/lib_AT91SAM7A3.h **** //* Object              : AT91SAM7A3 inlined functions
  17:./include/lib_AT91SAM7A3.h **** //* Generated           : AT91 SW Application Group  01/16/2006 (16:35:45)
  18:./include/lib_AT91SAM7A3.h **** //*
  19:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_MC_SAM.h/1.3/Thu Mar 25 15:19:14 2004//
  20:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_pdc.h/1.2/Tue Jul  2 13:29:40 2002//
  21:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_dbgu.h/1.1/Thu Aug 25 12:56:22 2005//
  22:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_shdwc_6122A.h/1.1/Wed Oct  6 14:06:00 2004//
  23:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_spi2.h/1.2/Tue Aug 23 15:37:28 2005//
  24:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_ssc.h/1.4/Fri Jan 31 12:19:20 2003//
  25:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_PWM_SAM.h/1.3/Thu Jan 22 10:10:50 2004//
  26:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_tc_1753b.h/1.1/Fri Jan 31 12:20:02 2003//
  27:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_pitc_6079A.h/1.2/Tue Nov  9 14:43:56 2004//
  28:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_adc.h/1.6/Fri Oct 17 09:12:38 2003//
  29:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_pmc_SAM.h/1.10/Fri Nov  4 09:39:44 2005//
  30:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_rstc_6098A.h/1.1/Wed Oct  6 10:39:20 2004//
  31:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_pio.h/1.3/Fri Jan 31 12:18:56 2003//
  32:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_rttc_6081A.h/1.1/Wed Oct  6 10:39:38 2004//
  33:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_twi.h/1.3/Mon Jul 19 14:27:58 2004//
  34:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_usart.h/1.5/Thu Nov 21 16:01:54 2002//
  35:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_mci.h/1.7/Wed May 19 09:27:28 2004//
  36:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_wdtc_6080A.h/1.1/Wed Oct  6 10:38:30 2004//
  37:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_udp.h/1.5/Tue Aug 30 12:13:47 2005//
  38:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_aic_6075b.h/1.2/Thu Jul  7 07:48:22 2005//
  39:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_can_AT91.h/1.5/Tue Aug 23 15:37:07 2005//
  40:./include/lib_AT91SAM7A3.h **** //* ----------------------------------------------------------------------------
  41:./include/lib_AT91SAM7A3.h **** 
  42:./include/lib_AT91SAM7A3.h **** #ifndef lib_AT91SAM7A3_H
  43:./include/lib_AT91SAM7A3.h **** #define lib_AT91SAM7A3_H
  44:./include/lib_AT91SAM7A3.h **** 
  45:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
  46:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR AIC
  47:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
  48:./include/lib_AT91SAM7A3.h **** #define AT91C_AIC_BRANCH_OPCODE ((void (*) ()) 0xE51FFF20) // ldr, pc, [pc, #-&F20]
  49:./include/lib_AT91SAM7A3.h **** 
  50:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  51:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_ConfigureIt
  52:./include/lib_AT91SAM7A3.h **** //* \brief Interrupt Handler Initialization
  53:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  54:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_AIC_ConfigureIt (
  55:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,  // \arg pointer to the AIC registers
  56:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id,     // \arg interrupt number to initialize
  57:./include/lib_AT91SAM7A3.h **** 	unsigned int priority,   // \arg priority to give to the interrupt
  58:./include/lib_AT91SAM7A3.h **** 	unsigned int src_type,   // \arg activation and sense of activation
  59:./include/lib_AT91SAM7A3.h **** 	void (*newHandler) () ) // \arg address of the interrupt handler
  60:./include/lib_AT91SAM7A3.h **** {
  61:./include/lib_AT91SAM7A3.h **** 	unsigned int oldHandler;
  62:./include/lib_AT91SAM7A3.h ****     unsigned int mask ;
  63:./include/lib_AT91SAM7A3.h **** 
  64:./include/lib_AT91SAM7A3.h ****     oldHandler = pAic->AIC_SVR[irq_id];
  65:./include/lib_AT91SAM7A3.h **** 
  66:./include/lib_AT91SAM7A3.h ****     mask = 0x1 << irq_id ;
  67:./include/lib_AT91SAM7A3.h ****     //* Disable the interrupt on the interrupt controller
  68:./include/lib_AT91SAM7A3.h ****     pAic->AIC_IDCR = mask ;
  69:./include/lib_AT91SAM7A3.h ****     //* Save the interrupt handler routine pointer and the interrupt priority
  70:./include/lib_AT91SAM7A3.h ****     pAic->AIC_SVR[irq_id] = (unsigned int) newHandler ;
  71:./include/lib_AT91SAM7A3.h ****     //* Store the Source Mode Register
  72:./include/lib_AT91SAM7A3.h ****     pAic->AIC_SMR[irq_id] = src_type | priority  ;
  73:./include/lib_AT91SAM7A3.h ****     //* Clear the interrupt on the interrupt controller
  74:./include/lib_AT91SAM7A3.h ****     pAic->AIC_ICCR = mask ;
  75:./include/lib_AT91SAM7A3.h **** 
  76:./include/lib_AT91SAM7A3.h **** 	return oldHandler;
  77:./include/lib_AT91SAM7A3.h **** }
  78:./include/lib_AT91SAM7A3.h **** 
  79:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  80:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_EnableIt
  81:./include/lib_AT91SAM7A3.h **** //* \brief Enable corresponding IT number
  82:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  83:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_EnableIt (
  84:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
  85:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id ) // \arg interrupt number to initialize
  86:./include/lib_AT91SAM7A3.h **** {
  87:./include/lib_AT91SAM7A3.h ****     //* Enable the interrupt on the interrupt controller
  88:./include/lib_AT91SAM7A3.h ****     pAic->AIC_IECR = 0x1 << irq_id ;
  89:./include/lib_AT91SAM7A3.h **** }
  90:./include/lib_AT91SAM7A3.h **** 
  91:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  92:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_DisableIt
  93:./include/lib_AT91SAM7A3.h **** //* \brief Disable corresponding IT number
  94:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  95:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_DisableIt (
  96:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
  97:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id ) // \arg interrupt number to initialize
  98:./include/lib_AT91SAM7A3.h **** {
  99:./include/lib_AT91SAM7A3.h ****     unsigned int mask = 0x1 << irq_id;
 100:./include/lib_AT91SAM7A3.h ****     //* Disable the interrupt on the interrupt controller
 101:./include/lib_AT91SAM7A3.h ****     pAic->AIC_IDCR = mask ;
 102:./include/lib_AT91SAM7A3.h ****     //* Clear the interrupt on the Interrupt Controller ( if one is pending )
 103:./include/lib_AT91SAM7A3.h ****     pAic->AIC_ICCR = mask ;
 104:./include/lib_AT91SAM7A3.h **** }
 105:./include/lib_AT91SAM7A3.h **** 
 106:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 107:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_ClearIt
 108:./include/lib_AT91SAM7A3.h **** //* \brief Clear corresponding IT number
 109:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 110:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_ClearIt (
 111:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 112:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id) // \arg interrupt number to initialize
 113:./include/lib_AT91SAM7A3.h **** {
 114:./include/lib_AT91SAM7A3.h ****     //* Clear the interrupt on the Interrupt Controller ( if one is pending )
 115:./include/lib_AT91SAM7A3.h ****     pAic->AIC_ICCR = (0x1 << irq_id);
 116:./include/lib_AT91SAM7A3.h **** }
 117:./include/lib_AT91SAM7A3.h **** 
 118:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 119:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_AcknowledgeIt
 120:./include/lib_AT91SAM7A3.h **** //* \brief Acknowledge corresponding IT number
 121:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 122:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_AcknowledgeIt (
 123:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic)     // \arg pointer to the AIC registers
 124:./include/lib_AT91SAM7A3.h **** {
 125:./include/lib_AT91SAM7A3.h ****     pAic->AIC_EOICR = pAic->AIC_EOICR;
 126:./include/lib_AT91SAM7A3.h **** }
 127:./include/lib_AT91SAM7A3.h **** 
 128:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 129:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_SetExceptionVector
 130:./include/lib_AT91SAM7A3.h **** //* \brief Configure vector handler
 131:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 132:./include/lib_AT91SAM7A3.h **** __inline unsigned int  AT91F_AIC_SetExceptionVector (
 133:./include/lib_AT91SAM7A3.h **** 	unsigned int *pVector, // \arg pointer to the AIC registers
 134:./include/lib_AT91SAM7A3.h **** 	void (*Handler) () )   // \arg Interrupt Handler
 135:./include/lib_AT91SAM7A3.h **** {
 136:./include/lib_AT91SAM7A3.h **** 	unsigned int oldVector = *pVector;
 137:./include/lib_AT91SAM7A3.h **** 
 138:./include/lib_AT91SAM7A3.h **** 	if ((unsigned int) Handler == (unsigned int) AT91C_AIC_BRANCH_OPCODE)
 139:./include/lib_AT91SAM7A3.h **** 		*pVector = (unsigned int) AT91C_AIC_BRANCH_OPCODE;
 140:./include/lib_AT91SAM7A3.h **** 	else
 141:./include/lib_AT91SAM7A3.h **** 		*pVector = (((((unsigned int) Handler) - ((unsigned int) pVector) - 0x8) >> 2) & 0x00FFFFFF) | 0x
 142:./include/lib_AT91SAM7A3.h **** 
 143:./include/lib_AT91SAM7A3.h **** 	return oldVector;
 144:./include/lib_AT91SAM7A3.h **** }
 145:./include/lib_AT91SAM7A3.h **** 
 146:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 147:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_Trig
 148:./include/lib_AT91SAM7A3.h **** //* \brief Trig an IT
 149:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 150:./include/lib_AT91SAM7A3.h **** __inline void  AT91F_AIC_Trig (
 151:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 152:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id) // \arg interrupt number
 153:./include/lib_AT91SAM7A3.h **** {
 154:./include/lib_AT91SAM7A3.h **** 	pAic->AIC_ISCR = (0x1 << irq_id) ;
 155:./include/lib_AT91SAM7A3.h **** }
 156:./include/lib_AT91SAM7A3.h **** 
 157:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 158:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_IsActive
 159:./include/lib_AT91SAM7A3.h **** //* \brief Test if an IT is active
 160:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 161:./include/lib_AT91SAM7A3.h **** __inline unsigned int  AT91F_AIC_IsActive (
 162:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 163:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id) // \arg Interrupt Number
 164:./include/lib_AT91SAM7A3.h **** {
 165:./include/lib_AT91SAM7A3.h **** 	return (pAic->AIC_ISR & (0x1 << irq_id));
 166:./include/lib_AT91SAM7A3.h **** }
 167:./include/lib_AT91SAM7A3.h **** 
 168:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 169:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_IsPending
 170:./include/lib_AT91SAM7A3.h **** //* \brief Test if an IT is pending
 171:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 172:./include/lib_AT91SAM7A3.h **** __inline unsigned int  AT91F_AIC_IsPending (
 173:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 174:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id) // \arg Interrupt Number
 175:./include/lib_AT91SAM7A3.h **** {
 176:./include/lib_AT91SAM7A3.h **** 	return (pAic->AIC_IPR & (0x1 << irq_id));
 177:./include/lib_AT91SAM7A3.h **** }
 178:./include/lib_AT91SAM7A3.h **** 
 179:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 180:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_Open
 181:./include/lib_AT91SAM7A3.h **** //* \brief Set exception vectors and AIC registers to default values
 182:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 183:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_Open(
 184:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,        // \arg pointer to the AIC registers
 185:./include/lib_AT91SAM7A3.h **** 	void (*IrqHandler) (),  // \arg Default IRQ vector exception
 186:./include/lib_AT91SAM7A3.h **** 	void (*FiqHandler) (),  // \arg Default FIQ vector exception
 187:./include/lib_AT91SAM7A3.h **** 	void (*DefaultHandler)  (), // \arg Default Handler set in ISR
 188:./include/lib_AT91SAM7A3.h **** 	void (*SpuriousHandler) (), // \arg Default Spurious Handler
 189:./include/lib_AT91SAM7A3.h **** 	unsigned int protectMode)   // \arg Debug Control Register
 190:./include/lib_AT91SAM7A3.h **** {
 191:./include/lib_AT91SAM7A3.h **** 	int i;
 192:./include/lib_AT91SAM7A3.h **** 
 193:./include/lib_AT91SAM7A3.h **** 	// Disable all interrupts and set IVR to the default handler
 194:./include/lib_AT91SAM7A3.h **** 	for (i = 0; i < 32; ++i) {
 195:./include/lib_AT91SAM7A3.h **** 		AT91F_AIC_DisableIt(pAic, i);
 196:./include/lib_AT91SAM7A3.h **** 		AT91F_AIC_ConfigureIt(pAic, i, AT91C_AIC_PRIOR_LOWEST, AT91C_AIC_SRCTYPE_HIGH_LEVEL, DefaultHandl
 197:./include/lib_AT91SAM7A3.h **** 	}
 198:./include/lib_AT91SAM7A3.h **** 
 199:./include/lib_AT91SAM7A3.h **** 	// Set the IRQ exception vector
 200:./include/lib_AT91SAM7A3.h **** 	AT91F_AIC_SetExceptionVector((unsigned int *) 0x18, IrqHandler);
 201:./include/lib_AT91SAM7A3.h **** 	// Set the Fast Interrupt exception vector
 202:./include/lib_AT91SAM7A3.h **** 	AT91F_AIC_SetExceptionVector((unsigned int *) 0x1C, FiqHandler);
 203:./include/lib_AT91SAM7A3.h **** 
 204:./include/lib_AT91SAM7A3.h **** 	pAic->AIC_SPU = (unsigned int) SpuriousHandler;
 205:./include/lib_AT91SAM7A3.h **** 	pAic->AIC_DCR = protectMode;
 206:./include/lib_AT91SAM7A3.h **** }
 207:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
 208:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR PDC
 209:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
 210:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 211:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SetNextRx
 212:./include/lib_AT91SAM7A3.h **** //* \brief Set the next receive transfer descriptor
 213:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 214:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_SetNextRx (
 215:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,     // \arg pointer to a PDC controller
 216:./include/lib_AT91SAM7A3.h **** 	char *address,       // \arg address to the next bloc to be received
 217:./include/lib_AT91SAM7A3.h **** 	unsigned int bytes)  // \arg number of bytes to be received
 218:./include/lib_AT91SAM7A3.h **** {
 219:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RNPR = (unsigned int) address;
 220:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RNCR = bytes;
 221:./include/lib_AT91SAM7A3.h **** }
 222:./include/lib_AT91SAM7A3.h **** 
 223:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 224:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SetNextTx
 225:./include/lib_AT91SAM7A3.h **** //* \brief Set the next transmit transfer descriptor
 226:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 227:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_SetNextTx (
 228:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
 229:./include/lib_AT91SAM7A3.h **** 	char *address,         // \arg address to the next bloc to be transmitted
 230:./include/lib_AT91SAM7A3.h **** 	unsigned int bytes)    // \arg number of bytes to be transmitted
 231:./include/lib_AT91SAM7A3.h **** {
 232:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TNPR = (unsigned int) address;
 233:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TNCR = bytes;
 234:./include/lib_AT91SAM7A3.h **** }
 235:./include/lib_AT91SAM7A3.h **** 
 236:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 237:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SetRx
 238:./include/lib_AT91SAM7A3.h **** //* \brief Set the receive transfer descriptor
 239:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 240:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_SetRx (
 241:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
 242:./include/lib_AT91SAM7A3.h **** 	char *address,         // \arg address to the next bloc to be received
 243:./include/lib_AT91SAM7A3.h **** 	unsigned int bytes)    // \arg number of bytes to be received
 244:./include/lib_AT91SAM7A3.h **** {
 245:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RPR = (unsigned int) address;
 246:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RCR = bytes;
 247:./include/lib_AT91SAM7A3.h **** }
 248:./include/lib_AT91SAM7A3.h **** 
 249:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 250:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SetTx
 251:./include/lib_AT91SAM7A3.h **** //* \brief Set the transmit transfer descriptor
 252:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 253:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_SetTx (
 254:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
 255:./include/lib_AT91SAM7A3.h **** 	char *address,         // \arg address to the next bloc to be transmitted
 256:./include/lib_AT91SAM7A3.h **** 	unsigned int bytes)    // \arg number of bytes to be transmitted
 257:./include/lib_AT91SAM7A3.h **** {
 258:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TPR = (unsigned int) address;
 259:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TCR = bytes;
 260:./include/lib_AT91SAM7A3.h **** }
 261:./include/lib_AT91SAM7A3.h **** 
 262:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 263:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_EnableTx
 264:./include/lib_AT91SAM7A3.h **** //* \brief Enable transmit
 265:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 266:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_EnableTx (
 267:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 268:./include/lib_AT91SAM7A3.h **** {
 269:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_PTCR = AT91C_PDC_TXTEN;
 270:./include/lib_AT91SAM7A3.h **** }
 271:./include/lib_AT91SAM7A3.h **** 
 272:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 273:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_EnableRx
 274:./include/lib_AT91SAM7A3.h **** //* \brief Enable receive
 275:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 276:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_EnableRx (
 277:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 278:./include/lib_AT91SAM7A3.h **** {
 279:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_PTCR = AT91C_PDC_RXTEN;
 280:./include/lib_AT91SAM7A3.h **** }
 281:./include/lib_AT91SAM7A3.h **** 
 282:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 283:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_DisableTx
 284:./include/lib_AT91SAM7A3.h **** //* \brief Disable transmit
 285:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 286:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_DisableTx (
 287:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 288:./include/lib_AT91SAM7A3.h **** {
 289:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_PTCR = AT91C_PDC_TXTDIS;
 290:./include/lib_AT91SAM7A3.h **** }
 291:./include/lib_AT91SAM7A3.h **** 
 292:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 293:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_DisableRx
 294:./include/lib_AT91SAM7A3.h **** //* \brief Disable receive
 295:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 296:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_DisableRx (
 297:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 298:./include/lib_AT91SAM7A3.h **** {
 299:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_PTCR = AT91C_PDC_RXTDIS;
 300:./include/lib_AT91SAM7A3.h **** }
 301:./include/lib_AT91SAM7A3.h **** 
 302:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 303:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_IsTxEmpty
 304:./include/lib_AT91SAM7A3.h **** //* \brief Test if the current transfer descriptor has been sent
 305:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 306:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PDC_IsTxEmpty ( // \return return 1 if transfer is complete
 307:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 308:./include/lib_AT91SAM7A3.h **** {
 309:./include/lib_AT91SAM7A3.h **** 	return !(pPDC->PDC_TCR);
 310:./include/lib_AT91SAM7A3.h **** }
 311:./include/lib_AT91SAM7A3.h **** 
 312:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 313:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_IsNextTxEmpty
 314:./include/lib_AT91SAM7A3.h **** //* \brief Test if the next transfer descriptor has been moved to the current td
 315:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 316:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PDC_IsNextTxEmpty ( // \return return 1 if transfer is complete
 317:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 318:./include/lib_AT91SAM7A3.h **** {
 319:./include/lib_AT91SAM7A3.h **** 	return !(pPDC->PDC_TNCR);
 320:./include/lib_AT91SAM7A3.h **** }
 321:./include/lib_AT91SAM7A3.h **** 
 322:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 323:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_IsRxEmpty
 324:./include/lib_AT91SAM7A3.h **** //* \brief Test if the current transfer descriptor has been filled
 325:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 326:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PDC_IsRxEmpty ( // \return return 1 if transfer is complete
 327:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 328:./include/lib_AT91SAM7A3.h **** {
 329:./include/lib_AT91SAM7A3.h **** 	return !(pPDC->PDC_RCR);
 330:./include/lib_AT91SAM7A3.h **** }
 331:./include/lib_AT91SAM7A3.h **** 
 332:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 333:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_IsNextRxEmpty
 334:./include/lib_AT91SAM7A3.h **** //* \brief Test if the next transfer descriptor has been moved to the current td
 335:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 336:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PDC_IsNextRxEmpty ( // \return return 1 if transfer is complete
 337:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 338:./include/lib_AT91SAM7A3.h **** {
 339:./include/lib_AT91SAM7A3.h **** 	return !(pPDC->PDC_RNCR);
 340:./include/lib_AT91SAM7A3.h **** }
 341:./include/lib_AT91SAM7A3.h **** 
 342:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 343:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_Open
 344:./include/lib_AT91SAM7A3.h **** //* \brief Open PDC: disable TX and RX reset transfer descriptors, re-enable RX and TX
 345:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 346:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_Open (
 347:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
 348:./include/lib_AT91SAM7A3.h **** {
 349:./include/lib_AT91SAM7A3.h ****     //* Disable the RX and TX PDC transfer requests
 350:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_DisableRx(pPDC);
 351:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_DisableTx(pPDC);
 352:./include/lib_AT91SAM7A3.h **** 
 353:./include/lib_AT91SAM7A3.h **** 	//* Reset all Counter register Next buffer first
 354:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
 355:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
 356:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
 357:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
 358:./include/lib_AT91SAM7A3.h **** 
 359:./include/lib_AT91SAM7A3.h ****     //* Enable the RX and TX PDC transfer requests
 360:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_EnableRx(pPDC);
 361:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_EnableTx(pPDC);
 362:./include/lib_AT91SAM7A3.h **** }
 363:./include/lib_AT91SAM7A3.h **** 
 364:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 365:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_Close
 366:./include/lib_AT91SAM7A3.h **** //* \brief Close PDC: disable TX and RX reset transfer descriptors
 367:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 368:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_Close (
 369:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
 370:./include/lib_AT91SAM7A3.h **** {
 371:./include/lib_AT91SAM7A3.h ****     //* Disable the RX and TX PDC transfer requests
 372:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_DisableRx(pPDC);
 373:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_DisableTx(pPDC);
 374:./include/lib_AT91SAM7A3.h **** 
 375:./include/lib_AT91SAM7A3.h **** 	//* Reset all Counter register Next buffer first
 376:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
 377:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
 378:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
 379:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
 380:./include/lib_AT91SAM7A3.h **** 
 381:./include/lib_AT91SAM7A3.h **** }
 382:./include/lib_AT91SAM7A3.h **** 
 383:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 384:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SendFrame
 385:./include/lib_AT91SAM7A3.h **** //* \brief Close PDC: disable TX and RX reset transfer descriptors
 386:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 387:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PDC_SendFrame(
 388:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,
 389:./include/lib_AT91SAM7A3.h **** 	char *pBuffer,
 390:./include/lib_AT91SAM7A3.h **** 	unsigned int szBuffer,
 391:./include/lib_AT91SAM7A3.h **** 	char *pNextBuffer,
 392:./include/lib_AT91SAM7A3.h **** 	unsigned int szNextBuffer )
 393:./include/lib_AT91SAM7A3.h **** {
 394:./include/lib_AT91SAM7A3.h **** 	if (AT91F_PDC_IsTxEmpty(pPDC)) {
 395:./include/lib_AT91SAM7A3.h **** 		//* Buffer and next buffer can be initialized
 396:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetTx(pPDC, pBuffer, szBuffer);
 397:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetNextTx(pPDC, pNextBuffer, szNextBuffer);
 398:./include/lib_AT91SAM7A3.h **** 		return 2;
 399:./include/lib_AT91SAM7A3.h **** 	}
 400:./include/lib_AT91SAM7A3.h **** 	else if (AT91F_PDC_IsNextTxEmpty(pPDC)) {
 401:./include/lib_AT91SAM7A3.h **** 		//* Only one buffer can be initialized
 402:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetNextTx(pPDC, pBuffer, szBuffer);
 403:./include/lib_AT91SAM7A3.h **** 		return 1;
 404:./include/lib_AT91SAM7A3.h **** 	}
 405:./include/lib_AT91SAM7A3.h **** 	else {
 406:./include/lib_AT91SAM7A3.h **** 		//* All buffer are in use...
 407:./include/lib_AT91SAM7A3.h **** 		return 0;
 408:./include/lib_AT91SAM7A3.h **** 	}
 409:./include/lib_AT91SAM7A3.h **** }
 410:./include/lib_AT91SAM7A3.h **** 
 411:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 412:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_ReceiveFrame
 413:./include/lib_AT91SAM7A3.h **** //* \brief Close PDC: disable TX and RX reset transfer descriptors
 414:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 415:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PDC_ReceiveFrame (
 416:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,
 417:./include/lib_AT91SAM7A3.h **** 	char *pBuffer,
 418:./include/lib_AT91SAM7A3.h **** 	unsigned int szBuffer,
 419:./include/lib_AT91SAM7A3.h **** 	char *pNextBuffer,
 420:./include/lib_AT91SAM7A3.h **** 	unsigned int szNextBuffer )
 421:./include/lib_AT91SAM7A3.h **** {
 422:./include/lib_AT91SAM7A3.h **** 	if (AT91F_PDC_IsRxEmpty(pPDC)) {
 423:./include/lib_AT91SAM7A3.h **** 		//* Buffer and next buffer can be initialized
 424:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetRx(pPDC, pBuffer, szBuffer);
 425:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetNextRx(pPDC, pNextBuffer, szNextBuffer);
 426:./include/lib_AT91SAM7A3.h **** 		return 2;
 427:./include/lib_AT91SAM7A3.h **** 	}
 428:./include/lib_AT91SAM7A3.h **** 	else if (AT91F_PDC_IsNextRxEmpty(pPDC)) {
 429:./include/lib_AT91SAM7A3.h **** 		//* Only one buffer can be initialized
 430:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetNextRx(pPDC, pBuffer, szBuffer);
 431:./include/lib_AT91SAM7A3.h **** 		return 1;
 432:./include/lib_AT91SAM7A3.h **** 	}
 433:./include/lib_AT91SAM7A3.h **** 	else {
 434:./include/lib_AT91SAM7A3.h **** 		//* All buffer are in use...
 435:./include/lib_AT91SAM7A3.h **** 		return 0;
 436:./include/lib_AT91SAM7A3.h **** 	}
 437:./include/lib_AT91SAM7A3.h **** }
 438:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
 439:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR DBGU
 440:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
 441:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 442:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_DBGU_InterruptEnable
 443:./include/lib_AT91SAM7A3.h **** //* \brief Enable DBGU Interrupt
 444:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 445:./include/lib_AT91SAM7A3.h **** __inline void AT91F_DBGU_InterruptEnable(
 446:./include/lib_AT91SAM7A3.h ****         AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
 447:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  dbgu interrupt to be enabled
 448:./include/lib_AT91SAM7A3.h **** {
 449:./include/lib_AT91SAM7A3.h ****         pDbgu->DBGU_IER = flag;
 450:./include/lib_AT91SAM7A3.h **** }
 451:./include/lib_AT91SAM7A3.h **** 
 452:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 453:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_DBGU_InterruptDisable
 454:./include/lib_AT91SAM7A3.h **** //* \brief Disable DBGU Interrupt
 455:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 456:./include/lib_AT91SAM7A3.h **** __inline void AT91F_DBGU_InterruptDisable(
 457:./include/lib_AT91SAM7A3.h ****         AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
 458:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  dbgu interrupt to be disabled
 459:./include/lib_AT91SAM7A3.h **** {
 460:./include/lib_AT91SAM7A3.h ****         pDbgu->DBGU_IDR = flag;
 461:./include/lib_AT91SAM7A3.h **** }
 462:./include/lib_AT91SAM7A3.h **** 
 463:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 464:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_DBGU_GetInterruptMaskStatus
 465:./include/lib_AT91SAM7A3.h **** //* \brief Return DBGU Interrupt Mask Status
 466:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 467:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_DBGU_GetInterruptMaskStatus( // \return DBGU Interrupt Mask Status
 468:./include/lib_AT91SAM7A3.h ****         AT91PS_DBGU pDbgu) // \arg  pointer to a DBGU controller
 469:./include/lib_AT91SAM7A3.h **** {
 470:./include/lib_AT91SAM7A3.h ****         return pDbgu->DBGU_IMR;
 471:./include/lib_AT91SAM7A3.h **** }
 472:./include/lib_AT91SAM7A3.h **** 
 473:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 474:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_DBGU_IsInterruptMasked
 475:./include/lib_AT91SAM7A3.h **** //* \brief Test if DBGU Interrupt is Masked 
 476:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 477:./include/lib_AT91SAM7A3.h **** __inline int AT91F_DBGU_IsInterruptMasked(
 478:./include/lib_AT91SAM7A3.h ****         AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
 479:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 480:./include/lib_AT91SAM7A3.h **** {
 481:./include/lib_AT91SAM7A3.h ****         return (AT91F_DBGU_GetInterruptMaskStatus(pDbgu) & flag);
 482:./include/lib_AT91SAM7A3.h **** }
 483:./include/lib_AT91SAM7A3.h **** 
 484:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
 485:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR PIO
 486:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
 487:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 488:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgPeriph
 489:./include/lib_AT91SAM7A3.h **** //* \brief Enable pins to be drived by peripheral
 490:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 491:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgPeriph(
 492:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 493:./include/lib_AT91SAM7A3.h **** 	unsigned int periphAEnable,  // \arg PERIPH A to enable
 494:./include/lib_AT91SAM7A3.h **** 	unsigned int periphBEnable)  // \arg PERIPH B to enable
 495:./include/lib_AT91SAM7A3.h **** 
 496:./include/lib_AT91SAM7A3.h **** {
 497:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_ASR = periphAEnable;
 498:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_BSR = periphBEnable;
 499:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PDR = (periphAEnable | periphBEnable); // Set in Periph mode
 500:./include/lib_AT91SAM7A3.h **** }
 501:./include/lib_AT91SAM7A3.h **** 
 502:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 503:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgOutput
 504:./include/lib_AT91SAM7A3.h **** //* \brief Enable PIO in output mode
 505:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 506:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgOutput(
 507:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 508:./include/lib_AT91SAM7A3.h **** 	unsigned int pioEnable)      // \arg PIO to be enabled
 509:./include/lib_AT91SAM7A3.h **** {
 510:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PER = pioEnable; // Set in PIO mode
 511:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_OER = pioEnable; // Configure in Output
 512:./include/lib_AT91SAM7A3.h **** }
 513:./include/lib_AT91SAM7A3.h **** 
 514:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 515:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgInput
 516:./include/lib_AT91SAM7A3.h **** //* \brief Enable PIO in input mode
 517:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 518:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgInput(
 519:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 520:./include/lib_AT91SAM7A3.h **** 	unsigned int inputEnable)      // \arg PIO to be enabled
 521:./include/lib_AT91SAM7A3.h **** {
 522:./include/lib_AT91SAM7A3.h **** 	// Disable output
 523:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_ODR  = inputEnable;
 524:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PER  = inputEnable;
 525:./include/lib_AT91SAM7A3.h **** }
 526:./include/lib_AT91SAM7A3.h **** 
 527:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 528:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgOpendrain
 529:./include/lib_AT91SAM7A3.h **** //* \brief Configure PIO in open drain
 530:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 531:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgOpendrain(
 532:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 533:./include/lib_AT91SAM7A3.h **** 	unsigned int multiDrvEnable) // \arg pio to be configured in open drain
 534:./include/lib_AT91SAM7A3.h **** {
 535:./include/lib_AT91SAM7A3.h **** 	// Configure the multi-drive option
 536:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_MDDR = ~multiDrvEnable;
 537:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_MDER = multiDrvEnable;
 538:./include/lib_AT91SAM7A3.h **** }
 539:./include/lib_AT91SAM7A3.h **** 
 540:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 541:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgPullup
 542:./include/lib_AT91SAM7A3.h **** //* \brief Enable pullup on PIO
 543:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 544:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgPullup(
 545:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 546:./include/lib_AT91SAM7A3.h **** 	unsigned int pullupEnable)   // \arg enable pullup on PIO
 547:./include/lib_AT91SAM7A3.h **** {
 548:./include/lib_AT91SAM7A3.h **** 		// Connect or not Pullup
 549:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PPUDR = ~pullupEnable;
 550:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PPUER = pullupEnable;
 551:./include/lib_AT91SAM7A3.h **** }
 552:./include/lib_AT91SAM7A3.h **** 
 553:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 554:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgDirectDrive
 555:./include/lib_AT91SAM7A3.h **** //* \brief Enable direct drive on PIO
 556:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 557:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgDirectDrive(
 558:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 559:./include/lib_AT91SAM7A3.h **** 	unsigned int directDrive)    // \arg PIO to be configured with direct drive
 560:./include/lib_AT91SAM7A3.h **** 
 561:./include/lib_AT91SAM7A3.h **** {
 562:./include/lib_AT91SAM7A3.h **** 	// Configure the Direct Drive
 563:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_OWDR  = ~directDrive;
 564:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_OWER  = directDrive;
 565:./include/lib_AT91SAM7A3.h **** }
 566:./include/lib_AT91SAM7A3.h **** 
 567:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 568:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgInputFilter
 569:./include/lib_AT91SAM7A3.h **** //* \brief Enable input filter on input PIO
 570:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 571:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgInputFilter(
 572:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 573:./include/lib_AT91SAM7A3.h **** 	unsigned int inputFilter)    // \arg PIO to be configured with input filter
 574:./include/lib_AT91SAM7A3.h **** 
 575:./include/lib_AT91SAM7A3.h **** {
 576:./include/lib_AT91SAM7A3.h **** 	// Configure the Direct Drive
 577:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_IFDR  = ~inputFilter;
 578:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_IFER  = inputFilter;
 579:./include/lib_AT91SAM7A3.h **** }
 580:./include/lib_AT91SAM7A3.h **** 
 581:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 582:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetInput
 583:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO input value
 584:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 585:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetInput( // \return PIO input
 586:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 587:./include/lib_AT91SAM7A3.h **** {
 588:./include/lib_AT91SAM7A3.h **** 	return pPio->PIO_PDSR;
 589:./include/lib_AT91SAM7A3.h **** }
 590:./include/lib_AT91SAM7A3.h **** 
 591:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 592:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsInputSet
 593:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO is input flag is active
 594:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 595:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsInputSet(
 596:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 597:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // \arg  flag to be tested
 598:./include/lib_AT91SAM7A3.h **** {
 599:./include/lib_AT91SAM7A3.h **** 	return (AT91F_PIO_GetInput(pPio) & flag);
 600:./include/lib_AT91SAM7A3.h **** }
 601:./include/lib_AT91SAM7A3.h **** 
 602:./include/lib_AT91SAM7A3.h **** 
 603:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 604:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_SetOutput
 605:./include/lib_AT91SAM7A3.h **** //* \brief Set to 1 output PIO
 606:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 607:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_SetOutput(
 608:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 609:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // \arg  output to be set
 610:./include/lib_AT91SAM7A3.h **** {
 611:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_SODR = flag;
 612:./include/lib_AT91SAM7A3.h **** }
 613:./include/lib_AT91SAM7A3.h **** 
 614:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 615:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_ClearOutput
 616:./include/lib_AT91SAM7A3.h **** //* \brief Set to 0 output PIO
 617:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 618:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_ClearOutput(
 619:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 620:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // \arg  output to be cleared
 621:./include/lib_AT91SAM7A3.h **** {
 622:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_CODR = flag;
 623:./include/lib_AT91SAM7A3.h **** }
 624:./include/lib_AT91SAM7A3.h **** 
 625:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 626:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_ForceOutput
 627:./include/lib_AT91SAM7A3.h **** //* \brief Force output when Direct drive option is enabled
 628:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 629:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_ForceOutput(
 630:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 631:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // \arg  output to be forced
 632:./include/lib_AT91SAM7A3.h **** {
 633:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_ODSR = flag;
 634:./include/lib_AT91SAM7A3.h **** }
 635:./include/lib_AT91SAM7A3.h **** 
 636:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 637:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_Enable
 638:./include/lib_AT91SAM7A3.h **** //* \brief Enable PIO
 639:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 640:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_Enable(
 641:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 642:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio to be enabled 
 643:./include/lib_AT91SAM7A3.h **** {
 644:./include/lib_AT91SAM7A3.h ****         pPio->PIO_PER = flag;
 645:./include/lib_AT91SAM7A3.h **** }
 646:./include/lib_AT91SAM7A3.h **** 
 647:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 648:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_Disable
 649:./include/lib_AT91SAM7A3.h **** //* \brief Disable PIO
 650:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 651:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_Disable(
 652:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 653:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio to be disabled 
 654:./include/lib_AT91SAM7A3.h **** {
 655:./include/lib_AT91SAM7A3.h ****         pPio->PIO_PDR = flag;
 1038              		.loc 2 655 0
 1039 00d0 354B     		ldr	r3, .L43+28
 1040 00d2 5A60     		str	r2, [r3, #4]
 1041 00d4 53E0     		b	.L32
 1042              	.LVL56:
 1043              	.L38:
 1044              	.LBE9:
 1045              	.LBE8:
 704:functions.c   **** #endif
 705:functions.c   **** 		}
 706:functions.c   **** 		// channel count must be > 1, else if 0 or 1 CUPDR changes CPRDR/CDTYR directly (see Errata)
 707:functions.c   **** 		else if( (status & channel) && (AT91C_BASE_PWMC->PWMC_CH[output].PWMC_CCNTR > 1) )
 1046              		.loc 1 707 0
 1047 00d6 2F4B     		ldr	r3, .L43+8
 1048 00d8 1B68     		ldr	r3, [r3]
 1049 00da 4846     		mov	r0, r9
 1050              	.LVL57:
 1051 00dc 0342     		tst	r3, r0
 1052 00de 4ED0     		beq	.L32
 1053              	.LVL58:
 1054              		.loc 1 707 0 is_stmt 0 discriminator 1
 1055 00e0 7201     		lsl	r2, r6, #5
 1056 00e2 3049     		ldr	r1, .L43+24
 1057 00e4 5218     		add	r2, r2, r1
 1058 00e6 5268     		ldr	r2, [r2, #4]
 1059 00e8 012A     		cmp	r2, #1
 1060 00ea 48D9     		bls	.L32
 708:functions.c   **** 		{
 709:functions.c   **** 			// if frequency changed then both period and duty will need updating
 710:functions.c   **** 			// if period > current duty, set new period - else set new duty first
 711:functions.c   **** 			if( (freqLast[output] != freq) && (period > AT91C_BASE_PWMC->PWMC_CH[output].PWMC_CDTYR) )
 1061              		.loc 1 711 0 is_stmt 1
 1062 00ec 7100     		lsl	r1, r6, #1
 1063 00ee 2A4A     		ldr	r2, .L43+12
 1064 00f0 8A5A     		ldrh	r2, [r1, r2]
 1065 00f2 4245     		cmp	r2, r8
 1066 00f4 3FD0     		beq	.L40
 1067              		.loc 1 711 0 is_stmt 0 discriminator 1
 1068 00f6 7201     		lsl	r2, r6, #5
 1069 00f8 2C48     		ldr	r0, .L43+32
 1070              	.LVL59:
 1071 00fa 1218     		add	r2, r2, r0
 1072 00fc 5268     		ldr	r2, [r2, #4]
 1073 00fe 9445     		cmp	ip, r2
 1074 0100 17D9     		bls	.L41
 712:functions.c   **** 			{
 713:functions.c   **** 				freqLast[output] = freq;
 1075              		.loc 1 713 0 is_stmt 1
 1076 0102 254A     		ldr	r2, .L43+12
 1077 0104 4046     		mov	r0, r8
 1078 0106 8852     		strh	r0, [r1, r2]
 714:functions.c   **** 				dutyLast[output] = 0; // force duty to updated next time
 1079              		.loc 1 714 0
 1080 0108 0021     		mov	r1, #0
 1081 010a 244A     		ldr	r2, .L43+16
 1082 010c 9155     		strb	r1, [r2, r6]
 715:functions.c   **** 				status &= ~channel;
 1083              		.loc 1 715 0
 1084 010e 4946     		mov	r1, r9
 1085 0110 8B43     		bic	r3, r1
 1086 0112 204A     		ldr	r2, .L43+8
 1087 0114 1360     		str	r3, [r2]
 716:functions.c   **** 				// set to update period
 717:functions.c   **** 				AT91C_BASE_PWMC->PWMC_CH[output].PWMC_CMR = mode | AT91C_PWMC_CPD;
 1088              		.loc 1 717 0
 1089 0116 8023     		mov	r3, #128
 1090 0118 DB00     		lsl	r3, r3, #3
 1091 011a 1D43     		orr	r5, r3
 1092              	.LVL60:
 1093 011c 321C     		mov	r2, r6
 1094 011e 1032     		add	r2, r2, #16
 1095 0120 5201     		lsl	r2, r2, #5
 1096 0122 1B4B     		ldr	r3, .L43+4
 1097 0124 D550     		str	r5, [r2, r3]
 718:functions.c   **** 				// set update register for duty
 719:functions.c   **** 				AT91C_BASE_PWMC->PWMC_CH[output].PWMC_CUPDR = period;
 1098              		.loc 1 719 0
 1099 0126 7601     		lsl	r6, r6, #5
 1100 0128 214A     		ldr	r2, .L43+36
 1101 012a B618     		add	r6, r6, r2
 1102 012c 6346     		mov	r3, ip
 1103 012e 3360     		str	r3, [r6]
 1104 0130 25E0     		b	.L32
 1105              	.LVL61:
 1106              	.L41:
 720:functions.c   **** 			}
 721:functions.c   **** 			// if duty or frequency changed, duty needs updating
 722:functions.c   **** 			else if( (dutyLast[output] != duty) || (freqLast[output] != freq) )
 723:functions.c   **** 			{
 724:functions.c   **** 				dutyLast[output] = duty;
 1107              		.loc 1 724 0
 1108 0132 1A4A     		ldr	r2, .L43+16
 1109 0134 9755     		strb	r7, [r2, r6]
 725:functions.c   **** 				status &= ~channel;
 1110              		.loc 1 725 0
 1111 0136 4846     		mov	r0, r9
 1112 0138 8343     		bic	r3, r0
 1113 013a 164A     		ldr	r2, .L43+8
 1114 013c 1360     		str	r3, [r2]
 726:functions.c   **** 				// set to update duty
 727:functions.c   **** 				AT91C_BASE_PWMC->PWMC_CH[output].PWMC_CMR = mode;
 1115              		.loc 1 727 0
 1116 013e 321C     		mov	r2, r6
 1117 0140 1032     		add	r2, r2, #16
 1118 0142 5201     		lsl	r2, r2, #5
 1119 0144 124B     		ldr	r3, .L43+4
 1120 0146 D550     		str	r5, [r2, r3]
 728:functions.c   **** 				// set update register for duty
 729:functions.c   **** 				AT91C_BASE_PWMC->PWMC_CH[output].PWMC_CUPDR = period * duty / 100;
 1121              		.loc 1 729 0
 1122 0148 6046     		mov	r0, ip
 1123 014a 7843     		mul	r0, r7
 1124 014c 6421     		mov	r1, #100
 1125 014e FFF7FEFF 		bl	__aeabi_uidiv
 1126              	.LVL62:
 1127 0152 7601     		lsl	r6, r6, #5
 1128 0154 1649     		ldr	r1, .L43+36
 1129 0156 7618     		add	r6, r6, r1
 1130 0158 3060     		str	r0, [r6]
 1131 015a 10E0     		b	.L32
 1132              	.LVL63:
 1133              	.L33:
 730:functions.c   **** 			}
 731:functions.c   **** 		}
 732:functions.c   **** 	}
 733:functions.c   **** 	else
 734:functions.c   **** 	{
 735:functions.c   **** #ifndef WINDOWS
 736:functions.c   **** 		// turn off output
 737:functions.c   **** 		AT91F_PIO_CfgOutput( AT91C_BASE_PIOA, portpin[output] );
 1134              		.loc 1 737 0
 1135 015c B600     		lsl	r6, r6, #2
 1136 015e 6B46     		mov	r3, sp
 1137              	.LVL64:
 1138 0160 F258     		ldr	r2, [r6, r3]
 1139              	.LVL65:
 1140              	.LBB10:
 1141              	.LBB11:
 510:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PER = pioEnable; // Set in PIO mode
 1142              		.loc 2 510 0
 1143 0162 114B     		ldr	r3, .L43+28
 1144 0164 1A60     		str	r2, [r3]
 511:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_OER = pioEnable; // Configure in Output
 1145              		.loc 2 511 0
 1146 0166 1A61     		str	r2, [r3, #16]
 1147              	.LBE11:
 1148              	.LBE10:
 738:functions.c   **** 		AT91F_PIO_SetOutput( AT91C_BASE_PIOA, portpin[output] );
 1149              		.loc 1 738 0
 1150 0168 6846     		mov	r0, sp
 1151 016a 3258     		ldr	r2, [r6, r0]
 1152              	.LVL66:
 1153              	.LBB12:
 1154              	.LBB13:
 611:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_SODR = flag;
 1155              		.loc 2 611 0
 1156 016c 1A63     		str	r2, [r3, #48]
 1157              	.LBE13:
 1158              	.LBE12:
 739:functions.c   **** #endif
 740:functions.c   **** 		// Stop PWM
 741:functions.c   **** 		AT91C_BASE_PWMC->PWMC_DIS = channel;
 1159              		.loc 1 741 0
 1160 016e 084B     		ldr	r3, .L43+4
 1161              	.LVL67:
 1162 0170 4946     		mov	r1, r9
 1163 0172 9960     		str	r1, [r3, #8]
 1164 0174 03E0     		b	.L32
 1165              	.LVL68:
 1166              	.L40:
 722:functions.c   **** 			else if( (dutyLast[output] != duty) || (freqLast[output] != freq) )
 1167              		.loc 1 722 0
 1168 0176 094A     		ldr	r2, .L43+16
 1169 0178 925D     		ldrb	r2, [r2, r6]
 1170 017a BA42     		cmp	r2, r7
 1171 017c D9D1     		bne	.L41
 1172              	.LVL69:
 1173              	.L32:
 742:functions.c   **** 	}
 743:functions.c   **** 
 744:functions.c   **** }
 1174              		.loc 1 744 0
 1175 017e 09B0     		add	sp, sp, #36
 1176              		@ sp needed for prologue
 1177              	.LVL70:
 1178 0180 0CBC     		pop	{r2, r3}
 1179 0182 9046     		mov	r8, r2
 1180 0184 9946     		mov	r9, r3
 1181 0186 F0BC     		pop	{r4, r5, r6, r7}
 1182 0188 01BC     		pop	{r0}
 1183 018a 0047     		bx	r0
 1184              	.L44:
 1185              		.align	2
 1186              	.L43:
 1187 018c 00000000 		.word	.LANCHOR11
 1188 0190 00C0FCFF 		.word	-212992
 1189 0194 00000000 		.word	.LANCHOR12
 1190 0198 00000000 		.word	.LANCHOR13
 1191 019c 00000000 		.word	.LANCHOR14
 1192 01a0 0040DB02 		.word	47923200
 1193 01a4 08C2FCFF 		.word	-212472
 1194 01a8 00F4FFFF 		.word	-3072
 1195 01ac 00C2FCFF 		.word	-212480
 1196 01b0 10C2FCFF 		.word	-212464
 1197              		.cfi_endproc
 1198              	.LFE383:
 1200              		.section	.text.ResetLubeCount,"ax",%progbits
 1201              		.align	2
 1202              		.global	ResetLubeCount
 1203              		.code	16
 1204              		.thumb_func
 1206              	ResetLubeCount:
 1207              	.LFB384:
 745:functions.c   **** // -----------------------------------------------------------
 746:functions.c   **** 
 747:functions.c   **** 
 748:functions.c   **** // -----------------------------------------------------------
 749:functions.c   **** // Function Name       : ResetLubeCount
 750:functions.c   **** // -----------------------------------------------------------
 751:functions.c   **** void ResetLubeCount( void )
 752:functions.c   **** {
 1208              		.loc 1 752 0
 1209              		.cfi_startproc
 1210 0000 00B5     		push	{lr}
 1211              	.LCFI11:
 1212              		.cfi_def_cfa_offset 4
 1213              		.cfi_offset 14, -4
 753:functions.c   **** 
 754:functions.c   **** 	if( pRun.pr.LubeCounter < 0 )
 1214              		.loc 1 754 0
 1215 0002 094B     		ldr	r3, .L48
 1216 0004 DA8C     		ldrh	r2, [r3, #38]
 1217 0006 1304     		lsl	r3, r2, #16
 1218 0008 1B14     		asr	r3, r3, #16
 1219 000a 06D5     		bpl	.L46
 755:functions.c   **** 	{
 756:functions.c   **** 		pRun.pr.LubeCounter += pFac.pf.GW302_LubeAlarm; // Reset to Lube Alarm (in bales) minus the numbe
 1220              		.loc 1 756 0
 1221 000c 7E23     		mov	r3, #126
 1222 000e 0749     		ldr	r1, .L48+4
 1223 0010 CB5A     		ldrh	r3, [r1, r3]
 1224 0012 D218     		add	r2, r2, r3
 1225 0014 044B     		ldr	r3, .L48
 1226 0016 DA84     		strh	r2, [r3, #38]
 1227 0018 04E0     		b	.L45
 1228              	.L46:
 757:functions.c   **** 	}
 758:functions.c   **** 	else // No extra bales since alarm first appeared
 759:functions.c   **** 	{
 760:functions.c   **** 		pRun.pr.LubeCounter = pFac.pf.GW302_LubeAlarm; // Reset to Lube Alarm (in bales)
 1229              		.loc 1 760 0
 1230 001a 7E23     		mov	r3, #126
 1231 001c 034A     		ldr	r2, .L48+4
 1232 001e D25A     		ldrh	r2, [r2, r3]
 1233 0020 014B     		ldr	r3, .L48
 1234 0022 DA84     		strh	r2, [r3, #38]
 1235              	.L45:
 761:functions.c   **** 	}
 762:functions.c   **** 
 763:functions.c   **** }
 1236              		.loc 1 763 0
 1237              		@ sp needed for prologue
 1238 0024 01BC     		pop	{r0}
 1239 0026 0047     		bx	r0
 1240              	.L49:
 1241              		.align	2
 1242              	.L48:
 1243 0028 00010000 		.word	.LANCHOR10
 1244 002c 00000000 		.word	.LANCHOR0
 1245              		.cfi_endproc
 1246              	.LFE384:
 1248              		.global	__aeabi_ui2f
 1249              		.global	__aeabi_f2d
 1250              		.global	__aeabi_dmul
 1251              		.global	__aeabi_ddiv
 1252              		.global	__aeabi_d2f
 1253              		.global	__aeabi_i2f
 1254              		.global	__aeabi_fmul
 1255              		.global	__aeabi_fadd
 1256              		.global	__aeabi_fsub
 1257              		.global	__aeabi_fdiv
 1258              		.global	__aeabi_fcmplt
 1259              		.global	__aeabi_fcmpgt
 1260              		.global	__aeabi_dadd
 1261              		.section	.text.Inputs,"ax",%progbits
 1262              		.align	2
 1263              		.global	Inputs
 1264              		.code	16
 1265              		.thumb_func
 1267              	Inputs:
 1268              	.LFB385:
 764:functions.c   **** // -----------------------------------------------------------
 765:functions.c   **** 
 766:functions.c   **** 
 767:functions.c   **** // -----------------------------------------------------------
 768:functions.c   **** // Function Name       : Inputs
 769:functions.c   **** // Object              : Calculates inputs
 770:functions.c   **** // Output Parameters   : DiaTargetVolts
 771:functions.c   **** //                       DiaMinExtDisplayPercent     (0.0 - 100.0 % of extended display range from 
 772:functions.c   **** //                       DiaTargetExtDisplayPercent  (0.0 - 100.0 % of extended display range from 
 773:functions.c   **** //                       BaleDiaExtDisplayPercent    (0.0 - 100.0 % of extended display range from 
 774:functions.c   **** //                       DiaMinVolts
 775:functions.c   **** //                       DiaMaxVolts
 776:functions.c   **** // -----------------------------------------------------------
 777:functions.c   **** void Inputs( void )
 778:functions.c   **** {    
 1269              		.loc 1 778 0
 1270              		.cfi_startproc
 1271 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1272              	.LCFI12:
 1273              		.cfi_def_cfa_offset 20
 1274              		.cfi_offset 4, -20
 1275              		.cfi_offset 5, -16
 1276              		.cfi_offset 6, -12
 1277              		.cfi_offset 7, -8
 1278              		.cfi_offset 14, -4
 1279 0002 5F46     		mov	r7, fp
 1280 0004 5646     		mov	r6, sl
 1281 0006 4D46     		mov	r5, r9
 1282 0008 4446     		mov	r4, r8
 1283 000a F0B4     		push	{r4, r5, r6, r7}
 1284              	.LCFI13:
 1285              		.cfi_def_cfa_offset 36
 1286              		.cfi_offset 8, -36
 1287              		.cfi_offset 9, -32
 1288              		.cfi_offset 10, -28
 1289              		.cfi_offset 11, -24
 1290 000c 83B0     		sub	sp, sp, #12
 1291              	.LCFI14:
 1292              		.cfi_def_cfa_offset 48
 779:functions.c   **** 	float DiaVoltsPer1PercentFullRange;       // V
 780:functions.c   **** 	float DiaCorrectionNudgeVolts;            // V
 781:functions.c   **** 	float DiaZeroVolts;                       // V
 782:functions.c   **** 
 783:functions.c   **** 	float DiaVoltsPerSetting;                 // V where Setting = 1 to 109 (which corresponds to 60 t
 784:functions.c   **** 
 785:functions.c   **** #ifdef DEVELOP
 786:functions.c   **** 	float DiaVoltsPer1PercentDisplayRange;    // V where DisplayRange = 0 to 100 % (which corresponds 
 787:functions.c   **** 
 788:functions.c   **** 	unsigned char tstring[32];                // used in printing out values
 789:functions.c   **** #endif
 790:functions.c   **** 
 791:functions.c   **** 	// Volts per 1% of full range = Voltage Range / 100  where Voltage Range = Bale Size Factor x Fixe
 792:functions.c   **** 	DiaVoltsPer1PercentFullRange = ((float)pFac.pf.GW302_BaleSizeFactor * DIA_FIXED_MULTIPLIER) / 100.
 1293              		.loc 1 792 0
 1294 000e E84C     		ldr	r4, .L117+16
 1295 0010 9023     		mov	r3, #144
 1296 0012 E05C     		ldrb	r0, [r4, r3]
 1297 0014 FFF7FEFF 		bl	__aeabi_ui2f
 1298              	.LVL71:
 1299 0018 FFF7FEFF 		bl	__aeabi_f2d
 1300              	.LVL72:
 1301 001c E14B     		ldr	r3, .L117+4
 1302 001e E04A     		ldr	r2, .L117
 1303 0020 FFF7FEFF 		bl	__aeabi_dmul
 1304              	.LVL73:
 1305 0024 E04A     		ldr	r2, .L117+8
 1306 0026 E14B     		ldr	r3, .L117+12
 1307 0028 FFF7FEFF 		bl	__aeabi_ddiv
 1308              	.LVL74:
 1309 002c FFF7FEFF 		bl	__aeabi_d2f
 1310              	.LVL75:
 1311 0030 051C     		add	r5, r0, #0
 1312              	.LVL76:
 793:functions.c   **** 
 794:functions.c   **** 	// Correction nudge voltage = Units nudged x Size of unit
 795:functions.c   **** 	DiaCorrectionNudgeVolts = (float)pFac.pf.GW302_DiameterCorrection * pFac.pf.GW302_DiaCorrection;
 1313              		.loc 1 795 0
 1314 0032 6823     		mov	r3, #104
 1315 0034 E056     		ldrsb	r0, [r4, r3]
 1316              	.LVL77:
 1317 0036 FFF7FEFF 		bl	__aeabi_i2f
 1318              	.LVL78:
 1319 003a C823     		mov	r3, #200
 1320 003c E158     		ldr	r1, [r4, r3]
 1321 003e FFF7FEFF 		bl	__aeabi_fmul
 1322              	.LVL79:
 796:functions.c   **** 
 797:functions.c   **** 	// Diameter zero voltage corresponding to 0cm = Pot Zero Voltage + Correction nudge voltage
 798:functions.c   **** 	DiaZeroVolts = pFac.pf.GW302_DiaPotZero + DiaCorrectionNudgeVolts;
 1323              		.loc 1 798 0
 1324 0042 616E     		ldr	r1, [r4, #100]
 1325 0044 FFF7FEFF 		bl	__aeabi_fadd
 1326              	.LVL80:
 1327 0048 8346     		mov	fp, r0
 1328              	.LVL81:
 799:functions.c   **** 
 800:functions.c   **** 	// Minimum voltage = (% diameter at setting 1 x Volts per 1%) + Diameter zero voltage correspondin
 801:functions.c   **** 	DiaMinVolts = ((float)pFac.pf.GW302_DiameterMin * DiaVoltsPer1PercentFullRange) + DiaZeroVolts;
 1329              		.loc 1 801 0
 1330 004a C423     		mov	r3, #196
 1331 004c E05C     		ldrb	r0, [r4, r3]
 1332              	.LVL82:
 1333 004e FFF7FEFF 		bl	__aeabi_ui2f
 1334              	.LVL83:
 1335 0052 291C     		add	r1, r5, #0
 1336 0054 FFF7FEFF 		bl	__aeabi_fmul
 1337              	.LVL84:
 1338 0058 5946     		mov	r1, fp
 1339 005a FFF7FEFF 		bl	__aeabi_fadd
 1340              	.LVL85:
 1341 005e 8146     		mov	r9, r0
 1342 0060 D44B     		ldr	r3, .L117+20
 1343 0062 1860     		str	r0, [r3]
 802:functions.c   **** 
 803:functions.c   **** 	// Maximum voltage = (% diameter at setting 109 x Volts per 1%) + Diameter zero voltage correspond
 804:functions.c   **** 	DiaMaxVolts = ((float)pFac.pf.GW302_DiameterMax * DiaVoltsPer1PercentFullRange) + DiaZeroVolts;
 1344              		.loc 1 804 0
 1345 0064 C523     		mov	r3, #197
 1346 0066 E05C     		ldrb	r0, [r4, r3]
 1347 0068 FFF7FEFF 		bl	__aeabi_ui2f
 1348              	.LVL86:
 1349 006c 291C     		add	r1, r5, #0
 1350 006e FFF7FEFF 		bl	__aeabi_fmul
 1351              	.LVL87:
 1352 0072 5946     		mov	r1, fp
 1353 0074 FFF7FEFF 		bl	__aeabi_fadd
 1354              	.LVL88:
 1355 0078 061C     		add	r6, r0, #0
 1356 007a CF4B     		ldr	r3, .L117+24
 1357 007c 1860     		str	r0, [r3]
 805:functions.c   **** 
 806:functions.c   **** 	// Volts per setting division = (Maximum voltage - Minimum voltage) / (109 - 1) where setting is 1
 807:functions.c   **** 	DiaVoltsPerSetting = (DiaMaxVolts - DiaMinVolts) / 108.0;
 1358              		.loc 1 807 0
 1359 007e 4946     		mov	r1, r9
 1360 0080 FFF7FEFF 		bl	__aeabi_fsub
 1361              	.LVL89:
 1362 0084 CD49     		ldr	r1, .L117+28
 1363 0086 FFF7FEFF 		bl	__aeabi_fdiv
 1364              	.LVL90:
 1365 008a 0190     		str	r0, [sp, #4]
 1366              	.LVL91:
 808:functions.c   **** 
 809:functions.c   **** 	// Target bale diameter voltage = ( (Target setting in cm - 60cm) x Volts per setting division  ) 
 810:functions.c   **** 	// Note: Target bale diameter voltage = Minimum voltage when Target setting is 60cm
 811:functions.c   **** 	DiaTargetVolts = ((float)(pFac.pf.GW302_BaleDiameter[pFac.pf.GW302_BaleProfile] - 60) * DiaVoltsPe
 1367              		.loc 1 811 0
 1368 008c 3A23     		mov	r3, #58
 1369 008e E35C     		ldrb	r3, [r4, r3]
 1370 0090 9A46     		mov	sl, r3
 1371 0092 5444     		add	r4, r4, sl
 1372 0094 3834     		add	r4, r4, #56
 1373 0096 E078     		ldrb	r0, [r4, #3]
 1374              	.LVL92:
 1375 0098 3C38     		sub	r0, r0, #60
 1376 009a FFF7FEFF 		bl	__aeabi_i2f
 1377              	.LVL93:
 1378 009e 0199     		ldr	r1, [sp, #4]
 1379 00a0 FFF7FEFF 		bl	__aeabi_fmul
 1380              	.LVL94:
 1381 00a4 011C     		add	r1, r0, #0
 1382 00a6 4846     		mov	r0, r9
 1383 00a8 FFF7FEFF 		bl	__aeabi_fadd
 1384              	.LVL95:
 1385 00ac 0090     		str	r0, [sp]
 1386 00ae C44B     		ldr	r3, .L117+32
 1387 00b0 1860     		str	r0, [r3]
 812:functions.c   **** 
 813:functions.c   **** #ifdef DEVELOP
 814:functions.c   **** 	// Volts per 1% of display range (from 0 to 100 % corresponding to 60 to 168cm and setting 1 to 10
 815:functions.c   **** 	// Not used in any calculations
 816:functions.c   **** 	DiaVoltsPer1PercentDisplayRange = (DiaMaxVolts - DiaMinVolts) / 100.0;
 817:functions.c   **** #endif
 818:functions.c   **** 
 819:functions.c   **** 	// Current bale diameter -- shown on scale with target & minimum bale diameters indicated
 820:functions.c   **** 
 821:functions.c   **** 	// Minimum bale diameter extended display percentage (0 - 100 % of extended display range from Pot
 822:functions.c   **** 	if(DiaMinVolts > DiaZeroVolts)
 1388              		.loc 1 822 0
 1389 00b2 5846     		mov	r0, fp
 1390 00b4 4946     		mov	r1, r9
 1391 00b6 FFF7FEFF 		bl	__aeabi_fcmplt
 1392              	.LVL96:
 1393 00ba 0028     		cmp	r0, #0
 1394 00bc 17D0     		beq	.L114
 823:functions.c   **** 		DiaMinExtDisplayPercent = ( (DiaMinVolts - DiaZeroVolts) / (DiaMaxVolts - DiaZeroVolts) ) * 100.0
 1395              		.loc 1 823 0
 1396 00be 4846     		mov	r0, r9
 1397 00c0 5946     		mov	r1, fp
 1398 00c2 FFF7FEFF 		bl	__aeabi_fsub
 1399              	.LVL97:
 1400 00c6 041C     		add	r4, r0, #0
 1401 00c8 301C     		add	r0, r6, #0
 1402 00ca 5946     		mov	r1, fp
 1403 00cc FFF7FEFF 		bl	__aeabi_fsub
 1404              	.LVL98:
 1405 00d0 011C     		add	r1, r0, #0
 1406 00d2 201C     		add	r0, r4, #0
 1407 00d4 FFF7FEFF 		bl	__aeabi_fdiv
 1408              	.LVL99:
 1409 00d8 BA49     		ldr	r1, .L117+36
 1410 00da FFF7FEFF 		bl	__aeabi_fmul
 1411              	.LVL100:
 1412 00de BA4B     		ldr	r3, .L117+40
 1413 00e0 1860     		str	r0, [r3]
 824:functions.c   **** 	else
 825:functions.c   **** 		DiaMinExtDisplayPercent = 0.0; // Limiting to 0.0%
 826:functions.c   **** 	if( DiaMinExtDisplayPercent > 100.0)
 1414              		.loc 1 826 0
 1415 00e2 B849     		ldr	r1, .L117+36
 1416 00e4 FFF7FEFF 		bl	__aeabi_fcmpgt
 1417              	.LVL101:
 1418 00e8 0028     		cmp	r0, #0
 1419 00ea 04D1     		bne	.L53
 1420 00ec 06E0     		b	.L54
 1421              	.L114:
 825:functions.c   **** 		DiaMinExtDisplayPercent = 0.0; // Limiting to 0.0%
 1422              		.loc 1 825 0
 1423 00ee 0022     		mov	r2, #0
 1424 00f0 B54B     		ldr	r3, .L117+40
 1425 00f2 1A60     		str	r2, [r3]
 1426 00f4 02E0     		b	.L54
 1427              	.L53:
 827:functions.c   **** 		DiaMinExtDisplayPercent = 100.0; // Limiting to 100.0%
 1428              		.loc 1 827 0
 1429 00f6 B34A     		ldr	r2, .L117+36
 1430 00f8 B34B     		ldr	r3, .L117+40
 1431 00fa 1A60     		str	r2, [r3]
 1432              	.L54:
 828:functions.c   **** 
 829:functions.c   **** 	// Target bale diameter extended display percentage (0 - 100 % of extended display range from PotZ
 830:functions.c   **** 	if(DiaTargetVolts > DiaZeroVolts)
 1433              		.loc 1 830 0
 1434 00fc 5846     		mov	r0, fp
 1435 00fe 0099     		ldr	r1, [sp]
 1436 0100 FFF7FEFF 		bl	__aeabi_fcmplt
 1437              	.LVL102:
 1438 0104 0028     		cmp	r0, #0
 1439 0106 17D0     		beq	.L115
 831:functions.c   **** 		DiaTargetExtDisplayPercent = ( (DiaTargetVolts - DiaZeroVolts) / (DiaMaxVolts - DiaZeroVolts) ) *
 1440              		.loc 1 831 0
 1441 0108 0098     		ldr	r0, [sp]
 1442 010a 5946     		mov	r1, fp
 1443 010c FFF7FEFF 		bl	__aeabi_fsub
 1444              	.LVL103:
 1445 0110 041C     		add	r4, r0, #0
 1446 0112 301C     		add	r0, r6, #0
 1447 0114 5946     		mov	r1, fp
 1448 0116 FFF7FEFF 		bl	__aeabi_fsub
 1449              	.LVL104:
 1450 011a 011C     		add	r1, r0, #0
 1451 011c 201C     		add	r0, r4, #0
 1452 011e FFF7FEFF 		bl	__aeabi_fdiv
 1453              	.LVL105:
 1454 0122 A849     		ldr	r1, .L117+36
 1455 0124 FFF7FEFF 		bl	__aeabi_fmul
 1456              	.LVL106:
 1457 0128 A84B     		ldr	r3, .L117+44
 1458 012a 1860     		str	r0, [r3]
 832:functions.c   **** 	else
 833:functions.c   **** 		DiaTargetExtDisplayPercent = 0.0; // Limiting to 0.0%
 834:functions.c   **** 	if( DiaTargetExtDisplayPercent > 100.0)
 1459              		.loc 1 834 0
 1460 012c A549     		ldr	r1, .L117+36
 1461 012e FFF7FEFF 		bl	__aeabi_fcmpgt
 1462              	.LVL107:
 1463 0132 0028     		cmp	r0, #0
 1464 0134 04D1     		bne	.L57
 1465 0136 06E0     		b	.L58
 1466              	.L115:
 833:functions.c   **** 		DiaTargetExtDisplayPercent = 0.0; // Limiting to 0.0%
 1467              		.loc 1 833 0
 1468 0138 0022     		mov	r2, #0
 1469 013a A44B     		ldr	r3, .L117+44
 1470 013c 1A60     		str	r2, [r3]
 1471 013e 02E0     		b	.L58
 1472              	.L57:
 835:functions.c   **** 		DiaTargetExtDisplayPercent = 100.0; // Limiting to 100.0%
 1473              		.loc 1 835 0
 1474 0140 A04A     		ldr	r2, .L117+36
 1475 0142 A24B     		ldr	r3, .L117+44
 1476 0144 1A60     		str	r2, [r3]
 1477              	.L58:
 836:functions.c   **** 
 837:functions.c   **** 	// Current bale diameter extended display percentage (0 - 100 %) = (Current bale diameter voltage 
 838:functions.c   **** 	if(BaleDiaVolts > DiaZeroVolts)
 1478              		.loc 1 838 0
 1479 0146 A24B     		ldr	r3, .L117+48
 1480 0148 1C68     		ldr	r4, [r3]
 1481 014a 5846     		mov	r0, fp
 1482 014c 211C     		add	r1, r4, #0
 1483 014e FFF7FEFF 		bl	__aeabi_fcmplt
 1484              	.LVL108:
 1485 0152 0028     		cmp	r0, #0
 1486 0154 21D0     		beq	.L116
 839:functions.c   **** 		// Multiplying (BaleDiaVolts - DiaZeroVolts) by 100.0 before division for accuracy
 840:functions.c   **** 		BaleDiaExtDisplayPercent = ( (BaleDiaVolts - DiaZeroVolts) * 100.0 ) / ( DiaMaxVolts - DiaZeroVol
 1487              		.loc 1 840 0
 1488 0156 201C     		add	r0, r4, #0
 1489 0158 5946     		mov	r1, fp
 1490 015a FFF7FEFF 		bl	__aeabi_fsub
 1491              	.LVL109:
 1492 015e FFF7FEFF 		bl	__aeabi_f2d
 1493              	.LVL110:
 1494 0162 914A     		ldr	r2, .L117+8
 1495 0164 914B     		ldr	r3, .L117+12
 1496 0166 FFF7FEFF 		bl	__aeabi_dmul
 1497              	.LVL111:
 1498 016a 041C     		mov	r4, r0
 1499 016c 0D1C     		mov	r5, r1
 1500              	.LVL112:
 1501 016e 301C     		add	r0, r6, #0
 1502 0170 5946     		mov	r1, fp
 1503 0172 FFF7FEFF 		bl	__aeabi_fsub
 1504              	.LVL113:
 1505 0176 FFF7FEFF 		bl	__aeabi_f2d
 1506              	.LVL114:
 1507 017a 021C     		mov	r2, r0
 1508 017c 0B1C     		mov	r3, r1
 1509 017e 201C     		mov	r0, r4
 1510 0180 291C     		mov	r1, r5
 1511 0182 FFF7FEFF 		bl	__aeabi_ddiv
 1512              	.LVL115:
 1513 0186 FFF7FEFF 		bl	__aeabi_d2f
 1514              	.LVL116:
 1515 018a 924B     		ldr	r3, .L117+52
 1516 018c 1860     		str	r0, [r3]
 841:functions.c   **** 	else
 842:functions.c   **** 		BaleDiaExtDisplayPercent = 0.0; // Limiting to 0.0%
 843:functions.c   **** 	if( BaleDiaExtDisplayPercent > 100.0)
 1517              		.loc 1 843 0
 1518 018e 8D49     		ldr	r1, .L117+36
 1519 0190 FFF7FEFF 		bl	__aeabi_fcmpgt
 1520              	.LVL117:
 1521 0194 0028     		cmp	r0, #0
 1522 0196 04D1     		bne	.L61
 1523 0198 06E0     		b	.L62
 1524              	.LVL118:
 1525              	.L116:
 842:functions.c   **** 		BaleDiaExtDisplayPercent = 0.0; // Limiting to 0.0%
 1526              		.loc 1 842 0
 1527 019a 0022     		mov	r2, #0
 1528 019c 8D4B     		ldr	r3, .L117+52
 1529 019e 1A60     		str	r2, [r3]
 1530 01a0 02E0     		b	.L62
 1531              	.LVL119:
 1532              	.L61:
 844:functions.c   **** 		BaleDiaExtDisplayPercent = 100.0; // Limiting to 100.0%
 1533              		.loc 1 844 0
 1534 01a2 884A     		ldr	r2, .L117+36
 1535 01a4 8B4B     		ldr	r3, .L117+52
 1536 01a6 1A60     		str	r2, [r3]
 1537              	.L62:
 845:functions.c   **** 
 846:functions.c   **** 
 847:functions.c   **** 	// Formation diameter voltage = % Upper diameter limit of 'Formation' stage * 100 % range from 0cm
 848:functions.c   **** 	DiaFormationVolts = ((float)pFac.pf.GW302_FormationDiameter[pFac.pf.GW302_BaleProfile] * ((DiaMaxV
 1538              		.loc 1 848 0
 1539 01a8 301C     		add	r0, r6, #0
 1540 01aa 5946     		mov	r1, fp
 1541 01ac FFF7FEFF 		bl	__aeabi_fsub
 1542              	.LVL120:
 1543 01b0 FFF7FEFF 		bl	__aeabi_f2d
 1544              	.LVL121:
 1545 01b4 7C4A     		ldr	r2, .L117+8
 1546 01b6 7D4B     		ldr	r3, .L117+12
 1547 01b8 FFF7FEFF 		bl	__aeabi_ddiv
 1548              	.LVL122:
 1549 01bc 061C     		mov	r6, r0
 1550 01be 0F1C     		mov	r7, r1
 1551 01c0 5846     		mov	r0, fp
 1552 01c2 FFF7FEFF 		bl	__aeabi_f2d
 1553              	.LVL123:
 1554 01c6 041C     		mov	r4, r0
 1555 01c8 0D1C     		mov	r5, r1
 1556 01ca 794A     		ldr	r2, .L117+16
 1557 01cc 9046     		mov	r8, r2
 1558 01ce D044     		add	r8, r8, sl
 1559 01d0 4346     		mov	r3, r8
 1560 01d2 0933     		add	r3, r3, #9
 1561 01d4 FF33     		add	r3, r3, #255
 1562 01d6 5878     		ldrb	r0, [r3, #1]
 1563 01d8 FFF7FEFF 		bl	__aeabi_ui2f
 1564              	.LVL124:
 1565 01dc FFF7FEFF 		bl	__aeabi_f2d
 1566              	.LVL125:
 1567 01e0 321C     		mov	r2, r6
 1568 01e2 3B1C     		mov	r3, r7
 1569 01e4 FFF7FEFF 		bl	__aeabi_dmul
 1570              	.LVL126:
 1571 01e8 221C     		mov	r2, r4
 1572 01ea 2B1C     		mov	r3, r5
 1573 01ec FFF7FEFF 		bl	__aeabi_dadd
 1574              	.LVL127:
 1575 01f0 FFF7FEFF 		bl	__aeabi_d2f
 1576              	.LVL128:
 1577 01f4 784B     		ldr	r3, .L117+56
 1578 01f6 1860     		str	r0, [r3]
 849:functions.c   **** 
 850:functions.c   **** 	// Formation2 diameter voltage = % Upper diameter limit of 'Formation2' stage * 100 % range from 0
 851:functions.c   **** 	DiaFormation2Volts = ((float)pFac.pf.GW302_Formation2Diameter[pFac.pf.GW302_BaleProfile] * ((DiaMa
 1579              		.loc 1 851 0
 1580 01f8 4346     		mov	r3, r8
 1581 01fa 1133     		add	r3, r3, #17
 1582 01fc FF33     		add	r3, r3, #255
 1583 01fe D878     		ldrb	r0, [r3, #3]
 1584 0200 FFF7FEFF 		bl	__aeabi_ui2f
 1585              	.LVL129:
 1586 0204 FFF7FEFF 		bl	__aeabi_f2d
 1587              	.LVL130:
 1588 0208 021C     		mov	r2, r0
 1589 020a 0B1C     		mov	r3, r1
 1590 020c 301C     		mov	r0, r6
 1591 020e 391C     		mov	r1, r7
 1592 0210 FFF7FEFF 		bl	__aeabi_dmul
 1593              	.LVL131:
 1594 0214 021C     		mov	r2, r0
 1595 0216 0B1C     		mov	r3, r1
 1596 0218 201C     		mov	r0, r4
 1597 021a 291C     		mov	r1, r5
 1598 021c FFF7FEFF 		bl	__aeabi_dadd
 1599              	.LVL132:
 1600 0220 FFF7FEFF 		bl	__aeabi_d2f
 1601              	.LVL133:
 1602 0224 6D4B     		ldr	r3, .L117+60
 1603 0226 1860     		str	r0, [r3]
 852:functions.c   **** 
 853:functions.c   **** 	// Core diameter voltage = ( (Core setting in cm - 60cm) x Volts per setting division  ) + Minimum
 854:functions.c   **** 	DiaCoreVolts = ((float)(pFac.pf.GW302_CoreDiameter[pFac.pf.GW302_BaleProfile] - 60) * DiaVoltsPerS
 1604              		.loc 1 854 0
 1605 0228 4023     		mov	r3, #64
 1606 022a 9844     		add	r8, r8, r3
 1607 022c 4246     		mov	r2, r8
 1608 022e 1078     		ldrb	r0, [r2]
 1609 0230 3C38     		sub	r0, r0, #60
 1610 0232 FFF7FEFF 		bl	__aeabi_i2f
 1611              	.LVL134:
 1612 0236 0199     		ldr	r1, [sp, #4]
 1613 0238 FFF7FEFF 		bl	__aeabi_fmul
 1614              	.LVL135:
 1615 023c 011C     		add	r1, r0, #0
 1616 023e 4846     		mov	r0, r9
 1617 0240 FFF7FEFF 		bl	__aeabi_fadd
 1618              	.LVL136:
 1619 0244 664B     		ldr	r3, .L117+64
 1620 0246 1860     		str	r0, [r3]
 855:functions.c   **** 
 856:functions.c   **** 	// Engage diameter voltage = Engage % setting x Target diameter voltage (from Zero pot voltage)
 857:functions.c   **** 	DiaEngageVolts = ((float)pFac.pf.GW302_EngageDiameter * ((DiaTargetVolts - DiaZeroVolts) / 100.0))
 1621              		.loc 1 857 0
 1622 0248 0098     		ldr	r0, [sp]
 1623 024a 5946     		mov	r1, fp
 1624 024c FFF7FEFF 		bl	__aeabi_fsub
 1625              	.LVL137:
 1626 0250 FFF7FEFF 		bl	__aeabi_f2d
 1627              	.LVL138:
 1628 0254 544A     		ldr	r2, .L117+8
 1629 0256 554B     		ldr	r3, .L117+12
 1630 0258 FFF7FEFF 		bl	__aeabi_ddiv
 1631              	.LVL139:
 1632 025c 061C     		mov	r6, r0
 1633 025e 0F1C     		mov	r7, r1
 1634 0260 9C23     		mov	r3, #156
 1635 0262 534A     		ldr	r2, .L117+16
 1636 0264 D05C     		ldrb	r0, [r2, r3]
 1637 0266 FFF7FEFF 		bl	__aeabi_ui2f
 1638              	.LVL140:
 1639 026a FFF7FEFF 		bl	__aeabi_f2d
 1640              	.LVL141:
 1641 026e 321C     		mov	r2, r6
 1642 0270 3B1C     		mov	r3, r7
 1643 0272 FFF7FEFF 		bl	__aeabi_dmul
 1644              	.LVL142:
 1645 0276 021C     		mov	r2, r0
 1646 0278 0B1C     		mov	r3, r1
 1647 027a 201C     		mov	r0, r4
 1648 027c 291C     		mov	r1, r5
 1649 027e FFF7FEFF 		bl	__aeabi_dadd
 1650              	.LVL143:
 1651 0282 FFF7FEFF 		bl	__aeabi_d2f
 1652              	.LVL144:
 1653 0286 574B     		ldr	r3, .L117+68
 1654 0288 1860     		str	r0, [r3]
 858:functions.c   **** 
 859:functions.c   **** 	// Pre warning beep diameter voltage = Pre Warning Beep % setting x Target diameter voltage (from 
 860:functions.c   **** 	DiaPreWarnVolts = ((float)pFac.pf.GW302_PreWarningBeep * ((DiaTargetVolts - DiaZeroVolts) / 100.0)
 1655              		.loc 1 860 0
 1656 028a 7423     		mov	r3, #116
 1657 028c 484A     		ldr	r2, .L117+16
 1658 028e D05C     		ldrb	r0, [r2, r3]
 1659 0290 FFF7FEFF 		bl	__aeabi_ui2f
 1660              	.LVL145:
 1661 0294 FFF7FEFF 		bl	__aeabi_f2d
 1662              	.LVL146:
 1663 0298 021C     		mov	r2, r0
 1664 029a 0B1C     		mov	r3, r1
 1665 029c 301C     		mov	r0, r6
 1666 029e 391C     		mov	r1, r7
 1667 02a0 FFF7FEFF 		bl	__aeabi_dmul
 1668              	.LVL147:
 1669 02a4 021C     		mov	r2, r0
 1670 02a6 0B1C     		mov	r3, r1
 1671 02a8 201C     		mov	r0, r4
 1672 02aa 291C     		mov	r1, r5
 1673 02ac FFF7FEFF 		bl	__aeabi_dadd
 1674              	.LVL148:
 1675 02b0 FFF7FEFF 		bl	__aeabi_d2f
 1676              	.LVL149:
 1677 02b4 4C4B     		ldr	r3, .L117+72
 1678 02b6 1860     		str	r0, [r3]
 861:functions.c   **** 
 862:functions.c   **** 
 863:functions.c   **** 	// Target density voltage during Main stage
 864:functions.c   **** 	switch( pFac.pf.GW302_BaleDensity[pFac.pf.GW302_BaleProfile] )
 1679              		.loc 1 864 0
 1680 02b8 4246     		mov	r2, r8
 1681 02ba 5379     		ldrb	r3, [r2, #5]
 1682 02bc 092B     		cmp	r3, #9
 1683 02be 39D8     		bhi	.L63
 1684 02c0 9B00     		lsl	r3, r3, #2
 1685 02c2 4A4A     		ldr	r2, .L117+76
 1686 02c4 D358     		ldr	r3, [r2, r3]
 1687 02c6 9F46     		mov	pc, r3
 1688              		.section	.rodata.Inputs,"a",%progbits
 1689              		.align	2
 1690              	.L73:
 1691 0000 34030000 		.word	.L63
 1692 0004 C8020000 		.word	.L64
 1693 0008 D4020000 		.word	.L65
 1694 000c E0020000 		.word	.L66
 1695 0010 EC020000 		.word	.L67
 1696 0014 F8020000 		.word	.L68
 1697 0018 04030000 		.word	.L69
 1698 001c 10030000 		.word	.L70
 1699 0020 1C030000 		.word	.L71
 1700 0024 28030000 		.word	.L72
 1701              		.section	.text.Inputs
 1702              	.L64:
 865:functions.c   **** 	{
 866:functions.c   **** 	case 1:
 867:functions.c   **** 		DensityBaleVolts = pFac.pf.GW302_Density1;
 1703              		.loc 1 867 0
 1704 02c8 D023     		mov	r3, #208
 1705 02ca 394A     		ldr	r2, .L117+16
 1706 02cc D258     		ldr	r2, [r2, r3]
 1707 02ce 484B     		ldr	r3, .L117+80
 1708 02d0 1A60     		str	r2, [r3]
 868:functions.c   **** 		break;
 1709              		.loc 1 868 0
 1710 02d2 34E0     		b	.L74
 1711              	.L65:
 869:functions.c   **** 	case 2:
 870:functions.c   **** 		DensityBaleVolts = pFac.pf.GW302_Density2;
 1712              		.loc 1 870 0
 1713 02d4 D423     		mov	r3, #212
 1714 02d6 364A     		ldr	r2, .L117+16
 1715 02d8 D258     		ldr	r2, [r2, r3]
 1716 02da 454B     		ldr	r3, .L117+80
 1717 02dc 1A60     		str	r2, [r3]
 871:functions.c   **** 		break;
 1718              		.loc 1 871 0
 1719 02de 2EE0     		b	.L74
 1720              	.L66:
 872:functions.c   **** 	case 3:
 873:functions.c   **** 		DensityBaleVolts = pFac.pf.GW302_Density3;
 1721              		.loc 1 873 0
 1722 02e0 D823     		mov	r3, #216
 1723 02e2 334A     		ldr	r2, .L117+16
 1724 02e4 D258     		ldr	r2, [r2, r3]
 1725 02e6 424B     		ldr	r3, .L117+80
 1726 02e8 1A60     		str	r2, [r3]
 874:functions.c   **** 		break;
 1727              		.loc 1 874 0
 1728 02ea 28E0     		b	.L74
 1729              	.L67:
 875:functions.c   **** 	case 4:
 876:functions.c   **** 		DensityBaleVolts = pFac.pf.GW302_Density4;
 1730              		.loc 1 876 0
 1731 02ec DC23     		mov	r3, #220
 1732 02ee 304A     		ldr	r2, .L117+16
 1733 02f0 D258     		ldr	r2, [r2, r3]
 1734 02f2 3F4B     		ldr	r3, .L117+80
 1735 02f4 1A60     		str	r2, [r3]
 877:functions.c   **** 		break;
 1736              		.loc 1 877 0
 1737 02f6 22E0     		b	.L74
 1738              	.L68:
 878:functions.c   **** 	case 5:
 879:functions.c   **** 		DensityBaleVolts = pFac.pf.GW302_Density5;
 1739              		.loc 1 879 0
 1740 02f8 E023     		mov	r3, #224
 1741 02fa 2D4A     		ldr	r2, .L117+16
 1742 02fc D258     		ldr	r2, [r2, r3]
 1743 02fe 3C4B     		ldr	r3, .L117+80
 1744 0300 1A60     		str	r2, [r3]
 880:functions.c   **** 		break;
 1745              		.loc 1 880 0
 1746 0302 1CE0     		b	.L74
 1747              	.L69:
 881:functions.c   **** 	case 6:
 882:functions.c   **** 		DensityBaleVolts = pFac.pf.GW302_Density6;
 1748              		.loc 1 882 0
 1749 0304 E423     		mov	r3, #228
 1750 0306 2A4A     		ldr	r2, .L117+16
 1751 0308 D258     		ldr	r2, [r2, r3]
 1752 030a 394B     		ldr	r3, .L117+80
 1753 030c 1A60     		str	r2, [r3]
 883:functions.c   **** 		break;
 1754              		.loc 1 883 0
 1755 030e 16E0     		b	.L74
 1756              	.L70:
 884:functions.c   **** 	case 7:
 885:functions.c   **** 		DensityBaleVolts = pFac.pf.GW302_Density7;
 1757              		.loc 1 885 0
 1758 0310 E823     		mov	r3, #232
 1759 0312 274A     		ldr	r2, .L117+16
 1760 0314 D258     		ldr	r2, [r2, r3]
 1761 0316 364B     		ldr	r3, .L117+80
 1762 0318 1A60     		str	r2, [r3]
 886:functions.c   **** 		break;
 1763              		.loc 1 886 0
 1764 031a 10E0     		b	.L74
 1765              	.L71:
 887:functions.c   **** 	case 8:
 888:functions.c   **** 		DensityBaleVolts = pFac.pf.GW302_Density8;
 1766              		.loc 1 888 0
 1767 031c EC23     		mov	r3, #236
 1768 031e 244A     		ldr	r2, .L117+16
 1769 0320 D258     		ldr	r2, [r2, r3]
 1770 0322 334B     		ldr	r3, .L117+80
 1771 0324 1A60     		str	r2, [r3]
 889:functions.c   **** 		break;
 1772              		.loc 1 889 0
 1773 0326 0AE0     		b	.L74
 1774              	.L72:
 890:functions.c   **** 	case 9:
 891:functions.c   **** 		DensityBaleVolts = pFac.pf.GW302_Density9;
 1775              		.loc 1 891 0
 1776 0328 F023     		mov	r3, #240
 1777 032a 214A     		ldr	r2, .L117+16
 1778 032c D258     		ldr	r2, [r2, r3]
 1779 032e 304B     		ldr	r3, .L117+80
 1780 0330 1A60     		str	r2, [r3]
 892:functions.c   **** 		break;
 1781              		.loc 1 892 0
 1782 0332 04E0     		b	.L74
 1783              	.L63:
 893:functions.c   **** 	default: // 10
 894:functions.c   **** 	DensityBaleVolts = pFac.pf.GW302_Density10;
 1784              		.loc 1 894 0
 1785 0334 F423     		mov	r3, #244
 1786 0336 1E4A     		ldr	r2, .L117+16
 1787 0338 D258     		ldr	r2, [r2, r3]
 1788 033a 2D4B     		ldr	r3, .L117+80
 1789 033c 1A60     		str	r2, [r3]
 1790              	.L74:
 895:functions.c   **** 	break;
 896:functions.c   **** 	}
 897:functions.c   **** 
 898:functions.c   **** 	// Target density voltage during Core stage
 899:functions.c   **** 	switch( pFac.pf.GW302_CoreDensity[pFac.pf.GW302_BaleProfile] )
 1791              		.loc 1 899 0
 1792 033e 1C4B     		ldr	r3, .L117+16
 1793 0340 5344     		add	r3, r3, sl
 1794 0342 4833     		add	r3, r3, #72
 1795 0344 9A78     		ldrb	r2, [r3, #2]
 1796 0346 092A     		cmp	r2, #9
 1797 0348 6AD8     		bhi	.L75
 1798 034a 9300     		lsl	r3, r2, #2
 1799 034c 294A     		ldr	r2, .L117+84
 1800 034e D358     		ldr	r3, [r2, r3]
 1801 0350 9F46     		mov	pc, r3
 1802              		.section	.rodata.Inputs
 1803              		.align	2
 1804              	.L85:
 1805 0028 20040000 		.word	.L75
 1806 002c 52030000 		.word	.L76
 1807 0030 5E030000 		.word	.L77
 1808 0034 6A030000 		.word	.L78
 1809 0038 76030000 		.word	.L79
 1810 003c 82030000 		.word	.L80
 1811 0040 8E030000 		.word	.L81
 1812 0044 FC030000 		.word	.L82
 1813 0048 08040000 		.word	.L83
 1814 004c 14040000 		.word	.L84
 1815              		.section	.text.Inputs
 1816              	.L76:
 900:functions.c   **** 	{
 901:functions.c   **** 	case 1:
 902:functions.c   **** 		DensityCoreVolts = pFac.pf.GW302_Density1;
 1817              		.loc 1 902 0
 1818 0352 D023     		mov	r3, #208
 1819 0354 164A     		ldr	r2, .L117+16
 1820 0356 D258     		ldr	r2, [r2, r3]
 1821 0358 274B     		ldr	r3, .L117+88
 1822 035a 1A60     		str	r2, [r3]
 903:functions.c   **** 		break;
 1823              		.loc 1 903 0
 1824 035c 65E0     		b	.L86
 1825              	.L77:
 904:functions.c   **** 	case 2:
 905:functions.c   **** 		DensityCoreVolts = pFac.pf.GW302_Density2;
 1826              		.loc 1 905 0
 1827 035e D423     		mov	r3, #212
 1828 0360 134A     		ldr	r2, .L117+16
 1829 0362 D258     		ldr	r2, [r2, r3]
 1830 0364 244B     		ldr	r3, .L117+88
 1831 0366 1A60     		str	r2, [r3]
 906:functions.c   **** 		break;
 1832              		.loc 1 906 0
 1833 0368 5FE0     		b	.L86
 1834              	.L78:
 907:functions.c   **** 	case 3:
 908:functions.c   **** 		DensityCoreVolts = pFac.pf.GW302_Density3;
 1835              		.loc 1 908 0
 1836 036a D823     		mov	r3, #216
 1837 036c 104A     		ldr	r2, .L117+16
 1838 036e D258     		ldr	r2, [r2, r3]
 1839 0370 214B     		ldr	r3, .L117+88
 1840 0372 1A60     		str	r2, [r3]
 909:functions.c   **** 		break;
 1841              		.loc 1 909 0
 1842 0374 59E0     		b	.L86
 1843              	.L79:
 910:functions.c   **** 	case 4:
 911:functions.c   **** 		DensityCoreVolts = pFac.pf.GW302_Density4;
 1844              		.loc 1 911 0
 1845 0376 DC23     		mov	r3, #220
 1846 0378 0D4A     		ldr	r2, .L117+16
 1847 037a D258     		ldr	r2, [r2, r3]
 1848 037c 1E4B     		ldr	r3, .L117+88
 1849 037e 1A60     		str	r2, [r3]
 912:functions.c   **** 		break;
 1850              		.loc 1 912 0
 1851 0380 53E0     		b	.L86
 1852              	.L80:
 913:functions.c   **** 	case 5:
 914:functions.c   **** 		DensityCoreVolts = pFac.pf.GW302_Density5;
 1853              		.loc 1 914 0
 1854 0382 E023     		mov	r3, #224
 1855 0384 0A4A     		ldr	r2, .L117+16
 1856 0386 D258     		ldr	r2, [r2, r3]
 1857 0388 1B4B     		ldr	r3, .L117+88
 1858 038a 1A60     		str	r2, [r3]
 915:functions.c   **** 		break;
 1859              		.loc 1 915 0
 1860 038c 4DE0     		b	.L86
 1861              	.L81:
 916:functions.c   **** 	case 6:
 917:functions.c   **** 		DensityCoreVolts = pFac.pf.GW302_Density6;
 1862              		.loc 1 917 0
 1863 038e E423     		mov	r3, #228
 1864 0390 074A     		ldr	r2, .L117+16
 1865 0392 D258     		ldr	r2, [r2, r3]
 1866 0394 184B     		ldr	r3, .L117+88
 1867 0396 1A60     		str	r2, [r3]
 918:functions.c   **** 		break;
 1868              		.loc 1 918 0
 1869 0398 47E0     		b	.L86
 1870              	.L118:
 1871 039a C046C046 		.align	3
 1871      C046
 1872              	.L117:
 1873 03a0 39B4C876 		.word	1992864825
 1874 03a4 BE9F8A3F 		.word	1066049470
 1875 03a8 00000000 		.word	0
 1876 03ac 00005940 		.word	1079574528
 1877 03b0 00000000 		.word	.LANCHOR0
 1878 03b4 00000000 		.word	DiaMinVolts
 1879 03b8 00000000 		.word	DiaMaxVolts
 1880 03bc 0000D842 		.word	1121452032
 1881 03c0 00000000 		.word	DiaTargetVolts
 1882 03c4 0000C842 		.word	1120403456
 1883 03c8 00000000 		.word	DiaMinExtDisplayPercent
 1884 03cc 00000000 		.word	DiaTargetExtDisplayPercent
 1885 03d0 00000000 		.word	BaleDiaVolts
 1886 03d4 00000000 		.word	BaleDiaExtDisplayPercent
 1887 03d8 00000000 		.word	DiaFormationVolts
 1888 03dc 00000000 		.word	DiaFormation2Volts
 1889 03e0 00000000 		.word	DiaCoreVolts
 1890 03e4 00000000 		.word	DiaEngageVolts
 1891 03e8 00000000 		.word	DiaPreWarnVolts
 1892 03ec 00000000 		.word	.L73
 1893 03f0 00000000 		.word	DensityBaleVolts
 1894 03f4 28000000 		.word	.L85
 1895 03f8 00000000 		.word	DensityCoreVolts
 1896              	.L82:
 919:functions.c   **** 	case 7:
 920:functions.c   **** 		DensityCoreVolts = pFac.pf.GW302_Density7;
 1897              		.loc 1 920 0
 1898 03fc E823     		mov	r3, #232
 1899 03fe 554A     		ldr	r2, .L119
 1900 0400 D258     		ldr	r2, [r2, r3]
 1901 0402 554B     		ldr	r3, .L119+4
 1902 0404 1A60     		str	r2, [r3]
 921:functions.c   **** 		break;
 1903              		.loc 1 921 0
 1904 0406 10E0     		b	.L86
 1905              	.L83:
 922:functions.c   **** 	case 8:
 923:functions.c   **** 		DensityCoreVolts = pFac.pf.GW302_Density8;
 1906              		.loc 1 923 0
 1907 0408 EC23     		mov	r3, #236
 1908 040a 524A     		ldr	r2, .L119
 1909 040c D258     		ldr	r2, [r2, r3]
 1910 040e 524B     		ldr	r3, .L119+4
 1911 0410 1A60     		str	r2, [r3]
 924:functions.c   **** 		break;
 1912              		.loc 1 924 0
 1913 0412 0AE0     		b	.L86
 1914              	.L84:
 925:functions.c   **** 	case 9:
 926:functions.c   **** 		DensityCoreVolts = pFac.pf.GW302_Density9;
 1915              		.loc 1 926 0
 1916 0414 F023     		mov	r3, #240
 1917 0416 4F4A     		ldr	r2, .L119
 1918 0418 D258     		ldr	r2, [r2, r3]
 1919 041a 4F4B     		ldr	r3, .L119+4
 1920 041c 1A60     		str	r2, [r3]
 927:functions.c   **** 		break;
 1921              		.loc 1 927 0
 1922 041e 04E0     		b	.L86
 1923              	.L75:
 928:functions.c   **** 	default: // 10
 929:functions.c   **** 	DensityCoreVolts = pFac.pf.GW302_Density10;
 1924              		.loc 1 929 0
 1925 0420 F423     		mov	r3, #244
 1926 0422 4C4A     		ldr	r2, .L119
 1927 0424 D258     		ldr	r2, [r2, r3]
 1928 0426 4C4B     		ldr	r3, .L119+4
 1929 0428 1A60     		str	r2, [r3]
 1930              	.L86:
 930:functions.c   **** 	break;
 931:functions.c   **** 	}
 932:functions.c   **** 
 933:functions.c   **** 	// Target density voltage during Formation2 stage
 934:functions.c   **** 	switch( pFac.pf.GW302_Formation2Density[pFac.pf.GW302_BaleProfile] )
 1931              		.loc 1 934 0
 1932 042a 4A4B     		ldr	r3, .L119
 1933 042c 5344     		add	r3, r3, sl
 1934 042e 0933     		add	r3, r3, #9
 1935 0430 FF33     		add	r3, r3, #255
 1936 0432 9A79     		ldrb	r2, [r3, #6]
 1937 0434 092A     		cmp	r2, #9
 1938 0436 39D8     		bhi	.L87
 1939 0438 9300     		lsl	r3, r2, #2
 1940 043a 484A     		ldr	r2, .L119+8
 1941 043c D358     		ldr	r3, [r2, r3]
 1942 043e 9F46     		mov	pc, r3
 1943              		.section	.rodata.Inputs
 1944              		.align	2
 1945              	.L97:
 1946 0050 AC040000 		.word	.L87
 1947 0054 40040000 		.word	.L88
 1948 0058 4C040000 		.word	.L89
 1949 005c 58040000 		.word	.L90
 1950 0060 64040000 		.word	.L91
 1951 0064 70040000 		.word	.L92
 1952 0068 7C040000 		.word	.L93
 1953 006c 88040000 		.word	.L94
 1954 0070 94040000 		.word	.L95
 1955 0074 A0040000 		.word	.L96
 1956              		.section	.text.Inputs
 1957              	.L88:
 935:functions.c   **** 	{
 936:functions.c   **** 	case 1:
 937:functions.c   **** 		DensityFormation2Volts = pFac.pf.GW302_Density1;
 1958              		.loc 1 937 0
 1959 0440 D023     		mov	r3, #208
 1960 0442 444A     		ldr	r2, .L119
 1961 0444 D258     		ldr	r2, [r2, r3]
 1962 0446 464B     		ldr	r3, .L119+12
 1963 0448 1A60     		str	r2, [r3]
 938:functions.c   **** 		break;
 1964              		.loc 1 938 0
 1965 044a 34E0     		b	.L98
 1966              	.L89:
 939:functions.c   **** 	case 2:
 940:functions.c   **** 		DensityFormation2Volts = pFac.pf.GW302_Density2;
 1967              		.loc 1 940 0
 1968 044c D423     		mov	r3, #212
 1969 044e 414A     		ldr	r2, .L119
 1970 0450 D258     		ldr	r2, [r2, r3]
 1971 0452 434B     		ldr	r3, .L119+12
 1972 0454 1A60     		str	r2, [r3]
 941:functions.c   **** 		break;
 1973              		.loc 1 941 0
 1974 0456 2EE0     		b	.L98
 1975              	.L90:
 942:functions.c   **** 	case 3:
 943:functions.c   **** 		DensityFormation2Volts = pFac.pf.GW302_Density3;
 1976              		.loc 1 943 0
 1977 0458 D823     		mov	r3, #216
 1978 045a 3E4A     		ldr	r2, .L119
 1979 045c D258     		ldr	r2, [r2, r3]
 1980 045e 404B     		ldr	r3, .L119+12
 1981 0460 1A60     		str	r2, [r3]
 944:functions.c   **** 		break;
 1982              		.loc 1 944 0
 1983 0462 28E0     		b	.L98
 1984              	.L91:
 945:functions.c   **** 	case 4:
 946:functions.c   **** 		DensityFormation2Volts = pFac.pf.GW302_Density4;
 1985              		.loc 1 946 0
 1986 0464 DC23     		mov	r3, #220
 1987 0466 3B4A     		ldr	r2, .L119
 1988 0468 D258     		ldr	r2, [r2, r3]
 1989 046a 3D4B     		ldr	r3, .L119+12
 1990 046c 1A60     		str	r2, [r3]
 947:functions.c   **** 		break;
 1991              		.loc 1 947 0
 1992 046e 22E0     		b	.L98
 1993              	.L92:
 948:functions.c   **** 	case 5:
 949:functions.c   **** 		DensityFormation2Volts = pFac.pf.GW302_Density5;
 1994              		.loc 1 949 0
 1995 0470 E023     		mov	r3, #224
 1996 0472 384A     		ldr	r2, .L119
 1997 0474 D258     		ldr	r2, [r2, r3]
 1998 0476 3A4B     		ldr	r3, .L119+12
 1999 0478 1A60     		str	r2, [r3]
 950:functions.c   **** 		break;
 2000              		.loc 1 950 0
 2001 047a 1CE0     		b	.L98
 2002              	.L93:
 951:functions.c   **** 	case 6:
 952:functions.c   **** 		DensityFormation2Volts = pFac.pf.GW302_Density6;
 2003              		.loc 1 952 0
 2004 047c E423     		mov	r3, #228
 2005 047e 354A     		ldr	r2, .L119
 2006 0480 D258     		ldr	r2, [r2, r3]
 2007 0482 374B     		ldr	r3, .L119+12
 2008 0484 1A60     		str	r2, [r3]
 953:functions.c   **** 		break;
 2009              		.loc 1 953 0
 2010 0486 16E0     		b	.L98
 2011              	.L94:
 954:functions.c   **** 	case 7:
 955:functions.c   **** 		DensityFormation2Volts = pFac.pf.GW302_Density7;
 2012              		.loc 1 955 0
 2013 0488 E823     		mov	r3, #232
 2014 048a 324A     		ldr	r2, .L119
 2015 048c D258     		ldr	r2, [r2, r3]
 2016 048e 344B     		ldr	r3, .L119+12
 2017 0490 1A60     		str	r2, [r3]
 956:functions.c   **** 		break;
 2018              		.loc 1 956 0
 2019 0492 10E0     		b	.L98
 2020              	.L95:
 957:functions.c   **** 	case 8:
 958:functions.c   **** 		DensityFormation2Volts = pFac.pf.GW302_Density8;
 2021              		.loc 1 958 0
 2022 0494 EC23     		mov	r3, #236
 2023 0496 2F4A     		ldr	r2, .L119
 2024 0498 D258     		ldr	r2, [r2, r3]
 2025 049a 314B     		ldr	r3, .L119+12
 2026 049c 1A60     		str	r2, [r3]
 959:functions.c   **** 		break;
 2027              		.loc 1 959 0
 2028 049e 0AE0     		b	.L98
 2029              	.L96:
 960:functions.c   **** 	case 9:
 961:functions.c   **** 		DensityFormation2Volts = pFac.pf.GW302_Density9;
 2030              		.loc 1 961 0
 2031 04a0 F023     		mov	r3, #240
 2032 04a2 2C4A     		ldr	r2, .L119
 2033 04a4 D258     		ldr	r2, [r2, r3]
 2034 04a6 2E4B     		ldr	r3, .L119+12
 2035 04a8 1A60     		str	r2, [r3]
 962:functions.c   **** 		break;
 2036              		.loc 1 962 0
 2037 04aa 04E0     		b	.L98
 2038              	.L87:
 963:functions.c   **** 	default: // 10
 964:functions.c   **** 	DensityFormation2Volts = pFac.pf.GW302_Density10;
 2039              		.loc 1 964 0
 2040 04ac F423     		mov	r3, #244
 2041 04ae 294A     		ldr	r2, .L119
 2042 04b0 D258     		ldr	r2, [r2, r3]
 2043 04b2 2B4B     		ldr	r3, .L119+12
 2044 04b4 1A60     		str	r2, [r3]
 2045              	.L98:
 965:functions.c   **** 	break;
 966:functions.c   **** 	}
 967:functions.c   **** 
 968:functions.c   **** 	// Target density voltage during Formation stage
 969:functions.c   **** 	switch( pFac.pf.GW302_FormationDensity[pFac.pf.GW302_BaleProfile] )
 2046              		.loc 1 969 0
 2047 04b6 274B     		ldr	r3, .L119
 2048 04b8 5344     		add	r3, r3, sl
 2049 04ba 0133     		add	r3, r3, #1
 2050 04bc FF33     		add	r3, r3, #255
 2051 04be 1A79     		ldrb	r2, [r3, #4]
 2052 04c0 092A     		cmp	r2, #9
 2053 04c2 39D8     		bhi	.L99
 2054 04c4 9300     		lsl	r3, r2, #2
 2055 04c6 274A     		ldr	r2, .L119+16
 2056 04c8 D358     		ldr	r3, [r2, r3]
 2057 04ca 9F46     		mov	pc, r3
 2058              		.section	.rodata.Inputs
 2059              		.align	2
 2060              	.L109:
 2061 0078 38050000 		.word	.L99
 2062 007c CC040000 		.word	.L100
 2063 0080 D8040000 		.word	.L101
 2064 0084 E4040000 		.word	.L102
 2065 0088 F0040000 		.word	.L103
 2066 008c FC040000 		.word	.L104
 2067 0090 08050000 		.word	.L105
 2068 0094 14050000 		.word	.L106
 2069 0098 20050000 		.word	.L107
 2070 009c 2C050000 		.word	.L108
 2071              		.section	.text.Inputs
 2072              	.L100:
 970:functions.c   **** 	{
 971:functions.c   **** 	case 1:
 972:functions.c   **** 		DensityFormationVolts = pFac.pf.GW302_Density1;
 2073              		.loc 1 972 0
 2074 04cc D023     		mov	r3, #208
 2075 04ce 214A     		ldr	r2, .L119
 2076 04d0 D258     		ldr	r2, [r2, r3]
 2077 04d2 254B     		ldr	r3, .L119+20
 2078 04d4 1A60     		str	r2, [r3]
 973:functions.c   **** 		break;
 2079              		.loc 1 973 0
 2080 04d6 34E0     		b	.L50
 2081              	.L101:
 974:functions.c   **** 	case 2:
 975:functions.c   **** 		DensityFormationVolts = pFac.pf.GW302_Density2;
 2082              		.loc 1 975 0
 2083 04d8 D423     		mov	r3, #212
 2084 04da 1E4A     		ldr	r2, .L119
 2085 04dc D258     		ldr	r2, [r2, r3]
 2086 04de 224B     		ldr	r3, .L119+20
 2087 04e0 1A60     		str	r2, [r3]
 976:functions.c   **** 		break;
 2088              		.loc 1 976 0
 2089 04e2 2EE0     		b	.L50
 2090              	.L102:
 977:functions.c   **** 	case 3:
 978:functions.c   **** 		DensityFormationVolts = pFac.pf.GW302_Density3;
 2091              		.loc 1 978 0
 2092 04e4 D823     		mov	r3, #216
 2093 04e6 1B4A     		ldr	r2, .L119
 2094 04e8 D258     		ldr	r2, [r2, r3]
 2095 04ea 1F4B     		ldr	r3, .L119+20
 2096 04ec 1A60     		str	r2, [r3]
 979:functions.c   **** 		break;
 2097              		.loc 1 979 0
 2098 04ee 28E0     		b	.L50
 2099              	.L103:
 980:functions.c   **** 	case 4:
 981:functions.c   **** 		DensityFormationVolts = pFac.pf.GW302_Density4;
 2100              		.loc 1 981 0
 2101 04f0 DC23     		mov	r3, #220
 2102 04f2 184A     		ldr	r2, .L119
 2103 04f4 D258     		ldr	r2, [r2, r3]
 2104 04f6 1C4B     		ldr	r3, .L119+20
 2105 04f8 1A60     		str	r2, [r3]
 982:functions.c   **** 		break;
 2106              		.loc 1 982 0
 2107 04fa 22E0     		b	.L50
 2108              	.L104:
 983:functions.c   **** 	case 5:
 984:functions.c   **** 		DensityFormationVolts = pFac.pf.GW302_Density5;
 2109              		.loc 1 984 0
 2110 04fc E023     		mov	r3, #224
 2111 04fe 154A     		ldr	r2, .L119
 2112 0500 D258     		ldr	r2, [r2, r3]
 2113 0502 194B     		ldr	r3, .L119+20
 2114 0504 1A60     		str	r2, [r3]
 985:functions.c   **** 		break;
 2115              		.loc 1 985 0
 2116 0506 1CE0     		b	.L50
 2117              	.L105:
 986:functions.c   **** 	case 6:
 987:functions.c   **** 		DensityFormationVolts = pFac.pf.GW302_Density6;
 2118              		.loc 1 987 0
 2119 0508 E423     		mov	r3, #228
 2120 050a 124A     		ldr	r2, .L119
 2121 050c D258     		ldr	r2, [r2, r3]
 2122 050e 164B     		ldr	r3, .L119+20
 2123 0510 1A60     		str	r2, [r3]
 988:functions.c   **** 		break;
 2124              		.loc 1 988 0
 2125 0512 16E0     		b	.L50
 2126              	.L106:
 989:functions.c   **** 	case 7:
 990:functions.c   **** 		DensityFormationVolts = pFac.pf.GW302_Density7;
 2127              		.loc 1 990 0
 2128 0514 E823     		mov	r3, #232
 2129 0516 0F4A     		ldr	r2, .L119
 2130 0518 D258     		ldr	r2, [r2, r3]
 2131 051a 134B     		ldr	r3, .L119+20
 2132 051c 1A60     		str	r2, [r3]
 991:functions.c   **** 		break;
 2133              		.loc 1 991 0
 2134 051e 10E0     		b	.L50
 2135              	.L107:
 992:functions.c   **** 	case 8:
 993:functions.c   **** 		DensityFormationVolts = pFac.pf.GW302_Density8;
 2136              		.loc 1 993 0
 2137 0520 EC23     		mov	r3, #236
 2138 0522 0C4A     		ldr	r2, .L119
 2139 0524 D258     		ldr	r2, [r2, r3]
 2140 0526 104B     		ldr	r3, .L119+20
 2141 0528 1A60     		str	r2, [r3]
 994:functions.c   **** 		break;
 2142              		.loc 1 994 0
 2143 052a 0AE0     		b	.L50
 2144              	.L108:
 995:functions.c   **** 	case 9:
 996:functions.c   **** 		DensityFormationVolts = pFac.pf.GW302_Density9;
 2145              		.loc 1 996 0
 2146 052c F023     		mov	r3, #240
 2147 052e 094A     		ldr	r2, .L119
 2148 0530 D258     		ldr	r2, [r2, r3]
 2149 0532 0D4B     		ldr	r3, .L119+20
 2150 0534 1A60     		str	r2, [r3]
 997:functions.c   **** 		break;
 2151              		.loc 1 997 0
 2152 0536 04E0     		b	.L50
 2153              	.L99:
 998:functions.c   **** 	default: // 10
 999:functions.c   **** 	DensityFormationVolts = pFac.pf.GW302_Density10;
 2154              		.loc 1 999 0
 2155 0538 F423     		mov	r3, #244
 2156 053a 064A     		ldr	r2, .L119
 2157 053c D258     		ldr	r2, [r2, r3]
 2158 053e 0A4B     		ldr	r3, .L119+20
 2159 0540 1A60     		str	r2, [r3]
 2160              	.L50:
1000:functions.c   **** 	break;
1001:functions.c   **** 	}
1002:functions.c   **** 
1003:functions.c   **** 
1004:functions.c   **** #if 0 // Testing - intermediate inputs & outputs
1005:functions.c   **** 
1006:functions.c   **** 	sprintf( tstring, "VP=%6.5fV", DiaVoltsPer1PercentFullRange ); // Calculated
1007:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 8, FIXED );
1008:functions.c   **** 	sprintf( tstring, "CN=%6.5fV", DiaCorrectionNudgeVolts ); // Calculated
1009:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 18, FIXED );
1010:functions.c   **** 	sprintf( tstring, "MI=%6.5fV", DiaMinVolts ); // Calculated
1011:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 28, FIXED );
1012:functions.c   **** 	sprintf( tstring, "MA=%6.5fV", DiaMaxVolts ); // Calculated
1013:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 38, FIXED );
1014:functions.c   **** 	sprintf( tstring, "PS=%6.5fV", DiaVoltsPerSetting ); // Calculated
1015:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 48, FIXED );
1016:functions.c   **** 	sprintf( tstring, "PP=%6.5fV", DiaVoltsPer1PercentDisplayRange ); // Calculated
1017:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 58, FIXED );
1018:functions.c   **** #endif
1019:functions.c   **** 
1020:functions.c   **** #if 0 // Testing - intermediate inputs & outputs
1021:functions.c   **** 
1022:functions.c   **** 	sprintf( tstring, "ZV=%6.5fV", DiaZeroVolts ); // Calculated
1023:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 8, FIXED );
1024:functions.c   **** 	sprintf( tstring, "FV=%6.5fV", DiaFormationVolts ); // Calculated
1025:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 18, FIXED );
1026:functions.c   **** 	sprintf( tstring, "F2=%6.5fV", DiaFormation2Volts ); // Calculated
1027:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 28, FIXED );
1028:functions.c   **** 	sprintf( tstring, "CV=%6.5fV", DiaCoreVolts ); // Calculated
1029:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 38, FIXED );
1030:functions.c   **** 	sprintf( tstring, "EV=%6.5fV", DiaEngageVolts ); // Calculated
1031:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 48, FIXED );
1032:functions.c   **** 	sprintf( tstring, "PW=%6.5fV", DiaPreWarnVolts ); // Calculated
1033:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 58, FIXED );
1034:functions.c   **** 
1035:functions.c   **** #endif
1036:functions.c   **** 
1037:functions.c   **** #if 0 // Testing - intermediate inputs & outputs
1038:functions.c   **** 
1039:functions.c   **** 	sprintf( tstring, "BD=%6.5fV", DensityBaleVolts ); // Set
1040:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 8, FIXED );
1041:functions.c   **** 	sprintf( tstring, "CD=%6.5fV", DensityCoreVolts ); // Set
1042:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 18, FIXED );
1043:functions.c   **** 	sprintf( tstring, "F2=%6.5fV", DensityFormation2Volts ); // Set
1044:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 28, FIXED );
1045:functions.c   **** 	sprintf( tstring, "FD=%6.5fV", DensityFormationVolts ); // Set
1046:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 38, FIXED );
1047:functions.c   **** 	sprintf( tstring, "On8=%02u Off8=%02u On2=%02u", OP8OnDelayTime, OP8OffDelayTime, OP2OnDelayTime);
1048:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 48, FIXED );
1049:functions.c   **** 	sprintf( tstring, "DV=%6.5fV", DensityPresVolts ); // Input
1050:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 58, FIXED );
1051:functions.c   **** #endif
1052:functions.c   **** 
1053:functions.c   **** #if 0 // Testing - main inputs & outputs
1054:functions.c   **** 
1055:functions.c   **** 	//sprintf( tstring, "ST=%02X SC=%02X", Stage, stagecomp );
1056:functions.c   **** 	//display_f1_text( tstring, TSMAX, 2, 68, FIXED );
1057:functions.c   **** 
1058:functions.c   **** 	sprintf( tstring, "DiMaV=%3.2fV", DiaMaxVolts ); // Calculated
1059:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 8, FIXED );
1060:functions.c   **** 
1061:functions.c   **** 	sprintf( tstring, "DTarV=%3.2fV", DiaTargetVolts );     // Calculated
1062:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 18, FIXED );
1063:functions.c   **** 
1064:functions.c   **** 	sprintf( tstring, "DiMiV=%3.2fV", DiaMinVolts ); // Calculated
1065:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 38, FIXED );
1066:functions.c   **** 
1067:functions.c   **** 	sprintf( tstring, "MiEx%%=%3.2f%%", DiaMinExtDisplayPercent ); // Calculated
1068:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 48, FIXED );
1069:functions.c   **** 
1070:functions.c   **** 	sprintf( tstring, "TaEx%%=%3.2f%%", DiaTargetExtDisplayPercent ); // Calculated
1071:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 58, FIXED );
1072:functions.c   **** 
1073:functions.c   **** 	sprintf( tstring, "BDiE%%=%3.2f%%", BaleDiaExtDisplayPercent ); // Calculated
1074:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 68, FIXED );
1075:functions.c   **** 
1076:functions.c   **** 	sprintf( tstring, "ZV=%6.5fV", DiaZeroVolts ); // Calculated
1077:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 88, FIXED );
1078:functions.c   **** 
1079:functions.c   **** 	sprintf( tstring, "PP=%6.5fV", DiaVoltsPer1PercentDisplayRange ); // Calculated
1080:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 98, FIXED );
1081:functions.c   **** 
1082:functions.c   **** 	sprintf( tstring, "PS=%6.5fV", DiaVoltsPerSetting ); // Calculated
1083:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 108, FIXED );
1084:functions.c   **** 
1085:functions.c   **** #endif
1086:functions.c   **** 
1087:functions.c   **** #if 0 // Testing Analogue inputs
1088:functions.c   **** 	sprintf( tstring, "KnifePresV=%4.3f", KnifePresVolts );
1089:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 48, FIXED );
1090:functions.c   **** 
1091:functions.c   **** 	sprintf( tstring, "BaleDiaV=%4.3f", BaleDiaVolts );
1092:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 58, FIXED );
1093:functions.c   **** 
1094:functions.c   **** 	sprintf( tstring, "DensityPresV=%4.3f", DensityPresVolts );
1095:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 68, FIXED );
1096:functions.c   **** 
1097:functions.c   **** 	sprintf( tstring, "BaleShapeV=%4.3f", BaleShapeVolts );
1098:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 78, FIXED );
1099:functions.c   **** #endif
1100:functions.c   **** 
1101:functions.c   **** #if 0 // Testing - inputs & outputs
1102:functions.c   **** 	sprintf( tstring, "%2.1fV", KnifePresVolts ); // Input Top - left
1103:functions.c   **** 	display_f1_text( tstring, TSMAX, 42, 8, FIXED );
1104:functions.c   **** 
1105:functions.c   **** 	sprintf( tstring, "%2.1fV", BaleShapeVolts ); // Input Top - right
1106:functions.c   **** 	display_f1_text( tstring, TSMAX, 66, 8, FIXED );
1107:functions.c   **** 
1108:functions.c   **** 	sprintf( tstring, "%2.1fV", DensityPresVolts ); // Input Bot - left
1109:functions.c   **** 	display_f1_text( tstring, TSMAX, 42, 18, FIXED );
1110:functions.c   **** 
1111:functions.c   **** 	sprintf( tstring, "%2.1fV", BaleDiaVolts ); // Input Bot - right
1112:functions.c   **** 	display_f1_text( tstring, TSMAX, 66, 18, FIXED );
1113:functions.c   **** #endif
1114:functions.c   **** 
1115:functions.c   **** #if 0 // Testing
1116:functions.c   **** 	sprintf( tstring, "%2.1fHz", NetPulseFrequency );
1117:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 78, FIXED );
1118:functions.c   **** 
1119:functions.c   **** 	sprintf( tstring, "%4u", TargetNetPulses ); // Input Bot - far right
1120:functions.c   **** 	display_f1_text( tstring, TSMAX, 50, 98, FIXED );
1121:functions.c   **** 
1122:functions.c   **** 	sprintf( tstring, "%4u", NetPulseCount ); // Input Bot - farthest far right
1123:functions.c   **** 	display_f1_text( tstring, TSMAX, 84, 98, FIXED );
1124:functions.c   **** 
1125:functions.c   **** 	//sprintf( tstring, "%4u", NetMetresPulseCount ); // Input Bot - farthest far right
1126:functions.c   **** 	//display_f1_text( tstring, TSMAX, 118, 98, FIXED );
1127:functions.c   **** #endif
1128:functions.c   **** 
1129:functions.c   **** #if 0 // Testing pulse counting
1130:functions.c   **** 	sprintf( tstring, "%2.1fHz", NetPulseFrequency );
1131:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 78, FIXED );
1132:functions.c   **** 
1133:functions.c   **** 	sprintf( tstring, "%4u", TargetNetPulses ); // Input Bot - far right
1134:functions.c   **** 	display_f1_text( tstring, TSMAX, 50, 98, FIXED );
1135:functions.c   **** 
1136:functions.c   **** 	sprintf( tstring, "%4u", NetPulseCount ); // Input Bot - farthest far right
1137:functions.c   **** 	display_f1_text( tstring, TSMAX, 84, 98, FIXED );
1138:functions.c   **** 
1139:functions.c   **** 	//sprintf( tstring, "%4u", NetMetresPulseCount ); // Input Bot - farthest far right
1140:functions.c   **** 	//display_f1_text( tstring, TSMAX, 118, 98, FIXED );
1141:functions.c   **** 
1142:functions.c   **** 	sprintf( tstring, "%4u", NewNetPulses ); // Input Bot - far right
1143:functions.c   **** 	display_f1_text( tstring, TSMAX, 50, 88, FIXED );
1144:functions.c   **** 
1145:functions.c   **** 	sprintf( tstring, "%4u", NetPulseCountPrev ); // Input Bot - farthest far right
1146:functions.c   **** 	display_f1_text( tstring, TSMAX, 84, 88, FIXED );
1147:functions.c   **** 
1148:functions.c   **** 	sprintf( tstring, "%4u", NetMetresPulseCount ); // Input Bot - farthest far right
1149:functions.c   **** 	display_f1_text( tstring, TSMAX, 118, 88, FIXED );
1150:functions.c   **** 
1151:functions.c   **** #endif
1152:functions.c   **** 
1153:functions.c   **** #if 0 // Testing net metres, pulse count, target pulses
1154:functions.c   **** 	sprintf( tstring, "MI=%2.1fV", DiaMinVolts ); // Calculated
1155:functions.c   **** 	display_f1_text( tstring, TSMAX, 42, 18, FIXED );
1156:functions.c   **** 
1157:functions.c   **** 	sprintf( tstring, "MA=%2.1fV", DiaMaxVolts ); // Calculated
1158:functions.c   **** 	display_f1_text( tstring, TSMAX, 42, 28, FIXED );
1159:functions.c   **** 
1160:functions.c   **** 	sprintf( tstring, "T=%2.1fV", DiaTargetVolts );     // Calculated
1161:functions.c   **** 	display_f1_text( tstring, TSMAX, 42, 38, FIXED );
1162:functions.c   **** 
1163:functions.c   **** 	sprintf( tstring, "ST=%02X", Stage );
1164:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 58, FIXED );
1165:functions.c   **** 
1166:functions.c   **** 	sprintf( tstring, "SC=%02X", stagecomp );
1167:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 68, FIXED );
1168:functions.c   **** 
1169:functions.c   **** 	/*sprintf( tstring, "%6u", TotalNetMetresLastSaved ); // NOT USED NOW
1170:functions.c   ****     display_f1_text( tstring, TSMAX, 2, 78, FIXED );*/
1171:functions.c   **** 
1172:functions.c   **** 	sprintf( tstring, "%2.1fHz", NetPulseFrequency );
1173:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 78, FIXED );
1174:functions.c   **** 
1175:functions.c   **** 	sprintf( tstring, "%2.1fV", KnifePresVolts ); // Input Top - left
1176:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 88, FIXED );
1177:functions.c   **** 
1178:functions.c   **** 	sprintf( tstring, "%2.1fV", BaleShapeVolts ); // Input Top - right
1179:functions.c   **** 	display_f1_text( tstring, TSMAX, 26, 88, FIXED );
1180:functions.c   **** 
1181:functions.c   **** 	sprintf( tstring, "%2.1fp/l", NetPulsesPerLayer ); // Input Top - far right
1182:functions.c   **** 	display_f1_text( tstring, TSMAX, 50, 88, FIXED );
1183:functions.c   **** 
1184:functions.c   **** 	sprintf( tstring, "%2.1fV", DensityPresVolts ); // Input Bot - left
1185:functions.c   **** 	display_f1_text( tstring, TSMAX, 2, 98, FIXED );
1186:functions.c   **** 
1187:functions.c   **** 	sprintf( tstring, "%2.1fV", BaleDiaVolts ); // Input Bot - right
1188:functions.c   **** 	display_f1_text( tstring, TSMAX, 26, 98, FIXED );
1189:functions.c   **** 
1190:functions.c   **** 	sprintf( tstring, "%u p", TargetNetPulses ); // Input Bot - far right
1191:functions.c   **** 	display_f1_text( tstring, TSMAX, 50, 98, FIXED );
1192:functions.c   **** 
1193:functions.c   **** 	sprintf( tstring, "%u p", NetPulseCount ); // Input Bot - farthest far right
1194:functions.c   **** 	display_f1_text( tstring, TSMAX, 74, 98, FIXED );
1195:functions.c   **** #endif
1196:functions.c   **** 
1197:functions.c   **** #if 0 // Testing Count for Net Pulses (on IP4) to stop after Target Pulses reached for Net Cut (OP7
1198:functions.c   **** 	sprintf( tstring, "NPC=%u", NetPulseCount );
1199:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  8, FIXED );
1200:functions.c   **** 
1201:functions.c   **** 	sprintf( tstring, "LST=%u", NetPulseCountAtLastCheck );
1202:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  18, FIXED );
1203:functions.c   **** 
1204:functions.c   **** 	sprintf( tstring, "OP7=%u", OP7OffDelayTime );
1205:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  28, FIXED );
1206:functions.c   **** 
1207:functions.c   **** 	sprintf( tstring, "STP=%u", IP4PulsesStoppedCount );
1208:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  38, FIXED );
1209:functions.c   **** #endif
1210:functions.c   **** 
1211:functions.c   **** #if 0 // Testing Analogue inputs
1212:functions.c   **** 	sprintf( tstring, "D1=%4.3f", BaleDiaVolts );
1213:functions.c   **** 	display_f1_text( tstring, TSMAX, 69, 28, FIXED );
1214:functions.c   **** 
1215:functions.c   **** 	sprintf( tstring, "P2=%4.3f", DensityPresVolts );
1216:functions.c   **** 	display_f1_text( tstring, TSMAX, 69, 78, FIXED );
1217:functions.c   **** 
1218:functions.c   **** 	sprintf( tstring, "S3=%4.3f", BaleShapeVolts );
1219:functions.c   **** 	display_f1_text( tstring, TSMAX, 69, 88, FIXED );
1220:functions.c   **** 
1221:functions.c   **** 	sprintf( tstring, "K4=%4.3f", KnifePresVolts );
1222:functions.c   **** 	display_f1_text( tstring, TSMAX, 69, 98, FIXED );
1223:functions.c   **** #endif
1224:functions.c   **** 
1225:functions.c   **** #if 0 // Testing memory
1226:functions.c   **** 	sprintf( tstring, "F=%3u", sizeof(pFac.pf) );
1227:functions.c   **** 	display_f1_text( tstring, TSMAX, 127, 16, FIXED );
1228:functions.c   **** 
1229:functions.c   **** 	sprintf( tstring, "R=%3u", sizeof(pRun.pr) );
1230:functions.c   **** 	display_f1_text( tstring, TSMAX, 127, 26, FIXED );
1231:functions.c   **** 
1232:functions.c   **** 	sprintf( tstring, "RF=%1u", TestOutputReadMemAllocFail);
1233:functions.c   **** 	display_f1_text( tstring, TSMAX, 127, 48, FIXED );
1234:functions.c   **** 
1235:functions.c   **** 	sprintf( tstring, "WF=%1u", TestOutputWriteMemAllocFail);
1236:functions.c   **** 	display_f1_text( tstring, TSMAX, 127, 58, FIXED );
1237:functions.c   **** #endif
1238:functions.c   **** 
1239:functions.c   **** #if 0 // Testing BaleKickerStatus & BaleDiameterStatusInManMode & ChamberStatus
1240:functions.c   **** 	sprintf( tstring, "BKS=%02X", BaleKickerStatus );
1241:functions.c   **** 	display_f1_text( tstring, TSMAX, 3, 78, FIXED );
1242:functions.c   **** 
1243:functions.c   **** 	sprintf( tstring, "BDSIMM=%02X", BaleDiameterStatusInManMode );
1244:functions.c   **** 	display_f1_text( tstring, TSMAX, 3, 88, FIXED );
1245:functions.c   **** 
1246:functions.c   **** 	sprintf( tstring, "CS=%02X", ChamberStatus );
1247:functions.c   **** 	display_f1_text( tstring, TSMAX, 3, 98, FIXED );
1248:functions.c   **** #endif
1249:functions.c   **** 
1250:functions.c   **** #if 0 // Testing Net Pulses (on IP4)
1251:functions.c   **** 	sprintf( tstring, "NPC=%3lu", NetPulseCount ); // added l
1252:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  8, FIXED );
1253:functions.c   **** 
1254:functions.c   **** 	sprintf( tstring, "TNP=%3u", TargetNetPulses );
1255:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  18, FIXED );
1256:functions.c   **** 
1257:functions.c   **** 	sprintf( tstring, "LST=%3u", NetPulseCountAtLastCheck );
1258:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  28, FIXED );
1259:functions.c   **** 
1260:functions.c   **** 	sprintf( tstring, "OP7=%3u", OP7OffDelayTime );
1261:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  38, FIXED );
1262:functions.c   **** 
1263:functions.c   **** 	sprintf( tstring, "STP=%3u", IP4PulsesStoppedCount );
1264:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  48, FIXED );
1265:functions.c   **** 
1266:functions.c   **** 	sprintf( tstring, "BEP=%3lu", BeakEngagePulseCount ); // added l
1267:functions.c   **** 	display_f1_text( tstring, TSMAX, 69,  58, FIXED );
1268:functions.c   **** #endif
1269:functions.c   **** 
1270:functions.c   **** #if 0 //#ifdef DEVELOP // Testing pulse counting -- Incl. testing Pre Net Pulses & Beak Engage Puls
1271:functions.c   **** 	sprintf( tstring, "  NPC=%4lu", NetPulseCount );
1272:functions.c   **** 	display_f1_text( tstring, TSMAX, 49,  8, FIXED );
1273:functions.c   **** 
1274:functions.c   **** 	sprintf( tstring, " SNPC=%4lu", Saved_NetPulseCount );
1275:functions.c   **** 	display_f1_text( tstring, TSMAX, 49,  18, FIXED );
1276:functions.c   **** 
1277:functions.c   **** 	sprintf( tstring, " TNPC=%4u", TargetNetPulses );
1278:functions.c   **** 	display_f1_text( tstring, TSMAX, 49,  28, FIXED );
1279:functions.c   **** 
1280:functions.c   **** 	sprintf( tstring, "SPNPC=%4lu", SavedPreNetPulseCount );
1281:functions.c   **** 	display_f1_text( tstring, TSMAX, 49,  38, FIXED );
1282:functions.c   **** 
1283:functions.c   **** 	sprintf( tstring, "TPNPC=%4lu", TargetPreNetPulseCount );
1284:functions.c   **** 	display_f1_text( tstring, TSMAX, 49,  48, FIXED );
1285:functions.c   **** 
1286:functions.c   **** 	sprintf( tstring, " BEPC=%4lu", BeakEngagePulseCount );
1287:functions.c   **** 	display_f1_text( tstring, TSMAX, 49,  58, FIXED );
1288:functions.c   **** 
1289:functions.c   **** 	sprintf( tstring, "SBEPC=%4lu", SavedBeakEngagePulseCount );
1290:functions.c   **** 	display_f1_text( tstring, TSMAX, 49,  68, FIXED );
1291:functions.c   **** 
1292:functions.c   **** 	sprintf( tstring, "TBEPC=%4lu", (unsigned long int)pFac.pf.GW302_BeakEngage );
1293:functions.c   **** 	display_f1_text( tstring, TSMAX, 49,  78, FIXED );
1294:functions.c   **** #endif
1295:functions.c   **** 
1296:functions.c   **** #ifdef DEVELOP // Testing state machine
1297:functions.c   **** 	sprintf( tstring, "ST=%02X", Stage );
1298:functions.c   **** 	display_f1_text( tstring, TSMAX, 3, 58, FIXED );
1299:functions.c   **** 
1300:functions.c   **** 	sprintf( tstring, "SC=%02X", stagecomp );
1301:functions.c   **** 	display_f1_text( tstring, TSMAX, 3, 68, FIXED );
1302:functions.c   **** #endif
1303:functions.c   **** 
1304:functions.c   **** }
 2161              		.loc 1 1304 0
 2162 0542 03B0     		add	sp, sp, #12
 2163              		@ sp needed for prologue
 2164              	.LVL150:
 2165 0544 3CBC     		pop	{r2, r3, r4, r5}
 2166 0546 9046     		mov	r8, r2
 2167 0548 9946     		mov	r9, r3
 2168 054a A246     		mov	sl, r4
 2169 054c AB46     		mov	fp, r5
 2170 054e F0BC     		pop	{r4, r5, r6, r7}
 2171 0550 01BC     		pop	{r0}
 2172 0552 0047     		bx	r0
 2173              	.L120:
 2174              		.align	2
 2175              	.L119:
 2176 0554 00000000 		.word	.LANCHOR0
 2177 0558 00000000 		.word	DensityCoreVolts
 2178 055c 50000000 		.word	.L97
 2179 0560 00000000 		.word	DensityFormation2Volts
 2180 0564 78000000 		.word	.L109
 2181 0568 00000000 		.word	DensityFormationVolts
 2182              		.cfi_endproc
 2183              	.LFE385:
 2185              		.global	__aeabi_dcmpgt
 2186              		.global	__aeabi_dcmplt
 2187 056c C046C046 		.section	.text.CheckAlarms,"ax",%progbits
 2188              		.align	2
 2189              		.global	CheckAlarms
 2190              		.code	16
 2191              		.thumb_func
 2193              	CheckAlarms:
 2194              	.LFB386:
1305:functions.c   **** // -----------------------------------------------------------
1306:functions.c   **** 
1307:functions.c   **** 
1308:functions.c   **** // -----------------------------------------------------------
1309:functions.c   **** // Function Name       : CheckAlarms
1310:functions.c   **** // -----------------------------------------------------------
1311:functions.c   **** void CheckAlarms( void )
1312:functions.c   **** {
 2195              		.loc 1 1312 0
 2196              		.cfi_startproc
 2197 0000 30B5     		push	{r4, r5, lr}
 2198              	.LCFI15:
 2199              		.cfi_def_cfa_offset 12
 2200              		.cfi_offset 4, -12
 2201              		.cfi_offset 5, -8
 2202              		.cfi_offset 14, -4
 2203 0002 83B0     		sub	sp, sp, #12
 2204              	.LCFI16:
 2205              		.cfi_def_cfa_offset 24
1313:functions.c   **** 
1314:functions.c   **** 	// -----------------------------------------------------------
1315:functions.c   **** 	// Density Pressure Too High Warning
1316:functions.c   **** 
1317:functions.c   **** 	if( DensityPresVolts > DPV_DENSITY_PRESSURE_TOO_HIGH_VOLTS )
 2206              		.loc 1 1317 0
 2207 0004 AE4B     		ldr	r3, .L152+16
 2208 0006 1868     		ldr	r0, [r3]
 2209 0008 FFF7FEFF 		bl	__aeabi_f2d
 2210              	.LVL151:
 2211 000c 041C     		mov	r4, r0
 2212 000e 0D1C     		mov	r5, r1
 2213 0010 A84B     		ldr	r3, .L152+4
 2214 0012 A74A     		ldr	r2, .L152
 2215 0014 FFF7FEFF 		bl	__aeabi_dcmpgt
 2216              	.LVL152:
 2217 0018 0028     		cmp	r0, #0
 2218 001a 1CD0     		beq	.L150
1318:functions.c   **** 	{
1319:functions.c   **** 		if( !(MWarn & MW_DENSITYPRESS) )
 2219              		.loc 1 1319 0
 2220 001c A94B     		ldr	r3, .L152+20
 2221 001e 1B78     		ldrb	r3, [r3]
 2222 0020 DA07     		lsl	r2, r3, #31
 2223 0022 0DD4     		bmi	.L124
1320:functions.c   **** 		{
1321:functions.c   **** 			MWarn |= MW_DENSITYPRESS;
 2224              		.loc 1 1321 0
 2225 0024 0122     		mov	r2, #1
 2226 0026 0121     		mov	r1, #1
 2227 0028 0B43     		orr	r3, r1
 2228 002a A649     		ldr	r1, .L152+20
 2229 002c 0B70     		strb	r3, [r1]
1322:functions.c   **** 			OKWarnBox = EXCL;
 2230              		.loc 1 1322 0
 2231 002e A64B     		ldr	r3, .L152+24
 2232 0030 1A70     		strb	r2, [r3]
1323:functions.c   **** 
1324:functions.c   **** 			// Sounding 1 beep when message first appears
1325:functions.c   **** 			buzz_count = 1;
 2233              		.loc 1 1325 0
 2234 0032 A64B     		ldr	r3, .L152+28
 2235 0034 1A70     		strb	r2, [r3]
1326:functions.c   **** 			buzz_length = 250;
 2236              		.loc 1 1326 0
 2237 0036 FA21     		mov	r1, #250
 2238 0038 A54B     		ldr	r3, .L152+32
 2239 003a 1960     		str	r1, [r3]
1327:functions.c   **** 
1328:functions.c   **** 			DensityPressureTooHigh = 1;
 2240              		.loc 1 1328 0
 2241 003c A54B     		ldr	r3, .L152+36
 2242 003e 1A70     		strb	r2, [r3]
 2243              	.L124:
1329:functions.c   **** 		}
1330:functions.c   **** 
1331:functions.c   **** 		// Sounding warning every second
1332:functions.c   **** 		if( !half_second )
 2244              		.loc 1 1332 0
 2245 0040 A54B     		ldr	r3, .L152+40
 2246 0042 1B78     		ldrb	r3, [r3]
 2247 0044 002B     		cmp	r3, #0
 2248 0046 1DD1     		bne	.L125
1333:functions.c   **** 		{
1334:functions.c   **** 			buzz_count = 1;
 2249              		.loc 1 1334 0
 2250 0048 0122     		mov	r2, #1
 2251 004a A04B     		ldr	r3, .L152+28
 2252 004c 1A70     		strb	r2, [r3]
1335:functions.c   **** 			buzz_length = 250;
 2253              		.loc 1 1335 0
 2254 004e FA22     		mov	r2, #250
 2255 0050 9F4B     		ldr	r3, .L152+32
 2256 0052 1A60     		str	r2, [r3]
 2257 0054 16E0     		b	.L125
 2258              	.L150:
1336:functions.c   **** 		}
1337:functions.c   **** 	}
1338:functions.c   **** 	else if( DensityPresVolts < (DPV_DENSITY_PRESSURE_TOO_HIGH_VOLTS - DPV_DENSITY_PRESSURE_TOO_HIGH_V
 2259              		.loc 1 1338 0
 2260 0056 201C     		mov	r0, r4
 2261 0058 291C     		mov	r1, r5
 2262 005a 974A     		ldr	r2, .L152+8
 2263 005c 974B     		ldr	r3, .L152+12
 2264 005e FFF7FEFF 		bl	__aeabi_dcmplt
 2265              	.LVL153:
 2266 0062 0028     		cmp	r0, #0
 2267 0064 0ED0     		beq	.L125
1339:functions.c   **** 	{
1340:functions.c   **** 		if( MWarn & MW_DENSITYPRESS )
 2268              		.loc 1 1340 0
 2269 0066 974B     		ldr	r3, .L152+20
 2270 0068 1B78     		ldrb	r3, [r3]
 2271 006a DA07     		lsl	r2, r3, #31
 2272 006c 0AD5     		bpl	.L125
1341:functions.c   **** 		{
1342:functions.c   **** 			MWarn &= ~MW_DENSITYPRESS;
 2273              		.loc 1 1342 0
 2274 006e 0122     		mov	r2, #1
 2275 0070 9343     		bic	r3, r2
 2276 0072 9449     		ldr	r1, .L152+20
 2277 0074 0B70     		strb	r3, [r1]
1343:functions.c   **** 			OKWarnBox &= ~EXCL;
 2278              		.loc 1 1343 0
 2279 0076 944B     		ldr	r3, .L152+24
 2280 0078 1978     		ldrb	r1, [r3]
 2281 007a 9143     		bic	r1, r2
 2282 007c 1970     		strb	r1, [r3]
1344:functions.c   **** 
1345:functions.c   **** 			DensityPressureTooHigh = 0;
 2283              		.loc 1 1345 0
 2284 007e 0022     		mov	r2, #0
 2285 0080 944B     		ldr	r3, .L152+36
 2286 0082 1A70     		strb	r2, [r3]
 2287              	.L125:
1346:functions.c   **** 		}
1347:functions.c   **** 	}
1348:functions.c   **** 
1349:functions.c   **** 
1350:functions.c   **** 	// -----------------------------------------------------------
1351:functions.c   **** 	// Check Net Error (AKA Net Warning)
1352:functions.c   **** 	if(pFac.pf.GW302_NetTwineOption == TO_NET) /**/
 2288              		.loc 1 1352 0
 2289 0084 7C23     		mov	r3, #124
 2290 0086 954A     		ldr	r2, .L152+44
 2291 0088 D35C     		ldrb	r3, [r2, r3]
 2292 008a 002B     		cmp	r3, #0
 2293 008c 21D1     		bne	.L127
1353:functions.c   **** 	{
1354:functions.c   **** 		if( NetWarningOn )
 2294              		.loc 1 1354 0
 2295 008e 944B     		ldr	r3, .L152+48
 2296 0090 1B78     		ldrb	r3, [r3]
 2297 0092 002B     		cmp	r3, #0
 2298 0094 10D0     		beq	.L128
1355:functions.c   **** 		{
1356:functions.c   **** 			if( !(MWarn & MW_CHECKNET) )
 2299              		.loc 1 1356 0
 2300 0096 8B4B     		ldr	r3, .L152+20
 2301 0098 1B78     		ldrb	r3, [r3]
 2302 009a 9A07     		lsl	r2, r3, #30
 2303 009c 19D4     		bmi	.L127
1357:functions.c   **** 			{
1358:functions.c   **** 				MWarn |= MW_CHECKNET;
 2304              		.loc 1 1358 0
 2305 009e 0222     		mov	r2, #2
 2306 00a0 1343     		orr	r3, r2
 2307 00a2 884A     		ldr	r2, .L152+20
 2308 00a4 1370     		strb	r3, [r2]
1359:functions.c   **** 				OKWarnBox = EXCL;
 2309              		.loc 1 1359 0
 2310 00a6 0123     		mov	r3, #1
 2311 00a8 874A     		ldr	r2, .L152+24
 2312 00aa 1370     		strb	r3, [r2]
1360:functions.c   **** 
1361:functions.c   **** 				// Sounding 1 beep when message first appears
1362:functions.c   **** 				buzz_count = 1;
 2313              		.loc 1 1362 0
 2314 00ac 874A     		ldr	r2, .L152+28
 2315 00ae 1370     		strb	r3, [r2]
1363:functions.c   **** 				buzz_length = 250;
 2316              		.loc 1 1363 0
 2317 00b0 FA22     		mov	r2, #250
 2318 00b2 874B     		ldr	r3, .L152+32
 2319 00b4 1A60     		str	r2, [r3]
 2320 00b6 0CE0     		b	.L127
 2321              	.L128:
1364:functions.c   **** 			}
1365:functions.c   **** 		}
1366:functions.c   **** 		else // !NetWarningOn
1367:functions.c   **** 		{
1368:functions.c   **** 			if( MWarn & MW_CHECKNET )
 2322              		.loc 1 1368 0
 2323 00b8 824B     		ldr	r3, .L152+20
 2324 00ba 1B78     		ldrb	r3, [r3]
 2325 00bc 9A07     		lsl	r2, r3, #30
 2326 00be 08D5     		bpl	.L127
1369:functions.c   **** 			{
1370:functions.c   **** 				MWarn &= ~MW_CHECKNET;
 2327              		.loc 1 1370 0
 2328 00c0 0222     		mov	r2, #2
 2329 00c2 9343     		bic	r3, r2
 2330 00c4 7F4A     		ldr	r2, .L152+20
 2331 00c6 1370     		strb	r3, [r2]
1371:functions.c   **** 				OKWarnBox &= ~EXCL;
 2332              		.loc 1 1371 0
 2333 00c8 7F4B     		ldr	r3, .L152+24
 2334 00ca 1A78     		ldrb	r2, [r3]
 2335 00cc 0121     		mov	r1, #1
 2336 00ce 8A43     		bic	r2, r1
 2337 00d0 1A70     		strb	r2, [r3]
 2338              	.L127:
1372:functions.c   **** 			}
1373:functions.c   **** 		}
1374:functions.c   **** 	}
1375:functions.c   **** 
1376:functions.c   **** 
1377:functions.c   **** 
1378:functions.c   **** 	// -----------------------------------------------------------
1379:functions.c   **** 	// Drop Floor (AKA Floor Position) Warning
1380:functions.c   **** 
1381:functions.c   **** 	if( !FLOOR_WORKING_POS )
 2339              		.loc 1 1381 0
 2340 00d2 844B     		ldr	r3, .L152+52
 2341 00d4 DB6B     		ldr	r3, [r3, #60]
 2342 00d6 DA04     		lsl	r2, r3, #19
 2343 00d8 10D4     		bmi	.L129
1382:functions.c   **** 	{
1383:functions.c   **** 		if( !(MWarn & MW_DROPFLOOR) )
 2344              		.loc 1 1383 0
 2345 00da 7A4B     		ldr	r3, .L152+20
 2346 00dc 1B78     		ldrb	r3, [r3]
 2347 00de 5A07     		lsl	r2, r3, #29
 2348 00e0 19D4     		bmi	.L130
1384:functions.c   **** 		{
1385:functions.c   **** 			MWarn |= MW_DROPFLOOR;
 2349              		.loc 1 1385 0
 2350 00e2 0422     		mov	r2, #4
 2351 00e4 1343     		orr	r3, r2
 2352 00e6 774A     		ldr	r2, .L152+20
 2353 00e8 1370     		strb	r3, [r2]
1386:functions.c   **** 			OKWarnBox = EXCL;
 2354              		.loc 1 1386 0
 2355 00ea 0123     		mov	r3, #1
 2356 00ec 764A     		ldr	r2, .L152+24
 2357 00ee 1370     		strb	r3, [r2]
1387:functions.c   **** 
1388:functions.c   **** 			// Sounding 1 beep when message first appears
1389:functions.c   **** 			buzz_count = 1;
 2358              		.loc 1 1389 0
 2359 00f0 764A     		ldr	r2, .L152+28
 2360 00f2 1370     		strb	r3, [r2]
1390:functions.c   **** 			buzz_length = 250;
 2361              		.loc 1 1390 0
 2362 00f4 FA22     		mov	r2, #250
 2363 00f6 764B     		ldr	r3, .L152+32
 2364 00f8 1A60     		str	r2, [r3]
 2365 00fa 0CE0     		b	.L130
 2366              	.L129:
1391:functions.c   **** 
1392:functions.c   **** 		}
1393:functions.c   **** 	}
1394:functions.c   **** 	else  // Floor (Position) Sensor closed
1395:functions.c   **** 	{
1396:functions.c   **** 		if( MWarn & MW_DROPFLOOR )
 2367              		.loc 1 1396 0
 2368 00fc 714B     		ldr	r3, .L152+20
 2369 00fe 1B78     		ldrb	r3, [r3]
 2370 0100 5A07     		lsl	r2, r3, #29
 2371 0102 08D5     		bpl	.L130
1397:functions.c   **** 		{
1398:functions.c   **** 			MWarn &= ~MW_DROPFLOOR;
 2372              		.loc 1 1398 0
 2373 0104 0422     		mov	r2, #4
 2374 0106 9343     		bic	r3, r2
 2375 0108 6E4A     		ldr	r2, .L152+20
 2376 010a 1370     		strb	r3, [r2]
1399:functions.c   **** 			OKWarnBox &= ~EXCL;
 2377              		.loc 1 1399 0
 2378 010c 6E4B     		ldr	r3, .L152+24
 2379 010e 1A78     		ldrb	r2, [r3]
 2380 0110 0121     		mov	r1, #1
 2381 0112 8A43     		bic	r2, r1
 2382 0114 1A70     		strb	r2, [r3]
 2383              	.L130:
1400:functions.c   **** 		}
1401:functions.c   **** 	}
1402:functions.c   **** 
1403:functions.c   **** 
1404:functions.c   **** 	// -----------------------------------------------------------
1405:functions.c   **** 	// Knife Maximum Pressure Warning
1406:functions.c   **** 	// Inhibited when:
1407:functions.c   **** 	// - 'Chopping Knives Fitted' set to disabled -- Chopping Knives not fitted
1408:functions.c   **** 	// - Outside Right (OR) button pressed while first screen displayed
1409:functions.c   **** 
1410:functions.c   **** 	if( pFac.pf.GW302_ChoppingKnivesFitted == CKF_ENABLED ) // 'Chopping Knives Fitted' set to enabled
 2384              		.loc 1 1410 0
 2385 0116 8C23     		mov	r3, #140
 2386 0118 5B00     		lsl	r3, r3, #1
 2387 011a 704A     		ldr	r2, .L152+44
 2388 011c D35C     		ldrb	r3, [r2, r3]
 2389 011e 012B     		cmp	r3, #1
 2390 0120 3DD1     		bne	.L131
1411:functions.c   **** 	{
1412:functions.c   **** 		if( (KnifePresVolts > pFac.pf.GW302_KnifePresWarn) &&
 2391              		.loc 1 1412 0
 2392 0122 FC23     		mov	r3, #252
 2393 0124 D058     		ldr	r0, [r2, r3]
 2394 0126 704B     		ldr	r3, .L152+56
 2395 0128 1968     		ldr	r1, [r3]
 2396 012a FFF7FEFF 		bl	__aeabi_fcmplt
 2397              	.LVL154:
 2398 012e 0028     		cmp	r0, #0
 2399 0130 28D0     		beq	.L132
1413:functions.c   **** 				( ((key & ~(SW_NEW | SW_REP)) != SW_OR) || SecondScreen ) )
 2400              		.loc 1 1413 0 discriminator 1
 2401 0132 6E4B     		ldr	r3, .L152+60
 2402 0134 1A68     		ldr	r2, [r3]
 2403 0136 9200     		lsl	r2, r2, #2
 2404 0138 9208     		lsr	r2, r2, #2
1412:functions.c   **** 		if( (KnifePresVolts > pFac.pf.GW302_KnifePresWarn) &&
 2405              		.loc 1 1412 0 discriminator 1
 2406 013a 8023     		mov	r3, #128
 2407 013c 5B00     		lsl	r3, r3, #1
 2408 013e 9A42     		cmp	r2, r3
 2409 0140 03D1     		bne	.L134
 2410              		.loc 1 1413 0
 2411 0142 6B4B     		ldr	r3, .L152+64
 2412 0144 1B78     		ldrb	r3, [r3]
 2413 0146 002B     		cmp	r3, #0
 2414 0148 1CD0     		beq	.L132
 2415              	.L134:
1414:functions.c   **** 		{
1415:functions.c   **** 			if( !(MWarn & MW_KNIFEPRES) )
 2416              		.loc 1 1415 0
 2417 014a 5E4B     		ldr	r3, .L152+20
 2418 014c 1B78     		ldrb	r3, [r3]
 2419 014e 1A07     		lsl	r2, r3, #28
 2420 0150 09D4     		bmi	.L135
1416:functions.c   **** 			{
1417:functions.c   **** 				//buzz_count = 1;
1418:functions.c   **** 				swrel = 0; /* search for if( looptime > 3 ) in screen.c */
 2421              		.loc 1 1418 0
 2422 0152 0021     		mov	r1, #0
 2423 0154 674A     		ldr	r2, .L152+68
 2424 0156 1170     		strb	r1, [r2]
1419:functions.c   **** 				MWarn |= MW_KNIFEPRES;
 2425              		.loc 1 1419 0
 2426 0158 0822     		mov	r2, #8
 2427 015a 1343     		orr	r3, r2
 2428 015c 594A     		ldr	r2, .L152+20
 2429 015e 1370     		strb	r3, [r2]
1420:functions.c   **** 				OKWarnBox = EXCL;
 2430              		.loc 1 1420 0
 2431 0160 0122     		mov	r2, #1
 2432 0162 594B     		ldr	r3, .L152+24
 2433 0164 1A70     		strb	r2, [r3]
 2434              	.L135:
1421:functions.c   **** 			}
1422:functions.c   **** 
1423:functions.c   **** 			if( !(swrel % 30) )
 2435              		.loc 1 1423 0
 2436 0166 634B     		ldr	r3, .L152+68
 2437 0168 1878     		ldrb	r0, [r3]
 2438 016a 1E21     		mov	r1, #30
 2439 016c FFF7FEFF 		bl	__aeabi_uidivmod
 2440              	.LVL155:
 2441 0170 0906     		lsl	r1, r1, #24
 2442 0172 14D1     		bne	.L131
1424:functions.c   **** 			{
1425:functions.c   **** 				//buzz_count = 1;  // 100ms beep every 3 seconds.
1426:functions.c   **** 				if( !DelayTime )  // When other beeps are going on
 2443              		.loc 1 1426 0
 2444 0174 604B     		ldr	r3, .L152+72
 2445 0176 1B78     		ldrb	r3, [r3]
 2446 0178 002B     		cmp	r3, #0
 2447 017a 10D1     		bne	.L131
1427:functions.c   **** 				{
1428:functions.c   **** 					buzz_length = 250;
 2448              		.loc 1 1428 0
 2449 017c FA22     		mov	r2, #250
 2450 017e 544B     		ldr	r3, .L152+32
 2451 0180 1A60     		str	r2, [r3]
 2452 0182 0CE0     		b	.L131
 2453              	.L132:
1429:functions.c   **** 				}
1430:functions.c   **** 			}
1431:functions.c   **** 		}
1432:functions.c   **** 		else // (KnifePresVolts <= pFac.pf.GW302_KnifePresWarn) or OR button pressed
1433:functions.c   **** 		{
1434:functions.c   **** 			if( MWarn & MW_KNIFEPRES )
 2454              		.loc 1 1434 0
 2455 0184 4F4B     		ldr	r3, .L152+20
 2456 0186 1B78     		ldrb	r3, [r3]
 2457 0188 1A07     		lsl	r2, r3, #28
 2458 018a 08D5     		bpl	.L131
1435:functions.c   **** 			{
1436:functions.c   **** 				MWarn &= ~MW_KNIFEPRES;
 2459              		.loc 1 1436 0
 2460 018c 0822     		mov	r2, #8
 2461 018e 9343     		bic	r3, r2
 2462 0190 4C4A     		ldr	r2, .L152+20
 2463 0192 1370     		strb	r3, [r2]
1437:functions.c   **** 				OKWarnBox &= ~EXCL;
 2464              		.loc 1 1437 0
 2465 0194 4C4B     		ldr	r3, .L152+24
 2466 0196 1A78     		ldrb	r2, [r3]
 2467 0198 0121     		mov	r1, #1
 2468 019a 8A43     		bic	r2, r1
 2469 019c 1A70     		strb	r2, [r3]
 2470              	.L131:
1438:functions.c   **** 			}
1439:functions.c   **** 		}
1440:functions.c   **** 	}
1441:functions.c   **** 
1442:functions.c   **** 
1443:functions.c   **** 	// -----------------------------------------------------------
1444:functions.c   **** 	// Chopping knives position Warning
1445:functions.c   **** 
1446:functions.c   **** 	if( DisableChoppingKnivesWarnings ) // Disabling prevents chopping knives position warning from co
 2471              		.loc 1 1446 0
 2472 019e 574B     		ldr	r3, .L152+76
 2473 01a0 1B78     		ldrb	r3, [r3]
 2474 01a2 002B     		cmp	r3, #0
 2475 01a4 10D0     		beq	.L136
1447:functions.c   **** 	{
1448:functions.c   **** 		if( MWarn & MW_CHOPKNIVPOS1 )
 2476              		.loc 1 1448 0
 2477 01a6 474B     		ldr	r3, .L152+20
 2478 01a8 1B78     		ldrb	r3, [r3]
 2479 01aa DA06     		lsl	r2, r3, #27
 2480 01ac 08D5     		bpl	.L137
1449:functions.c   **** 		{
1450:functions.c   **** 			// Both warnings disabled
1451:functions.c   **** 			MWarn &= ~(MW_CHOPKNIVPOS1);
 2481              		.loc 1 1451 0
 2482 01ae 1022     		mov	r2, #16
 2483 01b0 9343     		bic	r3, r2
 2484 01b2 444A     		ldr	r2, .L152+20
 2485 01b4 1370     		strb	r3, [r2]
1452:functions.c   **** 			OKWarnBox &= ~EXCL;
 2486              		.loc 1 1452 0
 2487 01b6 444B     		ldr	r3, .L152+24
 2488 01b8 1A78     		ldrb	r2, [r3]
 2489 01ba 0121     		mov	r1, #1
 2490 01bc 8A43     		bic	r2, r1
 2491 01be 1A70     		strb	r2, [r3]
 2492              	.L137:
1453:functions.c   **** 		}
1454:functions.c   **** 
1455:functions.c   **** 		// Chopping knives position Warning turned off
1456:functions.c   **** 		ChoppingKnives1WarningOn = 0;
 2493              		.loc 1 1456 0
 2494 01c0 0022     		mov	r2, #0
 2495 01c2 4F4B     		ldr	r3, .L152+80
 2496 01c4 1A70     		strb	r2, [r3]
 2497 01c6 13E0     		b	.L138
 2498              	.L136:
1457:functions.c   **** 	}
1458:functions.c   **** 	else if( ChoppingKnives1WarningOn ) // Chopping knives position Warning on
1459:functions.c   **** 	{
1460:functions.c   **** 		if( ChoppingKnives1WarningOn )
 2499              		.loc 1 1460 0
 2500 01c8 4D4B     		ldr	r3, .L152+80
 2501 01ca 1B78     		ldrb	r3, [r3]
 2502 01cc 002B     		cmp	r3, #0
 2503 01ce 0FD0     		beq	.L138
1461:functions.c   **** 		{
1462:functions.c   **** 			if( !(MWarn & MW_CHOPKNIVPOS1) )
 2504              		.loc 1 1462 0
 2505 01d0 3C4B     		ldr	r3, .L152+20
 2506 01d2 1B78     		ldrb	r3, [r3]
 2507 01d4 DA06     		lsl	r2, r3, #27
 2508 01d6 0BD4     		bmi	.L138
1463:functions.c   **** 			{
1464:functions.c   **** 				MWarn |= MW_CHOPKNIVPOS1;
 2509              		.loc 1 1464 0
 2510 01d8 1022     		mov	r2, #16
 2511 01da 1343     		orr	r3, r2
 2512 01dc 394A     		ldr	r2, .L152+20
 2513 01de 1370     		strb	r3, [r2]
1465:functions.c   **** 				OKWarnBox = EXCL;
 2514              		.loc 1 1465 0
 2515 01e0 0123     		mov	r3, #1
 2516 01e2 394A     		ldr	r2, .L152+24
 2517 01e4 1370     		strb	r3, [r2]
1466:functions.c   **** 
1467:functions.c   **** 				// Sounding 1 beep when message first appears
1468:functions.c   **** 				buzz_count = 1;
 2518              		.loc 1 1468 0
 2519 01e6 394A     		ldr	r2, .L152+28
 2520 01e8 1370     		strb	r3, [r2]
1469:functions.c   **** 				buzz_length = 250;
 2521              		.loc 1 1469 0
 2522 01ea FA22     		mov	r2, #250
 2523 01ec 384B     		ldr	r3, .L152+32
 2524 01ee 1A60     		str	r2, [r3]
 2525              	.L138:
1470:functions.c   **** 			}
1471:functions.c   **** 		}
1472:functions.c   **** 	}
1473:functions.c   **** 
1474:functions.c   **** 
1475:functions.c   **** 	// -----------------------------------------------------------
1476:functions.c   **** 	// Low Battery (AKA Low voltage) Warning
1477:functions.c   **** 
1478:functions.c   **** 	if( SupplyVolts < 10.5 )
 2526              		.loc 1 1478 0
 2527 01f0 444B     		ldr	r3, .L152+84
 2528 01f2 1868     		ldr	r0, [r3]
 2529 01f4 4449     		ldr	r1, .L152+88
 2530 01f6 FFF7FEFF 		bl	__aeabi_fcmplt
 2531              	.LVL156:
 2532 01fa 0028     		cmp	r0, #0
 2533 01fc 10D0     		beq	.L151
1479:functions.c   **** 	{
1480:functions.c   **** 		if( !(MWarn & MW_LOWBAT) )
 2534              		.loc 1 1480 0
 2535 01fe 314B     		ldr	r3, .L152+20
 2536 0200 1B78     		ldrb	r3, [r3]
 2537 0202 9A06     		lsl	r2, r3, #26
 2538 0204 19D4     		bmi	.L141
1481:functions.c   **** 		{
1482:functions.c   **** 			MWarn |= MW_LOWBAT;
 2539              		.loc 1 1482 0
 2540 0206 2022     		mov	r2, #32
 2541 0208 1343     		orr	r3, r2
 2542 020a 2E4A     		ldr	r2, .L152+20
 2543 020c 1370     		strb	r3, [r2]
1483:functions.c   **** 			OKWarnBox = EXCL;
 2544              		.loc 1 1483 0
 2545 020e 0123     		mov	r3, #1
 2546 0210 2D4A     		ldr	r2, .L152+24
 2547 0212 1370     		strb	r3, [r2]
1484:functions.c   **** 
1485:functions.c   **** 			// Sounding 1 beep when message first appears
1486:functions.c   **** 			buzz_count = 1;
 2548              		.loc 1 1486 0
 2549 0214 2D4A     		ldr	r2, .L152+28
 2550 0216 1370     		strb	r3, [r2]
1487:functions.c   **** 			buzz_length = 250;
 2551              		.loc 1 1487 0
 2552 0218 FA22     		mov	r2, #250
 2553 021a 2D4B     		ldr	r3, .L152+32
 2554 021c 1A60     		str	r2, [r3]
 2555 021e 0CE0     		b	.L141
 2556              	.L151:
1488:functions.c   **** 		}
1489:functions.c   **** 	}
1490:functions.c   **** 	else // SupplyVolts >= 10.5
1491:functions.c   **** 	{
1492:functions.c   **** 		if( MWarn & MW_LOWBAT )
 2557              		.loc 1 1492 0
 2558 0220 284B     		ldr	r3, .L152+20
 2559 0222 1B78     		ldrb	r3, [r3]
 2560 0224 9A06     		lsl	r2, r3, #26
 2561 0226 08D5     		bpl	.L141
1493:functions.c   **** 		{
1494:functions.c   **** 			MWarn &= ~MW_LOWBAT;
 2562              		.loc 1 1494 0
 2563 0228 2022     		mov	r2, #32
 2564 022a 9343     		bic	r3, r2
 2565 022c 254A     		ldr	r2, .L152+20
 2566 022e 1370     		strb	r3, [r2]
1495:functions.c   **** 			OKWarnBox &= ~EXCL;
 2567              		.loc 1 1495 0
 2568 0230 254B     		ldr	r3, .L152+24
 2569 0232 1A78     		ldrb	r2, [r3]
 2570 0234 0121     		mov	r1, #1
 2571 0236 8A43     		bic	r2, r1
 2572 0238 1A70     		strb	r2, [r3]
 2573              	.L141:
1496:functions.c   **** 		}
1497:functions.c   **** 	}
1498:functions.c   **** 
1499:functions.c   **** 
1500:functions.c   **** 	// -----------------------------------------------------------
1501:functions.c   **** 	// Lube Count Alarm
1502:functions.c   **** 
1503:functions.c   **** 	if( pRun.pr.LubeCounter <= 0 )
 2574              		.loc 1 1503 0
 2575 023a 344B     		ldr	r3, .L152+92
 2576 023c 2622     		mov	r2, #38
 2577 023e 9B5E     		ldrsh	r3, [r3, r2]
 2578 0240 002B     		cmp	r3, #0
 2579 0242 1DDC     		bgt	.L142
1504:functions.c   **** 	{
1505:functions.c   **** 		if( !MWarn && !(OKWarnBox & LUBE) ) // Lube count warning has lowest priority
 2580              		.loc 1 1505 0
 2581 0244 1F4B     		ldr	r3, .L152+20
 2582 0246 1B78     		ldrb	r3, [r3]
 2583 0248 002B     		cmp	r3, #0
 2584 024a 0AD1     		bne	.L143
 2585              		.loc 1 1505 0 is_stmt 0 discriminator 1
 2586 024c 1E4B     		ldr	r3, .L152+24
 2587 024e 1B78     		ldrb	r3, [r3]
 2588 0250 9A07     		lsl	r2, r3, #30
 2589 0252 06D4     		bmi	.L143
1506:functions.c   **** 		{
1507:functions.c   **** 			// Oil can icon shown instead of showing total net applied in metres in screens.c
1508:functions.c   **** 
1509:functions.c   **** 			OKWarnBox = LUBE;
 2590              		.loc 1 1509 0 is_stmt 1
 2591 0254 0222     		mov	r2, #2
 2592 0256 1C4B     		ldr	r3, .L152+24
 2593 0258 1A70     		strb	r2, [r3]
1510:functions.c   **** 
1511:functions.c   **** 			// Sounding 1 beep when message first appears
1512:functions.c   **** 			buzz_count = 1;
1513:functions.c   **** 			buzz_length = 250;
 2594              		.loc 1 1513 0
 2595 025a FA22     		mov	r2, #250
 2596 025c 1C4B     		ldr	r3, .L152+32
 2597 025e 1A60     		str	r2, [r3]
 2598 0260 07E0     		b	.L144
 2599              	.L143:
1514:functions.c   **** 
1515:functions.c   **** 			BeepDelay = 0;
1516:functions.c   **** 		}
1517:functions.c   **** 
1518:functions.c   **** 		// Beeping sounds continuously
1519:functions.c   **** 		if( BeepDelay )
 2600              		.loc 1 1519 0
 2601 0262 2B4B     		ldr	r3, .L152+96
 2602 0264 1B78     		ldrb	r3, [r3]
 2603 0266 002B     		cmp	r3, #0
 2604 0268 03D0     		beq	.L144
1520:functions.c   **** 		{
1521:functions.c   **** 			BeepDelay--;
 2605              		.loc 1 1521 0
 2606 026a 013B     		sub	r3, r3, #1
 2607 026c 284A     		ldr	r2, .L152+96
 2608 026e 1370     		strb	r3, [r2]
 2609 0270 17E0     		b	.L121
 2610              	.L144:
1522:functions.c   **** 		}
1523:functions.c   **** 		else
1524:functions.c   **** 		{
1525:functions.c   **** 			BeepDelay = 29;
 2611              		.loc 1 1525 0
 2612 0272 1D22     		mov	r2, #29
 2613 0274 264B     		ldr	r3, .L152+96
 2614 0276 1A70     		strb	r2, [r3]
1526:functions.c   **** 			buzz_count = 1;
 2615              		.loc 1 1526 0
 2616 0278 0122     		mov	r2, #1
 2617 027a 144B     		ldr	r3, .L152+28
 2618 027c 1A70     		strb	r2, [r3]
 2619 027e 10E0     		b	.L121
 2620              	.L142:
1527:functions.c   **** 		}
1528:functions.c   **** 	}
1529:functions.c   **** 	else // pRun.pr.LubeCounter > 0
1530:functions.c   **** 	{
1531:functions.c   **** 		if( OKWarnBox == LUBE )
 2621              		.loc 1 1531 0
 2622 0280 114B     		ldr	r3, .L152+24
 2623 0282 1B78     		ldrb	r3, [r3]
 2624 0284 022B     		cmp	r3, #2
 2625 0286 0CD1     		bne	.L121
1532:functions.c   **** 		{
1533:functions.c   **** 			OKWarnBox &= ~LUBE;
 2626              		.loc 1 1533 0
 2627 0288 0022     		mov	r2, #0
 2628 028a 0F4B     		ldr	r3, .L152+24
 2629 028c 1A70     		strb	r2, [r3]
1534:functions.c   **** 			draw_box( adm, 2+2, 11+2, 30+2, 32+2, CLEAR );
 2630              		.loc 1 1534 0
 2631 028e 2223     		mov	r3, #34
 2632 0290 0093     		str	r3, [sp]
 2633 0292 4023     		mov	r3, #64
 2634 0294 0193     		str	r3, [sp, #4]
 2635 0296 1F48     		ldr	r0, .L152+100
 2636 0298 0421     		mov	r1, #4
 2637 029a 0D22     		mov	r2, #13
 2638 029c 2023     		mov	r3, #32
 2639 029e FFF7FEFF 		bl	draw_box
 2640              	.LVL157:
 2641              	.L121:
1535:functions.c   **** 		}
1536:functions.c   **** 	}
1537:functions.c   **** 
1538:functions.c   **** }
 2642              		.loc 1 1538 0
 2643 02a2 03B0     		add	sp, sp, #12
 2644              		@ sp needed for prologue
 2645 02a4 30BC     		pop	{r4, r5}
 2646 02a6 01BC     		pop	{r0}
 2647 02a8 0047     		bx	r0
 2648              	.L153:
 2649 02aa C046C046 		.align	3
 2649      C046
 2650              	.L152:
 2651 02b0 33333333 		.word	858993459
 2652 02b4 33331340 		.word	1075000115
 2653 02b8 66666666 		.word	1717986918
 2654 02bc 66661240 		.word	1074947686
 2655 02c0 00000000 		.word	DensityPresVolts
 2656 02c4 00000000 		.word	MWarn
 2657 02c8 00000000 		.word	OKWarnBox
 2658 02cc 00000000 		.word	buzz_count
 2659 02d0 00000000 		.word	buzz_length
 2660 02d4 00000000 		.word	DensityPressureTooHigh
 2661 02d8 00000000 		.word	half_second
 2662 02dc 00000000 		.word	.LANCHOR0
 2663 02e0 00000000 		.word	NetWarningOn
 2664 02e4 00F6FFFF 		.word	-2560
 2665 02e8 00000000 		.word	KnifePresVolts
 2666 02ec 00000000 		.word	key
 2667 02f0 00000000 		.word	SecondScreen
 2668 02f4 00000000 		.word	swrel
 2669 02f8 00000000 		.word	DelayTime
 2670 02fc 00000000 		.word	DisableChoppingKnivesWarnings
 2671 0300 00000000 		.word	ChoppingKnives1WarningOn
 2672 0304 00000000 		.word	SupplyVolts
 2673 0308 00002841 		.word	1093140480
 2674 030c 00010000 		.word	.LANCHOR10
 2675 0310 00000000 		.word	BeepDelay
 2676 0314 00000000 		.word	adm
 2677              		.cfi_endproc
 2678              	.LFE386:
 2680              		.section	.text.ResetSequenceFactors,"ax",%progbits
 2681              		.align	2
 2682              		.global	ResetSequenceFactors
 2683              		.code	16
 2684              		.thumb_func
 2686              	ResetSequenceFactors:
 2687              	.LFB388:
1539:functions.c   **** // -----------------------------------------------------------
1540:functions.c   **** 
1541:functions.c   **** 
1542:functions.c   **** // -----------------------------------------------------------
1543:functions.c   **** // Function Name       : Sequence
1544:functions.c   **** // -----------------------------------------------------------
1545:functions.c   **** void Sequence( void )
1546:functions.c   **** {
1547:functions.c   **** 
1548:functions.c   **** 	static unsigned char Kniv1_IPOpenTime;
1549:functions.c   **** 	static unsigned long int LastNetPulseCount;
1550:functions.c   **** 
1551:functions.c   **** 
1552:functions.c   **** 	if( AllTime ) // Incremented every 100 msec in TC1_irq_handler; so this routine is executed once e
1553:functions.c   **** 	{
1554:functions.c   **** 		AllTime--;
1555:functions.c   **** 
1556:functions.c   **** 		if( AutoMan )
1557:functions.c   **** 		{
1558:functions.c   **** 
1559:functions.c   **** 			// -----------------------------------------------------------
1560:functions.c   **** 			// State machine:
1561:functions.c   **** 			// - only runs in AUTO mode -- this mode cannot be selected if chamber closed
1562:functions.c   **** 
1563:functions.c   **** 			switch( Stage )
1564:functions.c   **** 			{
1565:functions.c   **** 
1566:functions.c   **** 			// -----------------------------------------------------------
1567:functions.c   **** 			// State: 0
1568:functions.c   **** 
1569:functions.c   **** 			case STAGE_START:
1570:functions.c   **** 
1571:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
1572:functions.c   **** 				{
1573:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
1574:functions.c   **** 				}
1575:functions.c   **** 				else // Go to Formation stage
1576:functions.c   **** 				{
1577:functions.c   **** 					SequenceInProgress = 1;
1578:functions.c   **** 
1579:functions.c   **** 					OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1580:functions.c   **** 					OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1581:functions.c   **** 					Stage = STAGE_FORMATION; // Go to Formation stage
1582:functions.c   **** 
1583:functions.c   **** 				}
1584:functions.c   **** 				break;
1585:functions.c   **** 
1586:functions.c   **** 
1587:functions.c   **** 			// -----------------------------------------------------------
1588:functions.c   **** 			// State: 1
1589:functions.c   **** 
1590:functions.c   **** 			case STAGE_FORMATION:
1591:functions.c   **** 
1592:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
1593:functions.c   **** 				{
1594:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
1595:functions.c   **** 				}
1596:functions.c   **** 				else // Continuing Formation stage
1597:functions.c   **** 				{
1598:functions.c   **** 					SequenceInProgress = 1;
1599:functions.c   **** 
1600:functions.c   **** 					if( BaleDiaVolts > DiaFormationVolts )  // Formation diameter exceeded
1601:functions.c   **** 					{
1602:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1603:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1604:functions.c   **** 						Stage = STAGE_FORMATION2; // Go to Formation2 stage
1605:functions.c   **** 					}
1606:functions.c   **** 					else  // Formation diameter not yet reached
1607:functions.c   **** 					{
1608:functions.c   **** 						// -----------------------------------------------------------
1609:functions.c   **** 						// Density Control Function -- based on Formation Density
1610:functions.c   **** 
1611:functions.c   **** 						if( DensityPresVolts >= DensityFormationVolts ) // Target Formation density reached/exceeded
1612:functions.c   **** 						{
1613:functions.c   **** 							if( OP8OnDelayTime )
1614:functions.c   **** 								OP8OnDelayTime--;
1615:functions.c   **** 							else // Pres. Sw. delay has expired
1616:functions.c   **** 							{
1617:functions.c   **** 								SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
1618:functions.c   **** 								OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1619:functions.c   **** 							}
1620:functions.c   **** 						}
1621:functions.c   **** 						else if( DensityPresVolts < (DensityFormationVolts - pFac.pf.GW302_PresDeadband) ) // Fallen 
1622:functions.c   **** 						{
1623:functions.c   **** 							if( OP8OffDelayTime )
1624:functions.c   **** 								OP8OffDelayTime--;
1625:functions.c   **** 							else // Pres. Sw. delay has expired
1626:functions.c   **** 							{
1627:functions.c   **** 								AllSeqOpOff(); // All OPs OFF
1628:functions.c   **** 								OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1629:functions.c   **** 							}
1630:functions.c   **** 						}
1631:functions.c   **** 					}
1632:functions.c   **** 				}
1633:functions.c   **** 				break;
1634:functions.c   **** 
1635:functions.c   **** 
1636:functions.c   **** 			// -----------------------------------------------------------
1637:functions.c   **** 			// State: 2
1638:functions.c   **** 
1639:functions.c   **** 			case STAGE_FORMATION2:
1640:functions.c   **** 
1641:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
1642:functions.c   **** 				{
1643:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
1644:functions.c   **** 				}
1645:functions.c   **** 				else // Continuing Formation2 stage
1646:functions.c   **** 				{
1647:functions.c   **** 					SequenceInProgress = 1;
1648:functions.c   **** 
1649:functions.c   **** 					if( BaleDiaVolts > DiaFormation2Volts )  // Formation2 diameter exceeded
1650:functions.c   **** 					{
1651:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1652:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1653:functions.c   **** 						Stage = STAGE_CORE; // Go to Core stage
1654:functions.c   **** 					}
1655:functions.c   **** 					else  // Formation2 diameter not yet reached
1656:functions.c   **** 					{
1657:functions.c   **** 						// -----------------------------------------------------------
1658:functions.c   **** 						// Density Control Function -- based on Formation2 Density
1659:functions.c   **** 
1660:functions.c   **** 						if( DensityPresVolts >= DensityFormation2Volts ) // Target Formation2 density reached/exceede
1661:functions.c   **** 						{
1662:functions.c   **** 							if( OP8OnDelayTime )
1663:functions.c   **** 								OP8OnDelayTime--;
1664:functions.c   **** 							else // Pres. Sw. delay has expired
1665:functions.c   **** 							{
1666:functions.c   **** 								SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
1667:functions.c   **** 								OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1668:functions.c   **** 							}
1669:functions.c   **** 						}
1670:functions.c   **** 						else if( DensityPresVolts < (DensityFormation2Volts - pFac.pf.GW302_PresDeadband) ) // Fallen
1671:functions.c   **** 						{
1672:functions.c   **** 							if( OP8OffDelayTime )
1673:functions.c   **** 								OP8OffDelayTime--;
1674:functions.c   **** 							else // Pres. Sw. delay has expired
1675:functions.c   **** 							{
1676:functions.c   **** 								AllSeqOpOff(); // All OPs OFF
1677:functions.c   **** 								OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1678:functions.c   **** 							}
1679:functions.c   **** 						}
1680:functions.c   **** 					}
1681:functions.c   **** 				}
1682:functions.c   **** 				break;
1683:functions.c   **** 
1684:functions.c   **** 
1685:functions.c   **** 			// -----------------------------------------------------------
1686:functions.c   **** 			// State: 3
1687:functions.c   **** 
1688:functions.c   **** 			case STAGE_CORE:
1689:functions.c   **** 
1690:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
1691:functions.c   **** 				{
1692:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
1693:functions.c   **** 				}
1694:functions.c   **** 				else // Continuing Core stage
1695:functions.c   **** 				{
1696:functions.c   **** 					SequenceInProgress = 1;
1697:functions.c   **** 
1698:functions.c   **** 					if( BaleDiaVolts > DiaCoreVolts )  // Core diameter exceeded
1699:functions.c   **** 					{
1700:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1701:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1702:functions.c   **** 						Stage = STAGE_MAIN; // Go to Main stage
1703:functions.c   **** 					}
1704:functions.c   **** 					else  // Core diameter not yet reached
1705:functions.c   **** 					{
1706:functions.c   **** 						// -----------------------------------------------------------
1707:functions.c   **** 						// Density Control Function -- based on Bale Core Density
1708:functions.c   **** 
1709:functions.c   **** 						if( DensityPresVolts >= DensityCoreVolts ) // Target core density reached/exceeded
1710:functions.c   **** 						{
1711:functions.c   **** 							if( OP8OnDelayTime )
1712:functions.c   **** 								OP8OnDelayTime--;
1713:functions.c   **** 							else // Pres. Sw. delay has expired
1714:functions.c   **** 							{
1715:functions.c   **** 								SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
1716:functions.c   **** 								OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1717:functions.c   **** 							}
1718:functions.c   **** 						}
1719:functions.c   **** 						else if( DensityPresVolts < (DensityCoreVolts - pFac.pf.GW302_PresDeadband) ) // Fallen below
1720:functions.c   **** 						{
1721:functions.c   **** 							if( OP8OffDelayTime )
1722:functions.c   **** 								OP8OffDelayTime--;
1723:functions.c   **** 							else // Pres. Sw. delay has expired
1724:functions.c   **** 							{
1725:functions.c   **** 								AllSeqOpOff(); // All OPs OFF
1726:functions.c   **** 								OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
1727:functions.c   **** 							}
1728:functions.c   **** 						}
1729:functions.c   **** 					}
1730:functions.c   **** 				}
1731:functions.c   **** 				break;
1732:functions.c   **** 
1733:functions.c   **** 
1734:functions.c   **** 			// -----------------------------------------------------------
1735:functions.c   **** 			// State: 4
1736:functions.c   **** 
1737:functions.c   **** 			case STAGE_MAIN:
1738:functions.c   **** 
1739:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
1740:functions.c   **** 				{
1741:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
1742:functions.c   **** 				}
1743:functions.c   **** 				else // Continuing Main stage
1744:functions.c   **** 				{
1745:functions.c   **** 					SequenceInProgress = 1;
1746:functions.c   **** 
1747:functions.c   **** 					if( BaleDiaVolts > DiaTargetVolts )  // Target bale diameter exceeded
1748:functions.c   **** 					{
1749:functions.c   **** 						Stage = STAGE_NETTING_START; // Go to Netting stage
1750:functions.c   **** 					}
1751:functions.c   **** 					else  // Target bale diameter not yet reached
1752:functions.c   **** 					{
1753:functions.c   **** 						// Density Control Function (based on Target Bale Density) activated -- turned on
1754:functions.c   **** 						DensityControlFunctionActive = 1;
1755:functions.c   **** 
1756:functions.c   **** 					}
1757:functions.c   **** 
1758:functions.c   **** 					// Roller Engage Solenoid (OP5) turned on now/later when Engage diameter reached
1759:functions.c   **** 					if( BaleDiaVolts >= DiaEngageVolts ) // Engage diameter reached
1760:functions.c   **** 					{
1761:functions.c   **** 						if( pFac.pf.GW302_NetSystem == NS_ROLLER )
1762:functions.c   **** 						{
1763:functions.c   **** 
1764:functions.c   **** 							RollEngageTurnedOn = 1; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
1765:functions.c   **** 
1766:functions.c   **** 						}
1767:functions.c   **** 						else //  pFac.pf.GW302_NetSystem == NS_BEAK
1768:functions.c   **** 						{
1769:functions.c   **** 							// Roller Engage Solenoid (OP5) turned on after 'Beak Engage' pulses counted on IP4
1770:functions.c   **** 							// - Counting starts from now but checking only starts after OP2 (Net On) has come on
1771:functions.c   **** 							BeakEngagePulseCount = 0UL; // Resetting IP4 'Beak Engage' pulse count
1772:functions.c   **** 							OP5TurnedOnAfterBeakEngagePulsesEnabled = 1;
1773:functions.c   **** 						}
1774:functions.c   **** 					}
1775:functions.c   **** 				}
1776:functions.c   **** 				break;
1777:functions.c   **** 
1778:functions.c   **** 
1779:functions.c   **** 			// -----------------------------------------------------------
1780:functions.c   **** 			// State: 5
1781:functions.c   **** 
1782:functions.c   **** 			case STAGE_NETTING_START:
1783:functions.c   **** 
1784:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
1785:functions.c   **** 				{
1786:functions.c   **** 					// Pausing at start of Netting stage while button held
1787:functions.c   **** 
1788:functions.c   **** 					// -----------------------------------------------------------
1789:functions.c   **** 					// Roller Engage Solenoid (OP5) turned on now/later while Net On button 2 pressed
1790:functions.c   **** 
1791:functions.c   **** 					if( pFac.pf.GW302_NetSystem == NS_ROLLER )
1792:functions.c   **** 					{
1793:functions.c   **** 
1794:functions.c   **** 						RollEngageTurnedOn = 1; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
1795:functions.c   **** 
1796:functions.c   **** 					}
1797:functions.c   **** 					else //  pFac.pf.GW302_NetSystem == NS_BEAK
1798:functions.c   **** 					{
1799:functions.c   **** 						// Roller Engage Solenoid (OP5) turned on after 'Beak Engage' pulses counted on IP4
1800:functions.c   **** 						// - Counting starts from now but checking only starts after OP2 (Net On) has come on
1801:functions.c   **** 						OP5TurnedOnAfterBeakEngagePulsesEnabled = 1;
1802:functions.c   **** 					}
1803:functions.c   **** 				}
1804:functions.c   **** 				else // Continuing with this stage
1805:functions.c   **** 				{
1806:functions.c   **** 					SequenceInProgress = 1;
1807:functions.c   **** 
1808:functions.c   **** 					// Density Control Function active/not according to Target Bale Density ID
1809:functions.c   **** 					if( pFac.pf.GW302_BaleDensity[pFac.pf.GW302_BaleProfile] <= 5 ) // Target Bale Density ID is 1
1810:functions.c   **** 					{
1811:functions.c   **** 						DensityControlFunctionActive = 1; // Density Control Function (based on Target Bale Density) 
1812:functions.c   **** 					}
1813:functions.c   **** 					else // Target Bale Density ID is 6 - 10
1814:functions.c   **** 					{
1815:functions.c   **** 						DensityControlFunctionActive = 0; // Density Control Function (based on Target Bale Density) 
1816:functions.c   **** 
1817:functions.c   **** 						// Ensuring OP8 is turned off
1818:functions.c   **** 						SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
1819:functions.c   **** 						SeqOpOff |= OP_DENSITY_REL;
1820:functions.c   **** 					}
1821:functions.c   **** 
1822:functions.c   **** 					// Next stage
1823:functions.c   **** 					OP2OnDelayTime = (unsigned char)(pFac.pf.GW302_NetDelay * 10.0);
1824:functions.c   **** 					Stage = STAGE_NETTING_NET_DELAY; // Go to Net Delay stage
1825:functions.c   **** 				}
1826:functions.c   **** 				break;
1827:functions.c   **** 
1828:functions.c   **** 
1829:functions.c   **** 			// -----------------------------------------------------------
1830:functions.c   **** 			// State: 6
1831:functions.c   **** 
1832:functions.c   **** 			case STAGE_NETTING_NET_DELAY:
1833:functions.c   **** 
1834:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
1835:functions.c   **** 				{
1836:functions.c   **** 					// Pausing while button held
1837:functions.c   **** 					OP2OnDelayTime = 0; // Net Delay (t1) set to 0; hence, on key release go to Netting stage -- N
1838:functions.c   **** 				}
1839:functions.c   **** 				else // Continuing with this stage
1840:functions.c   **** 				{
1841:functions.c   **** 					SequenceInProgress = 1;
1842:functions.c   **** 
1843:functions.c   **** 					// Intermittent beep for duration of Net Delay time (t1) -- unless disabled by IP3 opening
1844:functions.c   **** 					if( !NettingStartBeepsDisabledWhileIP3OpenInAutoMode )
1845:functions.c   **** 					{
1846:functions.c   **** 						// Intermittent beep for duration of Net Delay time (t1)
1847:functions.c   **** 						buzz_count = 1;
1848:functions.c   **** 					}
1849:functions.c   **** 
1850:functions.c   **** 					if( OP2OnDelayTime )
1851:functions.c   **** 						OP2OnDelayTime--;
1852:functions.c   **** 					else // Net Delay (t1) has expired
1853:functions.c   **** 					{
1854:functions.c   **** 						SeqOpOn |= OP_NET_ON;   // OP2 ON: Net Clutch (AKA Net On)
1855:functions.c   **** 						stagecomp |= NETFEEDON; // Set NET FEED ON stage completed
1856:functions.c   **** 
1857:functions.c   **** 						// Roller Engage Solenoid (OP5) turned on after 'Beak Engage' pulses counted on IP4
1858:functions.c   **** 						// - Counting starts from now but checking only starts after OP2 (Net On) has come on
1859:functions.c   **** 						BeakEngagePulseCount = 0UL; // Resetting IP4 'Beak Engage' pulse count
1860:functions.c   **** 
1861:functions.c   **** #ifdef DEVELOP // Testing pulse counting
1862:functions.c   **** 						SavedBeakEngagePulseCount = 0UL;  // Resetting
1863:functions.c   **** #endif
1864:functions.c   **** 
1865:functions.c   **** 						// Continuous beep for 3s (when OP2 turns on) -- unless disabled by IP3 opening
1866:functions.c   **** 						if( !NettingStartBeepsDisabledWhileIP3OpenInAutoMode )
1867:functions.c   **** 						{
1868:functions.c   **** 							if( !cont_beep )
1869:functions.c   **** 							{
1870:functions.c   **** 								buzz_length = NETTING_START_BEEP; // Long continuous beep when netting starts in AUTO mode
1871:functions.c   **** 								cont_beep = 1;
1872:functions.c   **** 							}
1873:functions.c   **** 						}
1874:functions.c   **** 
1875:functions.c   **** 						// Calculating Target Net Pulses for current bale diameter (expected to be just above Target 
1876:functions.c   **** 						CalculateTargetNetPulses();
1877:functions.c   **** 
1878:functions.c   **** 						// Resetting IP4 net pulse count (when OP2 turns on)
1879:functions.c   **** 						NetPulseCount = 0UL;
1880:functions.c   **** 
1881:functions.c   **** 						// Start checking for no pulses detected on IP4 for NetWarningDelayTime since
1882:functions.c   **** 						// OP2 turned on or since the last pulse counted
1883:functions.c   **** 						if (pFac.pf.GW302_NetTwineOption == TO_NET)
1884:functions.c   **** 							NetPulseCheckingEnabled = 1;
1885:functions.c   **** 
1886:functions.c   **** 						LastNetPulseCount = NetPulseCount;
1887:functions.c   **** 						NetWarningDelayTime = (unsigned char)(pFac.pf.GW302_NoNetPulse * 10.0); // Delay before Check
1888:functions.c   **** 
1889:functions.c   **** 						// Next stage
1890:functions.c   **** 						OP2OffDelayTime = (unsigned char)(pFac.pf.GW302_NetOn * 10.0); // Total amount of time OP2 is
1891:functions.c   **** 						Stage = STAGE_NETTING_NET_ON; // Go to Netting stage -- Net On
1892:functions.c   **** 					}
1893:functions.c   **** 				}
1894:functions.c   **** 				break;
1895:functions.c   **** 
1896:functions.c   **** 
1897:functions.c   **** 			// -----------------------------------------------------------
1898:functions.c   **** 			// State: 7
1899:functions.c   **** 
1900:functions.c   **** 			case STAGE_NETTING_NET_ON:
1901:functions.c   **** 
1902:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
1903:functions.c   **** 				{
1904:functions.c   **** 					// Pausing while button held
1905:functions.c   **** 					OP2OffDelayTime = 0;  // Net On (t2) set to 0; hence on key release turn off OP2 & go to STAGE
1906:functions.c   **** 					NetWarningOn = 0;     // Check Net Error (AKA Net Warning) turned off -- if on
1907:functions.c   **** 				}
1908:functions.c   **** 				else // Continuing with this stage
1909:functions.c   **** 				{
1910:functions.c   **** 					SequenceInProgress = 1;
1911:functions.c   **** 
1912:functions.c   **** 					if( OP2OffDelayTime )
1913:functions.c   **** 					{
1914:functions.c   **** 						if( NetPulseFrequency > pFac.pf.GW302_NetSpeed ) // Net Pulse Frequency exceeds Net Speed
1915:functions.c   **** 						{
1916:functions.c   **** 							SeqOpOn &= ~OP_NET_ON; // OP2 OFF: Net Clutch (AKA Net On)
1917:functions.c   **** 							SeqOpOff |= OP_NET_ON;
1918:functions.c   **** 							OP2OffDelayTime = 0; // Net On (t2) expires
1919:functions.c   **** 						}
1920:functions.c   **** 						else // Net Pulse Frequency at/below Net Speed
1921:functions.c   **** 						{
1922:functions.c   **** 							OP2OffDelayTime--;
1923:functions.c   **** 						}
1924:functions.c   **** 					}
1925:functions.c   **** 					else // Net On (t2) has expired
1926:functions.c   **** 					{
1927:functions.c   **** 						SeqOpOn &= ~OP_NET_ON; // OP2 OFF: Net Clutch (AKA Net On)
1928:functions.c   **** 						SeqOpOff |= OP_NET_ON;
1929:functions.c   **** 
1930:functions.c   **** 						Stage = STAGE_NETTING_WAIT_REQ_NET_PULSES; // Go to Netting stage -- waiting for Target Net P
1931:functions.c   **** 					}
1932:functions.c   **** 				}
1933:functions.c   **** 				break;
1934:functions.c   **** 
1935:functions.c   **** 
1936:functions.c   **** 			// -----------------------------------------------------------
1937:functions.c   **** 			// State: 8
1938:functions.c   **** 
1939:functions.c   **** 			case STAGE_NETTING_WAIT_REQ_NET_PULSES:
1940:functions.c   **** 
1941:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
1942:functions.c   **** 				{
1943:functions.c   **** 					// Pausing while button held
1944:functions.c   **** 					// OP2 is turned on & kept on while key held down
1945:functions.c   **** 					NetWarningOn = 0;     // Check Net Error (AKA Net Warning) turned off -- if on
1946:functions.c   **** 				}
1947:functions.c   **** 				else // Continuing with this stage
1948:functions.c   **** 				{
1949:functions.c   **** 					SequenceInProgress = 1;
1950:functions.c   **** 
1951:functions.c   **** 					if(( NetPulseCount > (unsigned long int)TargetNetPulses ) || (pFac.pf.GW302_NetTwineOption == 
1952:functions.c   **** 					{
1953:functions.c   **** 						// Density Control Function active/not according to Target Bale Density ID
1954:functions.c   **** 						if( pFac.pf.GW302_BaleDensity[pFac.pf.GW302_BaleProfile] <= 5 ) // Target Bale Density ID is 
1955:functions.c   **** 						{
1956:functions.c   **** 							DensityControlFunctionActive = 0; // Density Control Function (based on Target Bale Density)
1957:functions.c   **** 
1958:functions.c   **** 							// Ensuring OP8 is turned off
1959:functions.c   **** 							SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
1960:functions.c   **** 							SeqOpOff |= OP_DENSITY_REL;
1961:functions.c   **** 						}
1962:functions.c   **** 
1963:functions.c   **** 						if(pFac.pf.GW302_NetTwineOption == TO_NET)
1964:functions.c   **** 							SeqOpOn |= OP_NET_CUT; // OP7 ON: Net Cut Motor (AKA Net Cut Trip)
1965:functions.c   **** 
1966:functions.c   **** 						stagecomp |= NETCUTON; // Set NET CUT ON stage completed
1967:functions.c   **** 
1968:functions.c   **** #ifdef DEVELOP // Testing pulse counting
1969:functions.c   **** 						Saved_NetPulseCount = NetPulseCount;
1970:functions.c   **** 						SavedPreNetPulseCount = 0UL;   // Resetting
1971:functions.c   **** 						TargetPreNetPulseCount = (unsigned long int)pFac.pf.GW302_PreNetPulse;
1972:functions.c   **** #endif
1973:functions.c   **** 
1974:functions.c   **** 						// Next stage
1975:functions.c   **** 						OP7OffDelayTime = (unsigned char)(pFac.pf.GW302_NetCutTime * 10.0);
1976:functions.c   **** 						IP4PulsesStoppedCount = IP4_PULSES_STOPPED_COUNT_DURATION; // 1.5 s
1977:functions.c   **** 						NetPulseCountAtLastCheck = NetPulseCount; // Pulse count saved
1978:functions.c   **** 						Stage = STAGE_NETTING_NET_CUT_ON; // Go to Netting stage -- Net Cut On
1979:functions.c   **** 
1980:functions.c   **** 						// Stop checking for no pulses detected on IP4 for NetWarningDelayTime
1981:functions.c   **** 						NetPulseCheckingEnabled = 0;
1982:functions.c   **** 
1983:functions.c   **** 						// Stop checking for 'Beak Engage' Pulses counted on IP4
1984:functions.c   **** 						OP5TurnedOnAfterBeakEngagePulsesEnabled = 0;
1985:functions.c   **** 					}
1986:functions.c   **** 				}
1987:functions.c   **** 				break;
1988:functions.c   **** 
1989:functions.c   **** 
1990:functions.c   **** 			// -----------------------------------------------------------
1991:functions.c   **** 			// State: 9
1992:functions.c   **** 
1993:functions.c   **** 			case STAGE_NETTING_NET_CUT_ON:
1994:functions.c   **** 
1995:functions.c   **** 				SequenceInProgress = 1;
1996:functions.c   **** 
1997:functions.c   **** 				if( OP7OffDelayTime || IP4PulsesStoppedCount )
1998:functions.c   **** 				{
1999:functions.c   **** 					if( OP7OffDelayTime )
2000:functions.c   **** 					{
2001:functions.c   **** 						OP7OffDelayTime--;
2002:functions.c   **** 					}
2003:functions.c   **** 
2004:functions.c   **** 					if( IP4PulsesStoppedCount )
2005:functions.c   **** 					{
2006:functions.c   **** 						if( NetPulseCount == NetPulseCountAtLastCheck ) // Net Pulses cease to be detected on IP4 aft
2007:functions.c   **** 								{
2008:functions.c   **** 							IP4PulsesStoppedCount--;
2009:functions.c   **** 								}
2010:functions.c   **** 						else // Net Pulses continue to be detected on IP4 after Target Net Pulses reached
2011:functions.c   **** 						{
2012:functions.c   **** 							IP4PulsesStoppedCount = IP4_PULSES_STOPPED_COUNT_DURATION; // Resetting to 1.5 s
2013:functions.c   **** 						}
2014:functions.c   **** 						NetPulseCountAtLastCheck = NetPulseCount; // Net Pulse count (for what will be the last check
2015:functions.c   **** 					}
2016:functions.c   **** 				}
2017:functions.c   **** 
2018:functions.c   **** 				// Net Cut Time (t5) has expired OR No Net Pulses detected on IP4 for > 1 s OR Net Cut Sensor c
2019:functions.c   **** 				if( !OP7OffDelayTime || !IP4PulsesStoppedCount || NET_CUT_SENSOR_CLOSED || (pFac.pf.GW302_NetTw
2020:functions.c   **** 				{
2021:functions.c   **** 					RollEngageTurnedOn = 0;     // OP5 Roller Engage Solenoid (AKA Pre Net Position) turned off
2022:functions.c   **** 					AllSeqOpOff(); // All OPs OFF
2023:functions.c   **** 
2024:functions.c   **** 					buzz_length = PROMPT_TO_OPEN_DOOR_BEEP; // Beep to prompt operator to open the chamber door & 
2025:functions.c   **** 
2026:functions.c   **** 					Stage = STAGE_NETTING_END; // Go to end of Netting stage
2027:functions.c   **** 				}
2028:functions.c   **** 				break;
2029:functions.c   **** 
2030:functions.c   **** 
2031:functions.c   **** 			// -----------------------------------------------------------
2032:functions.c   **** 			// State: 10 (Hex A)
2033:functions.c   **** 
2034:functions.c   **** 			case STAGE_NETTING_END:
2035:functions.c   **** 
2036:functions.c   **** 				SequenceInProgress = 1;
2037:functions.c   **** 
2038:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
2039:functions.c   **** 				{
2040:functions.c   **** 					stagecomp |= CHAMBOP;      // Set CHAMBER OPEN stage completed
2041:functions.c   **** 
2042:functions.c   **** 					buzz_length = AUTO_CONFIRM_DOOR_OPENED_BEEP; // Beep to confirm chamber door has been opened
2043:functions.c   **** 
2044:functions.c   **** 					Stage = STAGE_UNLOADING;   // Go to Unloading stage
2045:functions.c   **** 				}
2046:functions.c   **** 				break;
2047:functions.c   **** 
2048:functions.c   **** 
2049:functions.c   **** 			// -----------------------------------------------------------
2050:functions.c   **** 			// State: 11 (Hex B)
2051:functions.c   **** 
2052:functions.c   **** 			case STAGE_UNLOADING:
2053:functions.c   **** 
2054:functions.c   **** 				SequenceInProgress = 1;
2055:functions.c   **** 
2056:functions.c   **** 				if( CHAMBER_CLOSED ) // Chamber Locked Sensor closed
2057:functions.c   **** 				{
2058:functions.c   **** 					stagecomp |= CHAMBCLO;  // Set CHAMBER CLOSED stage completed
2059:functions.c   **** 
2060:functions.c   **** 					buzz_length = AUTO_CONFIRM_DOOR_CLOSED_BEEP; // Beep to confirm chamber door has been closed
2061:functions.c   **** 
2062:functions.c   **** 					// Next stage
2063:functions.c   **** 					ChamberClosedDelayTime = (unsigned char)(pFac.pf.GW302_DoorClosed * 10.0);
2064:functions.c   **** 					Stage = STAGE_UNLOADING_WAIT;      // Go to Unloading Wait stage
2065:functions.c   **** 				}
2066:functions.c   **** 				else // Chamber Locked Sensor still open
2067:functions.c   **** 				{
2068:functions.c   **** 					// Looking for Bale Kicker to go down then up
2069:functions.c   **** 					if( BALE_KICKER_DOWN ) // IP5: Bale Kicker Sensor open
2070:functions.c   **** 					{
2071:functions.c   **** 						BaleKickerStatus |= BKS_BALE_KICKER_DOWN; // Set BKS_BALE_KICKER_DOWN flag
2072:functions.c   **** 						BaleKickerStatus &= ~(BKS_BALE_KICKER_UP); // Flag to be set next
2073:functions.c   **** 					}
2074:functions.c   **** 					else if( BALE_KICKER_UP ) // IP5: Bale Kicker Sensor closed
2075:functions.c   **** 					{
2076:functions.c   **** 						if( BaleKickerStatus == BKS_BALE_KICKER_DOWN ) // BKS_BALE_KICKER_DOWN flag already set
2077:functions.c   **** 						{
2078:functions.c   **** 							BaleKickerStatus |= BKS_BALE_KICKER_UP; // Set BKS_BALE_KICKER_UP flag
2079:functions.c   **** 
2080:functions.c   **** 							buzz_length = AUTO_CONFIRM_BALE_UNLOADED_BEEP; // Beep to confirm bale has been unloaded
2081:functions.c   **** 							// Image of bale shown on the display disappears
2082:functions.c   **** 						}
2083:functions.c   **** 					}
2084:functions.c   **** 				}
2085:functions.c   **** 				break;
2086:functions.c   **** 
2087:functions.c   **** 
2088:functions.c   **** 			// -----------------------------------------------------------
2089:functions.c   **** 			// State: 12 (Hex C)
2090:functions.c   **** 
2091:functions.c   **** 			case STAGE_UNLOADING_WAIT:
2092:functions.c   **** 
2093:functions.c   **** 				SequenceInProgress = 1;
2094:functions.c   **** 
2095:functions.c   **** 				if( ChamberClosedDelayTime )
2096:functions.c   **** 					ChamberClosedDelayTime--;
2097:functions.c   **** 				else // Chamber/Door closed delay has expired
2098:functions.c   **** 				{
2099:functions.c   **** 					AllSeqOpOff();          // All OPs OFF
2100:functions.c   **** 
2101:functions.c   **** 					Stage = STAGE_END;      // Go to End stage
2102:functions.c   **** 				}
2103:functions.c   **** 				break;
2104:functions.c   **** 
2105:functions.c   **** 
2106:functions.c   **** 			// -----------------------------------------------------------
2107:functions.c   **** 			// State: 13 (Hex D)
2108:functions.c   **** 
2109:functions.c   **** 			case STAGE_END:
2110:functions.c   **** 
2111:functions.c   **** 				SequenceInProgress = 1;
2112:functions.c   **** 
2113:functions.c   **** 				if( stagecomp == (NETFEEDON | NETCUTON | CHAMBOP | CHAMBCLO) ) // all stages completed
2114:functions.c   **** 						{
2115:functions.c   **** 					stagecomp = SC_CLEAR; // Reset
2116:functions.c   **** 
2117:functions.c   **** 					UpdatingAndSavingTotalsToMemory();
2118:functions.c   **** 
2119:functions.c   **** 					buzz_length = ALL_STAGES_COMPLETE_BEEP; // Beep on completion of all stages
2120:functions.c   **** 						}
2121:functions.c   **** 
2122:functions.c   **** 				if( (pFac.pf.GW302_PreNetPulse > 0) && (pFac.pf.GW302_NetTwineOption == TO_NET))
2123:functions.c   **** 				{
2124:functions.c   **** 					SeqOpOn |= OP_NET_ON;         // OP2 ON: Net Clutch (AKA Net On)
2125:functions.c   **** 
2126:functions.c   **** 					// Resetting IP4 net pulse count (to count Pre Net Pulses)
2127:functions.c   **** 					NetPulseCount = 0UL;
2128:functions.c   **** 
2129:functions.c   **** 					// Start checking for no pulses detected on IP4 for NetWarningDelayTime since
2130:functions.c   **** 					// start of checking or since the last pulse counted
2131:functions.c   **** 					NetPulseCheckingEnabled = 1;
2132:functions.c   **** 					LastNetPulseCount = NetPulseCount;
2133:functions.c   **** 					NetWarningDelayTime = (unsigned char)(pFac.pf.GW302_NoNetPulse * 10.0); // Delay before Check 
2134:functions.c   **** 
2135:functions.c   **** 					// Next stage
2136:functions.c   **** 					Stage = STAGE_PRE_NET_PULSES; // Go to Pre Net Pulses stage
2137:functions.c   **** 				}
2138:functions.c   **** 				else // No Pre Net Pulses
2139:functions.c   **** 				{
2140:functions.c   **** 					// Finish sequence
2141:functions.c   **** 					ResetSequenceFactors( SEQ_ALL ); // Turns off all OPs & goes to start of sequence
2142:functions.c   **** 				}
2143:functions.c   **** 				break;
2144:functions.c   **** 
2145:functions.c   **** 
2146:functions.c   **** 			// -----------------------------------------------------------
2147:functions.c   **** 			// State: 14 (Hex E)
2148:functions.c   **** 
2149:functions.c   **** 			case STAGE_PRE_NET_PULSES:
2150:functions.c   **** 
2151:functions.c   **** 				SequenceInProgress = 1;
2152:functions.c   **** 
2153:functions.c   **** 				if( NetPulseCount >= (unsigned long int)pFac.pf.GW302_PreNetPulse ) // Sufficient Pre Net Pulse
2154:functions.c   **** 				{
2155:functions.c   **** #ifdef DEVELOP // Testing pulse counting
2156:functions.c   **** 					SavedPreNetPulseCount = NetPulseCount;
2157:functions.c   **** #endif
2158:functions.c   **** 					// Stop checking for no pulses detected on IP4 for NetWarningDelayTime
2159:functions.c   **** 					NetPulseCheckingEnabled = 0;
2160:functions.c   **** 
2161:functions.c   **** 					// Finish sequence
2162:functions.c   **** 					ResetSequenceFactors( SEQ_ALL );  // Turns off all OPs & goes to start of sequence
2163:functions.c   **** 				}
2164:functions.c   **** 				break;
2165:functions.c   **** 
2166:functions.c   **** 			} // end switch( Stage )
2167:functions.c   **** 
2168:functions.c   **** 
2169:functions.c   **** 			// -----------------------------------------------------------
2170:functions.c   **** 			// Density Control Function -- based on Target Bale Density (AUTO)
2171:functions.c   **** 
2172:functions.c   **** 			if( DensityControlFunctionActive )
2173:functions.c   **** 			{
2174:functions.c   **** 				if( DensityPresVolts >= DensityBaleVolts ) // Target bale density reached/exceeded
2175:functions.c   **** 				{
2176:functions.c   **** 					if( OP8OnDelayTime )
2177:functions.c   **** 						OP8OnDelayTime--;
2178:functions.c   **** 					else // Pres. Sw. delay has expired
2179:functions.c   **** 					{
2180:functions.c   **** 						SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
2181:functions.c   **** 						SeqOpOff &= ~OP_DENSITY_REL;
2182:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
2183:functions.c   **** 					}
2184:functions.c   **** 				}
2185:functions.c   **** 				else if( DensityPresVolts < (DensityBaleVolts - pFac.pf.GW302_PresDeadband) ) // Fallen below d
2186:functions.c   **** 				{
2187:functions.c   **** 					if( OP8OffDelayTime )
2188:functions.c   **** 						OP8OffDelayTime--;
2189:functions.c   **** 					else // Pres. Sw. delay has expired
2190:functions.c   **** 					{
2191:functions.c   **** 						SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
2192:functions.c   **** 						SeqOpOff |= OP_DENSITY_REL;
2193:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
2194:functions.c   **** 					}
2195:functions.c   **** 				}
2196:functions.c   **** 			} // end if( DensityControlFunctionActive )
2197:functions.c   **** 
2198:functions.c   **** 
2199:functions.c   **** 			// -----------------------------------------------------------
2200:functions.c   **** 			// Checking for no pulses detected on IP4 for NetWarningDelayTime (AUTO)
2201:functions.c   **** 
2202:functions.c   **** 			if( (NetPulseCheckingEnabled) && (pFac.pf.GW302_NetTwineOption == TO_NET) ) // Flag set from whe
2203:functions.c   **** 			{
2204:functions.c   **** 				if( (NetPulseCount == 0UL) || (NetPulseCount == LastNetPulseCount) ) // No pulses detected on I
2205:functions.c   **** 				{
2206:functions.c   **** 					if( NetWarningDelayTime )
2207:functions.c   **** 					{
2208:functions.c   **** 						NetWarningDelayTime--;
2209:functions.c   **** 					}
2210:functions.c   **** 					else // NetWarningDelayTime expired
2211:functions.c   **** 					{
2212:functions.c   **** 						if(pFac.pf.GW302_NetTwineOption == TO_NET) /**/
2213:functions.c   **** 							NetWarningOn = 1; // Check Net Error (AKA Net Warning) turned on
2214:functions.c   **** 					}
2215:functions.c   **** 				}
2216:functions.c   **** 				else // Pulses detected on IP4
2217:functions.c   **** 				{
2218:functions.c   **** 					NetWarningOn = 0; // Check Net Error (AKA Net Warning) turned off
2219:functions.c   **** 					LastNetPulseCount = NetPulseCount;
2220:functions.c   **** 					NetWarningDelayTime = (unsigned char)(pFac.pf.GW302_NoNetPulse * 10.0); // Delay before Check 
2221:functions.c   **** 				}
2222:functions.c   **** 
2223:functions.c   **** 				// Turning Net Warning off while IP3 is open
2224:functions.c   **** 				if( NetWarningDisabledWhileIP3OpenInAutoMode )
2225:functions.c   **** 				{
2226:functions.c   **** 					NetWarningOn = 0; // Check Net Error (AKA Net Warning) turned off
2227:functions.c   **** 				}
2228:functions.c   **** 
2229:functions.c   **** 			} // end if( NetPulseCheckingEnabled )
2230:functions.c   **** 
2231:functions.c   **** 
2232:functions.c   **** 			// -----------------------------------------------------------
2233:functions.c   **** 			// Roller Engage Solenoid (OP5) turned on after 'Beak Engage' Pulses counted on IP4 -- Only appl
2234:functions.c   **** 
2235:functions.c   **** 			if( OP5TurnedOnAfterBeakEngagePulsesEnabled ) // Flag set from when Engage diameter reached (or 
2236:functions.c   **** 			{
2237:functions.c   **** 				if( !NetWarningOn ) // Disabled while Check Net Error (AKA Net Warning) active
2238:functions.c   **** 				{
2239:functions.c   **** 					if( pFac.pf.GW302_NetSystem == NS_BEAK ) // Only applies if 'Net System' set to 'Beak' (Double
2240:functions.c   **** 					{
2241:functions.c   **** 						if( stagecomp == NETFEEDON ) // Only checks for 'Beak Engage' pulses after OP2 (Net On) has c
2242:functions.c   **** 						{
2243:functions.c   **** 							if( BeakEngagePulseCount >= (unsigned long int)pFac.pf.GW302_BeakEngage ) // 'Beak Engage' P
2244:functions.c   **** 							{
2245:functions.c   **** #ifdef DEVELOP // Testing pulse counting
2246:functions.c   **** 								if( !RollEngageTurnedOn )
2247:functions.c   **** 									SavedBeakEngagePulseCount = BeakEngagePulseCount;
2248:functions.c   **** #endif
2249:functions.c   **** 								RollEngageTurnedOn = 1; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
2250:functions.c   **** 
2251:functions.c   **** 							}
2252:functions.c   **** 						}
2253:functions.c   **** 					}
2254:functions.c   **** 				}
2255:functions.c   **** 			} // end if( OP5TurnedOnAfterBeakEngagePulsesEnabled )
2256:functions.c   **** 
2257:functions.c   **** 
2258:functions.c   **** 
2259:functions.c   **** 			// -----------------------------------------------------------
2260:functions.c   **** 			// Roller Engage Solenoid (OP5) turned on/off (AUTO)
2261:functions.c   **** 
2262:functions.c   **** 			if( NetWarningOn ) // Check Net Error (AKA Net Warning) active (AUTO)
2263:functions.c   **** 			{
2264:functions.c   **** 				SeqOpOn &= ~OP_ROLL_ENGAGE; // OP5 OFF: Roller Engage Solenoid (AKA Pre Net Position)
2265:functions.c   **** 				SeqOpOff |= OP_ROLL_ENGAGE;
2266:functions.c   **** 				RollerTimer = 0;
2267:functions.c   **** 			}
2268:functions.c   **** 			else if( RollEngageTurnedOn )
2269:functions.c   **** 			{
2270:functions.c   **** 				/*if(pFac.pf.GW302_NetTwineOption == TO_TWINE)
2271:functions.c   **** 				{*/
2272:functions.c   **** 				RollerTimer = OP_ROLL_ENGAGE_TIMER; /*3 seconds*/
2273:functions.c   **** 				/*}
2274:functions.c   **** 				else
2275:functions.c   **** 				{
2276:functions.c   **** 					SeqOpOn |= OP_ROLL_ENGAGE; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
2277:functions.c   **** 					SeqOpOff &= ~OP_ROLL_ENGAGE;
2278:functions.c   **** 				}*/
2279:functions.c   **** 
2280:functions.c   **** 			}
2281:functions.c   **** 
2282:functions.c   **** 
2283:functions.c   **** 
2284:functions.c   **** 
2285:functions.c   **** 
2286:functions.c   **** 			// -----------------------------------------------------------
2287:functions.c   **** 			// Pre Warning beep (AUTO) -- unless disabled by IP3 opening
2288:functions.c   **** 
2289:functions.c   **** 			if(  ( !NettingStartBeepsDisabledWhileIP3OpenInAutoMode )
2290:functions.c   **** 			  && ( BaleDiaVolts > DiaPreWarnVolts ) // Pre warning beep bale diameter exceeded
2291:functions.c   **** 			  && ( pFac.pf.GW302_PreWarningBeep > 0 ) // Pre Warning beep on (set to non-zero value)
2292:functions.c   **** 			  && ( !pre_warning_cont_beep ) )
2293:functions.c   **** 			{
2294:functions.c   **** 				buzz_length = PRE_WARNING_BEEP; // Pre Warning beep
2295:functions.c   **** 				pre_warning_cont_beep = 1;      // Only repeated after a sequence is completed
2296:functions.c   **** 
2297:functions.c   **** 			}
2298:functions.c   **** 
2299:functions.c   **** 
2300:functions.c   **** 			// -----------------------------------------------------------
2301:functions.c   **** 			// Beeping if chamber open > 1 s outside unloading (IP3 opens & closes) (AUTO)
2302:functions.c   **** 
2303:functions.c   **** 			if( (Stage != STAGE_NETTING_END)    &&    // Ignoring chamber opening between the start & end of
2304:functions.c   **** 					(Stage != STAGE_UNLOADING)      &&
2305:functions.c   **** 					(Stage != STAGE_UNLOADING_WAIT)    )
2306:functions.c   **** 			{
2307:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
2308:functions.c   **** 				{
2309:functions.c   **** 					// Beeping
2310:functions.c   **** 					if( ChamberOpenBeepDelay )
2311:functions.c   **** 					{
2312:functions.c   **** 						ChamberOpenBeepDelay--;
2313:functions.c   **** 					}
2314:functions.c   **** 					else
2315:functions.c   **** 					{
2316:functions.c   **** 						// Intermittent beeping while chamber open
2317:functions.c   **** 						buzz_length = AUTO_CHAMBER_OPEN_BEEP;
2318:functions.c   **** 						ChamberOpenBeepDelay = COBD_CHAMBER_OPEN_BEEP_DELAY;  // Reset chamber open beep delay to bee
2319:functions.c   **** 					}
2320:functions.c   **** 				}
2321:functions.c   **** 				else // Chamber closed
2322:functions.c   **** 				{
2323:functions.c   **** 					ChamberOpenBeepDelay = COBD_CHAMBER_OPEN_BEEP_DELAY; // to ensure beeping starts after 1 s del
2324:functions.c   **** 				}
2325:functions.c   **** 			}
2326:functions.c   **** 
2327:functions.c   **** 
2328:functions.c   **** 			// -----------------------------------------------------------
2329:functions.c   **** 			// Turning off OP2 & OP5 if chamber opens outside of unloading (AUTO)
2330:functions.c   **** 
2331:functions.c   **** 			if( (Stage != STAGE_NETTING_END)    &&    // Ignoring chamber opening between the start & end of
2332:functions.c   **** 					(Stage != STAGE_UNLOADING)      &&
2333:functions.c   **** 					(Stage != STAGE_UNLOADING_WAIT)    )
2334:functions.c   **** 			{
2335:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
2336:functions.c   **** 				{
2337:functions.c   **** 					// Saving OP5 flags if not yet saved
2338:functions.c   **** 					if( !SavedRollEngageTurnedOn )
2339:functions.c   **** 					{
2340:functions.c   **** 						SavedRollEngageTurnedOn = RollEngageTurnedOn;
2341:functions.c   **** 					}
2342:functions.c   **** 					if( !SavedOP5TurnedOnAfterBeakEngagePulsesEnabled )
2343:functions.c   **** 					{
2344:functions.c   **** 						SavedOP5TurnedOnAfterBeakEngagePulsesEnabled = OP5TurnedOnAfterBeakEngagePulsesEnabled;
2345:functions.c   **** 					}
2346:functions.c   **** 
2347:functions.c   **** 					// Ensuring OP5 Roller Engage Solenoid is off while Chamber Locked Sensor open
2348:functions.c   **** 					RollEngageTurnedOn = 0;                      // OP5 Roller Engage Solenoid (AKA Pre Net Positi
2349:functions.c   **** 					OP5TurnedOnAfterBeakEngagePulsesEnabled = 0; // Turning on Roller Engage Solenoid (OP5) after 
2350:functions.c   **** 					SeqOpOn &= ~OP_ROLL_ENGAGE; // OP5 OFF: Roller Engage Solenoid (AKA Pre Net Position)
2351:functions.c   **** 					SeqOpOff |= OP_ROLL_ENGAGE;
2352:functions.c   **** 
2353:functions.c   **** 					// Ensuring OP2 Net Clutch is off while Chamber Locked Sensor open
2354:functions.c   **** 					SeqOpOn &= ~OP_NET_ON; // OP2 OFF: Net Clutch (AKA Net On)
2355:functions.c   **** 					SeqOpOff |= OP_NET_ON;
2356:functions.c   **** 				}
2357:functions.c   **** 				else // Chamber closed
2358:functions.c   **** 				{
2359:functions.c   **** 					// Restoring OP5 flags if saved
2360:functions.c   **** 					if( SavedRollEngageTurnedOn )
2361:functions.c   **** 					{
2362:functions.c   **** 						RollEngageTurnedOn = SavedRollEngageTurnedOn;
2363:functions.c   **** 						SavedRollEngageTurnedOn = 0; // Reset
2364:functions.c   **** 					}
2365:functions.c   **** 					if( SavedOP5TurnedOnAfterBeakEngagePulsesEnabled )
2366:functions.c   **** 					{
2367:functions.c   **** 						OP5TurnedOnAfterBeakEngagePulsesEnabled = SavedOP5TurnedOnAfterBeakEngagePulsesEnabled;
2368:functions.c   **** 						SavedOP5TurnedOnAfterBeakEngagePulsesEnabled = 0; // Reset
2369:functions.c   **** 					}
2370:functions.c   **** 				}
2371:functions.c   **** 			}
2372:functions.c   **** 			else // Between start & end of unloading -- Netting finished before unloading OR waiting for suf
2373:functions.c   **** 			{
2374:functions.c   **** 				RollEngageTurnedOn = 0; // Reset
2375:functions.c   **** 				SavedRollEngageTurnedOn = 0; // Reset
2376:functions.c   **** 
2377:functions.c   **** 				OP5TurnedOnAfterBeakEngagePulsesEnabled = 0; // Reset
2378:functions.c   **** 				SavedOP5TurnedOnAfterBeakEngagePulsesEnabled = 0; // Reset
2379:functions.c   **** 			}
2380:functions.c   **** 
2381:functions.c   **** 
2382:functions.c   **** 			// -----------------------------------------------------------
2383:functions.c   **** 			// Disabling Net Warning & Netting Start Beeps (incl. Pre Warning & Net Delay Beeps) if chamber 
2384:functions.c   **** 
2385:functions.c   **** 			if( (Stage != STAGE_NETTING_END)    &&    // Ignoring chamber opening between the start & end of
2386:functions.c   **** 					(Stage != STAGE_UNLOADING)      &&
2387:functions.c   **** 					(Stage != STAGE_UNLOADING_WAIT)    )
2388:functions.c   **** 			{
2389:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
2390:functions.c   **** 				{
2391:functions.c   **** 					NetWarningDisabledWhileIP3OpenInAutoMode = 1;
2392:functions.c   **** 					NettingStartBeepsDisabledWhileIP3OpenInAutoMode = 1; // Including Pre Warning & Net Delay beep
2393:functions.c   **** 				}
2394:functions.c   **** 				else // Chamber closed
2395:functions.c   **** 				{
2396:functions.c   **** 					NetWarningDisabledWhileIP3OpenInAutoMode = 0; // Reset
2397:functions.c   **** 					NettingStartBeepsDisabledWhileIP3OpenInAutoMode = 0; // Reset
2398:functions.c   **** 				}
2399:functions.c   **** 			}
2400:functions.c   **** 			else // Between start & end of unloading -- Netting finished before unloading OR waiting for suf
2401:functions.c   **** 			{
2402:functions.c   **** 				NetWarningDisabledWhileIP3OpenInAutoMode = 0; // Reset
2403:functions.c   **** 				NettingStartBeepsDisabledWhileIP3OpenInAutoMode = 0; // Reset
2404:functions.c   **** 			}
2405:functions.c   **** 
2406:functions.c   **** 		}
2407:functions.c   **** 		else // MAN mode
2408:functions.c   **** 		{
2409:functions.c   **** 			// -----------------------------------------------------------
2410:functions.c   **** 			// Monitoring bale density (MAN)
2411:functions.c   **** 
2412:functions.c   **** 			if( BaleDiaVolts > DiaCoreVolts )  // Core diameter exceeded
2413:functions.c   **** 			{
2414:functions.c   **** 				// -----------------------------------------------------------
2415:functions.c   **** 				// Density Control Function -- based on Target Bale Density
2416:functions.c   **** 
2417:functions.c   **** 				if( DensityPresVolts >= DensityBaleVolts ) // Target bale density reached/exceeded
2418:functions.c   **** 				{
2419:functions.c   **** 					if( OP8OnDelayTime )
2420:functions.c   **** 						OP8OnDelayTime--;
2421:functions.c   **** 					else // Pres. Sw. delay has expired
2422:functions.c   **** 					{
2423:functions.c   **** 						SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
2424:functions.c   **** 						SeqOpOff &= ~OP_DENSITY_REL;
2425:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
2426:functions.c   **** 					}
2427:functions.c   **** 				}
2428:functions.c   **** 				else if( DensityPresVolts < (DensityBaleVolts - pFac.pf.GW302_PresDeadband) ) // Fallen below d
2429:functions.c   **** 				{
2430:functions.c   **** 					if( OP8OffDelayTime )
2431:functions.c   **** 						OP8OffDelayTime--;
2432:functions.c   **** 					else // Pres. Sw. delay has expired
2433:functions.c   **** 					{
2434:functions.c   **** 						SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
2435:functions.c   **** 						SeqOpOff |= OP_DENSITY_REL;
2436:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
2437:functions.c   **** 					}
2438:functions.c   **** 				}
2439:functions.c   **** 			}
2440:functions.c   **** 			else  // Core diameter not yet reached
2441:functions.c   **** 			{
2442:functions.c   **** 				// -----------------------------------------------------------
2443:functions.c   **** 				// Density Control Function -- based on Bale Core Density
2444:functions.c   **** 
2445:functions.c   **** 				if( DensityPresVolts >= DensityCoreVolts ) // Target core density reached/exceeded
2446:functions.c   **** 				{
2447:functions.c   **** 					if( OP8OnDelayTime )
2448:functions.c   **** 						OP8OnDelayTime--;
2449:functions.c   **** 					else // Pres. Sw. delay has expired
2450:functions.c   **** 					{
2451:functions.c   **** 						SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
2452:functions.c   **** 						SeqOpOff &= ~OP_DENSITY_REL;
2453:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
2454:functions.c   **** 					}
2455:functions.c   **** 				}
2456:functions.c   **** 				else if( DensityPresVolts < (DensityCoreVolts - pFac.pf.GW302_PresDeadband) ) // Fallen below d
2457:functions.c   **** 				{
2458:functions.c   **** 					if( OP8OffDelayTime )
2459:functions.c   **** 						OP8OffDelayTime--;
2460:functions.c   **** 					else // Pres. Sw. delay has expired
2461:functions.c   **** 					{
2462:functions.c   **** 						SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
2463:functions.c   **** 						SeqOpOff |= OP_DENSITY_REL;
2464:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
2465:functions.c   **** 					}
2466:functions.c   **** 				}
2467:functions.c   **** 			}
2468:functions.c   **** 
2469:functions.c   **** 
2470:functions.c   **** 			// -----------------------------------------------------------
2471:functions.c   **** 			// Monitoring bale size (MAN)
2472:functions.c   **** 
2473:functions.c   **** 			if( BaleDiaVolts > DiaTargetVolts )  // Target bale diameter exceeded
2474:functions.c   **** 			{
2475:functions.c   **** 				if( BalerFullDelayTime )
2476:functions.c   **** 				{
2477:functions.c   **** 					BalerFullDelayTime--;
2478:functions.c   **** 
2479:functions.c   **** 					// Intermittent beep for duration of Net Delay time (t1)
2480:functions.c   **** 					buzz_count = 1;
2481:functions.c   **** 
2482:functions.c   **** 					// Resetting to enable target beeps
2483:functions.c   **** 					target_bale_dia_reached_cont_beep = 0;
2484:functions.c   **** 				}
2485:functions.c   **** 				else // Baler Full / Net Delay (t1) has expired
2486:functions.c   **** 				{
2487:functions.c   **** 					// Continuous beep for 3s (when OP2 turns on)
2488:functions.c   **** 					if( !target_bale_dia_reached_cont_beep )
2489:functions.c   **** 					{
2490:functions.c   **** 						buzz_length = NETTING_START_BEEP; // Long continuous beep when netting can be started in MAN 
2491:functions.c   **** 						target_bale_dia_reached_cont_beep = 1;
2492:functions.c   **** 					}
2493:functions.c   **** 				}
2494:functions.c   **** 			}
2495:functions.c   **** 			else // Target bale diameter has not yet been reached
2496:functions.c   **** 			{
2497:functions.c   **** 				if( BaleDiaVolts > DiaPreWarnVolts ) // Pre warning beep bale diameter exceeded
2498:functions.c   **** 				{
2499:functions.c   **** 					if( pFac.pf.GW302_PreWarningBeep > 0 ) // Pre Warning beep on (set to non-zero value)
2500:functions.c   **** 					{
2501:functions.c   **** 						if( !pre_warning_cont_beep )
2502:functions.c   **** 						{
2503:functions.c   **** 							buzz_length = PRE_WARNING_BEEP; // Pre Warning beep
2504:functions.c   **** 							pre_warning_cont_beep = 1;      // Only repeated after a sequence is completed
2505:functions.c   **** 						}
2506:functions.c   **** 					}
2507:functions.c   **** 				}
2508:functions.c   **** 
2509:functions.c   **** 				// Resetting to allow baler full timer to be restarted & enable target beeps
2510:functions.c   **** 				BalerFullDelayTime = (unsigned char)(pFac.pf.GW302_NetDelay * 10.0);
2511:functions.c   **** 				target_bale_dia_reached_cont_beep = 0;
2512:functions.c   **** 			}
2513:functions.c   **** 
2514:functions.c   **** 
2515:functions.c   **** 			// -----------------------------------------------------------
2516:functions.c   **** 			// Stage completion (MAN)
2517:functions.c   **** 
2518:functions.c   **** 			// First 2 stages completed
2519:functions.c   **** 			if( stagecomp == (NETFEEDON | NETCUTON) )
2520:functions.c   **** 			{
2521:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
2522:functions.c   **** 				{
2523:functions.c   **** 					if( ChamberOpenDelayTime )
2524:functions.c   **** 					{
2525:functions.c   **** 						ChamberOpenDelayTime--;
2526:functions.c   **** 
2527:functions.c   **** 						if( !start_chamber_open_delay_cont_beep )
2528:functions.c   **** 						{
2529:functions.c   **** 							buzz_length = MAN_START_END_CHAMBER_OPEN_DELAY_BEEP; // Beep at start of chamber open delay
2530:functions.c   **** 							start_chamber_open_delay_cont_beep = 1;
2531:functions.c   **** 						}
2532:functions.c   **** 					}
2533:functions.c   **** 					else // Chamber open delay has expired
2534:functions.c   **** 					{
2535:functions.c   **** 						stagecomp |= CHAMBOP;     // Set CHAMBER OPEN stage completed
2536:functions.c   **** 						stagecomp &= ~(CHAMBCLO); // This stage is to be completed next
2537:functions.c   **** 
2538:functions.c   **** 						if( !end_chamber_open_delay_cont_beep )
2539:functions.c   **** 						{
2540:functions.c   **** 							buzz_length = MAN_START_END_CHAMBER_OPEN_DELAY_BEEP; // Beep at end of chamber open delay
2541:functions.c   **** 							end_chamber_open_delay_cont_beep = 1;
2542:functions.c   **** 						}
2543:functions.c   **** 					}
2544:functions.c   **** 				}
2545:functions.c   **** 
2546:functions.c   **** 				if( CHAMBER_CLOSED) // Chamber Locked Sensor closed
2547:functions.c   **** 				{
2548:functions.c   **** 					ChamberOpenDelayTime = CODT_CHAMBER_OPEN_TIME;  // Reset Chamber open delay
2549:functions.c   **** 					start_chamber_open_delay_cont_beep = 0;
2550:functions.c   **** 				}
2551:functions.c   **** 			}
2552:functions.c   **** 
2553:functions.c   **** 			// First 3 stages completed
2554:functions.c   **** 			if( stagecomp == (NETFEEDON | NETCUTON | CHAMBOP) )
2555:functions.c   **** 			{
2556:functions.c   **** 				if( CHAMBER_CLOSED) // Chamber Locked Sensor closed
2557:functions.c   **** 				{
2558:functions.c   **** 					stagecomp |= CHAMBCLO;  // Set CHAMBER CLOSED stage completed
2559:functions.c   **** 				}
2560:functions.c   **** 			}
2561:functions.c   **** 
2562:functions.c   **** 			// all stages completed (in the order indicated left to right)
2563:functions.c   **** 			if( stagecomp == (NETFEEDON | NETCUTON | CHAMBOP | CHAMBCLO) )
2564:functions.c   **** 			{
2565:functions.c   **** 				stagecomp = SC_CLEAR; // Reset
2566:functions.c   **** 
2567:functions.c   **** 				UpdatingAndSavingTotalsToMemory();
2568:functions.c   **** 
2569:functions.c   **** 				buzz_length = ALL_STAGES_COMPLETE_BEEP; // Beep on completion of all stages
2570:functions.c   **** 
2571:functions.c   **** 				ResetSequenceFactors( SEQ_ALL );
2572:functions.c   **** 			}
2573:functions.c   **** 
2574:functions.c   **** 
2575:functions.c   **** 			// -----------------------------------------------------------
2576:functions.c   **** 			// Roller Engage Solenoid (OP5) turned on/off (MAN)
2577:functions.c   **** 
2578:functions.c   **** 			if( pFac.pf.GW302_NetSystem == NS_ROLLER ) // Roller Engage Solenoid (OP5) only turned on/off if
2579:functions.c   **** 			{
2580:functions.c   **** 				// Turning Roller Engage Solenoid (OP5) on if Bale Diameter goes from below to above Engage dia
2581:functions.c   **** 				if( BaleDiaVolts < DiaEngageVolts ) // below Engage diameter
2582:functions.c   **** 				{
2583:functions.c   **** 					BaleDiameterStatusInManMode |= BDSIMM_BELOW_ENGAGE_DIA; // Set BDSIMM_BELOW_ENGAGE_DIA flag
2584:functions.c   **** 					BaleDiameterStatusInManMode &= ~(BDSIMM_ABOVE_ENGAGE_DIA); // Flag to be set next
2585:functions.c   **** 					RollEngageTurnedOnInManMode = 0; // OP5 OFF: Roller Engage Solenoid (AKA Pre Net Position) -- 
2586:functions.c   **** 				}
2587:functions.c   **** 				else // above Engage diameter
2588:functions.c   **** 				{
2589:functions.c   **** 					if( BaleDiameterStatusInManMode == BDSIMM_BELOW_ENGAGE_DIA ) // BDSIMM_BELOW_ENGAGE_DIA flag a
2590:functions.c   **** 					{
2591:functions.c   **** 						BaleDiameterStatusInManMode |= BDSIMM_ABOVE_ENGAGE_DIA; // Set BDSIMM_ABOVE_ENGAGE_DIA flag
2592:functions.c   **** 
2593:functions.c   **** 						if ((RollerTimer == 255) && (RollEngageTurnedOnInManMode == 0) )
2594:functions.c   **** 						{
2595:functions.c   **** 							RollEngageTurnedOnInManMode = 1; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position) --
2596:functions.c   **** 							RollerTimer = OP_ROLL_ENGAGE_TIMER; /*3 seconds*/
2597:functions.c   **** 						}
2598:functions.c   **** 
2599:functions.c   **** 					}
2600:functions.c   **** 				}
2601:functions.c   **** 
2602:functions.c   **** 				// Turning Roller Engage Solenoid (OP5) off if OP7 (Net Cut) comes on -- at any time
2603:functions.c   **** 				// Done in Button 2 code
2604:functions.c   **** 
2605:functions.c   **** 				// Turning Roller Engage Solenoid (OP5) off if chamber closes and opens -- at any time
2606:functions.c   **** 				if( ChamberStatus == (CS_CLOSED | CS_OPEN) ) // Chamber was closed and now opened
2607:functions.c   **** 				{
2608:functions.c   **** 					RollEngageTurnedOnInManMode = 0; // OP5 OFF: Roller Engage Solenoid (AKA Pre Net Position) -- 
2609:functions.c   **** 				}
2610:functions.c   **** 
2611:functions.c   **** 				// Turning Roller Engage Solenoid (OP5) on/off
2612:functions.c   **** /*				if( RollEngageTurnedOnInManMode )
2613:functions.c   **** 				{
2614:functions.c   **** 					KeyOpOn |=  OP_ROLL_ENGAGE; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
2615:functions.c   **** 				}*/
2616:functions.c   **** 
2617:functions.c   **** 			} // end if( pFac.pf.GW302_NetSystem == NS_ROLLER )
2618:functions.c   **** 
2619:functions.c   **** 		} // end MAN mode
2620:functions.c   **** 
2621:functions.c   **** 
2622:functions.c   **** 		/*if(pFac.pf.GW302_NetTwineOption == TO_TWINE)
2623:functions.c   **** 		{*/
2624:functions.c   **** 			if (RollerTimer && !(RollerTimer == 255))
2625:functions.c   **** 			{
2626:functions.c   **** 				RollEngageTurnedOn = 0;
2627:functions.c   **** 				SeqOpOn |= OP_ROLL_ENGAGE; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
2628:functions.c   **** 				SeqOpOff &= ~OP_ROLL_ENGAGE;
2629:functions.c   **** 				RollerTimer--;
2630:functions.c   **** 			}
2631:functions.c   **** 			else if(!RollerTimer)
2632:functions.c   **** 			{
2633:functions.c   **** 				SeqOpOn &= ~OP_ROLL_ENGAGE; // OP5 OFF: Roller Engage Solenoid (AKA Pre Net Position)
2634:functions.c   **** 				SeqOpOff |= OP_ROLL_ENGAGE;
2635:functions.c   **** 				RollerTimer = 255;
2636:functions.c   **** 			}
2637:functions.c   **** 		/* } */
2638:functions.c   **** 
2639:functions.c   **** 
2640:functions.c   **** 		// -----------------------------------------------------------
2641:functions.c   **** 		// Check Chopping knives position (MAN/AUTO)
2642:functions.c   **** 
2643:functions.c   **** 		if( CHOPPING_KNIVES_ON && // IP2 open: 11 Knife Sensor (AKA Chopping Knives position / Knives Pos
2644:functions.c   **** 				( (((key & ~(SW_NEW | SW_REP)) != SW_IR) && ((key & ~(SW_NEW | SW_REP)) != SW_OR)) || SecondScr
2645:functions.c   **** 		{
2646:functions.c   **** 			Kniv1_IPClosed = 1;
2647:functions.c   **** 			Kniv1_IPOpenTime = 0;
2648:functions.c   **** 		}
2649:functions.c   **** 		else // IP2 closed: 11 Knife Sensor in the OFF position
2650:functions.c   **** 		{
2651:functions.c   **** 			if( Kniv1_IPClosed )
2652:functions.c   **** 			{
2653:functions.c   **** 				if( Kniv1_IPOpenTime < 250 )
2654:functions.c   **** 					Kniv1_IPOpenTime++;
2655:functions.c   **** 
2656:functions.c   **** 				if( Kniv1_IPOpenTime > 10 )
2657:functions.c   **** 					ChoppingKnives1WarningOn = 1; // Chopping knives position Warning on
2658:functions.c   **** 			}
2659:functions.c   **** 		}
2660:functions.c   **** 
2661:functions.c   **** 
2662:functions.c   **** 		// -----------------------------------------------------------
2663:functions.c   **** 		// Check Chamber Locked Sensor (MAN/AUTO)
2664:functions.c   **** 
2665:functions.c   **** 		// Looking for Chamber to close then open
2666:functions.c   **** 		if( CHAMBER_CLOSED ) // IP3: Chamber Locked Sensor closed
2667:functions.c   **** 		{
2668:functions.c   **** 			ChamberStatus |= CS_CLOSED; // Set CS_CLOSED flag
2669:functions.c   **** 			ChamberStatus &= ~(CS_OPEN); // Flag to be set next
2670:functions.c   **** 		}
2671:functions.c   **** 		else // CHAMBER_OPEN -- IP3: Chamber Locked Sensor open
2672:functions.c   **** 		{
2673:functions.c   **** 			if( ChamberStatus == CS_CLOSED ) // CS_CLOSED flag already set
2674:functions.c   **** 			{
2675:functions.c   **** 				ChamberStatus |= CS_OPEN; // Set CS_OPEN flag
2676:functions.c   **** 				OP8OnCount = OP8_ON_COUNT_DURATION; // 6s -- Set count (or reset, if count down already underwa
2677:functions.c   **** 			}
2678:functions.c   **** 		}
2679:functions.c   **** 
2680:functions.c   **** 		// After Chamber closes then opens, turn on Density Release Solenoid for the count
2681:functions.c   **** 		if( OP8OnCount )
2682:functions.c   **** 		{
2683:functions.c   **** 			KeyOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
2684:functions.c   **** 
2685:functions.c   **** 			OP8OnCount--;
2686:functions.c   **** 		}
2687:functions.c   **** 
2688:functions.c   **** 
2689:functions.c   **** 		// -----------------------------------------------------------
2690:functions.c   **** 		// Check Bale Diameter (MAN/AUTO)
2691:functions.c   **** 
2692:functions.c   **** 		// Looking for whether Pre warning beep bale diameter exceeded OR Engage diameter reached
2693:functions.c   **** 		if( (BaleDiaVolts > DiaPreWarnVolts) || (BaleDiaVolts >= DiaEngageVolts) )
2694:functions.c   **** 		{
2695:functions.c   **** 			DrivingArrowBeepsDisabled = 1; // Driving Arrow Beeps turned off
2696:functions.c   **** 		}
2697:functions.c   **** 
2698:functions.c   **** 
2699:functions.c   **** 		// -----------------------------------------------------------
2700:functions.c   **** 		// Outputs (MAN/AUTO)
2701:functions.c   **** 
2702:functions.c   **** 		SeqOpOn = SeqOpOn & ~SeqOpOff; /* If an Op is to be turned off, dont turn it on */
2703:functions.c   **** 
2704:functions.c   **** 		OpOff = KeyOpOff | SeqOpOff;
2705:functions.c   **** 		/*AT91C_BASE_PIOA->PIO_SODR = OpOff;*/
2706:functions.c   **** 
2707:functions.c   **** 		OpOn = KeyOpOn | SeqOpOn;
2708:functions.c   **** 		/*AT91C_BASE_PIOA->PIO_CODR = OpOn;*/
2709:functions.c   **** 
2710:functions.c   **** 
2711:functions.c   **** 	} // end if( AllTime )
2712:functions.c   **** 
2713:functions.c   **** }
2714:functions.c   **** // -----------------------------------------------------------
2715:functions.c   **** 
2716:functions.c   **** 
2717:functions.c   **** // -----------------------------------------------------------
2718:functions.c   **** // Function Name       : ResetSequenceFactors
2719:functions.c   **** // -----------------------------------------------------------
2720:functions.c   **** void ResetSequenceFactors( unsigned char seq )
2721:functions.c   **** {
 2688              		.loc 1 2721 0
 2689              		.cfi_startproc
 2690              	.LVL158:
2722:functions.c   **** 	SeqOpOff = SeqOpOn;
 2691              		.loc 1 2722 0
 2692 0000 294A     		ldr	r2, .L155
2723:functions.c   **** 	OpOff = SeqOpOff;
 2693              		.loc 1 2723 0
 2694 0002 2A4B     		ldr	r3, .L155+4
 2695 0004 1168     		ldr	r1, [r2]
 2696 0006 1963     		str	r1, [r3, #48]
2724:functions.c   **** 	SeqOpOff = 0; /* Nothing off */
 2697              		.loc 1 2724 0
 2698 0008 0023     		mov	r3, #0
 2699 000a 2949     		ldr	r1, .L155+8
 2700 000c 0B60     		str	r3, [r1]
2725:functions.c   **** 	SeqOpOn = 0;  /* Nothing on */
 2701              		.loc 1 2725 0
 2702 000e 1360     		str	r3, [r2]
2726:functions.c   **** 
2727:functions.c   **** 	ContinueOnKeyRelease = 0;
 2703              		.loc 1 2727 0
 2704 0010 284A     		ldr	r2, .L155+12
 2705 0012 1370     		strb	r3, [r2]
2728:functions.c   **** 	StartAutoNet = 0;
 2706              		.loc 1 2728 0
 2707 0014 284A     		ldr	r2, .L155+16
 2708 0016 1370     		strb	r3, [r2]
2729:functions.c   **** 
2730:functions.c   **** 	Stage = STAGE_START;
 2709              		.loc 1 2730 0
 2710 0018 284A     		ldr	r2, .L155+20
 2711 001a 1370     		strb	r3, [r2]
2731:functions.c   **** 	stagecomp = SC_CLEAR;
 2712              		.loc 1 2731 0
 2713 001c 284A     		ldr	r2, .L155+24
 2714 001e 1370     		strb	r3, [r2]
2732:functions.c   **** 
2733:functions.c   **** 	cont_beep = 0;
 2715              		.loc 1 2733 0
 2716 0020 284A     		ldr	r2, .L155+28
 2717 0022 1370     		strb	r3, [r2]
2734:functions.c   **** 	target_bale_dia_reached_cont_beep = 0;
 2718              		.loc 1 2734 0
 2719 0024 284A     		ldr	r2, .L155+32
 2720 0026 1370     		strb	r3, [r2]
2735:functions.c   **** 	pre_warning_cont_beep = 0;
 2721              		.loc 1 2735 0
 2722 0028 284A     		ldr	r2, .L155+36
 2723 002a 1370     		strb	r3, [r2]
2736:functions.c   **** 	start_chamber_open_delay_cont_beep = 0;
 2724              		.loc 1 2736 0
 2725 002c 284A     		ldr	r2, .L155+40
 2726 002e 1370     		strb	r3, [r2]
2737:functions.c   **** 	end_chamber_open_delay_cont_beep = 0;
 2727              		.loc 1 2737 0
 2728 0030 284A     		ldr	r2, .L155+44
 2729 0032 1370     		strb	r3, [r2]
2738:functions.c   **** 
2739:functions.c   **** 	DensityPressureTooHigh = 0; // Density Pressure Too High Warning
 2730              		.loc 1 2739 0
 2731 0034 284A     		ldr	r2, .L155+48
 2732 0036 1370     		strb	r3, [r2]
2740:functions.c   **** 
2741:functions.c   **** 	SequenceInProgress = 0;
 2733              		.loc 1 2741 0
 2734 0038 284A     		ldr	r2, .L155+52
 2735 003a 1370     		strb	r3, [r2]
2742:functions.c   **** 
2743:functions.c   **** 	OP2OnDelayTime  = 0;        // Net Clutch (AKA Net On)
 2736              		.loc 1 2743 0
 2737 003c 284A     		ldr	r2, .L155+56
 2738 003e 1370     		strb	r3, [r2]
2744:functions.c   **** 	OP2OffDelayTime = 0;
 2739              		.loc 1 2744 0
 2740 0040 284A     		ldr	r2, .L155+60
 2741 0042 1370     		strb	r3, [r2]
2745:functions.c   **** 	OP7OffDelayTime = 0;        // Net Cut Motor (AKA Net Cut Trip)
 2742              		.loc 1 2745 0
 2743 0044 284A     		ldr	r2, .L155+64
 2744 0046 1370     		strb	r3, [r2]
2746:functions.c   **** 	OP8OnDelayTime  = 0;        // Density Release Solenoid (AKA Density Control)
 2745              		.loc 1 2746 0
 2746 0048 284A     		ldr	r2, .L155+68
 2747 004a 1370     		strb	r3, [r2]
2747:functions.c   **** 	OP8OffDelayTime = 0;
 2748              		.loc 1 2747 0
 2749 004c 284A     		ldr	r2, .L155+72
 2750 004e 1370     		strb	r3, [r2]
2748:functions.c   **** 
2749:functions.c   **** 	NetPulseCount = 0UL;        // Resetting IP4 net pulse count
 2751              		.loc 1 2749 0
 2752 0050 284A     		ldr	r2, .L155+76
 2753 0052 1360     		str	r3, [r2]
2750:functions.c   **** 	BeakEngagePulseCount = 0UL; // Resetting IP4 'Beak Engage' pulse count
 2754              		.loc 1 2750 0
 2755 0054 284A     		ldr	r2, .L155+80
 2756 0056 1360     		str	r3, [r2]
2751:functions.c   **** 	NewNetPulses = 0UL;         // Resetting new IP4 pulses
 2757              		.loc 1 2751 0
 2758 0058 284A     		ldr	r2, .L155+84
 2759 005a 1360     		str	r3, [r2]
2752:functions.c   **** 
2753:functions.c   **** #ifdef DEVELOP // Testing pulse counting
2754:functions.c   **** 	//Saved_NetPulseCount = 0UL;        // Resetting
2755:functions.c   **** 	//SavedBeakEngagePulseCount = 0UL;  // Resetting
2756:functions.c   **** #endif
2757:functions.c   **** 
2758:functions.c   **** 	NetWarningDelayTime = 0;    // Check Net Error (AKA Net Warning)
 2760              		.loc 1 2758 0
 2761 005c 284A     		ldr	r2, .L155+88
 2762 005e 1370     		strb	r3, [r2]
2759:functions.c   **** 	NetWarningOn = 0;           // Check Net Error (AKA Net Warning) turned off
 2763              		.loc 1 2759 0
 2764 0060 284A     		ldr	r2, .L155+92
 2765 0062 1370     		strb	r3, [r2]
2760:functions.c   **** 
2761:functions.c   **** 	RollEngageTurnedOn = 0;       // OP5 Roller Engage Solenoid (AKA Pre Net Position) turned off
 2766              		.loc 1 2761 0
 2767 0064 284A     		ldr	r2, .L155+96
 2768 0066 1370     		strb	r3, [r2]
2762:functions.c   **** 	SavedRollEngageTurnedOn = 0;  // Saved when IP3 opens in AUTO mode
 2769              		.loc 1 2762 0
 2770 0068 284A     		ldr	r2, .L155+100
 2771 006a 1370     		strb	r3, [r2]
2763:functions.c   **** 	NetWarningDisabledWhileIP3OpenInAutoMode = 0;
 2772              		.loc 1 2763 0
 2773 006c 284A     		ldr	r2, .L155+104
 2774 006e 1370     		strb	r3, [r2]
2764:functions.c   **** 	NettingStartBeepsDisabledWhileIP3OpenInAutoMode = 0; // Including Pre Warning & Net Delay beep
 2775              		.loc 1 2764 0
 2776 0070 284A     		ldr	r2, .L155+108
 2777 0072 1370     		strb	r3, [r2]
2765:functions.c   **** 
2766:functions.c   **** 	ChamberClosedDelayTime = 0; // Door Closed
 2778              		.loc 1 2766 0
 2779 0074 284A     		ldr	r2, .L155+112
 2780 0076 1370     		strb	r3, [r2]
2767:functions.c   **** 
2768:functions.c   **** 	ChamberOpenDelayTime = 0;   // applies to MAN mode only
 2781              		.loc 1 2768 0
 2782 0078 284A     		ldr	r2, .L155+116
 2783 007a 1370     		strb	r3, [r2]
2769:functions.c   **** 
2770:functions.c   **** 	ChamberOpenBeepDelay = COBD_CHAMBER_OPEN_BEEP_DELAY; // to ensure beeping starts after 1 s delay -
 2784              		.loc 1 2770 0
 2785 007c 0A21     		mov	r1, #10
 2786 007e 284A     		ldr	r2, .L155+120
 2787 0080 1170     		strb	r1, [r2]
2771:functions.c   **** 
2772:functions.c   **** 	BaleKickerStatus = BKS_CLEAR;               // Reset Bale Kicker Down/Up flags
 2788              		.loc 1 2772 0
 2789 0082 284A     		ldr	r2, .L155+124
 2790 0084 1370     		strb	r3, [r2]
2773:functions.c   **** 	BaleDiameterStatusInManMode = BDSIMM_CLEAR; // Reset Bale Diameter Below/Above Engage Diameter (in
 2791              		.loc 1 2773 0
 2792 0086 284A     		ldr	r2, .L155+128
 2793 0088 1370     		strb	r3, [r2]
2774:functions.c   **** 	ChamberStatus = CS_CLEAR;                   // Reset Chamber Closed/Open flags
 2794              		.loc 1 2774 0
 2795 008a 284A     		ldr	r2, .L155+132
 2796 008c 1370     		strb	r3, [r2]
2775:functions.c   **** 
2776:functions.c   **** 	OP8OnCount = 0;                 // Reset count for Density Release Solenoid (OP8) on after Chamber
 2797              		.loc 1 2776 0
 2798 008e 284A     		ldr	r2, .L155+136
 2799 0090 1370     		strb	r3, [r2]
2777:functions.c   **** 
2778:functions.c   **** 	DrivingArrowBeepsDisabled = 0;  // Driving Arrow Beeps turned on
 2800              		.loc 1 2778 0
 2801 0092 284A     		ldr	r2, .L155+140
 2802 0094 1370     		strb	r3, [r2]
2779:functions.c   **** 
2780:functions.c   **** 	DensityControlFunctionActive = 0;                 // Disabling (de-activating) Density Control Fun
 2803              		.loc 1 2780 0
 2804 0096 284A     		ldr	r2, .L155+144
 2805 0098 1370     		strb	r3, [r2]
2781:functions.c   **** 	NetPulseCheckingEnabled = 0;                      // Disabling checking for no pulses on IP4 (for 
 2806              		.loc 1 2781 0
 2807 009a 284A     		ldr	r2, .L155+148
 2808 009c 1370     		strb	r3, [r2]
2782:functions.c   **** 	OP5TurnedOnAfterBeakEngagePulsesEnabled = 0;      // Disabling turning on Roller Engage Solenoid (
 2809              		.loc 1 2782 0
 2810 009e 284A     		ldr	r2, .L155+152
 2811 00a0 1370     		strb	r3, [r2]
2783:functions.c   **** 	SavedOP5TurnedOnAfterBeakEngagePulsesEnabled = 0; // Saved when IP3 opens in AUTO mode
 2812              		.loc 1 2783 0
 2813 00a2 284A     		ldr	r2, .L155+156
 2814 00a4 1370     		strb	r3, [r2]
2784:functions.c   **** 
2785:functions.c   **** 
2786:functions.c   **** /*	pFac.pf.GW302_TwineOption = TO_OFF;
2787:functions.c   **** 	pFac.pf.GW302_NetTwineOption = TO_NET;*/
2788:functions.c   **** 
2789:functions.c   **** }
 2815              		.loc 1 2789 0
 2816              		@ sp needed for prologue
 2817 00a6 7047     		bx	lr
 2818              	.L156:
 2819              		.align	2
 2820              	.L155:
 2821 00a8 00000000 		.word	SeqOpOn
 2822 00ac 00F4FFFF 		.word	-3072
 2823 00b0 00000000 		.word	SeqOpOff
 2824 00b4 00000000 		.word	ContinueOnKeyRelease
 2825 00b8 00000000 		.word	StartAutoNet
 2826 00bc 00000000 		.word	Stage
 2827 00c0 00000000 		.word	stagecomp
 2828 00c4 00000000 		.word	cont_beep
 2829 00c8 00000000 		.word	target_bale_dia_reached_cont_beep
 2830 00cc 00000000 		.word	pre_warning_cont_beep
 2831 00d0 00000000 		.word	start_chamber_open_delay_cont_beep
 2832 00d4 00000000 		.word	end_chamber_open_delay_cont_beep
 2833 00d8 00000000 		.word	DensityPressureTooHigh
 2834 00dc 00000000 		.word	SequenceInProgress
 2835 00e0 00000000 		.word	OP2OnDelayTime
 2836 00e4 00000000 		.word	OP2OffDelayTime
 2837 00e8 00000000 		.word	OP7OffDelayTime
 2838 00ec 00000000 		.word	OP8OnDelayTime
 2839 00f0 00000000 		.word	OP8OffDelayTime
 2840 00f4 00000000 		.word	NetPulseCount
 2841 00f8 00000000 		.word	BeakEngagePulseCount
 2842 00fc 00000000 		.word	NewNetPulses
 2843 0100 00000000 		.word	NetWarningDelayTime
 2844 0104 00000000 		.word	NetWarningOn
 2845 0108 00000000 		.word	RollEngageTurnedOn
 2846 010c 00000000 		.word	SavedRollEngageTurnedOn
 2847 0110 00000000 		.word	NetWarningDisabledWhileIP3OpenInAutoMode
 2848 0114 00000000 		.word	NettingStartBeepsDisabledWhileIP3OpenInAutoMode
 2849 0118 00000000 		.word	ChamberClosedDelayTime
 2850 011c 00000000 		.word	ChamberOpenDelayTime
 2851 0120 00000000 		.word	ChamberOpenBeepDelay
 2852 0124 00000000 		.word	BaleKickerStatus
 2853 0128 00000000 		.word	BaleDiameterStatusInManMode
 2854 012c 00000000 		.word	ChamberStatus
 2855 0130 00000000 		.word	OP8OnCount
 2856 0134 00000000 		.word	DrivingArrowBeepsDisabled
 2857 0138 00000000 		.word	DensityControlFunctionActive
 2858 013c 00000000 		.word	NetPulseCheckingEnabled
 2859 0140 00000000 		.word	OP5TurnedOnAfterBeakEngagePulsesEnabled
 2860 0144 00000000 		.word	SavedOP5TurnedOnAfterBeakEngagePulsesEnabled
 2861              		.cfi_endproc
 2862              	.LFE388:
 2864              		.section	.text.AllSeqOpOff,"ax",%progbits
 2865              		.align	2
 2866              		.global	AllSeqOpOff
 2867              		.code	16
 2868              		.thumb_func
 2870              	AllSeqOpOff:
 2871              	.LFB389:
2790:functions.c   **** // -----------------------------------------------------------
2791:functions.c   **** 
2792:functions.c   **** 
2793:functions.c   **** // -----------------------------------------------------------
2794:functions.c   **** // Function Name       : AllSeqOpOff 
2795:functions.c   **** // -----------------------------------------------------------
2796:functions.c   **** void AllSeqOpOff( void )
2797:functions.c   **** {
 2872              		.loc 1 2797 0
 2873              		.cfi_startproc
2798:functions.c   **** 	SeqOpOff = SeqOpOn;
 2874              		.loc 1 2798 0
 2875 0000 044B     		ldr	r3, .L158
2799:functions.c   **** 	OpOff = SeqOpOff;
 2876              		.loc 1 2799 0
 2877 0002 054A     		ldr	r2, .L158+4
 2878 0004 1968     		ldr	r1, [r3]
 2879 0006 1163     		str	r1, [r2, #48]
2800:functions.c   **** 	SeqOpOff = 0; /* Nothing off */
 2880              		.loc 1 2800 0
 2881 0008 0022     		mov	r2, #0
 2882 000a 0449     		ldr	r1, .L158+8
 2883 000c 0A60     		str	r2, [r1]
2801:functions.c   **** 	SeqOpOn = 0;  /* Nothing on */
 2884              		.loc 1 2801 0
 2885 000e 1A60     		str	r2, [r3]
2802:functions.c   **** }
 2886              		.loc 1 2802 0
 2887              		@ sp needed for prologue
 2888 0010 7047     		bx	lr
 2889              	.L159:
 2890 0012 C046     		.align	2
 2891              	.L158:
 2892 0014 00000000 		.word	SeqOpOn
 2893 0018 00F4FFFF 		.word	-3072
 2894 001c 00000000 		.word	SeqOpOff
 2895              		.cfi_endproc
 2896              	.LFE389:
 2898              		.section	.text.UpdatingAndSavingTotalsToMemory,"ax",%progbits
 2899              		.align	2
 2900              		.global	UpdatingAndSavingTotalsToMemory
 2901              		.code	16
 2902              		.thumb_func
 2904              	UpdatingAndSavingTotalsToMemory:
 2905              	.LFB390:
2803:functions.c   **** // -----------------------------------------------------------
2804:functions.c   **** 
2805:functions.c   **** 
2806:functions.c   **** // -----------------------------------------------------------
2807:functions.c   **** // Function Name       : UpdatingAndSavingTotalsToMemory
2808:functions.c   **** // -----------------------------------------------------------
2809:functions.c   **** void UpdatingAndSavingTotalsToMemory( void ) 
2810:functions.c   **** {        
 2906              		.loc 1 2810 0
 2907              		.cfi_startproc
 2908 0000 10B5     		push	{r4, lr}
 2909              	.LCFI17:
 2910              		.cfi_def_cfa_offset 8
 2911              		.cfi_offset 4, -8
 2912              		.cfi_offset 14, -4
2811:functions.c   **** 	pFac.pf.BaleTotal[pFac.pf.BaleStore] += PF_GW302_BaleTotal[PF_STEP];
 2913              		.loc 1 2811 0
 2914 0002 1F4A     		ldr	r2, .L167
 2915 0004 3823     		mov	r3, #56
 2916 0006 D35C     		ldrb	r3, [r2, r3]
 2917 0008 191D     		add	r1, r3, #4
 2918 000a 8900     		lsl	r1, r1, #2
 2919 000c 8A58     		ldr	r2, [r1, r2]
 2920 000e 0132     		add	r2, r2, #1
2812:functions.c   **** 	if( pFac.pf.BaleTotal[pFac.pf.BaleStore] > PF_GW302_BaleTotal[PF_MAX] ) // Rolling over at max num
 2921              		.loc 1 2812 0
 2922 0010 1C49     		ldr	r1, .L167+4
 2923 0012 8A42     		cmp	r2, r1
 2924 0014 04D8     		bhi	.L161
2811:functions.c   **** 	pFac.pf.BaleTotal[pFac.pf.BaleStore] += PF_GW302_BaleTotal[PF_STEP];
 2925              		.loc 1 2811 0
 2926 0016 0433     		add	r3, r3, #4
 2927 0018 9B00     		lsl	r3, r3, #2
 2928 001a 1949     		ldr	r1, .L167
 2929 001c 5A50     		str	r2, [r3, r1]
 2930 001e 04E0     		b	.L162
 2931              	.L161:
2813:functions.c   **** 	{
2814:functions.c   **** 		pFac.pf.BaleTotal[pFac.pf.BaleStore] = PF_GW302_BaleTotal[PF_MIN]; // 0UL
 2932              		.loc 1 2814 0
 2933 0020 0433     		add	r3, r3, #4
 2934 0022 9B00     		lsl	r3, r3, #2
 2935 0024 0021     		mov	r1, #0
 2936 0026 164A     		ldr	r2, .L167
 2937 0028 9950     		str	r1, [r3, r2]
 2938              	.L162:
2815:functions.c   **** 	}
2816:functions.c   **** 
2817:functions.c   **** 	pFac.pf.GrandBaleTotal += PF_GW302_GrandBaleTotal[PF_STEP];
 2939              		.loc 1 2817 0
 2940 002a 154B     		ldr	r3, .L167
 2941 002c 9B68     		ldr	r3, [r3, #8]
 2942 002e 0133     		add	r3, r3, #1
2818:functions.c   **** 	if( pFac.pf.GrandBaleTotal > PF_GW302_GrandBaleTotal[PF_MAX] ) // Rolling over at max number of di
 2943              		.loc 1 2818 0
 2944 0030 154A     		ldr	r2, .L167+8
 2945 0032 9342     		cmp	r3, r2
 2946 0034 02D8     		bhi	.L163
2817:functions.c   **** 	pFac.pf.GrandBaleTotal += PF_GW302_GrandBaleTotal[PF_STEP];
 2947              		.loc 1 2817 0
 2948 0036 124A     		ldr	r2, .L167
 2949 0038 9360     		str	r3, [r2, #8]
 2950 003a 02E0     		b	.L164
 2951              	.L163:
2819:functions.c   **** 	{
2820:functions.c   **** 		pFac.pf.GrandBaleTotal = PF_GW302_GrandBaleTotal[PF_MIN]; // 0UL
 2952              		.loc 1 2820 0
 2953 003c 0022     		mov	r2, #0
 2954 003e 104B     		ldr	r3, .L167
 2955 0040 9A60     		str	r2, [r3, #8]
 2956              	.L164:
2821:functions.c   **** 	}
2822:functions.c   **** 
2823:functions.c   **** 	// Saving Net applied indicated by pulses counted for Netting stage of current sequence
2824:functions.c   **** 	// and unless instrument was powered up at the start of the sequence,
2825:functions.c   **** 	// any pulses counted since last save from previous sequence (including any pulses counted during 
2826:functions.c   **** 	pFac.pf.GW302_TotalNetMetres += NetMetresAppliedForCount;
 2957              		.loc 1 2826 0
 2958 0042 0F4B     		ldr	r3, .L167
 2959 0044 186F     		ldr	r0, [r3, #112]
 2960 0046 114B     		ldr	r3, .L167+12
 2961 0048 1968     		ldr	r1, [r3]
 2962 004a FFF7FEFF 		bl	__aeabi_fadd
 2963              	.LVL159:
 2964 004e 041C     		add	r4, r0, #0
2827:functions.c   **** 	if( pFac.pf.GW302_TotalNetMetres > PF_GW302_TotalNetMetres[PF_MAX] ) // Freezing Total Net Metres 
 2965              		.loc 1 2827 0
 2966 0050 0F49     		ldr	r1, .L167+16
 2967 0052 FFF7FEFF 		bl	__aeabi_fcmpgt
 2968              	.LVL160:
 2969 0056 0028     		cmp	r0, #0
 2970 0058 02D1     		bne	.L165
2826:functions.c   **** 	pFac.pf.GW302_TotalNetMetres += NetMetresAppliedForCount;
 2971              		.loc 1 2826 0
 2972 005a 094B     		ldr	r3, .L167
 2973 005c 1C67     		str	r4, [r3, #112]
 2974 005e 02E0     		b	.L166
 2975              	.L165:
2828:functions.c   **** 	{
2829:functions.c   **** 		pFac.pf.GW302_TotalNetMetres = PF_GW302_TotalNetMetres[PF_MAX];
 2976              		.loc 1 2829 0
 2977 0060 0B4A     		ldr	r2, .L167+16
 2978 0062 074B     		ldr	r3, .L167
 2979 0064 1A67     		str	r2, [r3, #112]
 2980              	.L166:
2830:functions.c   **** 	}
2831:functions.c   **** 	NetMetresPulseCount = 0UL; // Resetting IP4 pulse count for Net applied (in metres)
 2981              		.loc 1 2831 0
 2982 0066 0022     		mov	r2, #0
 2983 0068 0A4B     		ldr	r3, .L167+20
 2984 006a 1A60     		str	r2, [r3]
2832:functions.c   **** 
2833:functions.c   **** 	pRun.pr.LubeCounter--; // pRun.pr.LubeCounter allowed to go negative
 2985              		.loc 1 2833 0
 2986 006c 0A4B     		ldr	r3, .L167+24
 2987 006e DA8C     		ldrh	r2, [r3, #38]
 2988 0070 013A     		sub	r2, r2, #1
 2989 0072 DA84     		strh	r2, [r3, #38]
2834:functions.c   **** 
2835:functions.c   **** 	SavecalDelayOnMainDisplay = 1;
 2990              		.loc 1 2835 0
 2991 0074 0122     		mov	r2, #1
 2992 0076 094B     		ldr	r3, .L167+28
 2993 0078 1A70     		strb	r2, [r3]
2836:functions.c   **** }
 2994              		.loc 1 2836 0
 2995              		@ sp needed for prologue
 2996 007a 10BC     		pop	{r4}
 2997 007c 01BC     		pop	{r0}
 2998 007e 0047     		bx	r0
 2999              	.L168:
 3000              		.align	2
 3001              	.L167:
 3002 0080 00000000 		.word	.LANCHOR0
 3003 0084 0F270000 		.word	9999
 3004 0088 3F420F00 		.word	999999
 3005 008c 00000000 		.word	NetMetresAppliedForCount
 3006 0090 003C1C46 		.word	1176255488
 3007 0094 00000000 		.word	NetMetresPulseCount
 3008 0098 00010000 		.word	.LANCHOR10
 3009 009c 00000000 		.word	SavecalDelayOnMainDisplay
 3010              		.cfi_endproc
 3011              	.LFE390:
 3013              		.section	.text.CalculateNetPulseFrequency,"ax",%progbits
 3014              		.align	2
 3015              		.global	CalculateNetPulseFrequency
 3016              		.code	16
 3017              		.thumb_func
 3019              	CalculateNetPulseFrequency:
 3020              	.LFB391:
2837:functions.c   **** // -----------------------------------------------------------
2838:functions.c   **** 
2839:functions.c   **** 
2840:functions.c   **** // -----------------------------------------------------------
2841:functions.c   **** // Function Name       : CalculateNetPulseFrequency
2842:functions.c   **** // Object              : Calculates net pulse frequency (Hz)
2843:functions.c   **** // Output Parameters   : NetPulseFrequency
2844:functions.c   **** // -----------------------------------------------------------
2845:functions.c   **** void CalculateNetPulseFrequency( void )
2846:functions.c   **** {
 3021              		.loc 1 2846 0
 3022              		.cfi_startproc
 3023 0000 38B5     		push	{r3, r4, r5, lr}
 3024              	.LCFI18:
 3025              		.cfi_def_cfa_offset 16
 3026              		.cfi_offset 3, -16
 3027              		.cfi_offset 4, -12
 3028              		.cfi_offset 5, -8
 3029              		.cfi_offset 14, -4
2847:functions.c   **** 	if( f6time )
 3030              		.loc 1 2847 0
 3031 0002 0E4B     		ldr	r3, .L172
 3032 0004 1C68     		ldr	r4, [r3]
 3033 0006 002C     		cmp	r4, #0
 3034 0008 11D0     		beq	.L170
2848:functions.c   **** 		NetPulseFrequency = (float)f6count * (float)(MCK / 128) / (float)f6time;
 3035              		.loc 1 2848 0
 3036 000a 0D4B     		ldr	r3, .L172+4
 3037 000c 1888     		ldrh	r0, [r3]
 3038 000e FFF7FEFF 		bl	__aeabi_ui2f
 3039              	.LVL161:
 3040 0012 0C49     		ldr	r1, .L172+8
 3041 0014 FFF7FEFF 		bl	__aeabi_fmul
 3042              	.LVL162:
 3043 0018 051C     		add	r5, r0, #0
 3044 001a 201C     		mov	r0, r4
 3045 001c FFF7FEFF 		bl	__aeabi_ui2f
 3046              	.LVL163:
 3047 0020 011C     		add	r1, r0, #0
 3048 0022 281C     		add	r0, r5, #0
 3049 0024 FFF7FEFF 		bl	__aeabi_fdiv
 3050              	.LVL164:
 3051 0028 074B     		ldr	r3, .L172+12
 3052 002a 1860     		str	r0, [r3]
 3053 002c 02E0     		b	.L169
 3054              	.L170:
2849:functions.c   **** 	else
2850:functions.c   **** 		NetPulseFrequency = 0.0;
 3055              		.loc 1 2850 0
 3056 002e 0022     		mov	r2, #0
 3057 0030 054B     		ldr	r3, .L172+12
 3058 0032 1A60     		str	r2, [r3]
 3059              	.L169:
2851:functions.c   **** }
 3060              		.loc 1 2851 0
 3061              		@ sp needed for prologue
 3062 0034 38BC     		pop	{r3, r4, r5}
 3063 0036 01BC     		pop	{r0}
 3064 0038 0047     		bx	r0
 3065              	.L173:
 3066 003a C046     		.align	2
 3067              	.L172:
 3068 003c 00000000 		.word	f6time
 3069 0040 00000000 		.word	f6count
 3070 0044 00D0B648 		.word	1219940352
 3071 0048 00000000 		.word	NetPulseFrequency
 3072              		.cfi_endproc
 3073              	.LFE391:
 3075              		.section	.text.CalculateNetPulsesPerLayer,"ax",%progbits
 3076              		.align	2
 3077              		.global	CalculateNetPulsesPerLayer
 3078              		.code	16
 3079              		.thumb_func
 3081              	CalculateNetPulsesPerLayer:
 3082              	.LFB392:
2852:functions.c   **** // -----------------------------------------------------------
2853:functions.c   **** 
2854:functions.c   **** 
2855:functions.c   **** // -----------------------------------------------------------
2856:functions.c   **** // Function Name       : CalculateNetPulsesPerLayer
2857:functions.c   **** // Object              : Calculates net pulses per layer
2858:functions.c   **** // Output Parameters   : NetPulsesPerLayer
2859:functions.c   **** // -----------------------------------------------------------
2860:functions.c   **** void CalculateNetPulsesPerLayer( void ) 
2861:functions.c   **** {
 3083              		.loc 1 2861 0
 3084              		.cfi_startproc
 3085 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3086              	.LCFI19:
 3087              		.cfi_def_cfa_offset 24
 3088              		.cfi_offset 3, -24
 3089              		.cfi_offset 4, -20
 3090              		.cfi_offset 5, -16
 3091              		.cfi_offset 6, -12
 3092              		.cfi_offset 7, -8
 3093              		.cfi_offset 14, -4
2862:functions.c   **** 	float LinearCharacteristicGradient; // [m]
2863:functions.c   **** 	float LinearCharacteristicOffset; // [c]
2864:functions.c   **** 
2865:functions.c   **** 	// Net Pulses Per Layer [y] = function( Bale Diameter Voltage minus Minimum Bale Diameter Voltage 
2866:functions.c   **** 	// where function has a linear characteristic of the general form: y = mx + c
2867:functions.c   **** 
2868:functions.c   **** 	LinearCharacteristicGradient = (pFac.pf.GW302_MaxDiaPulsPerLay - pFac.pf.GW302_MinDiaPulsPerLay) /
 3094              		.loc 1 2868 0
 3095 0002 134E     		ldr	r6, .L175
 3096 0004 B023     		mov	r3, #176
 3097 0006 F458     		ldr	r4, [r6, r3]
 3098 0008 124B     		ldr	r3, .L175+4
 3099 000a 1D68     		ldr	r5, [r3]
 3100              	.LVL165:
2869:functions.c   **** 	LinearCharacteristicOffset = pFac.pf.GW302_MinDiaPulsPerLay;
2870:functions.c   **** 
2871:functions.c   **** 	NetPulsesPerLayer = ( LinearCharacteristicGradient * (BaleDiaVolts - DiaMinVolts) ) + LinearCharac
 3101              		.loc 1 2871 0
 3102 000c 124B     		ldr	r3, .L175+8
 3103 000e 1868     		ldr	r0, [r3]
 3104 0010 291C     		add	r1, r5, #0
 3105 0012 FFF7FEFF 		bl	__aeabi_fsub
 3106              	.LVL166:
 3107 0016 071C     		add	r7, r0, #0
2868:functions.c   **** 	LinearCharacteristicGradient = (pFac.pf.GW302_MaxDiaPulsPerLay - pFac.pf.GW302_MinDiaPulsPerLay) /
 3108              		.loc 1 2868 0
 3109 0018 B423     		mov	r3, #180
 3110 001a F058     		ldr	r0, [r6, r3]
 3111 001c 211C     		add	r1, r4, #0
 3112 001e FFF7FEFF 		bl	__aeabi_fsub
 3113              	.LVL167:
 3114 0022 061C     		add	r6, r0, #0
 3115 0024 0D4B     		ldr	r3, .L175+12
 3116 0026 1868     		ldr	r0, [r3]
 3117 0028 291C     		add	r1, r5, #0
 3118 002a FFF7FEFF 		bl	__aeabi_fsub
 3119              	.LVL168:
 3120 002e 011C     		add	r1, r0, #0
 3121 0030 301C     		add	r0, r6, #0
 3122 0032 FFF7FEFF 		bl	__aeabi_fdiv
 3123              	.LVL169:
 3124 0036 011C     		add	r1, r0, #0
 3125              		.loc 1 2871 0
 3126 0038 381C     		add	r0, r7, #0
 3127 003a FFF7FEFF 		bl	__aeabi_fmul
 3128              	.LVL170:
 3129 003e 011C     		add	r1, r0, #0
 3130 0040 201C     		add	r0, r4, #0
 3131 0042 FFF7FEFF 		bl	__aeabi_fadd
 3132              	.LVL171:
 3133 0046 064B     		ldr	r3, .L175+16
 3134 0048 1860     		str	r0, [r3]
2872:functions.c   **** }
 3135              		.loc 1 2872 0
 3136              		@ sp needed for prologue
 3137              	.LVL172:
 3138 004a F8BC     		pop	{r3, r4, r5, r6, r7}
 3139 004c 01BC     		pop	{r0}
 3140 004e 0047     		bx	r0
 3141              	.L176:
 3142              		.align	2
 3143              	.L175:
 3144 0050 00000000 		.word	.LANCHOR0
 3145 0054 00000000 		.word	DiaMinVolts
 3146 0058 00000000 		.word	BaleDiaVolts
 3147 005c 00000000 		.word	DiaMaxVolts
 3148 0060 00000000 		.word	NetPulsesPerLayer
 3149              		.cfi_endproc
 3150              	.LFE392:
 3152              		.global	__aeabi_f2uiz
 3153              		.section	.text.CalculateTargetNetPulses,"ax",%progbits
 3154              		.align	2
 3155              		.global	CalculateTargetNetPulses
 3156              		.code	16
 3157              		.thumb_func
 3159              	CalculateTargetNetPulses:
 3160              	.LFB393:
2873:functions.c   **** // -----------------------------------------------------------
2874:functions.c   **** 
2875:functions.c   **** 
2876:functions.c   **** // -----------------------------------------------------------
2877:functions.c   **** // Function Name       : CalculateTargetNetPulses
2878:functions.c   **** // Object              : Calculates target net pulses 
2879:functions.c   **** // Output Parameters   : TargetNetPulses
2880:functions.c   **** // -----------------------------------------------------------
2881:functions.c   **** void CalculateTargetNetPulses( void )
2882:functions.c   **** {
 3161              		.loc 1 2882 0
 3162              		.cfi_startproc
 3163 0000 10B5     		push	{r4, lr}
 3164              	.LCFI20:
 3165              		.cfi_def_cfa_offset 8
 3166              		.cfi_offset 4, -8
 3167              		.cfi_offset 14, -4
2883:functions.c   **** 	// Calculating Net Pulses Per Layer = function( Bale Diameter Voltage minus Minimum Bale Diameter 
2884:functions.c   **** 	CalculateNetPulsesPerLayer();
 3168              		.loc 1 2884 0
 3169 0002 FFF7FEFF 		bl	CalculateNetPulsesPerLayer
 3170              	.LVL173:
2885:functions.c   **** 
2886:functions.c   **** 	// Calculating Target Net Pulses = function( Net Pulses Per Layer )
2887:functions.c   **** 	TargetNetPulses = (unsigned short int)(NetPulsesPerLayer * pFac.pf.GW302_NetLayers[pFac.pf.GW302_B
 3171              		.loc 1 2887 0
 3172 0006 0C4C     		ldr	r4, .L178
 3173 0008 3A23     		mov	r3, #58
 3174 000a E35C     		ldrb	r3, [r4, r3]
 3175 000c 1433     		add	r3, r3, #20
 3176 000e 9B00     		lsl	r3, r3, #2
 3177 0010 1859     		ldr	r0, [r3, r4]
 3178 0012 0A4B     		ldr	r3, .L178+4
 3179 0014 1968     		ldr	r1, [r3]
 3180 0016 FFF7FEFF 		bl	__aeabi_fmul
 3181              	.LVL174:
 3182 001a B823     		mov	r3, #184
 3183 001c E158     		ldr	r1, [r4, r3]
 3184 001e FFF7FEFF 		bl	__aeabi_fmul
 3185              	.LVL175:
 3186 0022 FFF7FEFF 		bl	__aeabi_f2uiz
 3187              	.LVL176:
 3188 0026 A823     		mov	r3, #168
 3189 0028 E35C     		ldrb	r3, [r4, r3]
 3190 002a C01A     		sub	r0, r0, r3
 3191 002c 044B     		ldr	r3, .L178+8
 3192 002e 1880     		strh	r0, [r3]
2888:functions.c   **** }
 3193              		.loc 1 2888 0
 3194              		@ sp needed for prologue
 3195 0030 10BC     		pop	{r4}
 3196 0032 01BC     		pop	{r0}
 3197 0034 0047     		bx	r0
 3198              	.L179:
 3199 0036 C046     		.align	2
 3200              	.L178:
 3201 0038 00000000 		.word	.LANCHOR0
 3202 003c 00000000 		.word	NetPulsesPerLayer
 3203 0040 00000000 		.word	TargetNetPulses
 3204              		.cfi_endproc
 3205              	.LFE393:
 3207              		.global	__aeabi_d2uiz
 3208              		.global	__aeabi_fcmpge
 3209              		.section	.text.Sequence,"ax",%progbits
 3210              		.align	2
 3211              		.global	Sequence
 3212              		.code	16
 3213              		.thumb_func
 3215              	Sequence:
 3216              	.LFB387:
1546:functions.c   **** {
 3217              		.loc 1 1546 0
 3218              		.cfi_startproc
 3219 0000 70B5     		push	{r4, r5, r6, lr}
 3220              	.LCFI21:
 3221              		.cfi_def_cfa_offset 16
 3222              		.cfi_offset 4, -16
 3223              		.cfi_offset 5, -12
 3224              		.cfi_offset 6, -8
 3225              		.cfi_offset 14, -4
1552:functions.c   **** 	if( AllTime ) // Incremented every 100 msec in TC1_irq_handler; so this routine is executed once e
 3226              		.loc 1 1552 0
 3227 0002 D94B     		ldr	r3, .L374+8
 3228 0004 1B78     		ldrb	r3, [r3]
 3229 0006 002B     		cmp	r3, #0
 3230 0008 01D1     		bne	.LCB2918
 3231 000a 01F059F8 		bl	.L180	@far jump
 3232              	.LCB2918:
1554:functions.c   **** 		AllTime--;
 3233              		.loc 1 1554 0
 3234 000e 013B     		sub	r3, r3, #1
 3235 0010 D54A     		ldr	r2, .L374+8
 3236 0012 1370     		strb	r3, [r2]
1556:functions.c   **** 		if( AutoMan )
 3237              		.loc 1 1556 0
 3238 0014 D54B     		ldr	r3, .L374+12
 3239 0016 1B78     		ldrb	r3, [r3]
 3240 0018 002B     		cmp	r3, #0
 3241 001a 01D1     		bne	.LCB2925
 3242 001c 00F0DEFD 		bl	.L182	@far jump
 3243              	.LCB2925:
1563:functions.c   **** 			switch( Stage )
 3244              		.loc 1 1563 0
 3245 0020 D34B     		ldr	r3, .L374+16
 3246 0022 1A78     		ldrb	r2, [r3]
 3247 0024 0E2A     		cmp	r2, #14
 3248 0026 01D9     		bls	.LCB2929
 3249 0028 00F046FC 		bl	.L183	@far jump
 3250              	.LCB2929:
 3251 002c 9300     		lsl	r3, r2, #2
 3252 002e D14A     		ldr	r2, .L374+20
 3253 0030 D358     		ldr	r3, [r2, r3]
 3254 0032 9F46     		mov	pc, r3
 3255              		.section	.rodata.Sequence,"a",%progbits
 3256              		.align	2
 3257              	.L199:
 3258 0000 34000000 		.word	.L184
 3259 0004 76000000 		.word	.L185
 3260 0008 60010000 		.word	.L186
 3261 000c 46020000 		.word	.L187
 3262 0010 2C030000 		.word	.L188
 3263 0014 EA030000 		.word	.L189
 3264 0018 66040000 		.word	.L190
 3265 001c 28050000 		.word	.L191
 3266 0020 A0050000 		.word	.L192
 3267 0024 50060000 		.word	.L193
 3268 0028 D6060000 		.word	.L194
 3269 002c 88070000 		.word	.L195
 3270 0030 FE070000 		.word	.L196
 3271 0034 20080000 		.word	.L197
 3272 0038 98080000 		.word	.L198
 3273              		.section	.text.Sequence
 3274              	.L184:
1571:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
 3275              		.loc 1 1571 0
 3276 0034 D04B     		ldr	r3, .L374+24
 3277 0036 1B78     		ldrb	r3, [r3]
 3278 0038 002B     		cmp	r3, #0
 3279 003a 04D0     		beq	.L200
1573:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
 3280              		.loc 1 1573 0
 3281 003c 0522     		mov	r2, #5
 3282 003e CC4B     		ldr	r3, .L374+16
 3283 0040 1A70     		strb	r2, [r3]
 3284 0042 00F039FC 		bl	.L183	@ far jump
 3285              	.L200:
1577:functions.c   **** 					SequenceInProgress = 1;
 3286              		.loc 1 1577 0
 3287 0046 0124     		mov	r4, #1
 3288 0048 CC4B     		ldr	r3, .L374+28
 3289 004a 1C70     		strb	r4, [r3]
1579:functions.c   **** 					OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3290              		.loc 1 1579 0
 3291 004c 8823     		mov	r3, #136
 3292 004e CC4A     		ldr	r2, .L374+32
 3293 0050 D058     		ldr	r0, [r2, r3]
 3294 0052 FFF7FEFF 		bl	__aeabi_f2d
 3295              	.LVL177:
 3296 0056 C34B     		ldr	r3, .L374+4
 3297 0058 C14A     		ldr	r2, .L374
 3298 005a FFF7FEFF 		bl	__aeabi_dmul
 3299              	.LVL178:
 3300 005e FFF7FEFF 		bl	__aeabi_d2uiz
 3301              	.LVL179:
 3302 0062 0306     		lsl	r3, r0, #24
 3303 0064 1B0E     		lsr	r3, r3, #24
 3304 0066 C74A     		ldr	r2, .L374+36
 3305 0068 1370     		strb	r3, [r2]
1580:functions.c   **** 					OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3306              		.loc 1 1580 0
 3307 006a C74A     		ldr	r2, .L374+40
 3308 006c 1370     		strb	r3, [r2]
1581:functions.c   **** 					Stage = STAGE_FORMATION; // Go to Formation stage
 3309              		.loc 1 1581 0
 3310 006e C04B     		ldr	r3, .L374+16
 3311 0070 1C70     		strb	r4, [r3]
 3312 0072 00F021FC 		bl	.L183	@ far jump
 3313              	.L185:
1592:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
 3314              		.loc 1 1592 0
 3315 0076 C04B     		ldr	r3, .L374+24
 3316 0078 1B78     		ldrb	r3, [r3]
 3317 007a 002B     		cmp	r3, #0
 3318 007c 04D0     		beq	.L201
1594:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
 3319              		.loc 1 1594 0
 3320 007e 0522     		mov	r2, #5
 3321 0080 BB4B     		ldr	r3, .L374+16
 3322 0082 1A70     		strb	r2, [r3]
 3323 0084 00F018FC 		bl	.L183	@ far jump
 3324              	.L201:
1598:functions.c   **** 					SequenceInProgress = 1;
 3325              		.loc 1 1598 0
 3326 0088 0122     		mov	r2, #1
 3327 008a BC4B     		ldr	r3, .L374+28
 3328 008c 1A70     		strb	r2, [r3]
1600:functions.c   **** 					if( BaleDiaVolts > DiaFormationVolts )  // Formation diameter exceeded
 3329              		.loc 1 1600 0
 3330 008e BF4B     		ldr	r3, .L374+44
 3331 0090 1868     		ldr	r0, [r3]
 3332 0092 BF4B     		ldr	r3, .L374+48
 3333 0094 1968     		ldr	r1, [r3]
 3334 0096 FFF7FEFF 		bl	__aeabi_fcmpgt
 3335              	.LVL180:
 3336 009a 0028     		cmp	r0, #0
 3337 009c 15D0     		beq	.L357
1602:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3338              		.loc 1 1602 0
 3339 009e 8823     		mov	r3, #136
 3340 00a0 B74A     		ldr	r2, .L374+32
 3341 00a2 D058     		ldr	r0, [r2, r3]
 3342 00a4 FFF7FEFF 		bl	__aeabi_f2d
 3343              	.LVL181:
 3344 00a8 AE4B     		ldr	r3, .L374+4
 3345 00aa AD4A     		ldr	r2, .L374
 3346 00ac FFF7FEFF 		bl	__aeabi_dmul
 3347              	.LVL182:
 3348 00b0 FFF7FEFF 		bl	__aeabi_d2uiz
 3349              	.LVL183:
 3350 00b4 0306     		lsl	r3, r0, #24
 3351 00b6 1B0E     		lsr	r3, r3, #24
 3352 00b8 B24A     		ldr	r2, .L374+36
 3353 00ba 1370     		strb	r3, [r2]
1603:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3354              		.loc 1 1603 0
 3355 00bc B24A     		ldr	r2, .L374+40
 3356 00be 1370     		strb	r3, [r2]
1604:functions.c   **** 						Stage = STAGE_FORMATION2; // Go to Formation2 stage
 3357              		.loc 1 1604 0
 3358 00c0 0222     		mov	r2, #2
 3359 00c2 AB4B     		ldr	r3, .L374+16
 3360 00c4 1A70     		strb	r2, [r3]
 3361 00c6 00F0F7FB 		bl	.L183	@ far jump
 3362              	.L357:
1611:functions.c   **** 						if( DensityPresVolts >= DensityFormationVolts ) // Target Formation density reached/exceeded
 3363              		.loc 1 1611 0
 3364 00ca B24B     		ldr	r3, .L374+52
 3365 00cc 1C68     		ldr	r4, [r3]
 3366 00ce B24B     		ldr	r3, .L374+56
 3367 00d0 1D68     		ldr	r5, [r3]
 3368 00d2 201C     		add	r0, r4, #0
 3369 00d4 291C     		add	r1, r5, #0
 3370 00d6 FFF7FEFF 		bl	__aeabi_fcmpge
 3371              	.LVL184:
 3372 00da 0028     		cmp	r0, #0
 3373 00dc 1BD0     		beq	.L358
1613:functions.c   **** 							if( OP8OnDelayTime )
 3374              		.loc 1 1613 0
 3375 00de A94B     		ldr	r3, .L374+36
 3376 00e0 1B78     		ldrb	r3, [r3]
 3377 00e2 002B     		cmp	r3, #0
 3378 00e4 03D0     		beq	.L206
1614:functions.c   **** 								OP8OnDelayTime--;
 3379              		.loc 1 1614 0
 3380 00e6 013B     		sub	r3, r3, #1
 3381 00e8 A64A     		ldr	r2, .L374+36
 3382 00ea 1370     		strb	r3, [r2]
 3383 00ec E4E3     		b	.L183
 3384              	.L206:
1617:functions.c   **** 								SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
 3385              		.loc 1 1617 0
 3386 00ee AB4B     		ldr	r3, .L374+60
 3387 00f0 8022     		mov	r2, #128
 3388 00f2 1202     		lsl	r2, r2, #8
 3389 00f4 1868     		ldr	r0, [r3]
 3390 00f6 0243     		orr	r2, r0
 3391 00f8 1A60     		str	r2, [r3]
1618:functions.c   **** 								OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3392              		.loc 1 1618 0
 3393 00fa 8823     		mov	r3, #136
 3394 00fc A04A     		ldr	r2, .L374+32
 3395 00fe D058     		ldr	r0, [r2, r3]
 3396 0100 FFF7FEFF 		bl	__aeabi_f2d
 3397              	.LVL185:
 3398 0104 974B     		ldr	r3, .L374+4
 3399 0106 964A     		ldr	r2, .L374
 3400 0108 FFF7FEFF 		bl	__aeabi_dmul
 3401              	.LVL186:
 3402 010c FFF7FEFF 		bl	__aeabi_d2uiz
 3403              	.LVL187:
 3404 0110 9D4B     		ldr	r3, .L374+40
 3405 0112 1870     		strb	r0, [r3]
 3406 0114 D0E3     		b	.L183
 3407              	.L358:
1621:functions.c   **** 						else if( DensityPresVolts < (DensityFormationVolts - pFac.pf.GW302_PresDeadband) ) // Fallen 
 3408              		.loc 1 1621 0
 3409 0116 281C     		add	r0, r5, #0
 3410 0118 8023     		mov	r3, #128
 3411 011a 994A     		ldr	r2, .L374+32
 3412 011c D158     		ldr	r1, [r2, r3]
 3413 011e FFF7FEFF 		bl	__aeabi_fsub
 3414              	.LVL188:
 3415 0122 011C     		add	r1, r0, #0
 3416 0124 201C     		add	r0, r4, #0
 3417 0126 FFF7FEFF 		bl	__aeabi_fcmplt
 3418              	.LVL189:
 3419 012a 0028     		cmp	r0, #0
 3420 012c 00D1     		bne	.LCB3077
 3421 012e C3E3     		b	.L183	@long jump
 3422              	.LCB3077:
1623:functions.c   **** 							if( OP8OffDelayTime )
 3423              		.loc 1 1623 0
 3424 0130 954B     		ldr	r3, .L374+40
 3425 0132 1B78     		ldrb	r3, [r3]
 3426 0134 002B     		cmp	r3, #0
 3427 0136 03D0     		beq	.L208
1624:functions.c   **** 								OP8OffDelayTime--;
 3428              		.loc 1 1624 0
 3429 0138 013B     		sub	r3, r3, #1
 3430 013a 934A     		ldr	r2, .L374+40
 3431 013c 1370     		strb	r3, [r2]
 3432 013e BBE3     		b	.L183
 3433              	.L208:
1627:functions.c   **** 								AllSeqOpOff(); // All OPs OFF
 3434              		.loc 1 1627 0
 3435 0140 FFF7FEFF 		bl	AllSeqOpOff
 3436              	.LVL190:
1628:functions.c   **** 								OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3437              		.loc 1 1628 0
 3438 0144 8823     		mov	r3, #136
 3439 0146 8E4A     		ldr	r2, .L374+32
 3440 0148 D058     		ldr	r0, [r2, r3]
 3441 014a FFF7FEFF 		bl	__aeabi_f2d
 3442              	.LVL191:
 3443 014e 854B     		ldr	r3, .L374+4
 3444 0150 834A     		ldr	r2, .L374
 3445 0152 FFF7FEFF 		bl	__aeabi_dmul
 3446              	.LVL192:
 3447 0156 FFF7FEFF 		bl	__aeabi_d2uiz
 3448              	.LVL193:
 3449 015a 8A4B     		ldr	r3, .L374+36
 3450 015c 1870     		strb	r0, [r3]
 3451 015e ABE3     		b	.L183
 3452              	.L186:
1641:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
 3453              		.loc 1 1641 0
 3454 0160 854B     		ldr	r3, .L374+24
 3455 0162 1B78     		ldrb	r3, [r3]
 3456 0164 002B     		cmp	r3, #0
 3457 0166 03D0     		beq	.L209
1643:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
 3458              		.loc 1 1643 0
 3459 0168 0522     		mov	r2, #5
 3460 016a 814B     		ldr	r3, .L374+16
 3461 016c 1A70     		strb	r2, [r3]
 3462 016e A3E3     		b	.L183
 3463              	.L209:
1647:functions.c   **** 					SequenceInProgress = 1;
 3464              		.loc 1 1647 0
 3465 0170 0122     		mov	r2, #1
 3466 0172 824B     		ldr	r3, .L374+28
 3467 0174 1A70     		strb	r2, [r3]
1649:functions.c   **** 					if( BaleDiaVolts > DiaFormation2Volts )  // Formation2 diameter exceeded
 3468              		.loc 1 1649 0
 3469 0176 854B     		ldr	r3, .L374+44
 3470 0178 1868     		ldr	r0, [r3]
 3471 017a 894B     		ldr	r3, .L374+64
 3472 017c 1968     		ldr	r1, [r3]
 3473 017e FFF7FEFF 		bl	__aeabi_fcmpgt
 3474              	.LVL194:
 3475 0182 0028     		cmp	r0, #0
 3476 0184 14D0     		beq	.L359
1651:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3477              		.loc 1 1651 0
 3478 0186 8823     		mov	r3, #136
 3479 0188 7D4A     		ldr	r2, .L374+32
 3480 018a D058     		ldr	r0, [r2, r3]
 3481 018c FFF7FEFF 		bl	__aeabi_f2d
 3482              	.LVL195:
 3483 0190 744B     		ldr	r3, .L374+4
 3484 0192 734A     		ldr	r2, .L374
 3485 0194 FFF7FEFF 		bl	__aeabi_dmul
 3486              	.LVL196:
 3487 0198 FFF7FEFF 		bl	__aeabi_d2uiz
 3488              	.LVL197:
 3489 019c 0306     		lsl	r3, r0, #24
 3490 019e 1B0E     		lsr	r3, r3, #24
 3491 01a0 784A     		ldr	r2, .L374+36
 3492 01a2 1370     		strb	r3, [r2]
1652:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3493              		.loc 1 1652 0
 3494 01a4 784A     		ldr	r2, .L374+40
 3495 01a6 1370     		strb	r3, [r2]
1653:functions.c   **** 						Stage = STAGE_CORE; // Go to Core stage
 3496              		.loc 1 1653 0
 3497 01a8 0322     		mov	r2, #3
 3498 01aa 714B     		ldr	r3, .L374+16
 3499 01ac 1A70     		strb	r2, [r3]
 3500 01ae 83E3     		b	.L183
 3501              	.L359:
1660:functions.c   **** 						if( DensityPresVolts >= DensityFormation2Volts ) // Target Formation2 density reached/exceede
 3502              		.loc 1 1660 0
 3503 01b0 784B     		ldr	r3, .L374+52
 3504 01b2 1C68     		ldr	r4, [r3]
 3505 01b4 7B4B     		ldr	r3, .L374+68
 3506 01b6 1D68     		ldr	r5, [r3]
 3507 01b8 201C     		add	r0, r4, #0
 3508 01ba 291C     		add	r1, r5, #0
 3509 01bc FFF7FEFF 		bl	__aeabi_fcmpge
 3510              	.LVL198:
 3511 01c0 0028     		cmp	r0, #0
 3512 01c2 1BD0     		beq	.L360
1662:functions.c   **** 							if( OP8OnDelayTime )
 3513              		.loc 1 1662 0
 3514 01c4 6F4B     		ldr	r3, .L374+36
 3515 01c6 1B78     		ldrb	r3, [r3]
 3516 01c8 002B     		cmp	r3, #0
 3517 01ca 03D0     		beq	.L214
1663:functions.c   **** 								OP8OnDelayTime--;
 3518              		.loc 1 1663 0
 3519 01cc 013B     		sub	r3, r3, #1
 3520 01ce 6D4A     		ldr	r2, .L374+36
 3521 01d0 1370     		strb	r3, [r2]
 3522 01d2 71E3     		b	.L183
 3523              	.L214:
1666:functions.c   **** 								SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
 3524              		.loc 1 1666 0
 3525 01d4 714B     		ldr	r3, .L374+60
 3526 01d6 8022     		mov	r2, #128
 3527 01d8 1202     		lsl	r2, r2, #8
 3528 01da 1968     		ldr	r1, [r3]
 3529 01dc 0A43     		orr	r2, r1
 3530 01de 1A60     		str	r2, [r3]
1667:functions.c   **** 								OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3531              		.loc 1 1667 0
 3532 01e0 8823     		mov	r3, #136
 3533 01e2 674A     		ldr	r2, .L374+32
 3534 01e4 D058     		ldr	r0, [r2, r3]
 3535 01e6 FFF7FEFF 		bl	__aeabi_f2d
 3536              	.LVL199:
 3537 01ea 5E4B     		ldr	r3, .L374+4
 3538 01ec 5C4A     		ldr	r2, .L374
 3539 01ee FFF7FEFF 		bl	__aeabi_dmul
 3540              	.LVL200:
 3541 01f2 FFF7FEFF 		bl	__aeabi_d2uiz
 3542              	.LVL201:
 3543 01f6 644B     		ldr	r3, .L374+40
 3544 01f8 1870     		strb	r0, [r3]
 3545 01fa 5DE3     		b	.L183
 3546              	.L360:
1670:functions.c   **** 						else if( DensityPresVolts < (DensityFormation2Volts - pFac.pf.GW302_PresDeadband) ) // Fallen
 3547              		.loc 1 1670 0
 3548 01fc 281C     		add	r0, r5, #0
 3549 01fe 8023     		mov	r3, #128
 3550 0200 5F4A     		ldr	r2, .L374+32
 3551 0202 D158     		ldr	r1, [r2, r3]
 3552 0204 FFF7FEFF 		bl	__aeabi_fsub
 3553              	.LVL202:
 3554 0208 011C     		add	r1, r0, #0
 3555 020a 201C     		add	r0, r4, #0
 3556 020c FFF7FEFF 		bl	__aeabi_fcmplt
 3557              	.LVL203:
 3558 0210 0028     		cmp	r0, #0
 3559 0212 00D1     		bne	.LCB3207
 3560 0214 50E3     		b	.L183	@long jump
 3561              	.LCB3207:
1672:functions.c   **** 							if( OP8OffDelayTime )
 3562              		.loc 1 1672 0
 3563 0216 5C4B     		ldr	r3, .L374+40
 3564 0218 1B78     		ldrb	r3, [r3]
 3565 021a 002B     		cmp	r3, #0
 3566 021c 03D0     		beq	.L216
1673:functions.c   **** 								OP8OffDelayTime--;
 3567              		.loc 1 1673 0
 3568 021e 013B     		sub	r3, r3, #1
 3569 0220 594A     		ldr	r2, .L374+40
 3570 0222 1370     		strb	r3, [r2]
 3571 0224 48E3     		b	.L183
 3572              	.L216:
1676:functions.c   **** 								AllSeqOpOff(); // All OPs OFF
 3573              		.loc 1 1676 0
 3574 0226 FFF7FEFF 		bl	AllSeqOpOff
 3575              	.LVL204:
1677:functions.c   **** 								OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3576              		.loc 1 1677 0
 3577 022a 8823     		mov	r3, #136
 3578 022c 544A     		ldr	r2, .L374+32
 3579 022e D058     		ldr	r0, [r2, r3]
 3580 0230 FFF7FEFF 		bl	__aeabi_f2d
 3581              	.LVL205:
 3582 0234 4B4B     		ldr	r3, .L374+4
 3583 0236 4A4A     		ldr	r2, .L374
 3584 0238 FFF7FEFF 		bl	__aeabi_dmul
 3585              	.LVL206:
 3586 023c FFF7FEFF 		bl	__aeabi_d2uiz
 3587              	.LVL207:
 3588 0240 504B     		ldr	r3, .L374+36
 3589 0242 1870     		strb	r0, [r3]
 3590 0244 38E3     		b	.L183
 3591              	.L187:
1690:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
 3592              		.loc 1 1690 0
 3593 0246 4C4B     		ldr	r3, .L374+24
 3594 0248 1B78     		ldrb	r3, [r3]
 3595 024a 002B     		cmp	r3, #0
 3596 024c 03D0     		beq	.L217
1692:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
 3597              		.loc 1 1692 0
 3598 024e 0522     		mov	r2, #5
 3599 0250 474B     		ldr	r3, .L374+16
 3600 0252 1A70     		strb	r2, [r3]
 3601 0254 30E3     		b	.L183
 3602              	.L217:
1696:functions.c   **** 					SequenceInProgress = 1;
 3603              		.loc 1 1696 0
 3604 0256 0122     		mov	r2, #1
 3605 0258 484B     		ldr	r3, .L374+28
 3606 025a 1A70     		strb	r2, [r3]
1698:functions.c   **** 					if( BaleDiaVolts > DiaCoreVolts )  // Core diameter exceeded
 3607              		.loc 1 1698 0
 3608 025c 4B4B     		ldr	r3, .L374+44
 3609 025e 1868     		ldr	r0, [r3]
 3610 0260 514B     		ldr	r3, .L374+72
 3611 0262 1968     		ldr	r1, [r3]
 3612 0264 FFF7FEFF 		bl	__aeabi_fcmpgt
 3613              	.LVL208:
 3614 0268 0028     		cmp	r0, #0
 3615 026a 14D0     		beq	.L361
1700:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3616              		.loc 1 1700 0
 3617 026c 8823     		mov	r3, #136
 3618 026e 444A     		ldr	r2, .L374+32
 3619 0270 D058     		ldr	r0, [r2, r3]
 3620 0272 FFF7FEFF 		bl	__aeabi_f2d
 3621              	.LVL209:
 3622 0276 3B4B     		ldr	r3, .L374+4
 3623 0278 394A     		ldr	r2, .L374
 3624 027a FFF7FEFF 		bl	__aeabi_dmul
 3625              	.LVL210:
 3626 027e FFF7FEFF 		bl	__aeabi_d2uiz
 3627              	.LVL211:
 3628 0282 0306     		lsl	r3, r0, #24
 3629 0284 1B0E     		lsr	r3, r3, #24
 3630 0286 3F4A     		ldr	r2, .L374+36
 3631 0288 1370     		strb	r3, [r2]
1701:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3632              		.loc 1 1701 0
 3633 028a 3F4A     		ldr	r2, .L374+40
 3634 028c 1370     		strb	r3, [r2]
1702:functions.c   **** 						Stage = STAGE_MAIN; // Go to Main stage
 3635              		.loc 1 1702 0
 3636 028e 0422     		mov	r2, #4
 3637 0290 374B     		ldr	r3, .L374+16
 3638 0292 1A70     		strb	r2, [r3]
 3639 0294 10E3     		b	.L183
 3640              	.L361:
1709:functions.c   **** 						if( DensityPresVolts >= DensityCoreVolts ) // Target core density reached/exceeded
 3641              		.loc 1 1709 0
 3642 0296 3F4B     		ldr	r3, .L374+52
 3643 0298 1C68     		ldr	r4, [r3]
 3644 029a 444B     		ldr	r3, .L374+76
 3645 029c 1D68     		ldr	r5, [r3]
 3646 029e 201C     		add	r0, r4, #0
 3647 02a0 291C     		add	r1, r5, #0
 3648 02a2 FFF7FEFF 		bl	__aeabi_fcmpge
 3649              	.LVL212:
 3650 02a6 0028     		cmp	r0, #0
 3651 02a8 1BD0     		beq	.L362
1711:functions.c   **** 							if( OP8OnDelayTime )
 3652              		.loc 1 1711 0
 3653 02aa 364B     		ldr	r3, .L374+36
 3654 02ac 1B78     		ldrb	r3, [r3]
 3655 02ae 002B     		cmp	r3, #0
 3656 02b0 03D0     		beq	.L222
1712:functions.c   **** 								OP8OnDelayTime--;
 3657              		.loc 1 1712 0
 3658 02b2 013B     		sub	r3, r3, #1
 3659 02b4 334A     		ldr	r2, .L374+36
 3660 02b6 1370     		strb	r3, [r2]
 3661 02b8 FEE2     		b	.L183
 3662              	.L222:
1715:functions.c   **** 								SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
 3663              		.loc 1 1715 0
 3664 02ba 384B     		ldr	r3, .L374+60
 3665 02bc 8022     		mov	r2, #128
 3666 02be 1202     		lsl	r2, r2, #8
 3667 02c0 1868     		ldr	r0, [r3]
 3668 02c2 0243     		orr	r2, r0
 3669 02c4 1A60     		str	r2, [r3]
1716:functions.c   **** 								OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3670              		.loc 1 1716 0
 3671 02c6 8823     		mov	r3, #136
 3672 02c8 2D4A     		ldr	r2, .L374+32
 3673 02ca D058     		ldr	r0, [r2, r3]
 3674 02cc FFF7FEFF 		bl	__aeabi_f2d
 3675              	.LVL213:
 3676 02d0 244B     		ldr	r3, .L374+4
 3677 02d2 234A     		ldr	r2, .L374
 3678 02d4 FFF7FEFF 		bl	__aeabi_dmul
 3679              	.LVL214:
 3680 02d8 FFF7FEFF 		bl	__aeabi_d2uiz
 3681              	.LVL215:
 3682 02dc 2A4B     		ldr	r3, .L374+40
 3683 02de 1870     		strb	r0, [r3]
 3684 02e0 EAE2     		b	.L183
 3685              	.L362:
1719:functions.c   **** 						else if( DensityPresVolts < (DensityCoreVolts - pFac.pf.GW302_PresDeadband) ) // Fallen below
 3686              		.loc 1 1719 0
 3687 02e2 281C     		add	r0, r5, #0
 3688 02e4 8023     		mov	r3, #128
 3689 02e6 264A     		ldr	r2, .L374+32
 3690 02e8 D158     		ldr	r1, [r2, r3]
 3691 02ea FFF7FEFF 		bl	__aeabi_fsub
 3692              	.LVL216:
 3693 02ee 011C     		add	r1, r0, #0
 3694 02f0 201C     		add	r0, r4, #0
 3695 02f2 FFF7FEFF 		bl	__aeabi_fcmplt
 3696              	.LVL217:
 3697 02f6 0028     		cmp	r0, #0
 3698 02f8 00D1     		bne	.LCB3337
 3699 02fa DDE2     		b	.L183	@long jump
 3700              	.LCB3337:
1721:functions.c   **** 							if( OP8OffDelayTime )
 3701              		.loc 1 1721 0
 3702 02fc 224B     		ldr	r3, .L374+40
 3703 02fe 1B78     		ldrb	r3, [r3]
 3704 0300 002B     		cmp	r3, #0
 3705 0302 03D0     		beq	.L224
1722:functions.c   **** 								OP8OffDelayTime--;
 3706              		.loc 1 1722 0
 3707 0304 013B     		sub	r3, r3, #1
 3708 0306 204A     		ldr	r2, .L374+40
 3709 0308 1370     		strb	r3, [r2]
 3710 030a D5E2     		b	.L183
 3711              	.L224:
1725:functions.c   **** 								AllSeqOpOff(); // All OPs OFF
 3712              		.loc 1 1725 0
 3713 030c FFF7FEFF 		bl	AllSeqOpOff
 3714              	.LVL218:
1726:functions.c   **** 								OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 3715              		.loc 1 1726 0
 3716 0310 8823     		mov	r3, #136
 3717 0312 1B4A     		ldr	r2, .L374+32
 3718 0314 D058     		ldr	r0, [r2, r3]
 3719 0316 FFF7FEFF 		bl	__aeabi_f2d
 3720              	.LVL219:
 3721 031a 124B     		ldr	r3, .L374+4
 3722 031c 104A     		ldr	r2, .L374
 3723 031e FFF7FEFF 		bl	__aeabi_dmul
 3724              	.LVL220:
 3725 0322 FFF7FEFF 		bl	__aeabi_d2uiz
 3726              	.LVL221:
 3727 0326 174B     		ldr	r3, .L374+36
 3728 0328 1870     		strb	r0, [r3]
 3729 032a C5E2     		b	.L183
 3730              	.L188:
1739:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
 3731              		.loc 1 1739 0
 3732 032c 124B     		ldr	r3, .L374+24
 3733 032e 1B78     		ldrb	r3, [r3]
 3734 0330 002B     		cmp	r3, #0
 3735 0332 03D0     		beq	.L225
1741:functions.c   **** 					Stage = STAGE_NETTING_START; // Go straight to Netting stage
 3736              		.loc 1 1741 0
 3737 0334 0522     		mov	r2, #5
 3738 0336 0E4B     		ldr	r3, .L374+16
 3739 0338 1A70     		strb	r2, [r3]
 3740 033a BDE2     		b	.L183
 3741              	.L225:
1745:functions.c   **** 					SequenceInProgress = 1;
 3742              		.loc 1 1745 0
 3743 033c 0122     		mov	r2, #1
 3744 033e 0F4B     		ldr	r3, .L374+28
 3745 0340 1A70     		strb	r2, [r3]
1747:functions.c   **** 					if( BaleDiaVolts > DiaTargetVolts )  // Target bale diameter exceeded
 3746              		.loc 1 1747 0
 3747 0342 124B     		ldr	r3, .L374+44
 3748 0344 1C68     		ldr	r4, [r3]
 3749 0346 201C     		add	r0, r4, #0
 3750 0348 194B     		ldr	r3, .L374+80
 3751 034a 1968     		ldr	r1, [r3]
 3752 034c FFF7FEFF 		bl	__aeabi_fcmpgt
 3753              	.LVL222:
 3754 0350 0028     		cmp	r0, #0
 3755 0352 2FD0     		beq	.L363
1749:functions.c   **** 						Stage = STAGE_NETTING_START; // Go to Netting stage
 3756              		.loc 1 1749 0
 3757 0354 0522     		mov	r2, #5
 3758 0356 064B     		ldr	r3, .L374+16
 3759 0358 1A70     		strb	r2, [r3]
 3760 035a 2EE0     		b	.L228
 3761              	.L375:
 3762 035c C046C046 		.align	3
 3763              	.L374:
 3764 0360 00000000 		.word	0
 3765 0364 00002440 		.word	1076101120
 3766 0368 00000000 		.word	AllTime
 3767 036c 00000000 		.word	AutoMan
 3768 0370 00000000 		.word	Stage
 3769 0374 00000000 		.word	.L199
 3770 0378 00000000 		.word	StartAutoNet
 3771 037c 00000000 		.word	SequenceInProgress
 3772 0380 00000000 		.word	.LANCHOR0
 3773 0384 00000000 		.word	OP8OnDelayTime
 3774 0388 00000000 		.word	OP8OffDelayTime
 3775 038c 00000000 		.word	BaleDiaVolts
 3776 0390 00000000 		.word	DiaFormationVolts
 3777 0394 00000000 		.word	DensityPresVolts
 3778 0398 00000000 		.word	DensityFormationVolts
 3779 039c 00000000 		.word	SeqOpOn
 3780 03a0 00000000 		.word	DiaFormation2Volts
 3781 03a4 00000000 		.word	DensityFormation2Volts
 3782 03a8 00000000 		.word	DiaCoreVolts
 3783 03ac 00000000 		.word	DensityCoreVolts
 3784 03b0 00000000 		.word	DiaTargetVolts
 3785              	.L363:
1754:functions.c   **** 						DensityControlFunctionActive = 1;
 3786              		.loc 1 1754 0
 3787 03b4 0122     		mov	r2, #1
 3788 03b6 D44B     		ldr	r3, .L376+8
 3789 03b8 1A70     		strb	r2, [r3]
 3790              	.L228:
1759:functions.c   **** 					if( BaleDiaVolts >= DiaEngageVolts ) // Engage diameter reached
 3791              		.loc 1 1759 0
 3792 03ba 201C     		add	r0, r4, #0
 3793 03bc D34B     		ldr	r3, .L376+12
 3794 03be 1968     		ldr	r1, [r3]
 3795 03c0 FFF7FEFF 		bl	__aeabi_fcmpge
 3796              	.LVL223:
 3797 03c4 0028     		cmp	r0, #0
 3798 03c6 00D1     		bne	.LCB3433
 3799 03c8 76E2     		b	.L183	@long jump
 3800              	.LCB3433:
1761:functions.c   **** 						if( pFac.pf.GW302_NetSystem == NS_ROLLER )
 3801              		.loc 1 1761 0
 3802 03ca C123     		mov	r3, #193
 3803 03cc D04A     		ldr	r2, .L376+16
 3804 03ce D35C     		ldrb	r3, [r2, r3]
 3805 03d0 012B     		cmp	r3, #1
 3806 03d2 03D1     		bne	.L230
1764:functions.c   **** 							RollEngageTurnedOn = 1; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
 3807              		.loc 1 1764 0
 3808 03d4 0122     		mov	r2, #1
 3809 03d6 CF4B     		ldr	r3, .L376+20
 3810 03d8 1A70     		strb	r2, [r3]
 3811 03da 6DE2     		b	.L183
 3812              	.L230:
1771:functions.c   **** 							BeakEngagePulseCount = 0UL; // Resetting IP4 'Beak Engage' pulse count
 3813              		.loc 1 1771 0
 3814 03dc 0022     		mov	r2, #0
 3815 03de CE4B     		ldr	r3, .L376+24
 3816 03e0 1A60     		str	r2, [r3]
1772:functions.c   **** 							OP5TurnedOnAfterBeakEngagePulsesEnabled = 1;
 3817              		.loc 1 1772 0
 3818 03e2 0122     		mov	r2, #1
 3819 03e4 CD4B     		ldr	r3, .L376+28
 3820 03e6 1A70     		strb	r2, [r3]
 3821 03e8 66E2     		b	.L183
 3822              	.L189:
1784:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
 3823              		.loc 1 1784 0
 3824 03ea CD4B     		ldr	r3, .L376+32
 3825 03ec 1B78     		ldrb	r3, [r3]
 3826 03ee 002B     		cmp	r3, #0
 3827 03f0 0CD0     		beq	.L231
1791:functions.c   **** 					if( pFac.pf.GW302_NetSystem == NS_ROLLER )
 3828              		.loc 1 1791 0
 3829 03f2 C123     		mov	r3, #193
 3830 03f4 C64A     		ldr	r2, .L376+16
 3831 03f6 D35C     		ldrb	r3, [r2, r3]
 3832 03f8 012B     		cmp	r3, #1
 3833 03fa 03D1     		bne	.L232
1794:functions.c   **** 						RollEngageTurnedOn = 1; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
 3834              		.loc 1 1794 0
 3835 03fc 0122     		mov	r2, #1
 3836 03fe C54B     		ldr	r3, .L376+20
 3837 0400 1A70     		strb	r2, [r3]
 3838 0402 59E2     		b	.L183
 3839              	.L232:
1801:functions.c   **** 						OP5TurnedOnAfterBeakEngagePulsesEnabled = 1;
 3840              		.loc 1 1801 0
 3841 0404 0122     		mov	r2, #1
 3842 0406 C54B     		ldr	r3, .L376+28
 3843 0408 1A70     		strb	r2, [r3]
 3844 040a 55E2     		b	.L183
 3845              	.L231:
1806:functions.c   **** 					SequenceInProgress = 1;
 3846              		.loc 1 1806 0
 3847 040c 0122     		mov	r2, #1
 3848 040e C54B     		ldr	r3, .L376+36
 3849 0410 1A70     		strb	r2, [r3]
1809:functions.c   **** 					if( pFac.pf.GW302_BaleDensity[pFac.pf.GW302_BaleProfile] <= 5 ) // Target Bale Density ID is 1
 3850              		.loc 1 1809 0
 3851 0412 BF4B     		ldr	r3, .L376+16
 3852 0414 3A22     		mov	r2, #58
 3853 0416 9A5C     		ldrb	r2, [r3, r2]
 3854 0418 9B18     		add	r3, r3, r2
 3855 041a 4033     		add	r3, r3, #64
 3856 041c 5B79     		ldrb	r3, [r3, #5]
 3857 041e 052B     		cmp	r3, #5
 3858 0420 03D8     		bhi	.L233
1811:functions.c   **** 						DensityControlFunctionActive = 1; // Density Control Function (based on Target Bale Density) 
 3859              		.loc 1 1811 0
 3860 0422 0122     		mov	r2, #1
 3861 0424 B84B     		ldr	r3, .L376+8
 3862 0426 1A70     		strb	r2, [r3]
 3863 0428 0DE0     		b	.L234
 3864              	.L233:
1815:functions.c   **** 						DensityControlFunctionActive = 0; // Density Control Function (based on Target Bale Density) 
 3865              		.loc 1 1815 0
 3866 042a 0022     		mov	r2, #0
 3867 042c B64B     		ldr	r3, .L376+8
 3868 042e 1A70     		strb	r2, [r3]
1818:functions.c   **** 						SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
 3869              		.loc 1 1818 0
 3870 0430 BD4B     		ldr	r3, .L376+40
 3871 0432 BE4A     		ldr	r2, .L376+44
 3872 0434 1968     		ldr	r1, [r3]
 3873 0436 0A40     		and	r2, r1
 3874 0438 1A60     		str	r2, [r3]
1819:functions.c   **** 						SeqOpOff |= OP_DENSITY_REL;
 3875              		.loc 1 1819 0
 3876 043a BD4B     		ldr	r3, .L376+48
 3877 043c 8022     		mov	r2, #128
 3878 043e 1202     		lsl	r2, r2, #8
 3879 0440 1868     		ldr	r0, [r3]
 3880 0442 0243     		orr	r2, r0
 3881 0444 1A60     		str	r2, [r3]
 3882              	.L234:
1823:functions.c   **** 					OP2OnDelayTime = (unsigned char)(pFac.pf.GW302_NetDelay * 10.0);
 3883              		.loc 1 1823 0
 3884 0446 B24B     		ldr	r3, .L376+16
 3885 0448 986F     		ldr	r0, [r3, #120]
 3886 044a FFF7FEFF 		bl	__aeabi_f2d
 3887              	.LVL224:
 3888 044e AD4B     		ldr	r3, .L376+4
 3889 0450 AB4A     		ldr	r2, .L376
 3890 0452 FFF7FEFF 		bl	__aeabi_dmul
 3891              	.LVL225:
 3892 0456 FFF7FEFF 		bl	__aeabi_d2uiz
 3893              	.LVL226:
 3894 045a B64B     		ldr	r3, .L376+52
 3895 045c 1870     		strb	r0, [r3]
1824:functions.c   **** 					Stage = STAGE_NETTING_NET_DELAY; // Go to Net Delay stage
 3896              		.loc 1 1824 0
 3897 045e 0622     		mov	r2, #6
 3898 0460 B54B     		ldr	r3, .L376+56
 3899 0462 1A70     		strb	r2, [r3]
 3900 0464 28E2     		b	.L183
 3901              	.L190:
1834:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
 3902              		.loc 1 1834 0
 3903 0466 AE4B     		ldr	r3, .L376+32
 3904 0468 1B78     		ldrb	r3, [r3]
 3905 046a 002B     		cmp	r3, #0
 3906 046c 03D0     		beq	.L235
1837:functions.c   **** 					OP2OnDelayTime = 0; // Net Delay (t1) set to 0; hence, on key release go to Netting stage -- N
 3907              		.loc 1 1837 0
 3908 046e 0022     		mov	r2, #0
 3909 0470 B04B     		ldr	r3, .L376+52
 3910 0472 1A70     		strb	r2, [r3]
 3911 0474 20E2     		b	.L183
 3912              	.L235:
1841:functions.c   **** 					SequenceInProgress = 1;
 3913              		.loc 1 1841 0
 3914 0476 0122     		mov	r2, #1
 3915 0478 AA4B     		ldr	r3, .L376+36
 3916 047a 1A70     		strb	r2, [r3]
1844:functions.c   **** 					if( !NettingStartBeepsDisabledWhileIP3OpenInAutoMode )
 3917              		.loc 1 1844 0
 3918 047c AF4B     		ldr	r3, .L376+60
 3919 047e 1B78     		ldrb	r3, [r3]
 3920 0480 002B     		cmp	r3, #0
 3921 0482 02D1     		bne	.L236
1847:functions.c   **** 						buzz_count = 1;
 3922              		.loc 1 1847 0
 3923 0484 0121     		mov	r1, #1
 3924 0486 AE4A     		ldr	r2, .L376+64
 3925 0488 1170     		strb	r1, [r2]
 3926              	.L236:
1850:functions.c   **** 					if( OP2OnDelayTime )
 3927              		.loc 1 1850 0
 3928 048a AA4A     		ldr	r2, .L376+52
 3929 048c 1278     		ldrb	r2, [r2]
 3930 048e 002A     		cmp	r2, #0
 3931 0490 03D0     		beq	.L237
1851:functions.c   **** 						OP2OnDelayTime--;
 3932              		.loc 1 1851 0
 3933 0492 013A     		sub	r2, r2, #1
 3934 0494 A74B     		ldr	r3, .L376+52
 3935 0496 1A70     		strb	r2, [r3]
 3936 0498 0EE2     		b	.L183
 3937              	.L237:
1854:functions.c   **** 						SeqOpOn |= OP_NET_ON;   // OP2 ON: Net Clutch (AKA Net On)
 3938              		.loc 1 1854 0
 3939 049a A34A     		ldr	r2, .L376+40
 3940 049c 8021     		mov	r1, #128
 3941 049e 8903     		lsl	r1, r1, #14
 3942 04a0 1068     		ldr	r0, [r2]
 3943 04a2 0143     		orr	r1, r0
 3944 04a4 1160     		str	r1, [r2]
1855:functions.c   **** 						stagecomp |= NETFEEDON; // Set NET FEED ON stage completed
 3945              		.loc 1 1855 0
 3946 04a6 A74A     		ldr	r2, .L376+68
 3947 04a8 1078     		ldrb	r0, [r2]
 3948 04aa 0121     		mov	r1, #1
 3949 04ac 0143     		orr	r1, r0
 3950 04ae 1170     		strb	r1, [r2]
1859:functions.c   **** 						BeakEngagePulseCount = 0UL; // Resetting IP4 'Beak Engage' pulse count
 3951              		.loc 1 1859 0
 3952 04b0 0021     		mov	r1, #0
 3953 04b2 994A     		ldr	r2, .L376+24
 3954 04b4 1160     		str	r1, [r2]
1866:functions.c   **** 						if( !NettingStartBeepsDisabledWhileIP3OpenInAutoMode )
 3955              		.loc 1 1866 0
 3956 04b6 002B     		cmp	r3, #0
 3957 04b8 09D1     		bne	.L238
1868:functions.c   **** 							if( !cont_beep )
 3958              		.loc 1 1868 0
 3959 04ba A34B     		ldr	r3, .L376+72
 3960 04bc 1B78     		ldrb	r3, [r3]
 3961 04be 002B     		cmp	r3, #0
 3962 04c0 05D1     		bne	.L238
1870:functions.c   **** 								buzz_length = NETTING_START_BEEP; // Long continuous beep when netting starts in AUTO mode
 3963              		.loc 1 1870 0
 3964 04c2 A24A     		ldr	r2, .L376+76
 3965 04c4 A24B     		ldr	r3, .L376+80
 3966 04c6 1A60     		str	r2, [r3]
1871:functions.c   **** 								cont_beep = 1;
 3967              		.loc 1 1871 0
 3968 04c8 0122     		mov	r2, #1
 3969 04ca 9F4B     		ldr	r3, .L376+72
 3970 04cc 1A70     		strb	r2, [r3]
 3971              	.L238:
1876:functions.c   **** 						CalculateTargetNetPulses();
 3972              		.loc 1 1876 0
 3973 04ce FFF7FEFF 		bl	CalculateTargetNetPulses
 3974              	.LVL227:
1879:functions.c   **** 						NetPulseCount = 0UL;
 3975              		.loc 1 1879 0
 3976 04d2 0022     		mov	r2, #0
 3977 04d4 9F4B     		ldr	r3, .L376+84
 3978 04d6 1A60     		str	r2, [r3]
1883:functions.c   **** 						if (pFac.pf.GW302_NetTwineOption == TO_NET)
 3979              		.loc 1 1883 0
 3980 04d8 7C23     		mov	r3, #124
 3981 04da 8D4A     		ldr	r2, .L376+16
 3982 04dc D35C     		ldrb	r3, [r2, r3]
 3983 04de 002B     		cmp	r3, #0
 3984 04e0 02D1     		bne	.L239
1884:functions.c   **** 							NetPulseCheckingEnabled = 1;
 3985              		.loc 1 1884 0
 3986 04e2 0122     		mov	r2, #1
 3987 04e4 9C4B     		ldr	r3, .L376+88
 3988 04e6 1A70     		strb	r2, [r3]
 3989              	.L239:
1886:functions.c   **** 						LastNetPulseCount = NetPulseCount;
 3990              		.loc 1 1886 0
 3991 04e8 0022     		mov	r2, #0
 3992 04ea 9C4B     		ldr	r3, .L376+92
 3993 04ec 1A60     		str	r2, [r3]
1887:functions.c   **** 						NetWarningDelayTime = (unsigned char)(pFac.pf.GW302_NoNetPulse * 10.0); // Delay before Check
 3994              		.loc 1 1887 0
 3995 04ee 884C     		ldr	r4, .L376+16
 3996 04f0 BC23     		mov	r3, #188
 3997 04f2 E058     		ldr	r0, [r4, r3]
 3998 04f4 FFF7FEFF 		bl	__aeabi_f2d
 3999              	.LVL228:
 4000 04f8 824B     		ldr	r3, .L376+4
 4001 04fa 814A     		ldr	r2, .L376
 4002 04fc FFF7FEFF 		bl	__aeabi_dmul
 4003              	.LVL229:
 4004 0500 FFF7FEFF 		bl	__aeabi_d2uiz
 4005              	.LVL230:
 4006 0504 964B     		ldr	r3, .L376+96
 4007 0506 1870     		strb	r0, [r3]
1890:functions.c   **** 						OP2OffDelayTime = (unsigned char)(pFac.pf.GW302_NetOn * 10.0); // Total amount of time OP2 is
 4008              		.loc 1 1890 0
 4009 0508 A423     		mov	r3, #164
 4010 050a E058     		ldr	r0, [r4, r3]
 4011 050c FFF7FEFF 		bl	__aeabi_f2d
 4012              	.LVL231:
 4013 0510 7C4B     		ldr	r3, .L376+4
 4014 0512 7B4A     		ldr	r2, .L376
 4015 0514 FFF7FEFF 		bl	__aeabi_dmul
 4016              	.LVL232:
 4017 0518 FFF7FEFF 		bl	__aeabi_d2uiz
 4018              	.LVL233:
 4019 051c 914B     		ldr	r3, .L376+100
 4020 051e 1870     		strb	r0, [r3]
1891:functions.c   **** 						Stage = STAGE_NETTING_NET_ON; // Go to Netting stage -- Net On
 4021              		.loc 1 1891 0
 4022 0520 0722     		mov	r2, #7
 4023 0522 854B     		ldr	r3, .L376+56
 4024 0524 1A70     		strb	r2, [r3]
 4025 0526 C7E1     		b	.L183
 4026              	.L191:
1902:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
 4027              		.loc 1 1902 0
 4028 0528 7D4B     		ldr	r3, .L376+32
 4029 052a 1B78     		ldrb	r3, [r3]
 4030 052c 002B     		cmp	r3, #0
 4031 052e 05D0     		beq	.L240
1905:functions.c   **** 					OP2OffDelayTime = 0;  // Net On (t2) set to 0; hence on key release turn off OP2 & go to STAGE
 4032              		.loc 1 1905 0
 4033 0530 0023     		mov	r3, #0
 4034 0532 8C4A     		ldr	r2, .L376+100
 4035 0534 1370     		strb	r3, [r2]
1906:functions.c   **** 					NetWarningOn = 0;     // Check Net Error (AKA Net Warning) turned off -- if on
 4036              		.loc 1 1906 0
 4037 0536 8C4A     		ldr	r2, .L376+104
 4038 0538 1370     		strb	r3, [r2]
 4039 053a BDE1     		b	.L183
 4040              	.L240:
1910:functions.c   **** 					SequenceInProgress = 1;
 4041              		.loc 1 1910 0
 4042 053c 0122     		mov	r2, #1
 4043 053e 794B     		ldr	r3, .L376+36
 4044 0540 1A70     		strb	r2, [r3]
1912:functions.c   **** 					if( OP2OffDelayTime )
 4045              		.loc 1 1912 0
 4046 0542 884B     		ldr	r3, .L376+100
 4047 0544 1C78     		ldrb	r4, [r3]
 4048 0546 002C     		cmp	r4, #0
 4049 0548 1BD0     		beq	.L241
1914:functions.c   **** 						if( NetPulseFrequency > pFac.pf.GW302_NetSpeed ) // Net Pulse Frequency exceeds Net Speed
 4050              		.loc 1 1914 0
 4051 054a 8423     		mov	r3, #132
 4052 054c 704A     		ldr	r2, .L376+16
 4053 054e D058     		ldr	r0, [r2, r3]
 4054 0550 864B     		ldr	r3, .L376+108
 4055 0552 1968     		ldr	r1, [r3]
 4056 0554 FFF7FEFF 		bl	__aeabi_fcmplt
 4057              	.LVL234:
 4058 0558 0028     		cmp	r0, #0
 4059 055a 0ED0     		beq	.L364
1916:functions.c   **** 							SeqOpOn &= ~OP_NET_ON; // OP2 OFF: Net Clutch (AKA Net On)
 4060              		.loc 1 1916 0
 4061 055c 724B     		ldr	r3, .L376+40
 4062 055e 844A     		ldr	r2, .L376+112
 4063 0560 1968     		ldr	r1, [r3]
 4064 0562 0A40     		and	r2, r1
 4065 0564 1A60     		str	r2, [r3]
1917:functions.c   **** 							SeqOpOff |= OP_NET_ON;
 4066              		.loc 1 1917 0
 4067 0566 724B     		ldr	r3, .L376+48
 4068 0568 8022     		mov	r2, #128
 4069 056a 9203     		lsl	r2, r2, #14
 4070 056c 1868     		ldr	r0, [r3]
 4071 056e 0243     		orr	r2, r0
 4072 0570 1A60     		str	r2, [r3]
1918:functions.c   **** 							OP2OffDelayTime = 0; // Net On (t2) expires
 4073              		.loc 1 1918 0
 4074 0572 0022     		mov	r2, #0
 4075 0574 7B4B     		ldr	r3, .L376+100
 4076 0576 1A70     		strb	r2, [r3]
 4077 0578 9EE1     		b	.L183
 4078              	.L364:
1922:functions.c   **** 							OP2OffDelayTime--;
 4079              		.loc 1 1922 0
 4080 057a 013C     		sub	r4, r4, #1
 4081 057c 794B     		ldr	r3, .L376+100
 4082 057e 1C70     		strb	r4, [r3]
 4083 0580 9AE1     		b	.L183
 4084              	.L241:
1927:functions.c   **** 						SeqOpOn &= ~OP_NET_ON; // OP2 OFF: Net Clutch (AKA Net On)
 4085              		.loc 1 1927 0
 4086 0582 694B     		ldr	r3, .L376+40
 4087 0584 7A4A     		ldr	r2, .L376+112
 4088 0586 1968     		ldr	r1, [r3]
 4089 0588 0A40     		and	r2, r1
 4090 058a 1A60     		str	r2, [r3]
1928:functions.c   **** 						SeqOpOff |= OP_NET_ON;
 4091              		.loc 1 1928 0
 4092 058c 684B     		ldr	r3, .L376+48
 4093 058e 8022     		mov	r2, #128
 4094 0590 9203     		lsl	r2, r2, #14
 4095 0592 1868     		ldr	r0, [r3]
 4096 0594 0243     		orr	r2, r0
 4097 0596 1A60     		str	r2, [r3]
1930:functions.c   **** 						Stage = STAGE_NETTING_WAIT_REQ_NET_PULSES; // Go to Netting stage -- waiting for Target Net P
 4098              		.loc 1 1930 0
 4099 0598 0822     		mov	r2, #8
 4100 059a 674B     		ldr	r3, .L376+56
 4101 059c 1A70     		strb	r2, [r3]
 4102 059e 8BE1     		b	.L183
 4103              	.L192:
1941:functions.c   **** 				if( StartAutoNet ) // Start Netting button pressed
 4104              		.loc 1 1941 0
 4105 05a0 5F4B     		ldr	r3, .L376+32
 4106 05a2 1B78     		ldrb	r3, [r3]
 4107 05a4 002B     		cmp	r3, #0
 4108 05a6 03D0     		beq	.L244
1945:functions.c   **** 					NetWarningOn = 0;     // Check Net Error (AKA Net Warning) turned off -- if on
 4109              		.loc 1 1945 0
 4110 05a8 0022     		mov	r2, #0
 4111 05aa 6F4B     		ldr	r3, .L376+104
 4112 05ac 1A70     		strb	r2, [r3]
 4113 05ae 83E1     		b	.L183
 4114              	.L244:
1949:functions.c   **** 					SequenceInProgress = 1;
 4115              		.loc 1 1949 0
 4116 05b0 0122     		mov	r2, #1
 4117 05b2 5C4B     		ldr	r3, .L376+36
 4118 05b4 1A70     		strb	r2, [r3]
1951:functions.c   **** 					if(( NetPulseCount > (unsigned long int)TargetNetPulses ) || (pFac.pf.GW302_NetTwineOption == 
 4119              		.loc 1 1951 0
 4120 05b6 674B     		ldr	r3, .L376+84
 4121 05b8 1C68     		ldr	r4, [r3]
 4122 05ba 6E4B     		ldr	r3, .L376+116
 4123 05bc 1B88     		ldrh	r3, [r3]
 4124 05be A342     		cmp	r3, r4
 4125 05c0 05D3     		bcc	.L245
1951:functions.c   **** 					if(( NetPulseCount > (unsigned long int)TargetNetPulses ) || (pFac.pf.GW302_NetTwineOption == 
 4126              		.loc 1 1951 0 is_stmt 0 discriminator 1
 4127 05c2 7C23     		mov	r3, #124
 4128 05c4 524A     		ldr	r2, .L376+16
 4129 05c6 D35C     		ldrb	r3, [r2, r3]
 4130 05c8 012B     		cmp	r3, #1
 4131 05ca 00D0     		beq	.LCB3744
 4132 05cc 74E1     		b	.L183	@long jump
 4133              	.LCB3744:
 4134              	.L245:
1954:functions.c   **** 						if( pFac.pf.GW302_BaleDensity[pFac.pf.GW302_BaleProfile] <= 5 ) // Target Bale Density ID is 
 4135              		.loc 1 1954 0 is_stmt 1
 4136 05ce 504B     		ldr	r3, .L376+16
 4137 05d0 3A22     		mov	r2, #58
 4138 05d2 9A5C     		ldrb	r2, [r3, r2]
 4139 05d4 9B18     		add	r3, r3, r2
 4140 05d6 4033     		add	r3, r3, #64
 4141 05d8 5B79     		ldrb	r3, [r3, #5]
 4142 05da 052B     		cmp	r3, #5
 4143 05dc 0DD8     		bhi	.L246
1956:functions.c   **** 							DensityControlFunctionActive = 0; // Density Control Function (based on Target Bale Density)
 4144              		.loc 1 1956 0
 4145 05de 0022     		mov	r2, #0
 4146 05e0 494B     		ldr	r3, .L376+8
 4147 05e2 1A70     		strb	r2, [r3]
1959:functions.c   **** 							SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
 4148              		.loc 1 1959 0
 4149 05e4 504B     		ldr	r3, .L376+40
 4150 05e6 514A     		ldr	r2, .L376+44
 4151 05e8 1968     		ldr	r1, [r3]
 4152 05ea 0A40     		and	r2, r1
 4153 05ec 1A60     		str	r2, [r3]
1960:functions.c   **** 							SeqOpOff |= OP_DENSITY_REL;
 4154              		.loc 1 1960 0
 4155 05ee 504B     		ldr	r3, .L376+48
 4156 05f0 8022     		mov	r2, #128
 4157 05f2 1202     		lsl	r2, r2, #8
 4158 05f4 1868     		ldr	r0, [r3]
 4159 05f6 0243     		orr	r2, r0
 4160 05f8 1A60     		str	r2, [r3]
 4161              	.L246:
1963:functions.c   **** 						if(pFac.pf.GW302_NetTwineOption == TO_NET)
 4162              		.loc 1 1963 0
 4163 05fa 7C23     		mov	r3, #124
 4164 05fc 444A     		ldr	r2, .L376+16
 4165 05fe D35C     		ldrb	r3, [r2, r3]
 4166 0600 002B     		cmp	r3, #0
 4167 0602 05D1     		bne	.L247
1964:functions.c   **** 							SeqOpOn |= OP_NET_CUT; // OP7 ON: Net Cut Motor (AKA Net Cut Trip)
 4168              		.loc 1 1964 0
 4169 0604 484B     		ldr	r3, .L376+40
 4170 0606 8022     		mov	r2, #128
 4171 0608 9201     		lsl	r2, r2, #6
 4172 060a 1968     		ldr	r1, [r3]
 4173 060c 0A43     		orr	r2, r1
 4174 060e 1A60     		str	r2, [r3]
 4175              	.L247:
1966:functions.c   **** 						stagecomp |= NETCUTON; // Set NET CUT ON stage completed
 4176              		.loc 1 1966 0
 4177 0610 4C4B     		ldr	r3, .L376+68
 4178 0612 1978     		ldrb	r1, [r3]
 4179 0614 0222     		mov	r2, #2
 4180 0616 0A43     		orr	r2, r1
 4181 0618 1A70     		strb	r2, [r3]
1975:functions.c   **** 						OP7OffDelayTime = (unsigned char)(pFac.pf.GW302_NetCutTime * 10.0);
 4182              		.loc 1 1975 0
 4183 061a AC23     		mov	r3, #172
 4184 061c 3C4A     		ldr	r2, .L376+16
 4185 061e D058     		ldr	r0, [r2, r3]
 4186 0620 FFF7FEFF 		bl	__aeabi_f2d
 4187              	.LVL235:
 4188 0624 374B     		ldr	r3, .L376+4
 4189 0626 364A     		ldr	r2, .L376
 4190 0628 FFF7FEFF 		bl	__aeabi_dmul
 4191              	.LVL236:
 4192 062c FFF7FEFF 		bl	__aeabi_d2uiz
 4193              	.LVL237:
 4194 0630 514B     		ldr	r3, .L376+120
 4195 0632 1870     		strb	r0, [r3]
1976:functions.c   **** 						IP4PulsesStoppedCount = IP4_PULSES_STOPPED_COUNT_DURATION; // 1.5 s
 4196              		.loc 1 1976 0
 4197 0634 0F22     		mov	r2, #15
 4198 0636 514B     		ldr	r3, .L376+124
 4199 0638 1A70     		strb	r2, [r3]
1977:functions.c   **** 						NetPulseCountAtLastCheck = NetPulseCount; // Pulse count saved
 4200              		.loc 1 1977 0
 4201 063a 514B     		ldr	r3, .L376+128
 4202 063c 1C60     		str	r4, [r3]
1978:functions.c   **** 						Stage = STAGE_NETTING_NET_CUT_ON; // Go to Netting stage -- Net Cut On
 4203              		.loc 1 1978 0
 4204 063e 0922     		mov	r2, #9
 4205 0640 3D4B     		ldr	r3, .L376+56
 4206 0642 1A70     		strb	r2, [r3]
1981:functions.c   **** 						NetPulseCheckingEnabled = 0;
 4207              		.loc 1 1981 0
 4208 0644 0023     		mov	r3, #0
 4209 0646 444A     		ldr	r2, .L376+88
 4210 0648 1370     		strb	r3, [r2]
1984:functions.c   **** 						OP5TurnedOnAfterBeakEngagePulsesEnabled = 0;
 4211              		.loc 1 1984 0
 4212 064a 344A     		ldr	r2, .L376+28
 4213 064c 1370     		strb	r3, [r2]
 4214 064e 33E1     		b	.L183
 4215              	.L193:
1995:functions.c   **** 				SequenceInProgress = 1;
 4216              		.loc 1 1995 0
 4217 0650 0122     		mov	r2, #1
 4218 0652 344B     		ldr	r3, .L376+36
 4219 0654 1A70     		strb	r2, [r3]
1997:functions.c   **** 				if( OP7OffDelayTime || IP4PulsesStoppedCount )
 4220              		.loc 1 1997 0
 4221 0656 484B     		ldr	r3, .L376+120
 4222 0658 1B78     		ldrb	r3, [r3]
 4223 065a 002B     		cmp	r3, #0
 4224 065c 06D1     		bne	.L248
1997:functions.c   **** 				if( OP7OffDelayTime || IP4PulsesStoppedCount )
 4225              		.loc 1 1997 0 is_stmt 0 discriminator 1
 4226 065e 474B     		ldr	r3, .L376+124
 4227 0660 1B78     		ldrb	r3, [r3]
 4228 0662 002B     		cmp	r3, #0
 4229 0664 01D0     		beq	.LCB3830
 4230 0666 00F027FD 		bl	.L249	@far jump
 4231              	.LCB3830:
 4232 066a 27E0     		b	.L250
 4233              	.L248:
2001:functions.c   **** 						OP7OffDelayTime--;
 4234              		.loc 1 2001 0 is_stmt 1
 4235 066c 013B     		sub	r3, r3, #1
 4236 066e 424A     		ldr	r2, .L376+120
 4237 0670 1370     		strb	r3, [r2]
2004:functions.c   **** 					if( IP4PulsesStoppedCount )
 4238              		.loc 1 2004 0
 4239 0672 424B     		ldr	r3, .L376+124
 4240 0674 1A78     		ldrb	r2, [r3]
 4241 0676 002A     		cmp	r2, #0
 4242 0678 0ED0     		beq	.L251
 4243              	.L332:
2006:functions.c   **** 						if( NetPulseCount == NetPulseCountAtLastCheck ) // Net Pulses cease to be detected on IP4 aft
 4244              		.loc 1 2006 0
 4245 067a 364B     		ldr	r3, .L376+84
 4246 067c 1B68     		ldr	r3, [r3]
 4247 067e 4049     		ldr	r1, .L376+128
 4248 0680 0968     		ldr	r1, [r1]
 4249 0682 8B42     		cmp	r3, r1
 4250 0684 03D1     		bne	.L252
2008:functions.c   **** 							IP4PulsesStoppedCount--;
 4251              		.loc 1 2008 0
 4252 0686 013A     		sub	r2, r2, #1
 4253 0688 3C49     		ldr	r1, .L376+124
 4254 068a 0A70     		strb	r2, [r1]
 4255 068c 02E0     		b	.L253
 4256              	.L252:
2012:functions.c   **** 							IP4PulsesStoppedCount = IP4_PULSES_STOPPED_COUNT_DURATION; // Resetting to 1.5 s
 4257              		.loc 1 2012 0
 4258 068e 0F21     		mov	r1, #15
 4259 0690 3A4A     		ldr	r2, .L376+124
 4260 0692 1170     		strb	r1, [r2]
 4261              	.L253:
2014:functions.c   **** 						NetPulseCountAtLastCheck = NetPulseCount; // Net Pulse count (for what will be the last check
 4262              		.loc 1 2014 0
 4263 0694 3A4A     		ldr	r2, .L376+128
 4264 0696 1360     		str	r3, [r2]
 4265              	.L251:
2019:functions.c   **** 				if( !OP7OffDelayTime || !IP4PulsesStoppedCount || NET_CUT_SENSOR_CLOSED || (pFac.pf.GW302_NetTw
 4266              		.loc 1 2019 0
 4267 0698 374B     		ldr	r3, .L376+120
 4268 069a 1B78     		ldrb	r3, [r3]
 4269 069c 002B     		cmp	r3, #0
 4270 069e 0DD0     		beq	.L250
2019:functions.c   **** 				if( !OP7OffDelayTime || !IP4PulsesStoppedCount || NET_CUT_SENSOR_CLOSED || (pFac.pf.GW302_NetTw
 4271              		.loc 1 2019 0 is_stmt 0 discriminator 1
 4272 06a0 364B     		ldr	r3, .L376+124
 4273 06a2 1B78     		ldrb	r3, [r3]
 4274 06a4 002B     		cmp	r3, #0
 4275 06a6 09D0     		beq	.L250
 4276 06a8 364B     		ldr	r3, .L376+132
 4277 06aa DB6B     		ldr	r3, [r3, #60]
 4278 06ac DA00     		lsl	r2, r3, #3
 4279 06ae 05D4     		bmi	.L250
 4280 06b0 7C23     		mov	r3, #124
 4281 06b2 174A     		ldr	r2, .L376+16
 4282 06b4 D35C     		ldrb	r3, [r2, r3]
 4283 06b6 012B     		cmp	r3, #1
 4284 06b8 00D0     		beq	.LCB3883
 4285 06ba FDE0     		b	.L183	@long jump
 4286              	.LCB3883:
 4287              	.L250:
2021:functions.c   **** 					RollEngageTurnedOn = 0;     // OP5 Roller Engage Solenoid (AKA Pre Net Position) turned off
 4288              		.loc 1 2021 0 is_stmt 1
 4289 06bc 0022     		mov	r2, #0
 4290 06be 154B     		ldr	r3, .L376+20
 4291 06c0 1A70     		strb	r2, [r3]
2022:functions.c   **** 					AllSeqOpOff(); // All OPs OFF
 4292              		.loc 1 2022 0
 4293 06c2 FFF7FEFF 		bl	AllSeqOpOff
 4294              	.LVL238:
2024:functions.c   **** 					buzz_length = PROMPT_TO_OPEN_DOOR_BEEP; // Beep to prompt operator to open the chamber door & 
 4295              		.loc 1 2024 0
 4296 06c6 FA22     		mov	r2, #250
 4297 06c8 5200     		lsl	r2, r2, #1
 4298 06ca 214B     		ldr	r3, .L376+80
 4299 06cc 1A60     		str	r2, [r3]
2026:functions.c   **** 					Stage = STAGE_NETTING_END; // Go to end of Netting stage
 4300              		.loc 1 2026 0
 4301 06ce 0A22     		mov	r2, #10
 4302 06d0 194B     		ldr	r3, .L376+56
 4303 06d2 1A70     		strb	r2, [r3]
 4304 06d4 F0E0     		b	.L183
 4305              	.L194:
2036:functions.c   **** 				SequenceInProgress = 1;
 4306              		.loc 1 2036 0
 4307 06d6 0122     		mov	r2, #1
 4308 06d8 124B     		ldr	r3, .L376+36
 4309 06da 1A70     		strb	r2, [r3]
2038:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
 4310              		.loc 1 2038 0
 4311 06dc 294B     		ldr	r3, .L376+132
 4312 06de DB6B     		ldr	r3, [r3, #60]
 4313 06e0 5802     		lsl	r0, r3, #9
 4314 06e2 00D5     		bpl	.LCB3909
 4315 06e4 E8E0     		b	.L183	@long jump
 4316              	.LCB3909:
2040:functions.c   **** 					stagecomp |= CHAMBOP;      // Set CHAMBER OPEN stage completed
 4317              		.loc 1 2040 0
 4318 06e6 174B     		ldr	r3, .L376+68
 4319 06e8 1978     		ldrb	r1, [r3]
 4320 06ea 0422     		mov	r2, #4
 4321 06ec 0A43     		orr	r2, r1
 4322 06ee 1A70     		strb	r2, [r3]
2042:functions.c   **** 					buzz_length = AUTO_CONFIRM_DOOR_OPENED_BEEP; // Beep to confirm chamber door has been opened
 4323              		.loc 1 2042 0
 4324 06f0 FA22     		mov	r2, #250
 4325 06f2 174B     		ldr	r3, .L376+80
 4326 06f4 1A60     		str	r2, [r3]
2044:functions.c   **** 					Stage = STAGE_UNLOADING;   // Go to Unloading stage
 4327              		.loc 1 2044 0
 4328 06f6 0B22     		mov	r2, #11
 4329 06f8 0F4B     		ldr	r3, .L376+56
 4330 06fa 1A70     		strb	r2, [r3]
 4331 06fc DCE0     		b	.L183
 4332              	.L377:
 4333 06fe C046     		.align	3
 4334              	.L376:
 4335 0700 00000000 		.word	0
 4336 0704 00002440 		.word	1076101120
 4337 0708 00000000 		.word	DensityControlFunctionActive
 4338 070c 00000000 		.word	DiaEngageVolts
 4339 0710 00000000 		.word	.LANCHOR0
 4340 0714 00000000 		.word	RollEngageTurnedOn
 4341 0718 00000000 		.word	BeakEngagePulseCount
 4342 071c 00000000 		.word	OP5TurnedOnAfterBeakEngagePulsesEnabled
 4343 0720 00000000 		.word	StartAutoNet
 4344 0724 00000000 		.word	SequenceInProgress
 4345 0728 00000000 		.word	SeqOpOn
 4346 072c FF7FFFFF 		.word	-32769
 4347 0730 00000000 		.word	SeqOpOff
 4348 0734 00000000 		.word	OP2OnDelayTime
 4349 0738 00000000 		.word	Stage
 4350 073c 00000000 		.word	NettingStartBeepsDisabledWhileIP3OpenInAutoMode
 4351 0740 00000000 		.word	buzz_count
 4352 0744 00000000 		.word	stagecomp
 4353 0748 00000000 		.word	cont_beep
 4354 074c B80B0000 		.word	3000
 4355 0750 00000000 		.word	buzz_length
 4356 0754 00000000 		.word	NetPulseCount
 4357 0758 00000000 		.word	NetPulseCheckingEnabled
 4358 075c 00000000 		.word	.LANCHOR15
 4359 0760 00000000 		.word	NetWarningDelayTime
 4360 0764 00000000 		.word	OP2OffDelayTime
 4361 0768 00000000 		.word	NetWarningOn
 4362 076c 00000000 		.word	NetPulseFrequency
 4363 0770 FFFFDFFF 		.word	-2097153
 4364 0774 00000000 		.word	TargetNetPulses
 4365 0778 00000000 		.word	OP7OffDelayTime
 4366 077c 00000000 		.word	IP4PulsesStoppedCount
 4367 0780 00000000 		.word	NetPulseCountAtLastCheck
 4368 0784 00F6FFFF 		.word	-2560
 4369              	.L195:
2054:functions.c   **** 				SequenceInProgress = 1;
 4370              		.loc 1 2054 0
 4371 0788 0122     		mov	r2, #1
 4372 078a CD4B     		ldr	r3, .L378+8
 4373 078c 1A70     		strb	r2, [r3]
2056:functions.c   **** 				if( CHAMBER_CLOSED ) // Chamber Locked Sensor closed
 4374              		.loc 1 2056 0
 4375 078e CD4B     		ldr	r3, .L378+12
 4376 0790 DB6B     		ldr	r3, [r3, #60]
 4377 0792 5902     		lsl	r1, r3, #9
 4378 0794 18D5     		bpl	.L254
2058:functions.c   **** 					stagecomp |= CHAMBCLO;  // Set CHAMBER CLOSED stage completed
 4379              		.loc 1 2058 0
 4380 0796 CC4B     		ldr	r3, .L378+16
 4381 0798 1978     		ldrb	r1, [r3]
 4382 079a 0822     		mov	r2, #8
 4383 079c 0A43     		orr	r2, r1
 4384 079e 1A70     		strb	r2, [r3]
2060:functions.c   **** 					buzz_length = AUTO_CONFIRM_DOOR_CLOSED_BEEP; // Beep to confirm chamber door has been closed
 4385              		.loc 1 2060 0
 4386 07a0 FA22     		mov	r2, #250
 4387 07a2 CA4B     		ldr	r3, .L378+20
 4388 07a4 1A60     		str	r2, [r3]
2063:functions.c   **** 					ChamberClosedDelayTime = (unsigned char)(pFac.pf.GW302_DoorClosed * 10.0);
 4389              		.loc 1 2063 0
 4390 07a6 8C23     		mov	r3, #140
 4391 07a8 C94A     		ldr	r2, .L378+24
 4392 07aa D058     		ldr	r0, [r2, r3]
 4393 07ac FFF7FEFF 		bl	__aeabi_f2d
 4394              	.LVL239:
 4395 07b0 C24B     		ldr	r3, .L378+4
 4396 07b2 C14A     		ldr	r2, .L378
 4397 07b4 FFF7FEFF 		bl	__aeabi_dmul
 4398              	.LVL240:
 4399 07b8 FFF7FEFF 		bl	__aeabi_d2uiz
 4400              	.LVL241:
 4401 07bc C54B     		ldr	r3, .L378+28
 4402 07be 1870     		strb	r0, [r3]
2064:functions.c   **** 					Stage = STAGE_UNLOADING_WAIT;      // Go to Unloading Wait stage
 4403              		.loc 1 2064 0
 4404 07c0 0C22     		mov	r2, #12
 4405 07c2 C54B     		ldr	r3, .L378+32
 4406 07c4 1A70     		strb	r2, [r3]
 4407 07c6 77E0     		b	.L183
 4408              	.L254:
2069:functions.c   **** 					if( BALE_KICKER_DOWN ) // IP5: Bale Kicker Sensor open
 4409              		.loc 1 2069 0
 4410 07c8 BE4B     		ldr	r3, .L378+12
 4411 07ca DB6B     		ldr	r3, [r3, #60]
 4412 07cc 5A01     		lsl	r2, r3, #5
 4413 07ce 07D4     		bmi	.L255
2072:functions.c   **** 						BaleKickerStatus &= ~(BKS_BALE_KICKER_UP); // Flag to be set next
 4414              		.loc 1 2072 0
 4415 07d0 C24B     		ldr	r3, .L378+36
 4416 07d2 1A78     		ldrb	r2, [r3]
 4417 07d4 0221     		mov	r1, #2
 4418 07d6 8A43     		bic	r2, r1
 4419 07d8 0121     		mov	r1, #1
 4420 07da 0A43     		orr	r2, r1
 4421 07dc 1A70     		strb	r2, [r3]
 4422 07de 6BE0     		b	.L183
 4423              	.L255:
2074:functions.c   **** 					else if( BALE_KICKER_UP ) // IP5: Bale Kicker Sensor closed
 4424              		.loc 1 2074 0
 4425 07e0 B84B     		ldr	r3, .L378+12
 4426 07e2 DB6B     		ldr	r3, [r3, #60]
 4427 07e4 5801     		lsl	r0, r3, #5
 4428 07e6 67D5     		bpl	.L183
2076:functions.c   **** 						if( BaleKickerStatus == BKS_BALE_KICKER_DOWN ) // BKS_BALE_KICKER_DOWN flag already set
 4429              		.loc 1 2076 0
 4430 07e8 BC4B     		ldr	r3, .L378+36
 4431 07ea 1B78     		ldrb	r3, [r3]
 4432 07ec 012B     		cmp	r3, #1
 4433 07ee 63D1     		bne	.L183
2078:functions.c   **** 							BaleKickerStatus |= BKS_BALE_KICKER_UP; // Set BKS_BALE_KICKER_UP flag
 4434              		.loc 1 2078 0
 4435 07f0 0322     		mov	r2, #3
 4436 07f2 BA4B     		ldr	r3, .L378+36
 4437 07f4 1A70     		strb	r2, [r3]
2080:functions.c   **** 							buzz_length = AUTO_CONFIRM_BALE_UNLOADED_BEEP; // Beep to confirm bale has been unloaded
 4438              		.loc 1 2080 0
 4439 07f6 FA22     		mov	r2, #250
 4440 07f8 B44B     		ldr	r3, .L378+20
 4441 07fa 1A60     		str	r2, [r3]
 4442 07fc 5CE0     		b	.L183
 4443              	.L196:
2093:functions.c   **** 				SequenceInProgress = 1;
 4444              		.loc 1 2093 0
 4445 07fe 0122     		mov	r2, #1
 4446 0800 AF4B     		ldr	r3, .L378+8
 4447 0802 1A70     		strb	r2, [r3]
2095:functions.c   **** 				if( ChamberClosedDelayTime )
 4448              		.loc 1 2095 0
 4449 0804 B34B     		ldr	r3, .L378+28
 4450 0806 1B78     		ldrb	r3, [r3]
 4451 0808 002B     		cmp	r3, #0
 4452 080a 03D0     		beq	.L256
2096:functions.c   **** 					ChamberClosedDelayTime--;
 4453              		.loc 1 2096 0
 4454 080c 013B     		sub	r3, r3, #1
 4455 080e B14A     		ldr	r2, .L378+28
 4456 0810 1370     		strb	r3, [r2]
 4457 0812 51E0     		b	.L183
 4458              	.L256:
2099:functions.c   **** 					AllSeqOpOff();          // All OPs OFF
 4459              		.loc 1 2099 0
 4460 0814 FFF7FEFF 		bl	AllSeqOpOff
 4461              	.LVL242:
2101:functions.c   **** 					Stage = STAGE_END;      // Go to End stage
 4462              		.loc 1 2101 0
 4463 0818 0D22     		mov	r2, #13
 4464 081a AF4B     		ldr	r3, .L378+32
 4465 081c 1A70     		strb	r2, [r3]
 4466 081e 4BE0     		b	.L183
 4467              	.L197:
2111:functions.c   **** 				SequenceInProgress = 1;
 4468              		.loc 1 2111 0
 4469 0820 0122     		mov	r2, #1
 4470 0822 A74B     		ldr	r3, .L378+8
 4471 0824 1A70     		strb	r2, [r3]
2113:functions.c   **** 				if( stagecomp == (NETFEEDON | NETCUTON | CHAMBOP | CHAMBCLO) ) // all stages completed
 4472              		.loc 1 2113 0
 4473 0826 A84B     		ldr	r3, .L378+16
 4474 0828 1B78     		ldrb	r3, [r3]
 4475 082a 0F2B     		cmp	r3, #15
 4476 082c 08D1     		bne	.L257
2115:functions.c   **** 					stagecomp = SC_CLEAR; // Reset
 4477              		.loc 1 2115 0
 4478 082e 0022     		mov	r2, #0
 4479 0830 A54B     		ldr	r3, .L378+16
 4480 0832 1A70     		strb	r2, [r3]
2117:functions.c   **** 					UpdatingAndSavingTotalsToMemory();
 4481              		.loc 1 2117 0
 4482 0834 FFF7FEFF 		bl	UpdatingAndSavingTotalsToMemory
 4483              	.LVL243:
2119:functions.c   **** 					buzz_length = ALL_STAGES_COMPLETE_BEEP; // Beep on completion of all stages
 4484              		.loc 1 2119 0
 4485 0838 FA22     		mov	r2, #250
 4486 083a 9200     		lsl	r2, r2, #2
 4487 083c A34B     		ldr	r3, .L378+20
 4488 083e 1A60     		str	r2, [r3]
 4489              	.L257:
2122:functions.c   **** 				if( (pFac.pf.GW302_PreNetPulse > 0) && (pFac.pf.GW302_NetTwineOption == TO_NET))
 4490              		.loc 1 2122 0
 4491 0840 C023     		mov	r3, #192
 4492 0842 A34A     		ldr	r2, .L378+24
 4493 0844 D35C     		ldrb	r3, [r2, r3]
 4494 0846 002B     		cmp	r3, #0
 4495 0848 22D0     		beq	.L258
2122:functions.c   **** 				if( (pFac.pf.GW302_PreNetPulse > 0) && (pFac.pf.GW302_NetTwineOption == TO_NET))
 4496              		.loc 1 2122 0 is_stmt 0 discriminator 1
 4497 084a 7C23     		mov	r3, #124
 4498 084c D35C     		ldrb	r3, [r2, r3]
 4499 084e 002B     		cmp	r3, #0
 4500 0850 1ED1     		bne	.L258
2124:functions.c   **** 					SeqOpOn |= OP_NET_ON;         // OP2 ON: Net Clutch (AKA Net On)
 4501              		.loc 1 2124 0 is_stmt 1
 4502 0852 A34B     		ldr	r3, .L378+40
 4503 0854 8022     		mov	r2, #128
 4504 0856 9203     		lsl	r2, r2, #14
 4505 0858 1968     		ldr	r1, [r3]
 4506 085a 0A43     		orr	r2, r1
 4507 085c 1A60     		str	r2, [r3]
2127:functions.c   **** 					NetPulseCount = 0UL;
 4508              		.loc 1 2127 0
 4509 085e 0023     		mov	r3, #0
 4510 0860 A04A     		ldr	r2, .L378+44
 4511 0862 1360     		str	r3, [r2]
2131:functions.c   **** 					NetPulseCheckingEnabled = 1;
 4512              		.loc 1 2131 0
 4513 0864 0121     		mov	r1, #1
 4514 0866 A04A     		ldr	r2, .L378+48
 4515 0868 1170     		strb	r1, [r2]
2132:functions.c   **** 					LastNetPulseCount = NetPulseCount;
 4516              		.loc 1 2132 0
 4517 086a A04A     		ldr	r2, .L378+52
 4518 086c 1360     		str	r3, [r2]
2133:functions.c   **** 					NetWarningDelayTime = (unsigned char)(pFac.pf.GW302_NoNetPulse * 10.0); // Delay before Check 
 4519              		.loc 1 2133 0
 4520 086e BC23     		mov	r3, #188
 4521 0870 974A     		ldr	r2, .L378+24
 4522 0872 D058     		ldr	r0, [r2, r3]
 4523 0874 FFF7FEFF 		bl	__aeabi_f2d
 4524              	.LVL244:
 4525 0878 904B     		ldr	r3, .L378+4
 4526 087a 8F4A     		ldr	r2, .L378
 4527 087c FFF7FEFF 		bl	__aeabi_dmul
 4528              	.LVL245:
 4529 0880 FFF7FEFF 		bl	__aeabi_d2uiz
 4530              	.LVL246:
 4531 0884 9A4B     		ldr	r3, .L378+56
 4532 0886 1870     		strb	r0, [r3]
2136:functions.c   **** 					Stage = STAGE_PRE_NET_PULSES; // Go to Pre Net Pulses stage
 4533              		.loc 1 2136 0
 4534 0888 0E22     		mov	r2, #14
 4535 088a 934B     		ldr	r3, .L378+32
 4536 088c 1A70     		strb	r2, [r3]
 4537 088e 13E0     		b	.L183
 4538              	.L258:
2141:functions.c   **** 					ResetSequenceFactors( SEQ_ALL ); // Turns off all OPs & goes to start of sequence
 4539              		.loc 1 2141 0
 4540 0890 FF20     		mov	r0, #255
 4541 0892 FFF7FEFF 		bl	ResetSequenceFactors
 4542              	.LVL247:
 4543 0896 0FE0     		b	.L183
 4544              	.L198:
2151:functions.c   **** 				SequenceInProgress = 1;
 4545              		.loc 1 2151 0
 4546 0898 0122     		mov	r2, #1
 4547 089a 894B     		ldr	r3, .L378+8
 4548 089c 1A70     		strb	r2, [r3]
2153:functions.c   **** 				if( NetPulseCount >= (unsigned long int)pFac.pf.GW302_PreNetPulse ) // Sufficient Pre Net Pulse
 4549              		.loc 1 2153 0
 4550 089e C023     		mov	r3, #192
 4551 08a0 8B4A     		ldr	r2, .L378+24
 4552 08a2 D25C     		ldrb	r2, [r2, r3]
 4553 08a4 8F4B     		ldr	r3, .L378+44
 4554 08a6 1B68     		ldr	r3, [r3]
 4555 08a8 9A42     		cmp	r2, r3
 4556 08aa 05D8     		bhi	.L183
2159:functions.c   **** 					NetPulseCheckingEnabled = 0;
 4557              		.loc 1 2159 0
 4558 08ac 0022     		mov	r2, #0
 4559 08ae 8E4B     		ldr	r3, .L378+48
 4560 08b0 1A70     		strb	r2, [r3]
2162:functions.c   **** 					ResetSequenceFactors( SEQ_ALL );  // Turns off all OPs & goes to start of sequence
 4561              		.loc 1 2162 0
 4562 08b2 FF20     		mov	r0, #255
 4563 08b4 FFF7FEFF 		bl	ResetSequenceFactors
 4564              	.LVL248:
 4565              	.L183:
2172:functions.c   **** 			if( DensityControlFunctionActive )
 4566              		.loc 1 2172 0
 4567 08b8 8E4B     		ldr	r3, .L378+60
 4568 08ba 1B78     		ldrb	r3, [r3]
 4569 08bc 002B     		cmp	r3, #0
 4570 08be 56D0     		beq	.L259
2174:functions.c   **** 				if( DensityPresVolts >= DensityBaleVolts ) // Target bale density reached/exceeded
 4571              		.loc 1 2174 0
 4572 08c0 8D4B     		ldr	r3, .L378+64
 4573 08c2 1C68     		ldr	r4, [r3]
 4574 08c4 8D4B     		ldr	r3, .L378+68
 4575 08c6 1D68     		ldr	r5, [r3]
 4576 08c8 201C     		add	r0, r4, #0
 4577 08ca 291C     		add	r1, r5, #0
 4578 08cc FFF7FEFF 		bl	__aeabi_fcmpge
 4579              	.LVL249:
 4580 08d0 0028     		cmp	r0, #0
 4581 08d2 20D0     		beq	.L365
2176:functions.c   **** 					if( OP8OnDelayTime )
 4582              		.loc 1 2176 0
 4583 08d4 8A4B     		ldr	r3, .L378+72
 4584 08d6 1B78     		ldrb	r3, [r3]
 4585 08d8 002B     		cmp	r3, #0
 4586 08da 03D0     		beq	.L262
2177:functions.c   **** 						OP8OnDelayTime--;
 4587              		.loc 1 2177 0
 4588 08dc 013B     		sub	r3, r3, #1
 4589 08de 884A     		ldr	r2, .L378+72
 4590 08e0 1370     		strb	r3, [r2]
 4591 08e2 44E0     		b	.L259
 4592              	.L262:
2180:functions.c   **** 						SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
 4593              		.loc 1 2180 0
 4594 08e4 7E4B     		ldr	r3, .L378+40
 4595 08e6 8022     		mov	r2, #128
 4596 08e8 1202     		lsl	r2, r2, #8
 4597 08ea 1868     		ldr	r0, [r3]
 4598 08ec 0243     		orr	r2, r0
 4599 08ee 1A60     		str	r2, [r3]
2181:functions.c   **** 						SeqOpOff &= ~OP_DENSITY_REL;
 4600              		.loc 1 2181 0
 4601 08f0 844B     		ldr	r3, .L378+76
 4602 08f2 854A     		ldr	r2, .L378+80
 4603 08f4 1968     		ldr	r1, [r3]
 4604 08f6 0A40     		and	r2, r1
 4605 08f8 1A60     		str	r2, [r3]
2182:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 4606              		.loc 1 2182 0
 4607 08fa 8823     		mov	r3, #136
 4608 08fc 744A     		ldr	r2, .L378+24
 4609 08fe D058     		ldr	r0, [r2, r3]
 4610 0900 FFF7FEFF 		bl	__aeabi_f2d
 4611              	.LVL250:
 4612 0904 6D4B     		ldr	r3, .L378+4
 4613 0906 6C4A     		ldr	r2, .L378
 4614 0908 FFF7FEFF 		bl	__aeabi_dmul
 4615              	.LVL251:
 4616 090c FFF7FEFF 		bl	__aeabi_d2uiz
 4617              	.LVL252:
 4618 0910 7E4B     		ldr	r3, .L378+84
 4619 0912 1870     		strb	r0, [r3]
 4620 0914 2BE0     		b	.L259
 4621              	.L365:
2185:functions.c   **** 				else if( DensityPresVolts < (DensityBaleVolts - pFac.pf.GW302_PresDeadband) ) // Fallen below d
 4622              		.loc 1 2185 0
 4623 0916 281C     		add	r0, r5, #0
 4624 0918 8023     		mov	r3, #128
 4625 091a 6D4A     		ldr	r2, .L378+24
 4626 091c D158     		ldr	r1, [r2, r3]
 4627 091e FFF7FEFF 		bl	__aeabi_fsub
 4628              	.LVL253:
 4629 0922 011C     		add	r1, r0, #0
 4630 0924 201C     		add	r0, r4, #0
 4631 0926 FFF7FEFF 		bl	__aeabi_fcmplt
 4632              	.LVL254:
 4633 092a 0028     		cmp	r0, #0
 4634 092c 1FD0     		beq	.L259
2187:functions.c   **** 					if( OP8OffDelayTime )
 4635              		.loc 1 2187 0
 4636 092e 774B     		ldr	r3, .L378+84
 4637 0930 1B78     		ldrb	r3, [r3]
 4638 0932 002B     		cmp	r3, #0
 4639 0934 03D0     		beq	.L264
2188:functions.c   **** 						OP8OffDelayTime--;
 4640              		.loc 1 2188 0
 4641 0936 013B     		sub	r3, r3, #1
 4642 0938 744A     		ldr	r2, .L378+84
 4643 093a 1370     		strb	r3, [r2]
 4644 093c 17E0     		b	.L259
 4645              	.L264:
2191:functions.c   **** 						SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
 4646              		.loc 1 2191 0
 4647 093e 684B     		ldr	r3, .L378+40
 4648 0940 714A     		ldr	r2, .L378+80
 4649 0942 1868     		ldr	r0, [r3]
 4650 0944 0240     		and	r2, r0
 4651 0946 1A60     		str	r2, [r3]
2192:functions.c   **** 						SeqOpOff |= OP_DENSITY_REL;
 4652              		.loc 1 2192 0
 4653 0948 6E4B     		ldr	r3, .L378+76
 4654 094a 8022     		mov	r2, #128
 4655 094c 1202     		lsl	r2, r2, #8
 4656 094e 1968     		ldr	r1, [r3]
 4657 0950 0A43     		orr	r2, r1
 4658 0952 1A60     		str	r2, [r3]
2193:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 4659              		.loc 1 2193 0
 4660 0954 8823     		mov	r3, #136
 4661 0956 5E4A     		ldr	r2, .L378+24
 4662 0958 D058     		ldr	r0, [r2, r3]
 4663 095a FFF7FEFF 		bl	__aeabi_f2d
 4664              	.LVL255:
 4665 095e 574B     		ldr	r3, .L378+4
 4666 0960 554A     		ldr	r2, .L378
 4667 0962 FFF7FEFF 		bl	__aeabi_dmul
 4668              	.LVL256:
 4669 0966 FFF7FEFF 		bl	__aeabi_d2uiz
 4670              	.LVL257:
 4671 096a 654B     		ldr	r3, .L378+72
 4672 096c 1870     		strb	r0, [r3]
 4673              	.L259:
2202:functions.c   **** 			if( (NetPulseCheckingEnabled) && (pFac.pf.GW302_NetTwineOption == TO_NET) ) // Flag set from whe
 4674              		.loc 1 2202 0
 4675 096e 5E4B     		ldr	r3, .L378+48
 4676 0970 1B78     		ldrb	r3, [r3]
 4677 0972 002B     		cmp	r3, #0
 4678 0974 2FD0     		beq	.L265
2202:functions.c   **** 			if( (NetPulseCheckingEnabled) && (pFac.pf.GW302_NetTwineOption == TO_NET) ) // Flag set from whe
 4679              		.loc 1 2202 0 is_stmt 0 discriminator 1
 4680 0976 7C23     		mov	r3, #124
 4681 0978 554A     		ldr	r2, .L378+24
 4682 097a D35C     		ldrb	r3, [r2, r3]
 4683 097c 002B     		cmp	r3, #0
 4684 097e 2AD1     		bne	.L265
2204:functions.c   **** 				if( (NetPulseCount == 0UL) || (NetPulseCount == LastNetPulseCount) ) // No pulses detected on I
 4685              		.loc 1 2204 0 is_stmt 1
 4686 0980 584B     		ldr	r3, .L378+44
 4687 0982 1B68     		ldr	r3, [r3]
 4688 0984 002B     		cmp	r3, #0
 4689 0986 00D1     		bne	.LCB4261
 4690 0988 80E3     		b	.L266	@long jump
 4691              	.LCB4261:
2204:functions.c   **** 				if( (NetPulseCount == 0UL) || (NetPulseCount == LastNetPulseCount) ) // No pulses detected on I
 4692              		.loc 1 2204 0 is_stmt 0 discriminator 1
 4693 098a 584A     		ldr	r2, .L378+52
 4694 098c 1268     		ldr	r2, [r2]
 4695 098e 9342     		cmp	r3, r2
 4696 0990 08D1     		bne	.L366
 4697 0992 7BE3     		b	.L266
 4698              	.L328:
2208:functions.c   **** 						NetWarningDelayTime--;
 4699              		.loc 1 2208 0 is_stmt 1
 4700 0994 013A     		sub	r2, r2, #1
 4701 0996 564B     		ldr	r3, .L378+56
 4702 0998 1A70     		strb	r2, [r3]
 4703 099a 15E0     		b	.L268
 4704              	.L372:
2213:functions.c   **** 							NetWarningOn = 1; // Check Net Error (AKA Net Warning) turned on
 4705              		.loc 1 2213 0
 4706 099c 0122     		mov	r2, #1
 4707 099e 5C4B     		ldr	r3, .L378+88
 4708 09a0 1A70     		strb	r2, [r3]
 4709 09a2 11E0     		b	.L268
 4710              	.L366:
2218:functions.c   **** 					NetWarningOn = 0; // Check Net Error (AKA Net Warning) turned off
 4711              		.loc 1 2218 0
 4712 09a4 0021     		mov	r1, #0
 4713 09a6 5A4A     		ldr	r2, .L378+88
 4714 09a8 1170     		strb	r1, [r2]
2219:functions.c   **** 					LastNetPulseCount = NetPulseCount;
 4715              		.loc 1 2219 0
 4716 09aa 504A     		ldr	r2, .L378+52
 4717 09ac 1360     		str	r3, [r2]
2220:functions.c   **** 					NetWarningDelayTime = (unsigned char)(pFac.pf.GW302_NoNetPulse * 10.0); // Delay before Check 
 4718              		.loc 1 2220 0
 4719 09ae BC23     		mov	r3, #188
 4720 09b0 474A     		ldr	r2, .L378+24
 4721 09b2 D058     		ldr	r0, [r2, r3]
 4722 09b4 FFF7FEFF 		bl	__aeabi_f2d
 4723              	.LVL258:
 4724 09b8 404B     		ldr	r3, .L378+4
 4725 09ba 3F4A     		ldr	r2, .L378
 4726 09bc FFF7FEFF 		bl	__aeabi_dmul
 4727              	.LVL259:
 4728 09c0 FFF7FEFF 		bl	__aeabi_d2uiz
 4729              	.LVL260:
 4730 09c4 4A4B     		ldr	r3, .L378+56
 4731 09c6 1870     		strb	r0, [r3]
 4732              	.L268:
2224:functions.c   **** 				if( NetWarningDisabledWhileIP3OpenInAutoMode )
 4733              		.loc 1 2224 0
 4734 09c8 524B     		ldr	r3, .L378+92
 4735 09ca 1B78     		ldrb	r3, [r3]
 4736 09cc 002B     		cmp	r3, #0
 4737 09ce 02D0     		beq	.L265
2226:functions.c   **** 					NetWarningOn = 0; // Check Net Error (AKA Net Warning) turned off
 4738              		.loc 1 2226 0
 4739 09d0 0022     		mov	r2, #0
 4740 09d2 4F4B     		ldr	r3, .L378+88
 4741 09d4 1A70     		strb	r2, [r3]
 4742              	.L265:
2235:functions.c   **** 			if( OP5TurnedOnAfterBeakEngagePulsesEnabled ) // Flag set from when Engage diameter reached (or 
 4743              		.loc 1 2235 0
 4744 09d6 504B     		ldr	r3, .L378+96
 4745 09d8 1C78     		ldrb	r4, [r3]
 4746 09da 002C     		cmp	r4, #0
 4747 09dc 15D0     		beq	.L269
2237:functions.c   **** 				if( !NetWarningOn ) // Disabled while Check Net Error (AKA Net Warning) active
 4748              		.loc 1 2237 0
 4749 09de 4C4B     		ldr	r3, .L378+88
 4750 09e0 1B78     		ldrb	r3, [r3]
 4751 09e2 002B     		cmp	r3, #0
 4752 09e4 15D1     		bne	.L270
2239:functions.c   **** 					if( pFac.pf.GW302_NetSystem == NS_BEAK ) // Only applies if 'Net System' set to 'Beak' (Double
 4753              		.loc 1 2239 0
 4754 09e6 C123     		mov	r3, #193
 4755 09e8 394A     		ldr	r2, .L378+24
 4756 09ea D35C     		ldrb	r3, [r2, r3]
 4757 09ec 002B     		cmp	r3, #0
 4758 09ee 1FD1     		bne	.L271
2241:functions.c   **** 						if( stagecomp == NETFEEDON ) // Only checks for 'Beak Engage' pulses after OP2 (Net On) has c
 4759              		.loc 1 2241 0
 4760 09f0 354B     		ldr	r3, .L378+16
 4761 09f2 1B78     		ldrb	r3, [r3]
 4762 09f4 012B     		cmp	r3, #1
 4763 09f6 1BD1     		bne	.L271
2243:functions.c   **** 							if( BeakEngagePulseCount >= (unsigned long int)pFac.pf.GW302_BeakEngage ) // 'Beak Engage' P
 4764              		.loc 1 2243 0
 4765 09f8 C223     		mov	r3, #194
 4766 09fa D25C     		ldrb	r2, [r2, r3]
 4767 09fc 474B     		ldr	r3, .L378+100
 4768 09fe 1B68     		ldr	r3, [r3]
 4769 0a00 9A42     		cmp	r2, r3
 4770 0a02 15D8     		bhi	.L271
2249:functions.c   **** 								RollEngageTurnedOn = 1; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
 4771              		.loc 1 2249 0
 4772 0a04 0122     		mov	r2, #1
 4773 0a06 464B     		ldr	r3, .L378+104
 4774 0a08 1A70     		strb	r2, [r3]
 4775              	.L269:
2262:functions.c   **** 			if( NetWarningOn ) // Check Net Error (AKA Net Warning) active (AUTO)
 4776              		.loc 1 2262 0
 4777 0a0a 414B     		ldr	r3, .L378+88
 4778 0a0c 1B78     		ldrb	r3, [r3]
 4779 0a0e 002B     		cmp	r3, #0
 4780 0a10 0ED0     		beq	.L271
 4781              	.L270:
2264:functions.c   **** 				SeqOpOn &= ~OP_ROLL_ENGAGE; // OP5 OFF: Roller Engage Solenoid (AKA Pre Net Position)
 4782              		.loc 1 2264 0
 4783 0a12 334B     		ldr	r3, .L378+40
 4784 0a14 434A     		ldr	r2, .L378+108
 4785 0a16 1868     		ldr	r0, [r3]
 4786 0a18 0240     		and	r2, r0
 4787 0a1a 1A60     		str	r2, [r3]
2265:functions.c   **** 				SeqOpOff |= OP_ROLL_ENGAGE;
 4788              		.loc 1 2265 0
 4789 0a1c 394B     		ldr	r3, .L378+76
 4790 0a1e 8022     		mov	r2, #128
 4791 0a20 5204     		lsl	r2, r2, #17
 4792 0a22 1968     		ldr	r1, [r3]
 4793 0a24 0A43     		orr	r2, r1
 4794 0a26 1A60     		str	r2, [r3]
2266:functions.c   **** 				RollerTimer = 0;
 4795              		.loc 1 2266 0
 4796 0a28 0022     		mov	r2, #0
 4797 0a2a 3F4B     		ldr	r3, .L378+112
 4798 0a2c 1A70     		strb	r2, [r3]
 4799 0a2e 06E0     		b	.L272
 4800              	.L271:
2268:functions.c   **** 			else if( RollEngageTurnedOn )
 4801              		.loc 1 2268 0
 4802 0a30 3B4B     		ldr	r3, .L378+104
 4803 0a32 1B78     		ldrb	r3, [r3]
 4804 0a34 002B     		cmp	r3, #0
 4805 0a36 02D0     		beq	.L272
2272:functions.c   **** 				RollerTimer = OP_ROLL_ENGAGE_TIMER; /*3 seconds*/
 4806              		.loc 1 2272 0
 4807 0a38 1E22     		mov	r2, #30
 4808 0a3a 3B4B     		ldr	r3, .L378+112
 4809 0a3c 1A70     		strb	r2, [r3]
 4810              	.L272:
2289:functions.c   **** 			if(  ( !NettingStartBeepsDisabledWhileIP3OpenInAutoMode )
 4811              		.loc 1 2289 0
 4812 0a3e 3B4B     		ldr	r3, .L378+116
 4813 0a40 1B78     		ldrb	r3, [r3]
 4814 0a42 002B     		cmp	r3, #0
 4815 0a44 17D1     		bne	.L273
2290:functions.c   **** 			  && ( BaleDiaVolts > DiaPreWarnVolts ) // Pre warning beep bale diameter exceeded
 4816              		.loc 1 2290 0
 4817 0a46 3A4B     		ldr	r3, .L378+120
 4818 0a48 1868     		ldr	r0, [r3]
 4819 0a4a 3A4B     		ldr	r3, .L378+124
 4820 0a4c 1968     		ldr	r1, [r3]
 4821 0a4e FFF7FEFF 		bl	__aeabi_fcmpgt
 4822              	.LVL261:
 4823 0a52 0028     		cmp	r0, #0
 4824 0a54 0FD0     		beq	.L273
2291:functions.c   **** 			  && ( pFac.pf.GW302_PreWarningBeep > 0 ) // Pre Warning beep on (set to non-zero value)
 4825              		.loc 1 2291 0
 4826 0a56 7423     		mov	r3, #116
 4827 0a58 1D4A     		ldr	r2, .L378+24
 4828 0a5a D35C     		ldrb	r3, [r2, r3]
 4829 0a5c 002B     		cmp	r3, #0
 4830 0a5e 0AD0     		beq	.L273
2292:functions.c   **** 			  && ( !pre_warning_cont_beep ) )
 4831              		.loc 1 2292 0
 4832 0a60 354B     		ldr	r3, .L378+128
 4833 0a62 1B78     		ldrb	r3, [r3]
 4834 0a64 002B     		cmp	r3, #0
 4835 0a66 06D1     		bne	.L273
2294:functions.c   **** 				buzz_length = PRE_WARNING_BEEP; // Pre Warning beep
 4836              		.loc 1 2294 0
 4837 0a68 FA22     		mov	r2, #250
 4838 0a6a 9200     		lsl	r2, r2, #2
 4839 0a6c 174B     		ldr	r3, .L378+20
 4840 0a6e 1A60     		str	r2, [r3]
2295:functions.c   **** 				pre_warning_cont_beep = 1;      // Only repeated after a sequence is completed
 4841              		.loc 1 2295 0
 4842 0a70 0122     		mov	r2, #1
 4843 0a72 314B     		ldr	r3, .L378+128
 4844 0a74 1A70     		strb	r2, [r3]
 4845              	.L273:
2304:functions.c   **** 					(Stage != STAGE_UNLOADING)      &&
 4846              		.loc 1 2304 0
 4847 0a76 184B     		ldr	r3, .L378+32
 4848 0a78 1B78     		ldrb	r3, [r3]
 4849 0a7a 0A3B     		sub	r3, r3, #10
2303:functions.c   **** 			if( (Stage != STAGE_NETTING_END)    &&    // Ignoring chamber opening between the start & end of
 4850              		.loc 1 2303 0
 4851 0a7c 1B06     		lsl	r3, r3, #24
 4852 0a7e 1B0E     		lsr	r3, r3, #24
 4853 0a80 022B     		cmp	r3, #2
 4854 0a82 00D8     		bhi	.LCB4410
 4855 0a84 08E3     		b	.L275	@long jump
 4856              	.LCB4410:
2307:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
 4857              		.loc 1 2307 0
 4858 0a86 0F4B     		ldr	r3, .L378+12
 4859 0a88 DB6B     		ldr	r3, [r3, #60]
 4860 0a8a 5A02     		lsl	r2, r3, #9
 4861 0a8c 0ED4     		bmi	.L276
2310:functions.c   **** 					if( ChamberOpenBeepDelay )
 4862              		.loc 1 2310 0
 4863 0a8e 2B4B     		ldr	r3, .L378+132
 4864 0a90 1B78     		ldrb	r3, [r3]
 4865 0a92 002B     		cmp	r3, #0
 4866 0a94 03D0     		beq	.L277
2312:functions.c   **** 						ChamberOpenBeepDelay--;
 4867              		.loc 1 2312 0
 4868 0a96 013B     		sub	r3, r3, #1
 4869 0a98 284A     		ldr	r2, .L378+132
 4870 0a9a 1370     		strb	r3, [r2]
 4871 0a9c 06E3     		b	.L278
 4872              	.L277:
2317:functions.c   **** 						buzz_length = AUTO_CHAMBER_OPEN_BEEP;
 4873              		.loc 1 2317 0
 4874 0a9e FA22     		mov	r2, #250
 4875 0aa0 0A4B     		ldr	r3, .L378+20
 4876 0aa2 1A60     		str	r2, [r3]
2318:functions.c   **** 						ChamberOpenBeepDelay = COBD_CHAMBER_OPEN_BEEP_DELAY;  // Reset chamber open beep delay to bee
 4877              		.loc 1 2318 0
 4878 0aa4 0A22     		mov	r2, #10
 4879 0aa6 254B     		ldr	r3, .L378+132
 4880 0aa8 1A70     		strb	r2, [r3]
 4881 0aaa FFE2     		b	.L278
 4882              	.L276:
2323:functions.c   **** 					ChamberOpenBeepDelay = COBD_CHAMBER_OPEN_BEEP_DELAY; // to ensure beeping starts after 1 s del
 4883              		.loc 1 2323 0
 4884 0aac 0A22     		mov	r2, #10
 4885 0aae 234B     		ldr	r3, .L378+132
 4886 0ab0 1A70     		strb	r2, [r3]
 4887 0ab2 FBE2     		b	.L278
 4888              	.L379:
 4889 0ab4 C046C046 		.align	3
 4890              	.L378:
 4891 0ab8 00000000 		.word	0
 4892 0abc 00002440 		.word	1076101120
 4893 0ac0 00000000 		.word	SequenceInProgress
 4894 0ac4 00F6FFFF 		.word	-2560
 4895 0ac8 00000000 		.word	stagecomp
 4896 0acc 00000000 		.word	buzz_length
 4897 0ad0 00000000 		.word	.LANCHOR0
 4898 0ad4 00000000 		.word	ChamberClosedDelayTime
 4899 0ad8 00000000 		.word	Stage
 4900 0adc 00000000 		.word	BaleKickerStatus
 4901 0ae0 00000000 		.word	SeqOpOn
 4902 0ae4 00000000 		.word	NetPulseCount
 4903 0ae8 00000000 		.word	NetPulseCheckingEnabled
 4904 0aec 00000000 		.word	.LANCHOR15
 4905 0af0 00000000 		.word	NetWarningDelayTime
 4906 0af4 00000000 		.word	DensityControlFunctionActive
 4907 0af8 00000000 		.word	DensityPresVolts
 4908 0afc 00000000 		.word	DensityBaleVolts
 4909 0b00 00000000 		.word	OP8OnDelayTime
 4910 0b04 00000000 		.word	SeqOpOff
 4911 0b08 FF7FFFFF 		.word	-32769
 4912 0b0c 00000000 		.word	OP8OffDelayTime
 4913 0b10 00000000 		.word	NetWarningOn
 4914 0b14 00000000 		.word	NetWarningDisabledWhileIP3OpenInAutoMode
 4915 0b18 00000000 		.word	OP5TurnedOnAfterBeakEngagePulsesEnabled
 4916 0b1c 00000000 		.word	BeakEngagePulseCount
 4917 0b20 00000000 		.word	RollEngageTurnedOn
 4918 0b24 FFFFFFFE 		.word	-16777217
 4919 0b28 00000000 		.word	.LANCHOR16
 4920 0b2c 00000000 		.word	NettingStartBeepsDisabledWhileIP3OpenInAutoMode
 4921 0b30 00000000 		.word	BaleDiaVolts
 4922 0b34 00000000 		.word	DiaPreWarnVolts
 4923 0b38 00000000 		.word	pre_warning_cont_beep
 4924 0b3c 00000000 		.word	ChamberOpenBeepDelay
 4925              	.L330:
2338:functions.c   **** 					if( !SavedRollEngageTurnedOn )
 4926              		.loc 1 2338 0
 4927 0b40 C54B     		ldr	r3, .L380+8
 4928 0b42 1B78     		ldrb	r3, [r3]
 4929 0b44 002B     		cmp	r3, #0
 4930 0b46 03D1     		bne	.L279
2340:functions.c   **** 						SavedRollEngageTurnedOn = RollEngageTurnedOn;
 4931              		.loc 1 2340 0
 4932 0b48 C44B     		ldr	r3, .L380+12
 4933 0b4a 1A78     		ldrb	r2, [r3]
 4934 0b4c C24B     		ldr	r3, .L380+8
 4935 0b4e 1A70     		strb	r2, [r3]
 4936              	.L279:
2342:functions.c   **** 					if( !SavedOP5TurnedOnAfterBeakEngagePulsesEnabled )
 4937              		.loc 1 2342 0
 4938 0b50 C34B     		ldr	r3, .L380+16
 4939 0b52 1B78     		ldrb	r3, [r3]
 4940 0b54 002B     		cmp	r3, #0
 4941 0b56 01D1     		bne	.L280
2344:functions.c   **** 						SavedOP5TurnedOnAfterBeakEngagePulsesEnabled = OP5TurnedOnAfterBeakEngagePulsesEnabled;
 4942              		.loc 1 2344 0
 4943 0b58 C14B     		ldr	r3, .L380+16
 4944 0b5a 1C70     		strb	r4, [r3]
 4945              	.L280:
2348:functions.c   **** 					RollEngageTurnedOn = 0;                      // OP5 Roller Engage Solenoid (AKA Pre Net Positi
 4946              		.loc 1 2348 0
 4947 0b5c 0023     		mov	r3, #0
 4948 0b5e BF4A     		ldr	r2, .L380+12
 4949 0b60 1370     		strb	r3, [r2]
2349:functions.c   **** 					OP5TurnedOnAfterBeakEngagePulsesEnabled = 0; // Turning on Roller Engage Solenoid (OP5) after 
 4950              		.loc 1 2349 0
 4951 0b62 C04A     		ldr	r2, .L380+20
 4952 0b64 1370     		strb	r3, [r2]
2351:functions.c   **** 					SeqOpOff |= OP_ROLL_ENGAGE;
 4953              		.loc 1 2351 0
 4954 0b66 C04B     		ldr	r3, .L380+24
2354:functions.c   **** 					SeqOpOn &= ~OP_NET_ON; // OP2 OFF: Net Clutch (AKA Net On)
 4955              		.loc 1 2354 0
 4956 0b68 C04A     		ldr	r2, .L380+28
 4957 0b6a C149     		ldr	r1, .L380+32
 4958 0b6c 1068     		ldr	r0, [r2]
 4959 0b6e 0140     		and	r1, r0
 4960 0b70 1160     		str	r1, [r2]
2355:functions.c   **** 					SeqOpOff |= OP_NET_ON;
 4961              		.loc 1 2355 0
 4962 0b72 9022     		mov	r2, #144
 4963 0b74 5204     		lsl	r2, r2, #17
 4964 0b76 1968     		ldr	r1, [r3]
 4965 0b78 0A43     		orr	r2, r1
 4966 0b7a 1A60     		str	r2, [r3]
 4967 0b7c 11E0     		b	.L281
 4968              	.L373:
2360:functions.c   **** 					if( SavedRollEngageTurnedOn )
 4969              		.loc 1 2360 0
 4970 0b7e B64B     		ldr	r3, .L380+8
 4971 0b80 1B78     		ldrb	r3, [r3]
 4972 0b82 002B     		cmp	r3, #0
 4973 0b84 04D0     		beq	.L282
2362:functions.c   **** 						RollEngageTurnedOn = SavedRollEngageTurnedOn;
 4974              		.loc 1 2362 0
 4975 0b86 B54A     		ldr	r2, .L380+12
 4976 0b88 1370     		strb	r3, [r2]
2363:functions.c   **** 						SavedRollEngageTurnedOn = 0; // Reset
 4977              		.loc 1 2363 0
 4978 0b8a 0022     		mov	r2, #0
 4979 0b8c B24B     		ldr	r3, .L380+8
 4980 0b8e 1A70     		strb	r2, [r3]
 4981              	.L282:
2365:functions.c   **** 					if( SavedOP5TurnedOnAfterBeakEngagePulsesEnabled )
 4982              		.loc 1 2365 0
 4983 0b90 B34B     		ldr	r3, .L380+16
 4984 0b92 1B78     		ldrb	r3, [r3]
 4985 0b94 002B     		cmp	r3, #0
 4986 0b96 04D0     		beq	.L281
2367:functions.c   **** 						OP5TurnedOnAfterBeakEngagePulsesEnabled = SavedOP5TurnedOnAfterBeakEngagePulsesEnabled;
 4987              		.loc 1 2367 0
 4988 0b98 B24A     		ldr	r2, .L380+20
 4989 0b9a 1370     		strb	r3, [r2]
2368:functions.c   **** 						SavedOP5TurnedOnAfterBeakEngagePulsesEnabled = 0; // Reset
 4990              		.loc 1 2368 0
 4991 0b9c 0022     		mov	r2, #0
 4992 0b9e B04B     		ldr	r3, .L380+16
 4993 0ba0 1A70     		strb	r2, [r3]
 4994              	.L281:
2386:functions.c   **** 					(Stage != STAGE_UNLOADING)      &&
 4995              		.loc 1 2386 0
 4996 0ba2 B44B     		ldr	r3, .L380+36
 4997 0ba4 1B78     		ldrb	r3, [r3]
 4998 0ba6 0A3B     		sub	r3, r3, #10
2385:functions.c   **** 			if( (Stage != STAGE_NETTING_END)    &&    // Ignoring chamber opening between the start & end of
 4999              		.loc 1 2385 0
 5000 0ba8 1B06     		lsl	r3, r3, #24
 5001 0baa 1B0E     		lsr	r3, r3, #24
 5002 0bac 022B     		cmp	r3, #2
 5003 0bae 0FD9     		bls	.L283
2389:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
 5004              		.loc 1 2389 0
 5005 0bb0 B14B     		ldr	r3, .L380+40
 5006 0bb2 DB6B     		ldr	r3, [r3, #60]
 5007 0bb4 5A02     		lsl	r2, r3, #9
 5008 0bb6 05D4     		bmi	.L284
2391:functions.c   **** 					NetWarningDisabledWhileIP3OpenInAutoMode = 1;
 5009              		.loc 1 2391 0
 5010 0bb8 0123     		mov	r3, #1
 5011 0bba B04A     		ldr	r2, .L380+44
 5012 0bbc 1370     		strb	r3, [r2]
2392:functions.c   **** 					NettingStartBeepsDisabledWhileIP3OpenInAutoMode = 1; // Including Pre Warning & Net Delay beep
 5013              		.loc 1 2392 0
 5014 0bbe B04A     		ldr	r2, .L380+48
 5015 0bc0 1370     		strb	r3, [r2]
 5016 0bc2 CBE1     		b	.L285
 5017              	.L284:
2396:functions.c   **** 					NetWarningDisabledWhileIP3OpenInAutoMode = 0; // Reset
 5018              		.loc 1 2396 0
 5019 0bc4 0023     		mov	r3, #0
 5020 0bc6 AD4A     		ldr	r2, .L380+44
 5021 0bc8 1370     		strb	r3, [r2]
2397:functions.c   **** 					NettingStartBeepsDisabledWhileIP3OpenInAutoMode = 0; // Reset
 5022              		.loc 1 2397 0
 5023 0bca AD4A     		ldr	r2, .L380+48
 5024 0bcc 1370     		strb	r3, [r2]
 5025 0bce C5E1     		b	.L285
 5026              	.L283:
2402:functions.c   **** 				NetWarningDisabledWhileIP3OpenInAutoMode = 0; // Reset
 5027              		.loc 1 2402 0
 5028 0bd0 0023     		mov	r3, #0
 5029 0bd2 AA4A     		ldr	r2, .L380+44
 5030 0bd4 1370     		strb	r3, [r2]
2403:functions.c   **** 				NettingStartBeepsDisabledWhileIP3OpenInAutoMode = 0; // Reset
 5031              		.loc 1 2403 0
 5032 0bd6 AA4A     		ldr	r2, .L380+48
 5033 0bd8 1370     		strb	r3, [r2]
 5034 0bda BFE1     		b	.L285
 5035              	.L182:
2412:functions.c   **** 			if( BaleDiaVolts > DiaCoreVolts )  // Core diameter exceeded
 5036              		.loc 1 2412 0
 5037 0bdc A94B     		ldr	r3, .L380+52
 5038 0bde 1C68     		ldr	r4, [r3]
 5039 0be0 201C     		add	r0, r4, #0
 5040 0be2 A94B     		ldr	r3, .L380+56
 5041 0be4 1968     		ldr	r1, [r3]
 5042 0be6 FFF7FEFF 		bl	__aeabi_fcmpgt
 5043              	.LVL262:
 5044 0bea 0028     		cmp	r0, #0
 5045 0bec 57D0     		beq	.L367
2417:functions.c   **** 				if( DensityPresVolts >= DensityBaleVolts ) // Target bale density reached/exceeded
 5046              		.loc 1 2417 0
 5047 0bee A74B     		ldr	r3, .L380+60
 5048 0bf0 1D68     		ldr	r5, [r3]
 5049 0bf2 A74B     		ldr	r3, .L380+64
 5050 0bf4 1E68     		ldr	r6, [r3]
 5051 0bf6 281C     		add	r0, r5, #0
 5052 0bf8 311C     		add	r1, r6, #0
 5053 0bfa FFF7FEFF 		bl	__aeabi_fcmpge
 5054              	.LVL263:
 5055 0bfe 0028     		cmp	r0, #0
 5056 0c00 20D0     		beq	.L368
2419:functions.c   **** 					if( OP8OnDelayTime )
 5057              		.loc 1 2419 0
 5058 0c02 A44B     		ldr	r3, .L380+68
 5059 0c04 1B78     		ldrb	r3, [r3]
 5060 0c06 002B     		cmp	r3, #0
 5061 0c08 03D0     		beq	.L290
2420:functions.c   **** 						OP8OnDelayTime--;
 5062              		.loc 1 2420 0
 5063 0c0a 013B     		sub	r3, r3, #1
 5064 0c0c A14A     		ldr	r2, .L380+68
 5065 0c0e 1370     		strb	r3, [r2]
 5066 0c10 9CE0     		b	.L291
 5067              	.L290:
2423:functions.c   **** 						SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
 5068              		.loc 1 2423 0
 5069 0c12 964B     		ldr	r3, .L380+28
 5070 0c14 8022     		mov	r2, #128
 5071 0c16 1202     		lsl	r2, r2, #8
 5072 0c18 1868     		ldr	r0, [r3]
 5073 0c1a 0243     		orr	r2, r0
 5074 0c1c 1A60     		str	r2, [r3]
2424:functions.c   **** 						SeqOpOff &= ~OP_DENSITY_REL;
 5075              		.loc 1 2424 0
 5076 0c1e 924B     		ldr	r3, .L380+24
 5077 0c20 9D4A     		ldr	r2, .L380+72
 5078 0c22 1968     		ldr	r1, [r3]
 5079 0c24 0A40     		and	r2, r1
 5080 0c26 1A60     		str	r2, [r3]
2425:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 5081              		.loc 1 2425 0
 5082 0c28 8823     		mov	r3, #136
 5083 0c2a 9C4A     		ldr	r2, .L380+76
 5084 0c2c D058     		ldr	r0, [r2, r3]
 5085 0c2e FFF7FEFF 		bl	__aeabi_f2d
 5086              	.LVL264:
 5087 0c32 884B     		ldr	r3, .L380+4
 5088 0c34 864A     		ldr	r2, .L380
 5089 0c36 FFF7FEFF 		bl	__aeabi_dmul
 5090              	.LVL265:
 5091 0c3a FFF7FEFF 		bl	__aeabi_d2uiz
 5092              	.LVL266:
 5093 0c3e 984B     		ldr	r3, .L380+80
 5094 0c40 1870     		strb	r0, [r3]
 5095 0c42 83E0     		b	.L291
 5096              	.L368:
2428:functions.c   **** 				else if( DensityPresVolts < (DensityBaleVolts - pFac.pf.GW302_PresDeadband) ) // Fallen below d
 5097              		.loc 1 2428 0
 5098 0c44 301C     		add	r0, r6, #0
 5099 0c46 8023     		mov	r3, #128
 5100 0c48 944A     		ldr	r2, .L380+76
 5101 0c4a D158     		ldr	r1, [r2, r3]
 5102 0c4c FFF7FEFF 		bl	__aeabi_fsub
 5103              	.LVL267:
 5104 0c50 011C     		add	r1, r0, #0
 5105 0c52 281C     		add	r0, r5, #0
 5106 0c54 FFF7FEFF 		bl	__aeabi_fcmplt
 5107              	.LVL268:
 5108 0c58 0028     		cmp	r0, #0
 5109 0c5a 77D0     		beq	.L291
2430:functions.c   **** 					if( OP8OffDelayTime )
 5110              		.loc 1 2430 0
 5111 0c5c 904B     		ldr	r3, .L380+80
 5112 0c5e 1B78     		ldrb	r3, [r3]
 5113 0c60 002B     		cmp	r3, #0
 5114 0c62 03D0     		beq	.L293
2431:functions.c   **** 						OP8OffDelayTime--;
 5115              		.loc 1 2431 0
 5116 0c64 013B     		sub	r3, r3, #1
 5117 0c66 8E4A     		ldr	r2, .L380+80
 5118 0c68 1370     		strb	r3, [r2]
 5119 0c6a 6FE0     		b	.L291
 5120              	.L293:
2434:functions.c   **** 						SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
 5121              		.loc 1 2434 0
 5122 0c6c 7F4B     		ldr	r3, .L380+28
 5123 0c6e 8A4A     		ldr	r2, .L380+72
 5124 0c70 1868     		ldr	r0, [r3]
 5125 0c72 0240     		and	r2, r0
 5126 0c74 1A60     		str	r2, [r3]
2435:functions.c   **** 						SeqOpOff |= OP_DENSITY_REL;
 5127              		.loc 1 2435 0
 5128 0c76 7C4B     		ldr	r3, .L380+24
 5129 0c78 8022     		mov	r2, #128
 5130 0c7a 1202     		lsl	r2, r2, #8
 5131 0c7c 1968     		ldr	r1, [r3]
 5132 0c7e 0A43     		orr	r2, r1
 5133 0c80 1A60     		str	r2, [r3]
2436:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 5134              		.loc 1 2436 0
 5135 0c82 8823     		mov	r3, #136
 5136 0c84 854A     		ldr	r2, .L380+76
 5137 0c86 D058     		ldr	r0, [r2, r3]
 5138 0c88 FFF7FEFF 		bl	__aeabi_f2d
 5139              	.LVL269:
 5140 0c8c 714B     		ldr	r3, .L380+4
 5141 0c8e 704A     		ldr	r2, .L380
 5142 0c90 FFF7FEFF 		bl	__aeabi_dmul
 5143              	.LVL270:
 5144 0c94 FFF7FEFF 		bl	__aeabi_d2uiz
 5145              	.LVL271:
 5146 0c98 7E4B     		ldr	r3, .L380+68
 5147 0c9a 1870     		strb	r0, [r3]
 5148 0c9c 56E0     		b	.L291
 5149              	.L367:
2445:functions.c   **** 				if( DensityPresVolts >= DensityCoreVolts ) // Target core density reached/exceeded
 5150              		.loc 1 2445 0
 5151 0c9e 7B4B     		ldr	r3, .L380+60
 5152 0ca0 1D68     		ldr	r5, [r3]
 5153 0ca2 804B     		ldr	r3, .L380+84
 5154 0ca4 1E68     		ldr	r6, [r3]
 5155 0ca6 281C     		add	r0, r5, #0
 5156 0ca8 311C     		add	r1, r6, #0
 5157 0caa FFF7FEFF 		bl	__aeabi_fcmpge
 5158              	.LVL272:
 5159 0cae 0028     		cmp	r0, #0
 5160 0cb0 20D0     		beq	.L369
2447:functions.c   **** 					if( OP8OnDelayTime )
 5161              		.loc 1 2447 0
 5162 0cb2 784B     		ldr	r3, .L380+68
 5163 0cb4 1B78     		ldrb	r3, [r3]
 5164 0cb6 002B     		cmp	r3, #0
 5165 0cb8 03D0     		beq	.L296
2448:functions.c   **** 						OP8OnDelayTime--;
 5166              		.loc 1 2448 0
 5167 0cba 013B     		sub	r3, r3, #1
 5168 0cbc 754A     		ldr	r2, .L380+68
 5169 0cbe 1370     		strb	r3, [r2]
 5170 0cc0 44E0     		b	.L291
 5171              	.L296:
2451:functions.c   **** 						SeqOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
 5172              		.loc 1 2451 0
 5173 0cc2 6A4B     		ldr	r3, .L380+28
 5174 0cc4 8022     		mov	r2, #128
 5175 0cc6 1202     		lsl	r2, r2, #8
 5176 0cc8 1868     		ldr	r0, [r3]
 5177 0cca 0243     		orr	r2, r0
 5178 0ccc 1A60     		str	r2, [r3]
2452:functions.c   **** 						SeqOpOff &= ~OP_DENSITY_REL;
 5179              		.loc 1 2452 0
 5180 0cce 664B     		ldr	r3, .L380+24
 5181 0cd0 714A     		ldr	r2, .L380+72
 5182 0cd2 1968     		ldr	r1, [r3]
 5183 0cd4 0A40     		and	r2, r1
 5184 0cd6 1A60     		str	r2, [r3]
2453:functions.c   **** 						OP8OffDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 5185              		.loc 1 2453 0
 5186 0cd8 8823     		mov	r3, #136
 5187 0cda 704A     		ldr	r2, .L380+76
 5188 0cdc D058     		ldr	r0, [r2, r3]
 5189 0cde FFF7FEFF 		bl	__aeabi_f2d
 5190              	.LVL273:
 5191 0ce2 5C4B     		ldr	r3, .L380+4
 5192 0ce4 5A4A     		ldr	r2, .L380
 5193 0ce6 FFF7FEFF 		bl	__aeabi_dmul
 5194              	.LVL274:
 5195 0cea FFF7FEFF 		bl	__aeabi_d2uiz
 5196              	.LVL275:
 5197 0cee 6C4B     		ldr	r3, .L380+80
 5198 0cf0 1870     		strb	r0, [r3]
 5199 0cf2 2BE0     		b	.L291
 5200              	.L369:
2456:functions.c   **** 				else if( DensityPresVolts < (DensityCoreVolts - pFac.pf.GW302_PresDeadband) ) // Fallen below d
 5201              		.loc 1 2456 0
 5202 0cf4 301C     		add	r0, r6, #0
 5203 0cf6 8023     		mov	r3, #128
 5204 0cf8 684A     		ldr	r2, .L380+76
 5205 0cfa D158     		ldr	r1, [r2, r3]
 5206 0cfc FFF7FEFF 		bl	__aeabi_fsub
 5207              	.LVL276:
 5208 0d00 011C     		add	r1, r0, #0
 5209 0d02 281C     		add	r0, r5, #0
 5210 0d04 FFF7FEFF 		bl	__aeabi_fcmplt
 5211              	.LVL277:
 5212 0d08 0028     		cmp	r0, #0
 5213 0d0a 1FD0     		beq	.L291
2458:functions.c   **** 					if( OP8OffDelayTime )
 5214              		.loc 1 2458 0
 5215 0d0c 644B     		ldr	r3, .L380+80
 5216 0d0e 1B78     		ldrb	r3, [r3]
 5217 0d10 002B     		cmp	r3, #0
 5218 0d12 03D0     		beq	.L298
2459:functions.c   **** 						OP8OffDelayTime--;
 5219              		.loc 1 2459 0
 5220 0d14 013B     		sub	r3, r3, #1
 5221 0d16 624A     		ldr	r2, .L380+80
 5222 0d18 1370     		strb	r3, [r2]
 5223 0d1a 17E0     		b	.L291
 5224              	.L298:
2462:functions.c   **** 						SeqOpOn &= ~OP_DENSITY_REL; // OP8 OFF: Density Release Solenoid (AKA Density Control)
 5225              		.loc 1 2462 0
 5226 0d1c 534B     		ldr	r3, .L380+28
 5227 0d1e 5E4A     		ldr	r2, .L380+72
 5228 0d20 1868     		ldr	r0, [r3]
 5229 0d22 0240     		and	r2, r0
 5230 0d24 1A60     		str	r2, [r3]
2463:functions.c   **** 						SeqOpOff |= OP_DENSITY_REL;
 5231              		.loc 1 2463 0
 5232 0d26 504B     		ldr	r3, .L380+24
 5233 0d28 8022     		mov	r2, #128
 5234 0d2a 1202     		lsl	r2, r2, #8
 5235 0d2c 1968     		ldr	r1, [r3]
 5236 0d2e 0A43     		orr	r2, r1
 5237 0d30 1A60     		str	r2, [r3]
2464:functions.c   **** 						OP8OnDelayTime = (unsigned char)(pFac.pf.GW302_PresSwDelay * 10.0);
 5238              		.loc 1 2464 0
 5239 0d32 8823     		mov	r3, #136
 5240 0d34 594A     		ldr	r2, .L380+76
 5241 0d36 D058     		ldr	r0, [r2, r3]
 5242 0d38 FFF7FEFF 		bl	__aeabi_f2d
 5243              	.LVL278:
 5244 0d3c 454B     		ldr	r3, .L380+4
 5245 0d3e 444A     		ldr	r2, .L380
 5246 0d40 FFF7FEFF 		bl	__aeabi_dmul
 5247              	.LVL279:
 5248 0d44 FFF7FEFF 		bl	__aeabi_d2uiz
 5249              	.LVL280:
 5250 0d48 524B     		ldr	r3, .L380+68
 5251 0d4a 1870     		strb	r0, [r3]
 5252              	.L291:
2473:functions.c   **** 			if( BaleDiaVolts > DiaTargetVolts )  // Target bale diameter exceeded
 5253              		.loc 1 2473 0
 5254 0d4c 201C     		add	r0, r4, #0
 5255 0d4e 564B     		ldr	r3, .L380+88
 5256 0d50 1968     		ldr	r1, [r3]
 5257 0d52 FFF7FEFF 		bl	__aeabi_fcmpgt
 5258              	.LVL281:
 5259 0d56 0028     		cmp	r0, #0
 5260 0d58 18D0     		beq	.L370
2475:functions.c   **** 				if( BalerFullDelayTime )
 5261              		.loc 1 2475 0
 5262 0d5a 544B     		ldr	r3, .L380+92
 5263 0d5c 1B78     		ldrb	r3, [r3]
 5264 0d5e 002B     		cmp	r3, #0
 5265 0d60 09D0     		beq	.L301
2477:functions.c   **** 					BalerFullDelayTime--;
 5266              		.loc 1 2477 0
 5267 0d62 013B     		sub	r3, r3, #1
 5268 0d64 514A     		ldr	r2, .L380+92
 5269 0d66 1370     		strb	r3, [r2]
2480:functions.c   **** 					buzz_count = 1;
 5270              		.loc 1 2480 0
 5271 0d68 0122     		mov	r2, #1
 5272 0d6a 514B     		ldr	r3, .L380+96
 5273 0d6c 1A70     		strb	r2, [r3]
2483:functions.c   **** 					target_bale_dia_reached_cont_beep = 0;
 5274              		.loc 1 2483 0
 5275 0d6e 0022     		mov	r2, #0
 5276 0d70 504B     		ldr	r3, .L380+100
 5277 0d72 1A70     		strb	r2, [r3]
 5278 0d74 30E0     		b	.L302
 5279              	.L301:
2488:functions.c   **** 					if( !target_bale_dia_reached_cont_beep )
 5280              		.loc 1 2488 0
 5281 0d76 4F4B     		ldr	r3, .L380+100
 5282 0d78 1B78     		ldrb	r3, [r3]
 5283 0d7a 002B     		cmp	r3, #0
 5284 0d7c 2CD1     		bne	.L302
2490:functions.c   **** 						buzz_length = NETTING_START_BEEP; // Long continuous beep when netting can be started in MAN 
 5285              		.loc 1 2490 0
 5286 0d7e 4E4A     		ldr	r2, .L380+104
 5287 0d80 4E4B     		ldr	r3, .L380+108
 5288 0d82 1A60     		str	r2, [r3]
2491:functions.c   **** 						target_bale_dia_reached_cont_beep = 1;
 5289              		.loc 1 2491 0
 5290 0d84 0122     		mov	r2, #1
 5291 0d86 4B4B     		ldr	r3, .L380+100
 5292 0d88 1A70     		strb	r2, [r3]
 5293 0d8a 25E0     		b	.L302
 5294              	.L370:
2497:functions.c   **** 				if( BaleDiaVolts > DiaPreWarnVolts ) // Pre warning beep bale diameter exceeded
 5295              		.loc 1 2497 0
 5296 0d8c 201C     		add	r0, r4, #0
 5297 0d8e 4C4B     		ldr	r3, .L380+112
 5298 0d90 1968     		ldr	r1, [r3]
 5299 0d92 FFF7FEFF 		bl	__aeabi_fcmpgt
 5300              	.LVL282:
 5301 0d96 0028     		cmp	r0, #0
 5302 0d98 0FD0     		beq	.L303
2499:functions.c   **** 					if( pFac.pf.GW302_PreWarningBeep > 0 ) // Pre Warning beep on (set to non-zero value)
 5303              		.loc 1 2499 0
 5304 0d9a 7423     		mov	r3, #116
 5305 0d9c 3F4A     		ldr	r2, .L380+76
 5306 0d9e D35C     		ldrb	r3, [r2, r3]
 5307 0da0 002B     		cmp	r3, #0
 5308 0da2 0AD0     		beq	.L303
2501:functions.c   **** 						if( !pre_warning_cont_beep )
 5309              		.loc 1 2501 0
 5310 0da4 474B     		ldr	r3, .L380+116
 5311 0da6 1B78     		ldrb	r3, [r3]
 5312 0da8 002B     		cmp	r3, #0
 5313 0daa 06D1     		bne	.L303
2503:functions.c   **** 							buzz_length = PRE_WARNING_BEEP; // Pre Warning beep
 5314              		.loc 1 2503 0
 5315 0dac FA22     		mov	r2, #250
 5316 0dae 9200     		lsl	r2, r2, #2
 5317 0db0 424B     		ldr	r3, .L380+108
 5318 0db2 1A60     		str	r2, [r3]
2504:functions.c   **** 							pre_warning_cont_beep = 1;      // Only repeated after a sequence is completed
 5319              		.loc 1 2504 0
 5320 0db4 0122     		mov	r2, #1
 5321 0db6 434B     		ldr	r3, .L380+116
 5322 0db8 1A70     		strb	r2, [r3]
 5323              	.L303:
2510:functions.c   **** 				BalerFullDelayTime = (unsigned char)(pFac.pf.GW302_NetDelay * 10.0);
 5324              		.loc 1 2510 0
 5325 0dba 384B     		ldr	r3, .L380+76
 5326 0dbc 986F     		ldr	r0, [r3, #120]
 5327 0dbe FFF7FEFF 		bl	__aeabi_f2d
 5328              	.LVL283:
 5329 0dc2 244B     		ldr	r3, .L380+4
 5330 0dc4 224A     		ldr	r2, .L380
 5331 0dc6 FFF7FEFF 		bl	__aeabi_dmul
 5332              	.LVL284:
 5333 0dca FFF7FEFF 		bl	__aeabi_d2uiz
 5334              	.LVL285:
 5335 0dce 374B     		ldr	r3, .L380+92
 5336 0dd0 1870     		strb	r0, [r3]
2511:functions.c   **** 				target_bale_dia_reached_cont_beep = 0;
 5337              		.loc 1 2511 0
 5338 0dd2 0022     		mov	r2, #0
 5339 0dd4 374B     		ldr	r3, .L380+100
 5340 0dd6 1A70     		strb	r2, [r3]
 5341              	.L302:
2519:functions.c   **** 			if( stagecomp == (NETFEEDON | NETCUTON) )
 5342              		.loc 1 2519 0
 5343 0dd8 3B4B     		ldr	r3, .L380+120
 5344 0dda 1B78     		ldrb	r3, [r3]
 5345 0ddc 032B     		cmp	r3, #3
 5346 0dde 2CD1     		bne	.L305
2521:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
 5347              		.loc 1 2521 0
 5348 0de0 254B     		ldr	r3, .L380+40
 5349 0de2 DB6B     		ldr	r3, [r3, #60]
 5350 0de4 5A02     		lsl	r2, r3, #9
 5351 0de6 1ED4     		bmi	.L306
2523:functions.c   **** 					if( ChamberOpenDelayTime )
 5352              		.loc 1 2523 0
 5353 0de8 384B     		ldr	r3, .L380+124
 5354 0dea 1B78     		ldrb	r3, [r3]
 5355 0dec 002B     		cmp	r3, #0
 5356 0dee 0DD0     		beq	.L307
2525:functions.c   **** 						ChamberOpenDelayTime--;
 5357              		.loc 1 2525 0
 5358 0df0 013B     		sub	r3, r3, #1
 5359 0df2 364A     		ldr	r2, .L380+124
 5360 0df4 1370     		strb	r3, [r2]
2527:functions.c   **** 						if( !start_chamber_open_delay_cont_beep )
 5361              		.loc 1 2527 0
 5362 0df6 364B     		ldr	r3, .L380+128
 5363 0df8 1B78     		ldrb	r3, [r3]
 5364 0dfa 002B     		cmp	r3, #0
 5365 0dfc 13D1     		bne	.L306
2529:functions.c   **** 							buzz_length = MAN_START_END_CHAMBER_OPEN_DELAY_BEEP; // Beep at start of chamber open delay
 5366              		.loc 1 2529 0
 5367 0dfe FA22     		mov	r2, #250
 5368 0e00 2E4B     		ldr	r3, .L380+108
 5369 0e02 1A60     		str	r2, [r3]
2530:functions.c   **** 							start_chamber_open_delay_cont_beep = 1;
 5370              		.loc 1 2530 0
 5371 0e04 0122     		mov	r2, #1
 5372 0e06 324B     		ldr	r3, .L380+128
 5373 0e08 1A70     		strb	r2, [r3]
 5374 0e0a 0CE0     		b	.L306
 5375              	.L307:
2535:functions.c   **** 						stagecomp |= CHAMBOP;     // Set CHAMBER OPEN stage completed
 5376              		.loc 1 2535 0
 5377 0e0c 0722     		mov	r2, #7
 5378 0e0e 2E4B     		ldr	r3, .L380+120
 5379 0e10 1A70     		strb	r2, [r3]
2538:functions.c   **** 						if( !end_chamber_open_delay_cont_beep )
 5380              		.loc 1 2538 0
 5381 0e12 304B     		ldr	r3, .L380+132
 5382 0e14 1B78     		ldrb	r3, [r3]
 5383 0e16 002B     		cmp	r3, #0
 5384 0e18 05D1     		bne	.L306
2540:functions.c   **** 							buzz_length = MAN_START_END_CHAMBER_OPEN_DELAY_BEEP; // Beep at end of chamber open delay
 5385              		.loc 1 2540 0
 5386 0e1a FA22     		mov	r2, #250
 5387 0e1c 274B     		ldr	r3, .L380+108
 5388 0e1e 1A60     		str	r2, [r3]
2541:functions.c   **** 							end_chamber_open_delay_cont_beep = 1;
 5389              		.loc 1 2541 0
 5390 0e20 0122     		mov	r2, #1
 5391 0e22 2C4B     		ldr	r3, .L380+132
 5392 0e24 1A70     		strb	r2, [r3]
 5393              	.L306:
2546:functions.c   **** 				if( CHAMBER_CLOSED) // Chamber Locked Sensor closed
 5394              		.loc 1 2546 0
 5395 0e26 144B     		ldr	r3, .L380+40
 5396 0e28 DB6B     		ldr	r3, [r3, #60]
 5397 0e2a 5802     		lsl	r0, r3, #9
 5398 0e2c 05D5     		bpl	.L305
2548:functions.c   **** 					ChamberOpenDelayTime = CODT_CHAMBER_OPEN_TIME;  // Reset Chamber open delay
 5399              		.loc 1 2548 0
 5400 0e2e 1422     		mov	r2, #20
 5401 0e30 264B     		ldr	r3, .L380+124
 5402 0e32 1A70     		strb	r2, [r3]
2549:functions.c   **** 					start_chamber_open_delay_cont_beep = 0;
 5403              		.loc 1 2549 0
 5404 0e34 0022     		mov	r2, #0
 5405 0e36 264B     		ldr	r3, .L380+128
 5406 0e38 1A70     		strb	r2, [r3]
 5407              	.L305:
2554:functions.c   **** 			if( stagecomp == (NETFEEDON | NETCUTON | CHAMBOP) )
 5408              		.loc 1 2554 0
 5409 0e3a 234B     		ldr	r3, .L380+120
 5410 0e3c 1B78     		ldrb	r3, [r3]
 5411 0e3e 072B     		cmp	r3, #7
 5412 0e40 4AD1     		bne	.L308
2556:functions.c   **** 				if( CHAMBER_CLOSED) // Chamber Locked Sensor closed
 5413              		.loc 1 2556 0
 5414 0e42 0D4B     		ldr	r3, .L380+40
 5415 0e44 DB6B     		ldr	r3, [r3, #60]
 5416 0e46 5902     		lsl	r1, r3, #9
 5417 0e48 48D4     		bmi	.L309
 5418 0e4a 53E0     		b	.L310
 5419              	.L381:
 5420 0e4c C046C046 		.align	3
 5421              	.L380:
 5422 0e50 00000000 		.word	0
 5423 0e54 00002440 		.word	1076101120
 5424 0e58 00000000 		.word	SavedRollEngageTurnedOn
 5425 0e5c 00000000 		.word	RollEngageTurnedOn
 5426 0e60 00000000 		.word	SavedOP5TurnedOnAfterBeakEngagePulsesEnabled
 5427 0e64 00000000 		.word	OP5TurnedOnAfterBeakEngagePulsesEnabled
 5428 0e68 00000000 		.word	SeqOpOff
 5429 0e6c 00000000 		.word	SeqOpOn
 5430 0e70 FFFFDFFE 		.word	-18874369
 5431 0e74 00000000 		.word	Stage
 5432 0e78 00F6FFFF 		.word	-2560
 5433 0e7c 00000000 		.word	NetWarningDisabledWhileIP3OpenInAutoMode
 5434 0e80 00000000 		.word	NettingStartBeepsDisabledWhileIP3OpenInAutoMode
 5435 0e84 00000000 		.word	BaleDiaVolts
 5436 0e88 00000000 		.word	DiaCoreVolts
 5437 0e8c 00000000 		.word	DensityPresVolts
 5438 0e90 00000000 		.word	DensityBaleVolts
 5439 0e94 00000000 		.word	OP8OnDelayTime
 5440 0e98 FF7FFFFF 		.word	-32769
 5441 0e9c 00000000 		.word	.LANCHOR0
 5442 0ea0 00000000 		.word	OP8OffDelayTime
 5443 0ea4 00000000 		.word	DensityCoreVolts
 5444 0ea8 00000000 		.word	DiaTargetVolts
 5445 0eac 00000000 		.word	BalerFullDelayTime
 5446 0eb0 00000000 		.word	buzz_count
 5447 0eb4 00000000 		.word	target_bale_dia_reached_cont_beep
 5448 0eb8 B80B0000 		.word	3000
 5449 0ebc 00000000 		.word	buzz_length
 5450 0ec0 00000000 		.word	DiaPreWarnVolts
 5451 0ec4 00000000 		.word	pre_warning_cont_beep
 5452 0ec8 00000000 		.word	stagecomp
 5453 0ecc 00000000 		.word	ChamberOpenDelayTime
 5454 0ed0 00000000 		.word	start_chamber_open_delay_cont_beep
 5455 0ed4 00000000 		.word	end_chamber_open_delay_cont_beep
 5456              	.L308:
2563:functions.c   **** 			if( stagecomp == (NETFEEDON | NETCUTON | CHAMBOP | CHAMBCLO) )
 5457              		.loc 1 2563 0
 5458 0ed8 0F2B     		cmp	r3, #15
 5459 0eda 0BD1     		bne	.L310
 5460              	.L309:
2565:functions.c   **** 				stagecomp = SC_CLEAR; // Reset
 5461              		.loc 1 2565 0
 5462 0edc 0022     		mov	r2, #0
 5463 0ede 7A4B     		ldr	r3, .L382
 5464 0ee0 1A70     		strb	r2, [r3]
2567:functions.c   **** 				UpdatingAndSavingTotalsToMemory();
 5465              		.loc 1 2567 0
 5466 0ee2 FFF7FEFF 		bl	UpdatingAndSavingTotalsToMemory
 5467              	.LVL286:
2569:functions.c   **** 				buzz_length = ALL_STAGES_COMPLETE_BEEP; // Beep on completion of all stages
 5468              		.loc 1 2569 0
 5469 0ee6 FA22     		mov	r2, #250
 5470 0ee8 9200     		lsl	r2, r2, #2
 5471 0eea 784B     		ldr	r3, .L382+4
 5472 0eec 1A60     		str	r2, [r3]
2571:functions.c   **** 				ResetSequenceFactors( SEQ_ALL );
 5473              		.loc 1 2571 0
 5474 0eee FF20     		mov	r0, #255
 5475 0ef0 FFF7FEFF 		bl	ResetSequenceFactors
 5476              	.LVL287:
 5477              	.L310:
2578:functions.c   **** 			if( pFac.pf.GW302_NetSystem == NS_ROLLER ) // Roller Engage Solenoid (OP5) only turned on/off if
 5478              		.loc 1 2578 0
 5479 0ef4 C123     		mov	r3, #193
 5480 0ef6 764A     		ldr	r2, .L382+8
 5481 0ef8 D35C     		ldrb	r3, [r2, r3]
 5482 0efa 012B     		cmp	r3, #1
 5483 0efc 2ED1     		bne	.L285
2581:functions.c   **** 				if( BaleDiaVolts < DiaEngageVolts ) // below Engage diameter
 5484              		.loc 1 2581 0
 5485 0efe 754B     		ldr	r3, .L382+12
 5486 0f00 1868     		ldr	r0, [r3]
 5487 0f02 754B     		ldr	r3, .L382+16
 5488 0f04 1968     		ldr	r1, [r3]
 5489 0f06 FFF7FEFF 		bl	__aeabi_fcmplt
 5490              	.LVL288:
 5491 0f0a 0028     		cmp	r0, #0
 5492 0f0c 0AD0     		beq	.L371
2584:functions.c   **** 					BaleDiameterStatusInManMode &= ~(BDSIMM_ABOVE_ENGAGE_DIA); // Flag to be set next
 5493              		.loc 1 2584 0
 5494 0f0e 734B     		ldr	r3, .L382+20
 5495 0f10 1A78     		ldrb	r2, [r3]
 5496 0f12 0221     		mov	r1, #2
 5497 0f14 8A43     		bic	r2, r1
 5498 0f16 0121     		mov	r1, #1
 5499 0f18 0A43     		orr	r2, r1
 5500 0f1a 1A70     		strb	r2, [r3]
2585:functions.c   **** 					RollEngageTurnedOnInManMode = 0; // OP5 OFF: Roller Engage Solenoid (AKA Pre Net Position) -- 
 5501              		.loc 1 2585 0
 5502 0f1c 0022     		mov	r2, #0
 5503 0f1e 704B     		ldr	r3, .L382+24
 5504 0f20 1A70     		strb	r2, [r3]
 5505 0f22 14E0     		b	.L313
 5506              	.L371:
2589:functions.c   **** 					if( BaleDiameterStatusInManMode == BDSIMM_BELOW_ENGAGE_DIA ) // BDSIMM_BELOW_ENGAGE_DIA flag a
 5507              		.loc 1 2589 0
 5508 0f24 6D4B     		ldr	r3, .L382+20
 5509 0f26 1B78     		ldrb	r3, [r3]
 5510 0f28 012B     		cmp	r3, #1
 5511 0f2a 10D1     		bne	.L313
2591:functions.c   **** 						BaleDiameterStatusInManMode |= BDSIMM_ABOVE_ENGAGE_DIA; // Set BDSIMM_ABOVE_ENGAGE_DIA flag
 5512              		.loc 1 2591 0
 5513 0f2c 0322     		mov	r2, #3
 5514 0f2e 6B4B     		ldr	r3, .L382+20
 5515 0f30 1A70     		strb	r2, [r3]
2593:functions.c   **** 						if ((RollerTimer == 255) && (RollEngageTurnedOnInManMode == 0) )
 5516              		.loc 1 2593 0
 5517 0f32 6C4B     		ldr	r3, .L382+28
 5518 0f34 1B78     		ldrb	r3, [r3]
 5519 0f36 FF2B     		cmp	r3, #255
 5520 0f38 09D1     		bne	.L313
2593:functions.c   **** 						if ((RollerTimer == 255) && (RollEngageTurnedOnInManMode == 0) )
 5521              		.loc 1 2593 0 is_stmt 0 discriminator 1
 5522 0f3a 694B     		ldr	r3, .L382+24
 5523 0f3c 1B78     		ldrb	r3, [r3]
 5524 0f3e 002B     		cmp	r3, #0
 5525 0f40 05D1     		bne	.L313
2595:functions.c   **** 							RollEngageTurnedOnInManMode = 1; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position) --
 5526              		.loc 1 2595 0 is_stmt 1
 5527 0f42 0122     		mov	r2, #1
 5528 0f44 664B     		ldr	r3, .L382+24
 5529 0f46 1A70     		strb	r2, [r3]
2596:functions.c   **** 							RollerTimer = OP_ROLL_ENGAGE_TIMER; /*3 seconds*/
 5530              		.loc 1 2596 0
 5531 0f48 1E22     		mov	r2, #30
 5532 0f4a 664B     		ldr	r3, .L382+28
 5533 0f4c 1A70     		strb	r2, [r3]
 5534              	.L313:
2606:functions.c   **** 				if( ChamberStatus == (CS_CLOSED | CS_OPEN) ) // Chamber was closed and now opened
 5535              		.loc 1 2606 0
 5536 0f4e 664B     		ldr	r3, .L382+32
 5537 0f50 1B78     		ldrb	r3, [r3]
 5538 0f52 032B     		cmp	r3, #3
 5539 0f54 02D1     		bne	.L285
2608:functions.c   **** 					RollEngageTurnedOnInManMode = 0; // OP5 OFF: Roller Engage Solenoid (AKA Pre Net Position) -- 
 5540              		.loc 1 2608 0
 5541 0f56 0022     		mov	r2, #0
 5542 0f58 614B     		ldr	r3, .L382+24
 5543 0f5a 1A70     		strb	r2, [r3]
 5544              	.L285:
2624:functions.c   **** 			if (RollerTimer && !(RollerTimer == 255))
 5545              		.loc 1 2624 0
 5546 0f5c 614B     		ldr	r3, .L382+28
 5547 0f5e 1B78     		ldrb	r3, [r3]
 5548 0f60 5A1E     		sub	r2, r3, #1
 5549 0f62 1206     		lsl	r2, r2, #24
 5550 0f64 120E     		lsr	r2, r2, #24
 5551 0f66 FD2A     		cmp	r2, #253
 5552 0f68 10D8     		bhi	.L314
2626:functions.c   **** 				RollEngageTurnedOn = 0;
 5553              		.loc 1 2626 0
 5554 0f6a 0021     		mov	r1, #0
 5555 0f6c 5F4B     		ldr	r3, .L382+36
 5556 0f6e 1970     		strb	r1, [r3]
2627:functions.c   **** 				SeqOpOn |= OP_ROLL_ENGAGE; // OP5 ON: Roller Engage Solenoid (AKA Pre Net Position)
 5557              		.loc 1 2627 0
 5558 0f70 5F4B     		ldr	r3, .L382+40
 5559 0f72 8021     		mov	r1, #128
 5560 0f74 4904     		lsl	r1, r1, #17
 5561 0f76 1868     		ldr	r0, [r3]
 5562 0f78 0143     		orr	r1, r0
 5563 0f7a 1960     		str	r1, [r3]
2628:functions.c   **** 				SeqOpOff &= ~OP_ROLL_ENGAGE;
 5564              		.loc 1 2628 0
 5565 0f7c 5D4B     		ldr	r3, .L382+44
 5566 0f7e 5E49     		ldr	r1, .L382+48
 5567 0f80 1868     		ldr	r0, [r3]
 5568 0f82 0140     		and	r1, r0
 5569 0f84 1960     		str	r1, [r3]
2629:functions.c   **** 				RollerTimer--;
 5570              		.loc 1 2629 0
 5571 0f86 574B     		ldr	r3, .L382+28
 5572 0f88 1A70     		strb	r2, [r3]
 5573 0f8a 0FE0     		b	.L315
 5574              	.L314:
2631:functions.c   **** 			else if(!RollerTimer)
 5575              		.loc 1 2631 0
 5576 0f8c 002B     		cmp	r3, #0
 5577 0f8e 0DD1     		bne	.L315
2633:functions.c   **** 				SeqOpOn &= ~OP_ROLL_ENGAGE; // OP5 OFF: Roller Engage Solenoid (AKA Pre Net Position)
 5578              		.loc 1 2633 0
 5579 0f90 574B     		ldr	r3, .L382+40
 5580 0f92 594A     		ldr	r2, .L382+48
 5581 0f94 1968     		ldr	r1, [r3]
 5582 0f96 0A40     		and	r2, r1
 5583 0f98 1A60     		str	r2, [r3]
2634:functions.c   **** 				SeqOpOff |= OP_ROLL_ENGAGE;
 5584              		.loc 1 2634 0
 5585 0f9a 564B     		ldr	r3, .L382+44
 5586 0f9c 8022     		mov	r2, #128
 5587 0f9e 5204     		lsl	r2, r2, #17
 5588 0fa0 1868     		ldr	r0, [r3]
 5589 0fa2 0243     		orr	r2, r0
 5590 0fa4 1A60     		str	r2, [r3]
2635:functions.c   **** 				RollerTimer = 255;
 5591              		.loc 1 2635 0
 5592 0fa6 FF22     		mov	r2, #255
 5593 0fa8 4E4B     		ldr	r3, .L382+28
 5594 0faa 1A70     		strb	r2, [r3]
 5595              	.L315:
2643:functions.c   **** 		if( CHOPPING_KNIVES_ON && // IP2 open: 11 Knife Sensor (AKA Chopping Knives position / Knives Pos
 5596              		.loc 1 2643 0
 5597 0fac 534B     		ldr	r3, .L382+52
 5598 0fae DB6B     		ldr	r3, [r3, #60]
 5599 0fb0 D902     		lsl	r1, r3, #11
 5600 0fb2 14D5     		bpl	.L316
2644:functions.c   **** 				( (((key & ~(SW_NEW | SW_REP)) != SW_IR) && ((key & ~(SW_NEW | SW_REP)) != SW_OR)) || SecondScr
 5601              		.loc 1 2644 0 discriminator 1
 5602 0fb4 524B     		ldr	r3, .L382+56
 5603 0fb6 1B68     		ldr	r3, [r3]
 5604 0fb8 9B00     		lsl	r3, r3, #2
 5605 0fba 9B08     		lsr	r3, r3, #2
 5606 0fbc 5A1E     		sub	r2, r3, #1
 5607 0fbe FF3A     		sub	r2, r2, #255
2643:functions.c   **** 		if( CHOPPING_KNIVES_ON && // IP2 open: 11 Knife Sensor (AKA Chopping Knives position / Knives Pos
 5608              		.loc 1 2643 0 discriminator 1
 5609 0fc0 002A     		cmp	r2, #0
 5610 0fc2 01D0     		beq	.L356
 5611 0fc4 082B     		cmp	r3, #8
 5612 0fc6 03D1     		bne	.L317
 5613              	.L356:
2644:functions.c   **** 				( (((key & ~(SW_NEW | SW_REP)) != SW_IR) && ((key & ~(SW_NEW | SW_REP)) != SW_OR)) || SecondScr
 5614              		.loc 1 2644 0
 5615 0fc8 4E4B     		ldr	r3, .L382+60
 5616 0fca 1B78     		ldrb	r3, [r3]
 5617 0fcc 002B     		cmp	r3, #0
 5618 0fce 06D0     		beq	.L316
 5619              	.L317:
2646:functions.c   **** 			Kniv1_IPClosed = 1;
 5620              		.loc 1 2646 0
 5621 0fd0 0122     		mov	r2, #1
 5622 0fd2 4D4B     		ldr	r3, .L382+64
 5623 0fd4 1A70     		strb	r2, [r3]
2647:functions.c   **** 			Kniv1_IPOpenTime = 0;
 5624              		.loc 1 2647 0
 5625 0fd6 0022     		mov	r2, #0
 5626 0fd8 4C4B     		ldr	r3, .L382+68
 5627 0fda 1A70     		strb	r2, [r3]
 5628 0fdc 11E0     		b	.L319
 5629              	.L316:
2651:functions.c   **** 			if( Kniv1_IPClosed )
 5630              		.loc 1 2651 0
 5631 0fde 4A4B     		ldr	r3, .L382+64
 5632 0fe0 1B78     		ldrb	r3, [r3]
 5633 0fe2 002B     		cmp	r3, #0
 5634 0fe4 0DD0     		beq	.L319
2653:functions.c   **** 				if( Kniv1_IPOpenTime < 250 )
 5635              		.loc 1 2653 0
 5636 0fe6 494B     		ldr	r3, .L382+68
 5637 0fe8 1B78     		ldrb	r3, [r3]
 5638 0fea F92B     		cmp	r3, #249
 5639 0fec 02D8     		bhi	.L320
2654:functions.c   **** 					Kniv1_IPOpenTime++;
 5640              		.loc 1 2654 0
 5641 0fee 0133     		add	r3, r3, #1
 5642 0ff0 464A     		ldr	r2, .L382+68
 5643 0ff2 1370     		strb	r3, [r2]
 5644              	.L320:
2656:functions.c   **** 				if( Kniv1_IPOpenTime > 10 )
 5645              		.loc 1 2656 0
 5646 0ff4 454B     		ldr	r3, .L382+68
 5647 0ff6 1B78     		ldrb	r3, [r3]
 5648 0ff8 0A2B     		cmp	r3, #10
 5649 0ffa 02D9     		bls	.L319
2657:functions.c   **** 					ChoppingKnives1WarningOn = 1; // Chopping knives position Warning on
 5650              		.loc 1 2657 0
 5651 0ffc 0122     		mov	r2, #1
 5652 0ffe 444B     		ldr	r3, .L382+72
 5653 1000 1A70     		strb	r2, [r3]
 5654              	.L319:
2666:functions.c   **** 		if( CHAMBER_CLOSED ) // IP3: Chamber Locked Sensor closed
 5655              		.loc 1 2666 0
 5656 1002 3E4B     		ldr	r3, .L382+52
 5657 1004 DB6B     		ldr	r3, [r3, #60]
 5658 1006 5A02     		lsl	r2, r3, #9
 5659 1008 07D5     		bpl	.L321
2669:functions.c   **** 			ChamberStatus &= ~(CS_OPEN); // Flag to be set next
 5660              		.loc 1 2669 0
 5661 100a 374B     		ldr	r3, .L382+32
 5662 100c 1A78     		ldrb	r2, [r3]
 5663 100e 0221     		mov	r1, #2
 5664 1010 8A43     		bic	r2, r1
 5665 1012 0121     		mov	r1, #1
 5666 1014 0A43     		orr	r2, r1
 5667 1016 1A70     		strb	r2, [r3]
 5668 1018 08E0     		b	.L322
 5669              	.L321:
2673:functions.c   **** 			if( ChamberStatus == CS_CLOSED ) // CS_CLOSED flag already set
 5670              		.loc 1 2673 0
 5671 101a 334B     		ldr	r3, .L382+32
 5672 101c 1B78     		ldrb	r3, [r3]
 5673 101e 012B     		cmp	r3, #1
 5674 1020 04D1     		bne	.L322
2675:functions.c   **** 				ChamberStatus |= CS_OPEN; // Set CS_OPEN flag
 5675              		.loc 1 2675 0
 5676 1022 0322     		mov	r2, #3
 5677 1024 304B     		ldr	r3, .L382+32
 5678 1026 1A70     		strb	r2, [r3]
2681:functions.c   **** 		if( OP8OnCount )
 5679              		.loc 1 2681 0
 5680 1028 3C23     		mov	r3, #60
 5681 102a 03E0     		b	.L323
 5682              	.L322:
 5683 102c 394B     		ldr	r3, .L382+76
 5684 102e 1B78     		ldrb	r3, [r3]
 5685 1030 002B     		cmp	r3, #0
 5686 1032 08D0     		beq	.L324
 5687              	.L323:
2683:functions.c   **** 			KeyOpOn |= OP_DENSITY_REL; // OP8 ON: Density Release Solenoid (AKA Density Control)
 5688              		.loc 1 2683 0
 5689 1034 384A     		ldr	r2, .L382+80
 5690 1036 8021     		mov	r1, #128
 5691 1038 0902     		lsl	r1, r1, #8
 5692 103a 1068     		ldr	r0, [r2]
 5693 103c 0143     		orr	r1, r0
 5694 103e 1160     		str	r1, [r2]
2685:functions.c   **** 			OP8OnCount--;
 5695              		.loc 1 2685 0
 5696 1040 013B     		sub	r3, r3, #1
 5697 1042 344A     		ldr	r2, .L382+76
 5698 1044 1370     		strb	r3, [r2]
 5699              	.L324:
2693:functions.c   **** 		if( (BaleDiaVolts > DiaPreWarnVolts) || (BaleDiaVolts >= DiaEngageVolts) )
 5700              		.loc 1 2693 0
 5701 1046 234B     		ldr	r3, .L382+12
 5702 1048 1C68     		ldr	r4, [r3]
 5703 104a 201C     		add	r0, r4, #0
 5704 104c 334B     		ldr	r3, .L382+84
 5705 104e 1968     		ldr	r1, [r3]
 5706 1050 FFF7FEFF 		bl	__aeabi_fcmpgt
 5707              	.LVL289:
 5708 1054 0028     		cmp	r0, #0
 5709 1056 06D1     		bne	.L325
2693:functions.c   **** 		if( (BaleDiaVolts > DiaPreWarnVolts) || (BaleDiaVolts >= DiaEngageVolts) )
 5710              		.loc 1 2693 0 is_stmt 0 discriminator 1
 5711 1058 201C     		add	r0, r4, #0
 5712 105a 1F4B     		ldr	r3, .L382+16
 5713 105c 1968     		ldr	r1, [r3]
 5714 105e FFF7FEFF 		bl	__aeabi_fcmpge
 5715              	.LVL290:
 5716 1062 0028     		cmp	r0, #0
 5717 1064 02D0     		beq	.L326
 5718              	.L325:
2695:functions.c   **** 			DrivingArrowBeepsDisabled = 1; // Driving Arrow Beeps turned off
 5719              		.loc 1 2695 0 is_stmt 1
 5720 1066 0122     		mov	r2, #1
 5721 1068 2D4B     		ldr	r3, .L382+88
 5722 106a 1A70     		strb	r2, [r3]
 5723              	.L326:
2702:functions.c   **** 		SeqOpOn = SeqOpOn & ~SeqOpOff; /* If an Op is to be turned off, dont turn it on */
 5724              		.loc 1 2702 0
 5725 106c 214B     		ldr	r3, .L382+44
 5726 106e 1B68     		ldr	r3, [r3]
 5727 1070 1F49     		ldr	r1, .L382+40
 5728 1072 0A68     		ldr	r2, [r1]
 5729 1074 9A43     		bic	r2, r3
 5730 1076 0A60     		str	r2, [r1]
2704:functions.c   **** 		OpOff = KeyOpOff | SeqOpOff;
 5731              		.loc 1 2704 0
 5732 1078 2A49     		ldr	r1, .L382+92
 5733 107a 0968     		ldr	r1, [r1]
 5734 107c 1943     		orr	r1, r3
 5735 107e 2A4B     		ldr	r3, .L382+96
 5736 1080 1963     		str	r1, [r3, #48]
2707:functions.c   **** 		OpOn = KeyOpOn | SeqOpOn;
 5737              		.loc 1 2707 0
 5738 1082 2549     		ldr	r1, .L382+80
 5739 1084 0968     		ldr	r1, [r1]
 5740 1086 0A43     		orr	r2, r1
 5741 1088 5A63     		str	r2, [r3, #52]
 5742 108a 19E0     		b	.L180
 5743              	.L266:
2206:functions.c   **** 					if( NetWarningDelayTime )
 5744              		.loc 1 2206 0
 5745 108c 274B     		ldr	r3, .L382+100
 5746 108e 1A78     		ldrb	r2, [r3]
 5747 1090 002A     		cmp	r2, #0
 5748 1092 00D0     		beq	.LCB5265
 5749 1094 7EE4     		b	.L328	@long jump
 5750              	.LCB5265:
 5751 1096 81E4     		b	.L372
 5752              	.L275:
2374:functions.c   **** 				RollEngageTurnedOn = 0; // Reset
 5753              		.loc 1 2374 0
 5754 1098 0023     		mov	r3, #0
 5755 109a 144A     		ldr	r2, .L382+36
 5756 109c 1370     		strb	r3, [r2]
2375:functions.c   **** 				SavedRollEngageTurnedOn = 0; // Reset
 5757              		.loc 1 2375 0
 5758 109e 244A     		ldr	r2, .L382+104
 5759 10a0 1370     		strb	r3, [r2]
2377:functions.c   **** 				OP5TurnedOnAfterBeakEngagePulsesEnabled = 0; // Reset
 5760              		.loc 1 2377 0
 5761 10a2 244A     		ldr	r2, .L382+108
 5762 10a4 1370     		strb	r3, [r2]
2378:functions.c   **** 				SavedOP5TurnedOnAfterBeakEngagePulsesEnabled = 0; // Reset
 5763              		.loc 1 2378 0
 5764 10a6 244A     		ldr	r2, .L382+112
 5765 10a8 1370     		strb	r3, [r2]
 5766 10aa 7AE5     		b	.L281
 5767              	.L278:
2335:functions.c   **** 				if( CHAMBER_OPEN ) // Chamber Locked Sensor open
 5768              		.loc 1 2335 0
 5769 10ac 134B     		ldr	r3, .L382+52
 5770 10ae DB6B     		ldr	r3, [r3, #60]
 5771 10b0 5902     		lsl	r1, r3, #9
 5772 10b2 00D4     		bmi	.LCB5288
 5773 10b4 44E5     		b	.L330	@long jump
 5774              	.LCB5288:
 5775 10b6 62E5     		b	.L373
 5776              	.L249:
2004:functions.c   **** 					if( IP4PulsesStoppedCount )
 5777              		.loc 1 2004 0
 5778 10b8 204B     		ldr	r3, .L382+116
 5779 10ba 1A78     		ldrb	r2, [r3]
 5780 10bc FFF7DDFA 		bl	.L332	@ far jump
 5781              	.L180:
2713:functions.c   **** }
 5782              		.loc 1 2713 0
 5783              		@ sp needed for prologue
 5784 10c0 70BC     		pop	{r4, r5, r6}
 5785 10c2 01BC     		pop	{r0}
 5786 10c4 0047     		bx	r0
 5787              	.L383:
 5788 10c6 C046     		.align	2
 5789              	.L382:
 5790 10c8 00000000 		.word	stagecomp
 5791 10cc 00000000 		.word	buzz_length
 5792 10d0 00000000 		.word	.LANCHOR0
 5793 10d4 00000000 		.word	BaleDiaVolts
 5794 10d8 00000000 		.word	DiaEngageVolts
 5795 10dc 00000000 		.word	BaleDiameterStatusInManMode
 5796 10e0 00000000 		.word	RollEngageTurnedOnInManMode
 5797 10e4 00000000 		.word	.LANCHOR16
 5798 10e8 00000000 		.word	ChamberStatus
 5799 10ec 00000000 		.word	RollEngageTurnedOn
 5800 10f0 00000000 		.word	SeqOpOn
 5801 10f4 00000000 		.word	SeqOpOff
 5802 10f8 FFFFFFFE 		.word	-16777217
 5803 10fc 00F6FFFF 		.word	-2560
 5804 1100 00000000 		.word	key
 5805 1104 00000000 		.word	SecondScreen
 5806 1108 00000000 		.word	Kniv1_IPClosed
 5807 110c 00000000 		.word	.LANCHOR17
 5808 1110 00000000 		.word	ChoppingKnives1WarningOn
 5809 1114 00000000 		.word	OP8OnCount
 5810 1118 00000000 		.word	KeyOpOn
 5811 111c 00000000 		.word	DiaPreWarnVolts
 5812 1120 00000000 		.word	DrivingArrowBeepsDisabled
 5813 1124 00000000 		.word	KeyOpOff
 5814 1128 00F4FFFF 		.word	-3072
 5815 112c 00000000 		.word	NetWarningDelayTime
 5816 1130 00000000 		.word	SavedRollEngageTurnedOn
 5817 1134 00000000 		.word	OP5TurnedOnAfterBeakEngagePulsesEnabled
 5818 1138 00000000 		.word	SavedOP5TurnedOnAfterBeakEngagePulsesEnabled
 5819 113c 00000000 		.word	IP4PulsesStoppedCount
 5820              		.cfi_endproc
 5821              	.LFE387:
 5823              		.global	__aeabi_dsub
 5824              		.section	.text.CalculateAnalogInputRollingAverages,"ax",%progbits
 5825              		.align	2
 5826              		.global	CalculateAnalogInputRollingAverages
 5827              		.code	16
 5828              		.thumb_func
 5830              	CalculateAnalogInputRollingAverages:
 5831              	.LFB394:
2889:functions.c   **** // -----------------------------------------------------------
2890:functions.c   **** 
2891:functions.c   **** #ifndef WINDOWS
2892:functions.c   **** // -----------------------------------------------------------
2893:functions.c   **** // Function Name       : CalculateAnalogInputRollingAverages 
2894:functions.c   **** // Object              : Calculates analogue input rolling averages
2895:functions.c   **** // Output Parameters   : BaleDiaVolts     - Bale Diameter (AnIP1)
2896:functions.c   **** //                       DensityPresVolts - (Bale) Density Pressure (AnIP2)
2897:functions.c   **** //                       BaleShapeVolts   - Bale Shape Indicator (AnIP3) 
2898:functions.c   **** //                       KnifePresVolts   - Knife Pressure (AnIP4)        
2899:functions.c   **** // -----------------------------------------------------------
2900:functions.c   **** void CalculateAnalogInputRollingAverages( void ) 
2901:functions.c   **** {
 5832              		.loc 1 2901 0
 5833              		.cfi_startproc
 5834 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5835              	.LCFI22:
 5836              		.cfi_def_cfa_offset 24
 5837              		.cfi_offset 3, -24
 5838              		.cfi_offset 4, -20
 5839              		.cfi_offset 5, -16
 5840              		.cfi_offset 6, -12
 5841              		.cfi_offset 7, -8
 5842              		.cfi_offset 14, -4
 5843 0002 4F46     		mov	r7, r9
 5844 0004 4646     		mov	r6, r8
 5845 0006 C0B4     		push	{r6, r7}
 5846              	.LCFI23:
 5847              		.cfi_def_cfa_offset 32
 5848              		.cfi_offset 8, -32
 5849              		.cfi_offset 9, -28
2902:functions.c   **** 	// Average Sample
2903:functions.c   **** 	float BaleDiaVoltsAvSample;     // V
2904:functions.c   **** 	float DensityPresVoltsAvSample; // V
2905:functions.c   **** 	float BaleShapeVoltsAvSample;   // V
2906:functions.c   **** 	float KnifePresVoltsAvSample;   // V
2907:functions.c   **** 
2908:functions.c   **** 	// Rolling Average Sample
2909:functions.c   **** 	static float BaleDiaVoltsRollAvSample;     // V
2910:functions.c   **** 	static float DensityPresVoltsRollAvSample; // V
2911:functions.c   **** 	static float BaleShapeVoltsRollAvSample;   // V
2912:functions.c   **** 	static float KnifePresVoltsRollAvSample;   // V
2913:functions.c   **** 
2914:functions.c   **** 	// RollingAverageSample = ( [SmoothingFactor]% x AverageSample ) +
2915:functions.c   **** 	//                        ( [100-SmoothingFactor]% x Previous_RollingAverageSample )
2916:functions.c   **** 	// where AverageSample = Average of total NUM_ACCUMULATED_SAMPLES
2917:functions.c   **** 
2918:functions.c   **** 	// AnIP1: Bale Diameter
2919:functions.c   **** 	BaleDiaVoltsTotAccumMultSamples = (unsigned long int)( (float)BaleDiaVoltsTotAccumMultSamples * PO
 5850              		.loc 1 2919 0
 5851 0008 BB4C     		ldr	r4, .L385+32
 5852 000a 2068     		ldr	r0, [r4]
 5853 000c FFF7FEFF 		bl	__aeabi_ui2f
 5854              	.LVL291:
 5855 0010 FFF7FEFF 		bl	__aeabi_f2d
 5856              	.LVL292:
 5857 0014 B14B     		ldr	r3, .L385+4
 5858 0016 B04A     		ldr	r2, .L385
 5859 0018 FFF7FEFF 		bl	__aeabi_dmul
 5860              	.LVL293:
 5861 001c B04A     		ldr	r2, .L385+8
 5862 001e B14B     		ldr	r3, .L385+12
 5863 0020 FFF7FEFF 		bl	__aeabi_dmul
 5864              	.LVL294:
 5865 0024 B04A     		ldr	r2, .L385+16
 5866 0026 B14B     		ldr	r3, .L385+20
 5867 0028 FFF7FEFF 		bl	__aeabi_dmul
 5868              	.LVL295:
 5869 002c FFF7FEFF 		bl	__aeabi_d2uiz
 5870              	.LVL296:
 5871 0030 8146     		mov	r9, r0
 5872 0032 2060     		str	r0, [r4]
 5873              	.LVL297:
2920:functions.c   **** 	BaleDiaVoltsAvSample = (float)BaleDiaVoltsTotAccumMultSamples / (float)(NUM_ACCUMULATED_SAMPLES * 
2921:functions.c   **** 	BaleDiaVoltsRollAvSample = ( ((float)pFac.pf.GW302_BaleDiaSmoothingFactor/100.0) * BaleDiaVoltsAvS
 5874              		.loc 1 2921 0
 5875 0034 B14A     		ldr	r2, .L385+36
 5876 0036 9046     		mov	r8, r2
 5877 0038 CC23     		mov	r3, #204
 5878 003a D05C     		ldrb	r0, [r2, r3]
 5879              	.LVL298:
 5880 003c FFF7FEFF 		bl	__aeabi_ui2f
 5881              	.LVL299:
 5882 0040 FFF7FEFF 		bl	__aeabi_f2d
 5883              	.LVL300:
 5884 0044 041C     		mov	r4, r0
 5885 0046 0D1C     		mov	r5, r1
 5886 0048 A94A     		ldr	r2, .L385+24
 5887 004a AA4B     		ldr	r3, .L385+28
 5888 004c FFF7FEFF 		bl	__aeabi_ddiv
 5889              	.LVL301:
 5890 0050 061C     		mov	r6, r0
 5891 0052 0F1C     		mov	r7, r1
2920:functions.c   **** 	BaleDiaVoltsAvSample = (float)BaleDiaVoltsTotAccumMultSamples / (float)(NUM_ACCUMULATED_SAMPLES * 
 5892              		.loc 1 2920 0
 5893 0054 4846     		mov	r0, r9
 5894 0056 FFF7FEFF 		bl	__aeabi_ui2f
 5895              	.LVL302:
 5896 005a A949     		ldr	r1, .L385+40
 5897 005c FFF7FEFF 		bl	__aeabi_fdiv
 5898              	.LVL303:
 5899              		.loc 1 2921 0
 5900 0060 FFF7FEFF 		bl	__aeabi_f2d
 5901              	.LVL304:
 5902 0064 021C     		mov	r2, r0
 5903 0066 0B1C     		mov	r3, r1
 5904 0068 301C     		mov	r0, r6
 5905 006a 391C     		mov	r1, r7
 5906 006c FFF7FEFF 		bl	__aeabi_dmul
 5907              	.LVL305:
 5908 0070 061C     		mov	r6, r0
 5909 0072 0F1C     		mov	r7, r1
2922:functions.c   **** 			( ((100.0 - (float)pFac.pf.GW302_BaleDiaSmoothingFactor)/100.0) * BaleDiaVoltsRollAvSample);
 5910              		.loc 1 2922 0
 5911 0074 9E48     		ldr	r0, .L385+24
 5912 0076 9F49     		ldr	r1, .L385+28
 5913 0078 221C     		mov	r2, r4
 5914 007a 2B1C     		mov	r3, r5
 5915 007c FFF7FEFF 		bl	__aeabi_dsub
 5916              	.LVL306:
 5917 0080 9B4A     		ldr	r2, .L385+24
 5918 0082 9C4B     		ldr	r3, .L385+28
 5919 0084 FFF7FEFF 		bl	__aeabi_ddiv
 5920              	.LVL307:
 5921 0088 041C     		mov	r4, r0
 5922 008a 0D1C     		mov	r5, r1
 5923 008c 9D4B     		ldr	r3, .L385+44
 5924 008e 9946     		mov	r9, r3
 5925              	.LVL308:
 5926 0090 1868     		ldr	r0, [r3]
 5927 0092 FFF7FEFF 		bl	__aeabi_f2d
 5928              	.LVL309:
 5929 0096 021C     		mov	r2, r0
 5930 0098 0B1C     		mov	r3, r1
 5931 009a 201C     		mov	r0, r4
 5932 009c 291C     		mov	r1, r5
 5933 009e FFF7FEFF 		bl	__aeabi_dmul
 5934              	.LVL310:
 5935 00a2 021C     		mov	r2, r0
 5936 00a4 0B1C     		mov	r3, r1
2921:functions.c   **** 	BaleDiaVoltsRollAvSample = ( ((float)pFac.pf.GW302_BaleDiaSmoothingFactor/100.0) * BaleDiaVoltsAvS
 5937              		.loc 1 2921 0
 5938 00a6 301C     		mov	r0, r6
 5939 00a8 391C     		mov	r1, r7
 5940 00aa FFF7FEFF 		bl	__aeabi_dadd
 5941              	.LVL311:
 5942 00ae FFF7FEFF 		bl	__aeabi_d2f
 5943              	.LVL312:
 5944 00b2 4B46     		mov	r3, r9
 5945 00b4 1860     		str	r0, [r3]
2923:functions.c   **** 	BaleDiaVolts = BaleDiaVoltsRollAvSample;
 5946              		.loc 1 2923 0
 5947 00b6 944B     		ldr	r3, .L385+48
 5948 00b8 1860     		str	r0, [r3]
2924:functions.c   **** 
2925:functions.c   **** 	// AnIP2: (Bale) Density Pressure
2926:functions.c   **** 	DensityPresVoltsTotAccumMultSamples = (unsigned long int)( (float)DensityPresVoltsTotAccumMultSamp
 5949              		.loc 1 2926 0
 5950 00ba 944C     		ldr	r4, .L385+52
 5951 00bc 2068     		ldr	r0, [r4]
 5952 00be FFF7FEFF 		bl	__aeabi_ui2f
 5953              	.LVL313:
 5954 00c2 FFF7FEFF 		bl	__aeabi_f2d
 5955              	.LVL314:
 5956 00c6 854B     		ldr	r3, .L385+4
 5957 00c8 834A     		ldr	r2, .L385
 5958 00ca FFF7FEFF 		bl	__aeabi_dmul
 5959              	.LVL315:
 5960 00ce 844A     		ldr	r2, .L385+8
 5961 00d0 844B     		ldr	r3, .L385+12
 5962 00d2 FFF7FEFF 		bl	__aeabi_dmul
 5963              	.LVL316:
 5964 00d6 844A     		ldr	r2, .L385+16
 5965 00d8 844B     		ldr	r3, .L385+20
 5966 00da FFF7FEFF 		bl	__aeabi_dmul
 5967              	.LVL317:
 5968 00de FFF7FEFF 		bl	__aeabi_d2uiz
 5969              	.LVL318:
 5970 00e2 8146     		mov	r9, r0
 5971 00e4 2060     		str	r0, [r4]
 5972              	.LVL319:
2927:functions.c   **** 	DensityPresVoltsAvSample = (float)DensityPresVoltsTotAccumMultSamples / (float)(NUM_ACCUMULATED_SA
2928:functions.c   **** 	DensityPresVoltsRollAvSample = ( ((float)pFac.pf.GW302_DensityPresSmoothingFactor/100.0) * Density
 5973              		.loc 1 2928 0
 5974 00e6 CD23     		mov	r3, #205
 5975 00e8 4246     		mov	r2, r8
 5976 00ea D05C     		ldrb	r0, [r2, r3]
 5977              	.LVL320:
 5978 00ec FFF7FEFF 		bl	__aeabi_ui2f
 5979              	.LVL321:
 5980 00f0 FFF7FEFF 		bl	__aeabi_f2d
 5981              	.LVL322:
 5982 00f4 041C     		mov	r4, r0
 5983 00f6 0D1C     		mov	r5, r1
 5984 00f8 7D4A     		ldr	r2, .L385+24
 5985 00fa 7E4B     		ldr	r3, .L385+28
 5986 00fc FFF7FEFF 		bl	__aeabi_ddiv
 5987              	.LVL323:
 5988 0100 061C     		mov	r6, r0
 5989 0102 0F1C     		mov	r7, r1
2927:functions.c   **** 	DensityPresVoltsAvSample = (float)DensityPresVoltsTotAccumMultSamples / (float)(NUM_ACCUMULATED_SA
 5990              		.loc 1 2927 0
 5991 0104 4846     		mov	r0, r9
 5992 0106 FFF7FEFF 		bl	__aeabi_ui2f
 5993              	.LVL324:
 5994 010a 7D49     		ldr	r1, .L385+40
 5995 010c FFF7FEFF 		bl	__aeabi_fdiv
 5996              	.LVL325:
 5997              		.loc 1 2928 0
 5998 0110 FFF7FEFF 		bl	__aeabi_f2d
 5999              	.LVL326:
 6000 0114 021C     		mov	r2, r0
 6001 0116 0B1C     		mov	r3, r1
 6002 0118 301C     		mov	r0, r6
 6003 011a 391C     		mov	r1, r7
 6004 011c FFF7FEFF 		bl	__aeabi_dmul
 6005              	.LVL327:
 6006 0120 061C     		mov	r6, r0
 6007 0122 0F1C     		mov	r7, r1
2929:functions.c   **** 			( ((100.0 - (float)pFac.pf.GW302_DensityPresSmoothingFactor)/100.0) * DensityPresVoltsRollAvSamp
 6008              		.loc 1 2929 0
 6009 0124 7248     		ldr	r0, .L385+24
 6010 0126 7349     		ldr	r1, .L385+28
 6011 0128 221C     		mov	r2, r4
 6012 012a 2B1C     		mov	r3, r5
 6013 012c FFF7FEFF 		bl	__aeabi_dsub
 6014              	.LVL328:
 6015 0130 6F4A     		ldr	r2, .L385+24
 6016 0132 704B     		ldr	r3, .L385+28
 6017 0134 FFF7FEFF 		bl	__aeabi_ddiv
 6018              	.LVL329:
 6019 0138 041C     		mov	r4, r0
 6020 013a 0D1C     		mov	r5, r1
 6021 013c 744B     		ldr	r3, .L385+56
 6022 013e 9946     		mov	r9, r3
 6023              	.LVL330:
 6024 0140 1868     		ldr	r0, [r3]
 6025 0142 FFF7FEFF 		bl	__aeabi_f2d
 6026              	.LVL331:
 6027 0146 021C     		mov	r2, r0
 6028 0148 0B1C     		mov	r3, r1
 6029 014a 201C     		mov	r0, r4
 6030 014c 291C     		mov	r1, r5
 6031 014e FFF7FEFF 		bl	__aeabi_dmul
 6032              	.LVL332:
 6033 0152 021C     		mov	r2, r0
 6034 0154 0B1C     		mov	r3, r1
2928:functions.c   **** 	DensityPresVoltsRollAvSample = ( ((float)pFac.pf.GW302_DensityPresSmoothingFactor/100.0) * Density
 6035              		.loc 1 2928 0
 6036 0156 301C     		mov	r0, r6
 6037 0158 391C     		mov	r1, r7
 6038 015a FFF7FEFF 		bl	__aeabi_dadd
 6039              	.LVL333:
 6040 015e FFF7FEFF 		bl	__aeabi_d2f
 6041              	.LVL334:
 6042 0162 4B46     		mov	r3, r9
 6043 0164 1860     		str	r0, [r3]
2930:functions.c   **** 	DensityPresVolts = DensityPresVoltsRollAvSample;
 6044              		.loc 1 2930 0
 6045 0166 6B4B     		ldr	r3, .L385+60
 6046 0168 1860     		str	r0, [r3]
2931:functions.c   **** 
2932:functions.c   **** 	// AnIP3: Bale Shape Indicator
2933:functions.c   **** 	BaleShapeVoltsTotAccumMultSamples = (unsigned long int)( (float)BaleShapeVoltsTotAccumMultSamples 
 6047              		.loc 1 2933 0
 6048 016a 6B4C     		ldr	r4, .L385+64
 6049 016c 2068     		ldr	r0, [r4]
 6050 016e FFF7FEFF 		bl	__aeabi_ui2f
 6051              	.LVL335:
 6052 0172 FFF7FEFF 		bl	__aeabi_f2d
 6053              	.LVL336:
 6054 0176 594B     		ldr	r3, .L385+4
 6055 0178 574A     		ldr	r2, .L385
 6056 017a FFF7FEFF 		bl	__aeabi_dmul
 6057              	.LVL337:
 6058 017e 584A     		ldr	r2, .L385+8
 6059 0180 584B     		ldr	r3, .L385+12
 6060 0182 FFF7FEFF 		bl	__aeabi_dmul
 6061              	.LVL338:
 6062 0186 584A     		ldr	r2, .L385+16
 6063 0188 584B     		ldr	r3, .L385+20
 6064 018a FFF7FEFF 		bl	__aeabi_dmul
 6065              	.LVL339:
 6066 018e FFF7FEFF 		bl	__aeabi_d2uiz
 6067              	.LVL340:
 6068 0192 8146     		mov	r9, r0
 6069 0194 2060     		str	r0, [r4]
 6070              	.LVL341:
2934:functions.c   **** 	BaleShapeVoltsAvSample = (float)BaleShapeVoltsTotAccumMultSamples / (float)(NUM_ACCUMULATED_SAMPLE
2935:functions.c   **** 	BaleShapeVoltsRollAvSample = ( ((float)pFac.pf.GW302_BaleShapeSmoothingFactor/100.0) * BaleShapeVo
 6071              		.loc 1 2935 0
 6072 0196 CE23     		mov	r3, #206
 6073 0198 4246     		mov	r2, r8
 6074 019a D05C     		ldrb	r0, [r2, r3]
 6075              	.LVL342:
 6076 019c FFF7FEFF 		bl	__aeabi_ui2f
 6077              	.LVL343:
 6078 01a0 FFF7FEFF 		bl	__aeabi_f2d
 6079              	.LVL344:
 6080 01a4 041C     		mov	r4, r0
 6081 01a6 0D1C     		mov	r5, r1
 6082 01a8 514A     		ldr	r2, .L385+24
 6083 01aa 524B     		ldr	r3, .L385+28
 6084 01ac FFF7FEFF 		bl	__aeabi_ddiv
 6085              	.LVL345:
 6086 01b0 061C     		mov	r6, r0
 6087 01b2 0F1C     		mov	r7, r1
2934:functions.c   **** 	BaleShapeVoltsAvSample = (float)BaleShapeVoltsTotAccumMultSamples / (float)(NUM_ACCUMULATED_SAMPLE
 6088              		.loc 1 2934 0
 6089 01b4 4846     		mov	r0, r9
 6090 01b6 FFF7FEFF 		bl	__aeabi_ui2f
 6091              	.LVL346:
 6092 01ba 5149     		ldr	r1, .L385+40
 6093 01bc FFF7FEFF 		bl	__aeabi_fdiv
 6094              	.LVL347:
 6095              		.loc 1 2935 0
 6096 01c0 FFF7FEFF 		bl	__aeabi_f2d
 6097              	.LVL348:
 6098 01c4 021C     		mov	r2, r0
 6099 01c6 0B1C     		mov	r3, r1
 6100 01c8 301C     		mov	r0, r6
 6101 01ca 391C     		mov	r1, r7
 6102 01cc FFF7FEFF 		bl	__aeabi_dmul
 6103              	.LVL349:
 6104 01d0 061C     		mov	r6, r0
 6105 01d2 0F1C     		mov	r7, r1
2936:functions.c   **** 			( ((100.0 - (float)pFac.pf.GW302_BaleShapeSmoothingFactor)/100.0) * BaleShapeVoltsRollAvSample);
 6106              		.loc 1 2936 0
 6107 01d4 4648     		ldr	r0, .L385+24
 6108 01d6 4749     		ldr	r1, .L385+28
 6109 01d8 221C     		mov	r2, r4
 6110 01da 2B1C     		mov	r3, r5
 6111 01dc FFF7FEFF 		bl	__aeabi_dsub
 6112              	.LVL350:
 6113 01e0 434A     		ldr	r2, .L385+24
 6114 01e2 444B     		ldr	r3, .L385+28
 6115 01e4 FFF7FEFF 		bl	__aeabi_ddiv
 6116              	.LVL351:
 6117 01e8 041C     		mov	r4, r0
 6118 01ea 0D1C     		mov	r5, r1
 6119 01ec 4B4B     		ldr	r3, .L385+68
 6120 01ee 9946     		mov	r9, r3
 6121              	.LVL352:
 6122 01f0 1868     		ldr	r0, [r3]
 6123 01f2 FFF7FEFF 		bl	__aeabi_f2d
 6124              	.LVL353:
 6125 01f6 021C     		mov	r2, r0
 6126 01f8 0B1C     		mov	r3, r1
 6127 01fa 201C     		mov	r0, r4
 6128 01fc 291C     		mov	r1, r5
 6129 01fe FFF7FEFF 		bl	__aeabi_dmul
 6130              	.LVL354:
 6131 0202 021C     		mov	r2, r0
 6132 0204 0B1C     		mov	r3, r1
2935:functions.c   **** 	BaleShapeVoltsRollAvSample = ( ((float)pFac.pf.GW302_BaleShapeSmoothingFactor/100.0) * BaleShapeVo
 6133              		.loc 1 2935 0
 6134 0206 301C     		mov	r0, r6
 6135 0208 391C     		mov	r1, r7
 6136 020a FFF7FEFF 		bl	__aeabi_dadd
 6137              	.LVL355:
 6138 020e FFF7FEFF 		bl	__aeabi_d2f
 6139              	.LVL356:
 6140 0212 4B46     		mov	r3, r9
 6141 0214 1860     		str	r0, [r3]
2937:functions.c   **** 	BaleShapeVolts = BaleShapeVoltsRollAvSample;
 6142              		.loc 1 2937 0
 6143 0216 424B     		ldr	r3, .L385+72
 6144 0218 1860     		str	r0, [r3]
2938:functions.c   **** 
2939:functions.c   **** 	// AnIP4: Knife Pressure
2940:functions.c   **** 	KnifePresVoltsTotAccumMultSamples = (unsigned long int)( (float)KnifePresVoltsTotAccumMultSamples 
 6145              		.loc 1 2940 0
 6146 021a 424C     		ldr	r4, .L385+76
 6147 021c 2068     		ldr	r0, [r4]
 6148 021e FFF7FEFF 		bl	__aeabi_ui2f
 6149              	.LVL357:
 6150 0222 FFF7FEFF 		bl	__aeabi_f2d
 6151              	.LVL358:
 6152 0226 2D4B     		ldr	r3, .L385+4
 6153 0228 2B4A     		ldr	r2, .L385
 6154 022a FFF7FEFF 		bl	__aeabi_dmul
 6155              	.LVL359:
 6156 022e 2C4A     		ldr	r2, .L385+8
 6157 0230 2C4B     		ldr	r3, .L385+12
 6158 0232 FFF7FEFF 		bl	__aeabi_dmul
 6159              	.LVL360:
 6160 0236 2C4A     		ldr	r2, .L385+16
 6161 0238 2C4B     		ldr	r3, .L385+20
 6162 023a FFF7FEFF 		bl	__aeabi_dmul
 6163              	.LVL361:
 6164 023e FFF7FEFF 		bl	__aeabi_d2uiz
 6165              	.LVL362:
 6166 0242 8146     		mov	r9, r0
 6167 0244 2060     		str	r0, [r4]
 6168              	.LVL363:
2941:functions.c   **** 	KnifePresVoltsAvSample = (float)KnifePresVoltsTotAccumMultSamples / (float)(NUM_ACCUMULATED_SAMPLE
2942:functions.c   **** 	KnifePresVoltsRollAvSample = ( ((float)pFac.pf.GW302_KnifePresSmoothingFactor/100.0) * KnifePresVo
 6169              		.loc 1 2942 0
 6170 0246 CF23     		mov	r3, #207
 6171 0248 4246     		mov	r2, r8
 6172 024a D05C     		ldrb	r0, [r2, r3]
 6173              	.LVL364:
 6174 024c FFF7FEFF 		bl	__aeabi_ui2f
 6175              	.LVL365:
 6176 0250 FFF7FEFF 		bl	__aeabi_f2d
 6177              	.LVL366:
 6178 0254 041C     		mov	r4, r0
 6179 0256 0D1C     		mov	r5, r1
 6180 0258 254A     		ldr	r2, .L385+24
 6181 025a 264B     		ldr	r3, .L385+28
 6182 025c FFF7FEFF 		bl	__aeabi_ddiv
 6183              	.LVL367:
 6184 0260 061C     		mov	r6, r0
 6185 0262 0F1C     		mov	r7, r1
2941:functions.c   **** 	KnifePresVoltsAvSample = (float)KnifePresVoltsTotAccumMultSamples / (float)(NUM_ACCUMULATED_SAMPLE
 6186              		.loc 1 2941 0
 6187 0264 4846     		mov	r0, r9
 6188 0266 FFF7FEFF 		bl	__aeabi_ui2f
 6189              	.LVL368:
 6190 026a 2549     		ldr	r1, .L385+40
 6191 026c FFF7FEFF 		bl	__aeabi_fdiv
 6192              	.LVL369:
 6193              		.loc 1 2942 0
 6194 0270 FFF7FEFF 		bl	__aeabi_f2d
 6195              	.LVL370:
 6196 0274 021C     		mov	r2, r0
 6197 0276 0B1C     		mov	r3, r1
 6198 0278 301C     		mov	r0, r6
 6199 027a 391C     		mov	r1, r7
 6200 027c FFF7FEFF 		bl	__aeabi_dmul
 6201              	.LVL371:
 6202 0280 061C     		mov	r6, r0
 6203 0282 0F1C     		mov	r7, r1
2943:functions.c   **** 			( ((100.0 - (float)pFac.pf.GW302_KnifePresSmoothingFactor)/100.0) * KnifePresVoltsRollAvSample);
 6204              		.loc 1 2943 0
 6205 0284 1A48     		ldr	r0, .L385+24
 6206 0286 1B49     		ldr	r1, .L385+28
 6207 0288 221C     		mov	r2, r4
 6208 028a 2B1C     		mov	r3, r5
 6209 028c FFF7FEFF 		bl	__aeabi_dsub
 6210              	.LVL372:
 6211 0290 174A     		ldr	r2, .L385+24
 6212 0292 184B     		ldr	r3, .L385+28
 6213 0294 FFF7FEFF 		bl	__aeabi_ddiv
 6214              	.LVL373:
 6215 0298 041C     		mov	r4, r0
 6216 029a 0D1C     		mov	r5, r1
 6217 029c 224B     		ldr	r3, .L385+80
 6218 029e 9846     		mov	r8, r3
 6219 02a0 1868     		ldr	r0, [r3]
 6220 02a2 FFF7FEFF 		bl	__aeabi_f2d
 6221              	.LVL374:
 6222 02a6 021C     		mov	r2, r0
 6223 02a8 0B1C     		mov	r3, r1
 6224 02aa 201C     		mov	r0, r4
 6225 02ac 291C     		mov	r1, r5
 6226 02ae FFF7FEFF 		bl	__aeabi_dmul
 6227              	.LVL375:
 6228 02b2 021C     		mov	r2, r0
 6229 02b4 0B1C     		mov	r3, r1
2942:functions.c   **** 	KnifePresVoltsRollAvSample = ( ((float)pFac.pf.GW302_KnifePresSmoothingFactor/100.0) * KnifePresVo
 6230              		.loc 1 2942 0
 6231 02b6 301C     		mov	r0, r6
 6232 02b8 391C     		mov	r1, r7
 6233 02ba FFF7FEFF 		bl	__aeabi_dadd
 6234              	.LVL376:
 6235 02be FFF7FEFF 		bl	__aeabi_d2f
 6236              	.LVL377:
 6237 02c2 4346     		mov	r3, r8
 6238 02c4 1860     		str	r0, [r3]
2944:functions.c   **** 	KnifePresVolts = KnifePresVoltsRollAvSample;
 6239              		.loc 1 2944 0
 6240 02c6 194B     		ldr	r3, .L385+84
 6241 02c8 1860     		str	r0, [r3]
2945:functions.c   **** }
 6242              		.loc 1 2945 0
 6243              		@ sp needed for prologue
 6244              	.LVL378:
 6245 02ca 0CBC     		pop	{r2, r3}
 6246 02cc 9046     		mov	r8, r2
 6247 02ce 9946     		mov	r9, r3
 6248 02d0 F8BC     		pop	{r3, r4, r5, r6, r7}
 6249 02d2 01BC     		pop	{r0}
 6250 02d4 0047     		bx	r0
 6251              	.L386:
 6252 02d6 C046     		.align	3
 6253              	.L385:
 6254 02d8 4A0C022B 		.word	721554506
 6255 02dc 8716F93F 		.word	1073288839
 6256 02e0 6D1AD0A6 		.word	-1496311187
 6257 02e4 016D6A3F 		.word	1063939329
 6258 02e8 00000000 		.word	0
 6259 02ec 006AF840 		.word	1090021888
 6260 02f0 00000000 		.word	0
 6261 02f4 00005940 		.word	1079574528
 6262 02f8 00000000 		.word	BaleDiaVoltsTotAccumMultSamples
 6263 02fc 00000000 		.word	.LANCHOR0
 6264 0300 8096984A 		.word	1251513984
 6265 0304 00000000 		.word	.LANCHOR18
 6266 0308 00000000 		.word	BaleDiaVolts
 6267 030c 00000000 		.word	DensityPresVoltsTotAccumMultSamples
 6268 0310 00000000 		.word	.LANCHOR19
 6269 0314 00000000 		.word	DensityPresVolts
 6270 0318 00000000 		.word	BaleShapeVoltsTotAccumMultSamples
 6271 031c 00000000 		.word	.LANCHOR20
 6272 0320 00000000 		.word	BaleShapeVolts
 6273 0324 00000000 		.word	KnifePresVoltsTotAccumMultSamples
 6274 0328 00000000 		.word	.LANCHOR21
 6275 032c 00000000 		.word	KnifePresVolts
 6276              		.cfi_endproc
 6277              	.LFE394:
 6279              		.global	pFac
 6280              		.global	pRun
 6281              		.comm	mcm,72,4
 6282              		.comm	tl_confimation_delay,2,4
 6283              		.comm	tl_target_count,2,4
 6284              		.comm	SavedOP5TurnedOnAfterBeakEngagePulsesEnabled,1,1
 6285              		.comm	OP5TurnedOnAfterBeakEngagePulsesEnabled,1,1
 6286              		.comm	NetPulseCheckingEnabled,1,1
 6287              		.comm	DensityControlFunctionActive,1,1
 6288              		.comm	DrivingArrowBeepsDisabled,1,1
 6289              		.comm	NetPulseCountAtLastCheck,4,4
 6290              		.comm	IP4PulsesStoppedCount,1,1
 6291              		.comm	OP8OnCount,1,1
 6292              		.comm	ChamberStatus,1,1
 6293              		.comm	BaleDiameterStatusInManMode,1,1
 6294              		.comm	BaleKickerStatus,1,1
 6295              		.comm	ChamberOpenBeepDelay,1,1
 6296              		.comm	ChamberOpenDelayTime,1,1
 6297              		.comm	BalerFullDelayTime,1,1
 6298              		.comm	ChamberClosedDelayTime,1,1
 6299              		.comm	ChoppingKnives1WarningOn,1,1
 6300              		.comm	RollEngageTurnedOnInManMode,1,1
 6301              		.global	RollerTimer
 6302              		.comm	NettingStartBeepsDisabledWhileIP3OpenInAutoMode,1,1
 6303              		.comm	NetWarningDisabledWhileIP3OpenInAutoMode,1,1
 6304              		.comm	SavedRollEngageTurnedOn,1,1
 6305              		.comm	RollEngageTurnedOn,1,1
 6306              		.comm	NetWarningOn,1,1
 6307              		.comm	NetWarningDelayTime,1,1
 6308              		.comm	OP8OffDelayTime,1,1
 6309              		.comm	OP8OnDelayTime,1,1
 6310              		.comm	OP7OffDelayTime,1,1
 6311              		.comm	OP2OffDelayTime,1,1
 6312              		.comm	OP2OnDelayTime,1,1
 6313              		.comm	SequenceInProgress,1,1
 6314              		.comm	TargetNetPulses,2,2
 6315              		.comm	NetPulsesPerLayer,4,4
 6316              		.comm	NetPulseFrequency,4,4
 6317              		.comm	NetMetresAppliedForCount,4,4
 6318              		.comm	NetMetresPulseCount,4,4
 6319              		.comm	NewNetPulses,4,4
 6320              		.comm	NetPulseCountPrev,4,4
 6321              		.comm	BeakEngagePulseCount,4,4
 6322              		.comm	NetPulseCount,4,4
 6323              		.comm	cal_speed_pulses,4,4
 6324              		.comm	end_chamber_open_delay_cont_beep,1,1
 6325              		.comm	start_chamber_open_delay_cont_beep,1,1
 6326              		.comm	pre_warning_cont_beep,1,1
 6327              		.comm	target_bale_dia_reached_cont_beep,1,1
 6328              		.comm	cont_beep,1,1
 6329              		.comm	knivesdelay,1,1
 6330              		.comm	stagecomp,1,1
 6331              		.comm	BeepDelay,1,1
 6332              		.comm	DelayTime,1,1
 6333              		.comm	Stage,1,1
 6334              		.comm	TC1_count0,4,4
 6335              		.comm	AllTime,1,1
 6336              		.comm	off_length,4,4
 6337              		.comm	buzz_length,4,4
 6338              		.comm	TC1_millisec_count,4,4
 6339              		.comm	newf6,1,1
 6340              		.comm	f6time,4,4
 6341              		.comm	f0time,4,4
 6342              		.comm	f6count,2,2
 6343              		.comm	f0count,2,2
 6344              		.comm	EOC7_interrupt_count,4,4
 6345              		.comm	TC1_interrupt_count,4,4
 6346              		.comm	KnifePresVoltsTotAccumMultSamples,4,4
 6347              		.comm	BaleShapeVoltsTotAccumMultSamples,4,4
 6348              		.comm	DensityPresVoltsTotAccumMultSamples,4,4
 6349              		.comm	BaleDiaVoltsTotAccumMultSamples,4,4
 6350              		.comm	buzz_count,1,1
 6351              		.comm	PowerSwitchedOff,1,1
 6352              		.comm	RunFactorStatus,1,1
 6353              		.comm	ClockRam,16,4
 6354              		.comm	SavecalDelayOnMainDisplay,1,1
 6355              		.comm	SavecalDelayWithinMenus,1,1
 6356              		.comm	number,16,4
 6357              		.comm	valuechanged,1,1
 6358              		.comm	editing,1,1
 6359              		.comm	savecal,1,1
 6360              		.comm	key,4,4
 6361              		.comm	PreviousWindow,128,4
 6362              		.comm	window,4,4
 6363              		.comm	DensityPressureTooHigh,1,1
 6364              		.comm	DensityFormationVolts,4,4
 6365              		.comm	DensityFormation2Volts,4,4
 6366              		.comm	DensityCoreVolts,4,4
 6367              		.comm	DensityBaleVolts,4,4
 6368              		.comm	DiaPreWarnVolts,4,4
 6369              		.comm	DiaEngageVolts,4,4
 6370              		.comm	DiaCoreVolts,4,4
 6371              		.comm	DiaFormation2Volts,4,4
 6372              		.comm	DiaFormationVolts,4,4
 6373              		.comm	BaleDiaExtDisplayPercent,4,4
 6374              		.comm	DiaTargetExtDisplayPercent,4,4
 6375              		.comm	DiaMinExtDisplayPercent,4,4
 6376              		.comm	DiaMaxVolts,4,4
 6377              		.comm	DiaMinVolts,4,4
 6378              		.comm	DiaTargetVolts,4,4
 6379              		.comm	KeyOpOff,4,4
 6380              		.comm	KeyOpOn,4,4
 6381              		.comm	SeqOpOff,4,4
 6382              		.comm	SeqOpOn,4,4
 6383              		.comm	Kniv1_IPClosed,1,1
 6384              		.comm	SupplyVolts,4,4
 6385              		.comm	KnifePresVolts,4,4
 6386              		.comm	BaleShapeVolts,4,4
 6387              		.comm	DensityPresVolts,4,4
 6388              		.comm	BaleDiaVolts,4,4
 6389              		.comm	StartAutoNet,1,1
 6390              		.comm	ContinueOnKeyRelease,1,1
 6391              		.comm	DisableChoppingKnivesWarnings,1,1
 6392              		.comm	swrel,1,1
 6393              		.comm	AutoMan,1,1
 6394              		.comm	half_second,1,1
 6395              		.comm	offtime,1,1
 6396              		.comm	looptime,1,1
 6397              		.comm	reverttime,1,1
 6398              		.comm	deftime,1,1
 6399              		.comm	nextwindow,1,1
 6400              		.comm	windowdepth,1,1
 6401              		.comm	leaf,1,1
 6402              		.comm	escape,1,1
 6403              		.comm	selection,1,1
 6404              		.comm	startup,1,1
 6405              		.comm	adm,2560,4
 6406              		.comm	buffer,2688,4
 6407              		.comm	ptText,4,4
 6408              		.global	PinOption
 6409              		.global	Bar
 6410              		.global	PresetNetLayers
 6411              		.global	PresetFormation2Density
 6412              		.global	PresetFormation2Diameter
 6413              		.global	PresetFormationDensity
 6414              		.global	PresetFormationDiameter
 6415              		.global	PresetBaleDensity
 6416              		.global	PresetBaleDiameter
 6417              		.global	PresetCoreDensity
 6418              		.global	PresetCoreDiameter
 6419              		.global	PF_GW302_ChoppingKnivesFitted
 6420              		.global	PF_GW302_Formation2Diameter
 6421              		.global	PF_GW302_Formation2Density
 6422              		.global	PF_GW302_FormationDiameter
 6423              		.global	PF_GW302_FormationDensity
 6424              		.global	PF_GW302_DiverterDelay
 6425              		.global	PF_GW302_KnifePresWarn
 6426              		.global	PF_GW302_KnifePressure
 6427              		.global	PF_GW302_Density10
 6428              		.global	PF_GW302_Density9
 6429              		.global	PF_GW302_Density8
 6430              		.global	PF_GW302_Density7
 6431              		.global	PF_GW302_Density6
 6432              		.global	PF_GW302_Density5
 6433              		.global	PF_GW302_Density4
 6434              		.global	PF_GW302_Density3
 6435              		.global	PF_GW302_Density2
 6436              		.global	PF_GW302_Density1
 6437              		.global	PF_GW302_KnifePresSmoothingFactor
 6438              		.global	PF_GW302_BaleShapeSmoothingFactor
 6439              		.global	PF_GW302_DensityPresSmoothingFactor
 6440              		.global	PF_GW302_BaleDiaSmoothingFactor
 6441              		.global	PF_GW302_DiaCorrection
 6442              		.global	PF_GW302_DiameterMax
 6443              		.global	PF_GW302_DiameterMin
 6444              		.global	PF_GW302_TwineOption
 6445              		.global	PF_GW302_BeakEngage
 6446              		.global	PF_GW302_NetSystem
 6447              		.global	PF_GW302_PreNetPulse
 6448              		.global	PF_GW302_NoNetPulse
 6449              		.global	PF_GW302_NetFactor
 6450              		.global	PF_GW302_MaxDiaPulsPerLay
 6451              		.global	PF_GW302_MinDiaPulsPerLay
 6452              		.global	PF_GW302_NetCutTime
 6453              		.global	PF_GW302_NetCutPulse
 6454              		.global	PF_GW302_NetOn
 6455              		.global	PF_GW302_RollerDelay
 6456              		.global	PF_GW302_BaleIndicator
 6457              		.global	PF_GW302_EngageDiameter
 6458              		.global	PF_GW302_FillPotIgnore
 6459              		.global	PF_GW302_FillPotRange
 6460              		.global	PF_GW302_BaleSizeFactor
 6461              		.global	PF_GW302_DoorClosed
 6462              		.global	PF_GW302_PresSwDelay
 6463              		.global	PF_GW302_NetSpeed
 6464              		.global	PF_GW302_PresDeadband
 6465              		.global	PF_GW302_LubeAlarm
 6466              		.global	PF_GW302_NetTwineOption
 6467              		.global	PF_GW302_NetDelay
 6468              		.global	PF_GW302_PreWarningBeep
 6469              		.global	PF_GW302_TotalNetMetres
 6470              		.global	PF_GW302_BaleShapeIndicatorZero
 6471              		.global	PF_GW302_BaleShapeIndicator
 6472              		.global	PF_GW302_DiameterCorrection
 6473              		.global	PF_GW302_DiaPotZero
 6474              		.global	PF_GW302_GrandBaleTotal
 6475              		.global	PF_GW302_BaleStore
 6476              		.global	PF_GW302_BaleTotal
 6477              		.global	PF_GW302_NetLayers
 6478              		.global	PF_GW302_CoreDensity
 6479              		.global	PF_GW302_BaleDensity
 6480              		.global	PF_GW302_CoreDiameter
 6481              		.global	PF_GW302_BaleDiameter
 6482              		.global	PF_GW302_BaleProfile
 6483              		.global	op_status
 6484              		.global	ip_status
 6485              		.global	NCkey
 6486              		.global	LCkey
 6487              		.global	UCkey
 6488              		.global	Store
 6489              		.global	MonthofYear
 6490              		.global	DayofWeek
 6491              		.global	binHex
 6492              		.comm	POWERtaskhandle,4,4
 6493              		.comm	TWItaskhandle,4,4
 6494              		.comm	SetTime,4,4
 6495              		.section	.rodata
 6496              		.align	2
 6497              		.set	.LANCHOR11,. + 0
 6498              	.LC0:
 6499 0000 00000400 		.word	262144
 6500 0004 00000800 		.word	524288
 6501 0008 00001000 		.word	1048576
 6502 000c 00002000 		.word	2097152
 6503 0010 00004000 		.word	4194304
 6504 0014 00008000 		.word	8388608
 6505 0018 00000001 		.word	16777216
 6506 001c 00000002 		.word	33554432
 6507              		.section	.rodata.PF_GW302_NoNetPulse,"a",%progbits
 6508              		.align	2
 6511              	PF_GW302_NoNetPulse:
 6512 0000 CDCCCC3D 		.word	1036831949
 6513 0004 00000000 		.word	0
 6514 0008 66661E41 		.word	1092511334
 6515 000c 00008040 		.word	1082130432
 6516              		.section	.rodata.PF_GW302_KnifePressure,"a",%progbits
 6517              		.align	2
 6520              	PF_GW302_KnifePressure:
 6521 0000 0AD7233C 		.word	1008981770
 6522 0004 00000000 		.word	0
 6523 0008 0AD71F41 		.word	1092605706
 6524 000c 6666663F 		.word	1063675494
 6525              		.section	.rodata.PresetBaleDensity,"a",%progbits
 6526              		.align	2
 6527              		.set	.LANCHOR4,. + 0
 6530              	PresetBaleDensity:
 6531 0000 0A       		.byte	10
 6532 0001 09       		.byte	9
 6533 0002 08       		.byte	8
 6534 0003 04       		.byte	4
 6535 0004 02       		.byte	2
 6536 0005 000000   		.section	.rodata.PF_GW302_PreNetPulse,"a",%progbits
 6537              		.align	2
 6540              	PF_GW302_PreNetPulse:
 6541 0000 01       		.byte	1
 6542 0001 00       		.byte	0
 6543 0002 63       		.byte	99
 6544 0003 02       		.byte	2
 6545              		.section	.rodata.str1.4,"aMS",%progbits,1
 6546              		.align	2
 6547              	.LC3:
 6548 0000 25303258 		.ascii	"%02X:%02X\000"
 6548      3A253032 
 6548      5800
 6549 000a 0000     		.space	2
 6550              	.LC223:
 6551 000c 2D2D2D00 		.ascii	"---\000"
 6552              	.LC224:
 6553 0010 4A616E00 		.ascii	"Jan\000"
 6554              	.LC225:
 6555 0014 46656200 		.ascii	"Feb\000"
 6556              	.LC226:
 6557 0018 4D617200 		.ascii	"Mar\000"
 6558              	.LC227:
 6559 001c 41707200 		.ascii	"Apr\000"
 6560              	.LC228:
 6561 0020 4D617900 		.ascii	"May\000"
 6562              	.LC229:
 6563 0024 4A756E00 		.ascii	"Jun\000"
 6564              	.LC230:
 6565 0028 4A756C00 		.ascii	"Jul\000"
 6566              	.LC231:
 6567 002c 41756700 		.ascii	"Aug\000"
 6568              	.LC232:
 6569 0030 53657000 		.ascii	"Sep\000"
 6570              	.LC233:
 6571 0034 4F637400 		.ascii	"Oct\000"
 6572              	.LC234:
 6573 0038 4E6F7600 		.ascii	"Nov\000"
 6574              	.LC235:
 6575 003c 44656300 		.ascii	"Dec\000"
 6576              	.LC236:
 6577 0040 53756E00 		.ascii	"Sun\000"
 6578              	.LC237:
 6579 0044 4D6F6E00 		.ascii	"Mon\000"
 6580              	.LC238:
 6581 0048 54756500 		.ascii	"Tue\000"
 6582              	.LC239:
 6583 004c 57656400 		.ascii	"Wed\000"
 6584              	.LC240:
 6585 0050 54687200 		.ascii	"Thr\000"
 6586              	.LC241:
 6587 0054 46726900 		.ascii	"Fri\000"
 6588              	.LC242:
 6589 0058 53617400 		.ascii	"Sat\000"
 6590              		.section	.rodata.PF_GW302_GrandBaleTotal,"a",%progbits
 6591              		.align	2
 6594              	PF_GW302_GrandBaleTotal:
 6595 0000 01000000 		.word	1
 6596 0004 00000000 		.word	0
 6597 0008 3F420F00 		.word	999999
 6598 000c 00000000 		.word	0
 6599              		.section	.rodata.PF_GW302_NetCutTime,"a",%progbits
 6600              		.align	2
 6603              	PF_GW302_NetCutTime:
 6604 0000 CDCCCC3D 		.word	1036831949
 6605 0004 00000000 		.word	0
 6606 0008 66661E41 		.word	1092511334
 6607 000c 0000C040 		.word	1086324736
 6608              		.section	.rodata.PF_GW302_TwineOption,"a",%progbits
 6609              		.align	2
 6612              	PF_GW302_TwineOption:
 6613 0000 01       		.byte	1
 6614 0001 00       		.byte	0
 6615 0002 01       		.byte	1
 6616 0003 00       		.byte	0
 6617              		.section	.rodata.PF_GW302_DiameterMax,"a",%progbits
 6618              		.align	2
 6621              	PF_GW302_DiameterMax:
 6622 0000 01       		.byte	1
 6623 0001 00       		.byte	0
 6624 0002 64       		.byte	100
 6625 0003 64       		.byte	100
 6626              		.section	.rodata.PF_GW302_NetLayers,"a",%progbits
 6627              		.align	2
 6630              	PF_GW302_NetLayers:
 6631 0000 CDCCCC3D 		.word	1036831949
 6632 0004 0000C03F 		.word	1069547520
 6633 0008 0000C040 		.word	1086324736
 6634 000c 00000000 		.word	0
 6635              		.section	.bss.dutyLast.9531,"aw",%nobits
 6636              		.align	2
 6637              		.set	.LANCHOR14,. + 0
 6640              	dutyLast.9531:
 6641 0000 00000000 		.space	8
 6641      00000000 
 6642              		.section	.rodata.PF_GW302_DiameterMin,"a",%progbits
 6643              		.align	2
 6646              	PF_GW302_DiameterMin:
 6647 0000 01       		.byte	1
 6648 0001 00       		.byte	0
 6649 0002 64       		.byte	100
 6650 0003 08       		.byte	8
 6651              		.section	.rodata.PF_GW302_RollerDelay,"a",%progbits
 6652              		.align	2
 6655              	PF_GW302_RollerDelay:
 6656 0000 CDCCCC3D 		.word	1036831949
 6657 0004 00000000 		.word	0
 6658 0008 66661E41 		.word	1092511334
 6659 000c 0000003F 		.word	1056964608
 6660              		.section	.rodata.PresetCoreDiameter,"a",%progbits
 6661              		.align	2
 6662              		.set	.LANCHOR3,. + 0
 6665              	PresetCoreDiameter:
 6666 0000 46       		.byte	70
 6667 0001 46       		.byte	70
 6668 0002 46       		.byte	70
 6669 0003 5A       		.byte	90
 6670 0004 5A       		.byte	90
 6671 0005 000000   		.section	.rodata.PF_GW302_ChoppingKnivesFitted,"a",%progbits
 6672              		.align	2
 6675              	PF_GW302_ChoppingKnivesFitted:
 6676 0000 01       		.byte	1
 6677 0001 00       		.byte	0
 6678 0002 01       		.byte	1
 6679 0003 00       		.byte	0
 6680              		.section	.bss.BaleShapeVoltsRollAvSample.9647,"aw",%nobits
 6681              		.align	2
 6682              		.set	.LANCHOR20,. + 0
 6685              	BaleShapeVoltsRollAvSample.9647:
 6686 0000 00000000 		.space	4
 6687              		.section	.rodata.PF_GW302_NetTwineOption,"a",%progbits
 6688              		.align	2
 6691              	PF_GW302_NetTwineOption:
 6692 0000 01       		.byte	1
 6693 0001 00       		.byte	0
 6694 0002 01       		.byte	1
 6695 0003 00       		.byte	0
 6696              		.section	.rodata.NCkey,"a",%progbits
 6697              		.align	2
 6700              	NCkey:
 6701 0000 30313233 		.ascii	"0123456789.+-\261!#\242\243$\000"
 6701      34353637 
 6701      38392E2B 
 6701      2DB12123 
 6701      A2A32400 
 6702              		.section	.rodata.ip_status,"a",%progbits
 6703              		.align	2
 6706              	ip_status:
 6707 0000 00000000 		.word	SWOPEN
 6708 0004 00000000 		.word	SWCLOSED
 6709              		.section	.rodata.PF_GW302_FormationDensity,"a",%progbits
 6710              		.align	2
 6713              	PF_GW302_FormationDensity:
 6714 0000 01       		.byte	1
 6715 0001 01       		.byte	1
 6716 0002 0A       		.byte	10
 6717 0003 00       		.byte	0
 6718              		.section	.rodata.PF_GW302_PreWarningBeep,"a",%progbits
 6719              		.align	2
 6722              	PF_GW302_PreWarningBeep:
 6723 0000 01       		.byte	1
 6724 0001 01       		.byte	1
 6725 0002 64       		.byte	100
 6726 0003 5A       		.byte	90
 6727              		.section	.bss.Kniv1_IPOpenTime.9600,"aw",%nobits
 6728              		.set	.LANCHOR17,. + 0
 6731              	Kniv1_IPOpenTime.9600:
 6732 0000 00       		.space	1
 6733              		.section	.rodata.PresetCoreDensity,"a",%progbits
 6734              		.align	2
 6735              		.set	.LANCHOR5,. + 0
 6738              	PresetCoreDensity:
 6739 0000 09       		.byte	9
 6740 0001 08       		.byte	8
 6741 0002 07       		.byte	7
 6742 0003 03       		.byte	3
 6743 0004 01       		.byte	1
 6744 0005 000000   		.section	.rodata.PF_GW302_BaleIndicator,"a",%progbits
 6745              		.align	2
 6748              	PF_GW302_BaleIndicator:
 6749 0000 01       		.byte	1
 6750 0001 00       		.byte	0
 6751 0002 01       		.byte	1
 6752 0003 00       		.byte	0
 6753              		.section	.rodata.PF_GW302_PresDeadband,"a",%progbits
 6754              		.align	2
 6757              	PF_GW302_PresDeadband:
 6758 0000 0AD7233C 		.word	1008981770
 6759 0004 00000000 		.word	0
 6760 0008 0AD71F41 		.word	1092605706
 6761 000c 00000000 		.word	0
 6762              		.section	.rodata.PF_GW302_Formation2Density,"a",%progbits
 6763              		.align	2
 6766              	PF_GW302_Formation2Density:
 6767 0000 01       		.byte	1
 6768 0001 01       		.byte	1
 6769 0002 0A       		.byte	10
 6770 0003 00       		.byte	0
 6771              		.section	.rodata.PF_GW302_MinDiaPulsPerLay,"a",%progbits
 6772              		.align	2
 6775              	PF_GW302_MinDiaPulsPerLay:
 6776 0000 CDCCCC3D 		.word	1036831949
 6777 0004 00000000 		.word	0
 6778 0008 9AF97944 		.word	1148844442
 6779 000c 00001842 		.word	1108869120
 6780              		.section	.rodata.PF_GW302_BaleSizeFactor,"a",%progbits
 6781              		.align	2
 6784              	PF_GW302_BaleSizeFactor:
 6785 0000 01       		.byte	1
 6786 0001 64       		.byte	100
 6787 0002 FA       		.byte	-6
 6788 0003 DD       		.byte	-35
 6789              		.section	.rodata.DayofWeek,"a",%progbits
 6790              		.align	2
 6793              	DayofWeek:
 6794 0000 40000000 		.word	.LC236
 6795 0004 44000000 		.word	.LC237
 6796 0008 48000000 		.word	.LC238
 6797 000c 4C000000 		.word	.LC239
 6798 0010 50000000 		.word	.LC240
 6799 0014 54000000 		.word	.LC241
 6800 0018 58000000 		.word	.LC242
 6801              		.section	.rodata.PF_GW302_Density10,"a",%progbits
 6802              		.align	2
 6805              	PF_GW302_Density10:
 6806 0000 0AD7233C 		.word	1008981770
 6807 0004 00000000 		.word	0
 6808 0008 00002041 		.word	1092616192
 6809 000c 00008040 		.word	1082130432
 6810              		.section	.rodata.PF_GW302_Density1,"a",%progbits
 6811              		.align	2
 6814              	PF_GW302_Density1:
 6815 0000 0AD7233C 		.word	1008981770
 6816 0004 00000000 		.word	0
 6817 0008 00002041 		.word	1092616192
 6818 000c 00000000 		.word	0
 6819              		.section	.rodata.PF_GW302_Density2,"a",%progbits
 6820              		.align	2
 6823              	PF_GW302_Density2:
 6824 0000 0AD7233C 		.word	1008981770
 6825 0004 00000000 		.word	0
 6826 0008 00002041 		.word	1092616192
 6827 000c CDCC4C3F 		.word	1061997773
 6828              		.section	.rodata.PF_GW302_Density3,"a",%progbits
 6829              		.align	2
 6832              	PF_GW302_Density3:
 6833 0000 0AD7233C 		.word	1008981770
 6834 0004 00000000 		.word	0
 6835 0008 00002041 		.word	1092616192
 6836 000c 9A99993F 		.word	1067030938
 6837              		.section	.bss.BaleDiaVoltsRollAvSample.9645,"aw",%nobits
 6838              		.align	2
 6839              		.set	.LANCHOR18,. + 0
 6842              	BaleDiaVoltsRollAvSample.9645:
 6843 0000 00000000 		.space	4
 6844              		.section	.rodata.PF_GW302_Density5,"a",%progbits
 6845              		.align	2
 6848              	PF_GW302_Density5:
 6849 0000 0AD7233C 		.word	1008981770
 6850 0004 00000000 		.word	0
 6851 0008 00002041 		.word	1092616192
 6852 000c 00000040 		.word	1073741824
 6853              		.section	.rodata.PF_GW302_BaleShapeSmoothingFactor,"a",%progbits
 6854              		.align	2
 6857              	PF_GW302_BaleShapeSmoothingFactor:
 6858 0000 01       		.byte	1
 6859 0001 01       		.byte	1
 6860 0002 64       		.byte	100
 6861 0003 32       		.byte	50
 6862              		.section	.rodata.PF_GW302_BaleTotal,"a",%progbits
 6863              		.align	2
 6866              	PF_GW302_BaleTotal:
 6867 0000 01000000 		.word	1
 6868 0004 00000000 		.word	0
 6869 0008 0F270000 		.word	9999
 6870 000c 00000000 		.word	0
 6871              		.section	.rodata.PF_GW302_Density8,"a",%progbits
 6872              		.align	2
 6875              	PF_GW302_Density8:
 6876 0000 0AD7233C 		.word	1008981770
 6877 0004 00000000 		.word	0
 6878 0008 00002041 		.word	1092616192
 6879 000c CDCC4C40 		.word	1078774989
 6880              		.section	.bss.status.9530,"aw",%nobits
 6881              		.align	2
 6882              		.set	.LANCHOR12,. + 0
 6885              	status.9530:
 6886 0000 00000000 		.space	4
 6887              		.section	.rodata.PF_GW302_BaleShapeIndicator,"a",%progbits
 6888              		.align	2
 6891              	PF_GW302_BaleShapeIndicator:
 6892 0000 01       		.byte	1
 6893 0001 00       		.byte	0
 6894 0002 02       		.byte	2
 6895 0003 00       		.byte	0
 6896              		.section	.rodata.PF_GW302_BaleStore,"a",%progbits
 6897              		.align	2
 6900              	PF_GW302_BaleStore:
 6901 0000 01       		.byte	1
 6902 0001 00       		.byte	0
 6903 0002 09       		.byte	9
 6904 0003 00       		.byte	0
 6905              		.section	.rodata.PF_GW302_TotalNetMetres,"a",%progbits
 6906              		.align	2
 6909              	PF_GW302_TotalNetMetres:
 6910 0000 00000000 		.word	0
 6911 0004 00000000 		.word	0
 6912 0008 003C1C46 		.word	1176255488
 6913 000c 00000000 		.word	0
 6914              		.section	.rodata.PF_GW302_PresSwDelay,"a",%progbits
 6915              		.align	2
 6918              	PF_GW302_PresSwDelay:
 6919 0000 CDCCCC3D 		.word	1036831949
 6920 0004 00000000 		.word	0
 6921 0008 66661E41 		.word	1092511334
 6922 000c CDCC4C3E 		.word	1045220557
 6923              		.section	.rodata.PF_GW302_EngageDiameter,"a",%progbits
 6924              		.align	2
 6927              	PF_GW302_EngageDiameter:
 6928 0000 01       		.byte	1
 6929 0001 00       		.byte	0
 6930 0002 64       		.byte	100
 6931 0003 5F       		.byte	95
 6932              		.section	.rodata.PF_GW302_NetSpeed,"a",%progbits
 6933              		.align	2
 6936              	PF_GW302_NetSpeed:
 6937 0000 CDCCCC3D 		.word	1036831949
 6938 0004 00000000 		.word	0
 6939 0008 0000C642 		.word	1120272384
 6940 000c 00004842 		.word	1112014848
 6941              		.section	.rodata.PF_GW302_NetFactor,"a",%progbits
 6942              		.align	2
 6945              	PF_GW302_NetFactor:
 6946 0000 CDCCCC3D 		.word	1036831949
 6947 0004 00000000 		.word	0
 6948 0008 66661E41 		.word	1092511334
 6949 000c 0000803F 		.word	1065353216
 6950              		.section	.IRamNV,"aw",%progbits
 6951              		.align	2
 6952              		.set	.LANCHOR0,. + 0
 6953              		.set	.LANCHOR10,. + 256
 6956              	pFac:
 6957 0000 00000000 		.space	288
 6957      00000000 
 6957      00000000 
 6957      00000000 
 6957      00000000 
 6960              	pRun:
 6961 0120 00000000 		.space	16
 6961      00000000 
 6961      00000000 
 6961      00000000 
 6962              		.section	.rodata.PresetFormationDensity,"a",%progbits
 6963              		.align	2
 6964              		.set	.LANCHOR6,. + 0
 6967              	PresetFormationDensity:
 6968 0000 0A       		.byte	10
 6969 0001 0A       		.byte	10
 6970 0002 0A       		.byte	10
 6971 0003 05       		.byte	5
 6972 0004 05       		.byte	5
 6973 0005 000000   		.section	.rodata.PF_GW302_NetCutPulse,"a",%progbits
 6974              		.align	2
 6977              	PF_GW302_NetCutPulse:
 6978 0000 01       		.byte	1
 6979 0001 00       		.byte	0
 6980 0002 63       		.byte	99
 6981 0003 28       		.byte	40
 6982              		.section	.rodata.op_status,"a",%progbits
 6983              		.align	2
 6986              	op_status:
 6987 0000 00000000 		.word	BUTTON04
 6988 0004 00000000 		.word	BUTTON01
 6989              		.section	.rodata.PF_GW302_LubeAlarm,"a",%progbits
 6990              		.align	2
 6993              	PF_GW302_LubeAlarm:
 6994 0000 0100     		.short	1
 6995 0002 0000     		.short	0
 6996 0004 E703     		.short	999
 6997 0006 2C01     		.short	300
 6998              		.section	.rodata.PF_GW302_KnifePresSmoothingFactor,"a",%progbits
 6999              		.align	2
 7002              	PF_GW302_KnifePresSmoothingFactor:
 7003 0000 01       		.byte	1
 7004 0001 01       		.byte	1
 7005 0002 64       		.byte	100
 7006 0003 32       		.byte	50
 7007              		.section	.rodata.PresetFormation2Density,"a",%progbits
 7008              		.align	2
 7009              		.set	.LANCHOR8,. + 0
 7012              	PresetFormation2Density:
 7013 0000 0A       		.byte	10
 7014 0001 0A       		.byte	10
 7015 0002 0A       		.byte	10
 7016 0003 05       		.byte	5
 7017 0004 05       		.byte	5
 7018 0005 000000   		.section	.rodata.PF_GW302_FillPotIgnore,"a",%progbits
 7019              		.align	2
 7022              	PF_GW302_FillPotIgnore:
 7023 0000 0AD7233C 		.word	1008981770
 7024 0004 00000000 		.word	0
 7025 0008 0AD71F41 		.word	1092605706
 7026 000c 0000803E 		.word	1048576000
 7027              		.section	.rodata.PF_GW302_NetDelay,"a",%progbits
 7028              		.align	2
 7031              	PF_GW302_NetDelay:
 7032 0000 CDCCCC3D 		.word	1036831949
 7033 0004 00000000 		.word	0
 7034 0008 0000A040 		.word	1084227584
 7035 000c 00000040 		.word	1073741824
 7036              		.section	.rodata.PF_GW302_DiaCorrection,"a",%progbits
 7037              		.align	2
 7040              	PF_GW302_DiaCorrection:
 7041 0000 0AD7233C 		.word	1008981770
 7042 0004 00000000 		.word	0
 7043 0008 CDCC4C3E 		.word	1045220557
 7044 000c 0AD7233C 		.word	1008981770
 7045              		.section	.rodata.LCkey,"a",%progbits
 7046              		.align	2
 7049              	LCkey:
 7050 0000 2061E0E1 		.ascii	" a\340\341\342\343\344\345\346bc\347de\350\351\352\353"
 7050      E2E3E4E5 
 7050      E66263E7 
 7050      6465E8E9 
 7050      EAEB
 7051 0012 66676869 		.ascii	"fghi\354\355\356\357\360jklmn\361o\362\363\364\365\366"
 7051      ECEDEEEF 
 7051      F06A6B6C 
 7051      6D6EF16F 
 7051      F2F3F4F5 
 7052 0027 F8707172 		.ascii	"\370pqrstu\371\372\373\374vwxy\375\377z\376\000"
 7052      737475F9 
 7052      FAFBFC76 
 7052      777879FD 
 7052      FF7AFE00 
 7053 003b 00       		.section	.rodata.PF_GW302_BaleDiameter,"a",%progbits
 7054              		.align	2
 7057              	PF_GW302_BaleDiameter:
 7058 0000 01       		.byte	1
 7059 0001 3C       		.byte	60
 7060 0002 A8       		.byte	-88
 7061 0003 00       		.byte	0
 7062              		.section	.bss.LastNetPulseCount.9601,"aw",%nobits
 7063              		.align	2
 7064              		.set	.LANCHOR15,. + 0
 7067              	LastNetPulseCount.9601:
 7068 0000 00000000 		.space	4
 7069              		.section	.rodata.PF_GW302_DiameterCorrection,"a",%progbits
 7070              		.align	2
 7073              	PF_GW302_DiameterCorrection:
 7074 0000 01       		.byte	1
 7075 0001 EC       		.byte	-20
 7076 0002 14       		.byte	20
 7077 0003 00       		.byte	0
 7078              		.section	.rodata.PresetBaleDiameter,"a",%progbits
 7079              		.align	2
 7080              		.set	.LANCHOR2,. + 0
 7083              	PresetBaleDiameter:
 7084 0000 7D       		.byte	125
 7085 0001 7D       		.byte	125
 7086 0002 7D       		.byte	125
 7087 0003 7D       		.byte	125
 7088 0004 7D       		.byte	125
 7089 0005 000000   		.section	.rodata.Store,"a",%progbits
 7090              		.align	2
 7093              	Store:
 7094 0000 41       		.byte	65
 7095 0001 42       		.byte	66
 7096 0002 43       		.byte	67
 7097 0003 44       		.byte	68
 7098 0004 45       		.byte	69
 7099 0005 46       		.byte	70
 7100 0006 47       		.byte	71
 7101 0007 48       		.byte	72
 7102 0008 49       		.byte	73
 7103 0009 4A       		.byte	74
 7104 000a 0000     		.section	.rodata.PresetNetLayers,"a",%progbits
 7105              		.align	2
 7106              		.set	.LANCHOR1,. + 0
 7109              	PresetNetLayers:
 7110 0000 00006040 		.word	1080033280
 7111 0004 00004040 		.word	1077936128
 7112 0008 00002040 		.word	1075838976
 7113 000c 66668640 		.word	1082549862
 7114 0010 66668640 		.word	1082549862
 7115              		.section	.rodata.PF_GW302_BaleDensity,"a",%progbits
 7116              		.align	2
 7119              	PF_GW302_BaleDensity:
 7120 0000 01       		.byte	1
 7121 0001 01       		.byte	1
 7122 0002 0A       		.byte	10
 7123 0003 00       		.byte	0
 7124              		.section	.rodata.binHex,"a",%progbits
 7125              		.align	2
 7128              	binHex:
 7129 0000 30       		.byte	48
 7130 0001 31       		.byte	49
 7131 0002 32       		.byte	50
 7132 0003 33       		.byte	51
 7133 0004 34       		.byte	52
 7134 0005 35       		.byte	53
 7135 0006 36       		.byte	54
 7136 0007 37       		.byte	55
 7137 0008 38       		.byte	56
 7138 0009 39       		.byte	57
 7139 000a 41       		.byte	65
 7140 000b 42       		.byte	66
 7141 000c 43       		.byte	67
 7142 000d 44       		.byte	68
 7143 000e 45       		.byte	69
 7144 000f 46       		.byte	70
 7145              		.section	.rodata.PF_GW302_BaleShapeIndicatorZero,"a",%progbits
 7146              		.align	2
 7149              	PF_GW302_BaleShapeIndicatorZero:
 7150 0000 00000000 		.word	0
 7151 0004 00000000 		.word	0
 7152 0008 00001041 		.word	1091567616
 7153 000c 00002040 		.word	1075838976
 7154              		.section	.rodata.PF_GW302_DiaPotZero,"a",%progbits
 7155              		.align	2
 7158              	PF_GW302_DiaPotZero:
 7159 0000 00000000 		.word	0
 7160 0004 00000000 		.word	0
 7161 0008 00000000 		.word	0
 7162 000c 0000803F 		.word	1065353216
 7163              		.section	.rodata.UCkey,"a",%progbits
 7164              		.align	2
 7167              	UCkey:
 7168 0000 20C0C1C2 		.ascii	" \300\301\302\303\304\305\306ABC\307DE\310\311\312\313"
 7168      C3C4C5C6 
 7168      414243C7 
 7168      4445C8C9 
 7168      CACB
 7169 0012 46474849 		.ascii	"FGHI\314\315\316\317\320JKLMN\321O\322\323\324\325\326"
 7169      CCCDCECF 
 7169      D04A4B4C 
 7169      4D4ED14F 
 7169      D2D3D4D5 
 7170 0027 D8505152 		.ascii	"\330PQRSTU\331\332\333\334VWXY\335\337Z\336\000"
 7170      535455D9 
 7170      DADBDC56 
 7170      575859DD 
 7170      DF5ADE00 
 7171 003b 00       		.section	.rodata.PF_GW302_DensityPresSmoothingFactor,"a",%progbits
 7172              		.align	2
 7175              	PF_GW302_DensityPresSmoothingFactor:
 7176 0000 01       		.byte	1
 7177 0001 01       		.byte	1
 7178 0002 64       		.byte	100
 7179 0003 64       		.byte	100
 7180              		.section	.bss.DensityPresVoltsRollAvSample.9646,"aw",%nobits
 7181              		.align	2
 7182              		.set	.LANCHOR19,. + 0
 7185              	DensityPresVoltsRollAvSample.9646:
 7186 0000 00000000 		.space	4
 7187              		.section	.rodata.PF_GW302_NetSystem,"a",%progbits
 7188              		.align	2
 7191              	PF_GW302_NetSystem:
 7192 0000 01       		.byte	1
 7193 0001 00       		.byte	0
 7194 0002 01       		.byte	1
 7195 0003 01       		.byte	1
 7196              		.section	.rodata.PF_GW302_Density4,"a",%progbits
 7197              		.align	2
 7200              	PF_GW302_Density4:
 7201 0000 0AD7233C 		.word	1008981770
 7202 0004 00000000 		.word	0
 7203 0008 00002041 		.word	1092616192
 7204 000c CDCCCC3F 		.word	1070386381
 7205              		.section	.rodata.PF_GW302_Density6,"a",%progbits
 7206              		.align	2
 7209              	PF_GW302_Density6:
 7210 0000 0AD7233C 		.word	1008981770
 7211 0004 00000000 		.word	0
 7212 0008 00002041 		.word	1092616192
 7213 000c 9A991940 		.word	1075419546
 7214              		.section	.rodata.PF_GW302_Density7,"a",%progbits
 7215              		.align	2
 7218              	PF_GW302_Density7:
 7219 0000 0AD7233C 		.word	1008981770
 7220 0004 00000000 		.word	0
 7221 0008 00002041 		.word	1092616192
 7222 000c 33333340 		.word	1077097267
 7223              		.section	.rodata.PF_GW302_Density9,"a",%progbits
 7224              		.align	2
 7227              	PF_GW302_Density9:
 7228 0000 0AD7233C 		.word	1008981770
 7229 0004 00000000 		.word	0
 7230 0008 00002041 		.word	1092616192
 7231 000c 66666640 		.word	1080452710
 7232              		.section	.rodata.PF_GW302_KnifePresWarn,"a",%progbits
 7233              		.align	2
 7236              	PF_GW302_KnifePresWarn:
 7237 0000 0AD7233C 		.word	1008981770
 7238 0004 00000000 		.word	0
 7239 0008 0AD71F41 		.word	1092605706
 7240 000c 6666A63F 		.word	1067869798
 7241              		.section	.rodata.PF_GW302_FormationDiameter,"a",%progbits
 7242              		.align	2
 7245              	PF_GW302_FormationDiameter:
 7246 0000 01       		.byte	1
 7247 0001 00       		.byte	0
 7248 0002 64       		.byte	100
 7249 0003 00       		.byte	0
 7250              		.section	.rodata.PF_GW302_MaxDiaPulsPerLay,"a",%progbits
 7251              		.align	2
 7254              	PF_GW302_MaxDiaPulsPerLay:
 7255 0000 CDCCCC3D 		.word	1036831949
 7256 0004 00000000 		.word	0
 7257 0008 9AF97944 		.word	1148844442
 7258 000c 0000D842 		.word	1121452032
 7259              		.section	.rodata.PF_GW302_BaleProfile,"a",%progbits
 7260              		.align	2
 7263              	PF_GW302_BaleProfile:
 7264 0000 01       		.byte	1
 7265 0001 00       		.byte	0
 7266 0002 04       		.byte	4
 7267 0003 00       		.byte	0
 7268              		.section	.data.RollerTimer,"aw",%progbits
 7269              		.set	.LANCHOR16,. + 0
 7272              	RollerTimer:
 7273 0000 FF       		.byte	-1
 7274              		.section	.rodata.Bar,"a",%progbits
 7275              		.align	2
 7278              	Bar:
 7279 0000 00       		.byte	0
 7280 0001 28       		.byte	40
 7281 0002 3C       		.byte	60
 7282 0003 50       		.byte	80
 7283 0004 64       		.byte	100
 7284 0005 78       		.byte	120
 7285 0006 8C       		.byte	-116
 7286 0007 A0       		.byte	-96
 7287 0008 B4       		.byte	-76
 7288 0009 C8       		.byte	-56
 7289 000a 0000     		.section	.rodata.PF_GW302_Formation2Diameter,"a",%progbits
 7290              		.align	2
 7293              	PF_GW302_Formation2Diameter:
 7294 0000 01       		.byte	1
 7295 0001 00       		.byte	0
 7296 0002 64       		.byte	100
 7297 0003 00       		.byte	0
 7298              		.section	.rodata.PF_GW302_CoreDensity,"a",%progbits
 7299              		.align	2
 7302              	PF_GW302_CoreDensity:
 7303 0000 01       		.byte	1
 7304 0001 01       		.byte	1
 7305 0002 0A       		.byte	10
 7306 0003 00       		.byte	0
 7307              		.section	.rodata.PF_GW302_BaleDiaSmoothingFactor,"a",%progbits
 7308              		.align	2
 7311              	PF_GW302_BaleDiaSmoothingFactor:
 7312 0000 01       		.byte	1
 7313 0001 01       		.byte	1
 7314 0002 64       		.byte	100
 7315 0003 32       		.byte	50
 7316              		.section	.bss.KnifePresVoltsRollAvSample.9648,"aw",%nobits
 7317              		.align	2
 7318              		.set	.LANCHOR21,. + 0
 7321              	KnifePresVoltsRollAvSample.9648:
 7322 0000 00000000 		.space	4
 7323              		.section	.rodata.PF_GW302_NetOn,"a",%progbits
 7324              		.align	2
 7327              	PF_GW302_NetOn:
 7328 0000 CDCCCC3D 		.word	1036831949
 7329 0004 00000000 		.word	0
 7330 0008 66661E41 		.word	1092511334
 7331 000c 00004040 		.word	1077936128
 7332              		.section	.rodata.PF_GW302_FillPotRange,"a",%progbits
 7333              		.align	2
 7336              	PF_GW302_FillPotRange:
 7337 0000 0AD7233C 		.word	1008981770
 7338 0004 00000000 		.word	0
 7339 0008 0AD71F41 		.word	1092605706
 7340 000c 0000803F 		.word	1065353216
 7341              		.section	.rodata.PF_GW302_BeakEngage,"a",%progbits
 7342              		.align	2
 7345              	PF_GW302_BeakEngage:
 7346 0000 01       		.byte	1
 7347 0001 00       		.byte	0
 7348 0002 63       		.byte	99
 7349 0003 06       		.byte	6
 7350              		.section	.rodata.PF_GW302_DiverterDelay,"a",%progbits
 7351              		.align	2
 7354              	PF_GW302_DiverterDelay:
 7355 0000 CDCCCC3D 		.word	1036831949
 7356 0004 00000000 		.word	0
 7357 0008 66661E41 		.word	1092511334
 7358 000c CDCC4C3E 		.word	1045220557
 7359              		.section	.rodata.PF_GW302_DoorClosed,"a",%progbits
 7360              		.align	2
 7363              	PF_GW302_DoorClosed:
 7364 0000 CDCCCC3D 		.word	1036831949
 7365 0004 00000000 		.word	0
 7366 0008 66661E41 		.word	1092511334
 7367 000c 0000C03F 		.word	1069547520
 7368              		.section	.bss.freqLast.9532,"aw",%nobits
 7369              		.align	2
 7370              		.set	.LANCHOR13,. + 0
 7373              	freqLast.9532:
 7374 0000 00000000 		.space	16
 7374      00000000 
 7374      00000000 
 7374      00000000 
 7375              		.section	.rodata.PF_GW302_CoreDiameter,"a",%progbits
 7376              		.align	2
 7379              	PF_GW302_CoreDiameter:
 7380 0000 01       		.byte	1
 7381 0001 3C       		.byte	60
 7382 0002 82       		.byte	-126
 7383 0003 00       		.byte	0
 7384              		.section	.rodata.PresetFormation2Diameter,"a",%progbits
 7385              		.align	2
 7386              		.set	.LANCHOR9,. + 0
 7389              	PresetFormation2Diameter:
 7390 0000 00000000 		.space	5
 7390      00
 7391 0005 000000   		.section	.rodata.PinOption,"a",%progbits
 7392              		.align	2
 7395              	PinOption:
 7396 0000 910D     		.short	3473
 7397 0002 0000     		.space	2
 7398 0004 00000000 		.word	screen141
 7399              		.section	.rodata.PresetFormationDiameter,"a",%progbits
 7400              		.align	2
 7401              		.set	.LANCHOR7,. + 0
 7404              	PresetFormationDiameter:
 7405 0000 00000000 		.space	5
 7405      00
 7406 0005 000000   		.section	.rodata.MonthofYear,"a",%progbits
 7407              		.align	2
 7410              	MonthofYear:
 7411 0000 0C000000 		.word	.LC223
 7412 0004 10000000 		.word	.LC224
 7413 0008 14000000 		.word	.LC225
 7414 000c 18000000 		.word	.LC226
 7415 0010 1C000000 		.word	.LC227
 7416 0014 20000000 		.word	.LC228
 7417 0018 24000000 		.word	.LC229
 7418 001c 28000000 		.word	.LC230
 7419 0020 2C000000 		.word	.LC231
 7420 0024 30000000 		.word	.LC232
 7421 0028 34000000 		.word	.LC233
 7422 002c 38000000 		.word	.LC234
 7423 0030 3C000000 		.word	.LC235
 7424              		.text
 7425              	.Letext0:
 7426              		.file 3 "./include/AT91SAM7A3.h"
 7427              		.file 4 "./include/task.h"
 7428              		.file 5 "./include/queue.h"
 7429              		.file 6 "./include/semphr.h"
 7430              		.file 7 "Board.h"
 7431              		.file 8 "bm_f1all.h"
 7432              		.file 9 "c:/gnuarm-471_eabi/lib/gcc/../../arm-none-eabi/sys-include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:00000000 functions.c
  C:\Temp\cczXv9hx.s:18     .text.ClockDisplay:00000000 $t
  C:\Temp\cczXv9hx.s:23     .text.ClockDisplay:00000000 ClockDisplay
  C:\Temp\cczXv9hx.s:116    .text.ClockDisplay:00000074 $d
                            *COM*:00000a00 adm
                            *COM*:00000010 ClockRam
                            *COM*:00000001 half_second
  C:\Temp\cczXv9hx.s:125    .text.CheckSumIt:00000000 $t
  C:\Temp\cczXv9hx.s:130    .text.CheckSumIt:00000000 CheckSumIt
  C:\Temp\cczXv9hx.s:174    .text.SetDefaultFactors:00000000 $t
  C:\Temp\cczXv9hx.s:179    .text.SetDefaultFactors:00000000 SetDefaultFactors
  C:\Temp\cczXv9hx.s:594    .text.SetDefaultFactors:0000023c $d
                            *COM*:00000004 ptText
  C:\Temp\cczXv9hx.s:629    .text.SetDefaultTotals:00000000 $t
  C:\Temp\cczXv9hx.s:634    .text.SetDefaultTotals:00000000 SetDefaultTotals
  C:\Temp\cczXv9hx.s:711    .text.SetDefaultTotals:00000064 $d
  C:\Temp\cczXv9hx.s:717    .text.SetStartupDefaults:00000000 $t
  C:\Temp\cczXv9hx.s:722    .text.SetStartupDefaults:00000000 SetStartupDefaults
  C:\Temp\cczXv9hx.s:777    .text.SetStartupDefaults:00000044 $d
                            *COM*:00000004 key
                            *COM*:00000004 window
                            *COM*:00000001 looptime
                            *COM*:00000001 AutoMan
  C:\Temp\cczXv9hx.s:794    .text.btobcd:00000000 $t
  C:\Temp\cczXv9hx.s:799    .text.btobcd:00000000 btobcd
  C:\Temp\cczXv9hx.s:833    .text.bcdtob:00000000 $t
  C:\Temp\cczXv9hx.s:838    .text.bcdtob:00000000 bcdtob
  C:\Temp\cczXv9hx.s:862    .text.SetOutputPWM:00000000 $t
  C:\Temp\cczXv9hx.s:867    .text.SetOutputPWM:00000000 SetOutputPWM
  C:\Temp\cczXv9hx.s:1187   .text.SetOutputPWM:0000018c $d
  C:\Temp\cczXv9hx.s:1201   .text.ResetLubeCount:00000000 $t
  C:\Temp\cczXv9hx.s:1206   .text.ResetLubeCount:00000000 ResetLubeCount
  C:\Temp\cczXv9hx.s:1243   .text.ResetLubeCount:00000028 $d
  C:\Temp\cczXv9hx.s:1262   .text.Inputs:00000000 $t
  C:\Temp\cczXv9hx.s:1267   .text.Inputs:00000000 Inputs
  C:\Temp\cczXv9hx.s:1689   .rodata.Inputs:00000000 $d
  C:\Temp\cczXv9hx.s:1873   .text.Inputs:000003a0 $d
                            *COM*:00000004 DiaMinVolts
                            *COM*:00000004 DiaMaxVolts
                            *COM*:00000004 DiaTargetVolts
                            *COM*:00000004 DiaMinExtDisplayPercent
                            *COM*:00000004 DiaTargetExtDisplayPercent
                            *COM*:00000004 BaleDiaVolts
                            *COM*:00000004 BaleDiaExtDisplayPercent
                            *COM*:00000004 DiaFormationVolts
                            *COM*:00000004 DiaFormation2Volts
                            *COM*:00000004 DiaCoreVolts
                            *COM*:00000004 DiaEngageVolts
                            *COM*:00000004 DiaPreWarnVolts
                            *COM*:00000004 DensityBaleVolts
                            *COM*:00000004 DensityCoreVolts
  C:\Temp\cczXv9hx.s:1898   .text.Inputs:000003fc $t
  C:\Temp\cczXv9hx.s:2176   .text.Inputs:00000554 $d
                            *COM*:00000004 DensityFormation2Volts
                            *COM*:00000004 DensityFormationVolts
  C:\Temp\cczXv9hx.s:2188   .text.CheckAlarms:00000000 $t
  C:\Temp\cczXv9hx.s:2193   .text.CheckAlarms:00000000 CheckAlarms
  C:\Temp\cczXv9hx.s:2651   .text.CheckAlarms:000002b0 $d
                            *COM*:00000004 DensityPresVolts
                            *COM*:00000001 buzz_count
                            *COM*:00000004 buzz_length
                            *COM*:00000001 DensityPressureTooHigh
                            *COM*:00000001 NetWarningOn
                            *COM*:00000004 KnifePresVolts
                            *COM*:00000001 swrel
                            *COM*:00000001 DelayTime
                            *COM*:00000001 DisableChoppingKnivesWarnings
                            *COM*:00000001 ChoppingKnives1WarningOn
                            *COM*:00000004 SupplyVolts
                            *COM*:00000001 BeepDelay
  C:\Temp\cczXv9hx.s:2681   .text.ResetSequenceFactors:00000000 $t
  C:\Temp\cczXv9hx.s:2686   .text.ResetSequenceFactors:00000000 ResetSequenceFactors
  C:\Temp\cczXv9hx.s:2821   .text.ResetSequenceFactors:000000a8 $d
                            *COM*:00000004 SeqOpOn
                            *COM*:00000004 SeqOpOff
                            *COM*:00000001 ContinueOnKeyRelease
                            *COM*:00000001 StartAutoNet
                            *COM*:00000001 Stage
                            *COM*:00000001 stagecomp
                            *COM*:00000001 cont_beep
                            *COM*:00000001 target_bale_dia_reached_cont_beep
                            *COM*:00000001 pre_warning_cont_beep
                            *COM*:00000001 start_chamber_open_delay_cont_beep
                            *COM*:00000001 end_chamber_open_delay_cont_beep
                            *COM*:00000001 SequenceInProgress
                            *COM*:00000001 OP2OnDelayTime
                            *COM*:00000001 OP2OffDelayTime
                            *COM*:00000001 OP7OffDelayTime
                            *COM*:00000001 OP8OnDelayTime
                            *COM*:00000001 OP8OffDelayTime
                            *COM*:00000004 NetPulseCount
                            *COM*:00000004 BeakEngagePulseCount
                            *COM*:00000004 NewNetPulses
                            *COM*:00000001 NetWarningDelayTime
                            *COM*:00000001 RollEngageTurnedOn
                            *COM*:00000001 SavedRollEngageTurnedOn
                            *COM*:00000001 NetWarningDisabledWhileIP3OpenInAutoMode
                            *COM*:00000001 NettingStartBeepsDisabledWhileIP3OpenInAutoMode
                            *COM*:00000001 ChamberClosedDelayTime
                            *COM*:00000001 ChamberOpenDelayTime
                            *COM*:00000001 ChamberOpenBeepDelay
                            *COM*:00000001 BaleKickerStatus
                            *COM*:00000001 BaleDiameterStatusInManMode
                            *COM*:00000001 ChamberStatus
                            *COM*:00000001 OP8OnCount
                            *COM*:00000001 DrivingArrowBeepsDisabled
                            *COM*:00000001 DensityControlFunctionActive
                            *COM*:00000001 NetPulseCheckingEnabled
                            *COM*:00000001 OP5TurnedOnAfterBeakEngagePulsesEnabled
                            *COM*:00000001 SavedOP5TurnedOnAfterBeakEngagePulsesEnabled
  C:\Temp\cczXv9hx.s:2865   .text.AllSeqOpOff:00000000 $t
  C:\Temp\cczXv9hx.s:2870   .text.AllSeqOpOff:00000000 AllSeqOpOff
  C:\Temp\cczXv9hx.s:2892   .text.AllSeqOpOff:00000014 $d
  C:\Temp\cczXv9hx.s:2899   .text.UpdatingAndSavingTotalsToMemory:00000000 $t
  C:\Temp\cczXv9hx.s:2904   .text.UpdatingAndSavingTotalsToMemory:00000000 UpdatingAndSavingTotalsToMemory
  C:\Temp\cczXv9hx.s:3002   .text.UpdatingAndSavingTotalsToMemory:00000080 $d
                            *COM*:00000004 NetMetresAppliedForCount
                            *COM*:00000004 NetMetresPulseCount
                            *COM*:00000001 SavecalDelayOnMainDisplay
  C:\Temp\cczXv9hx.s:3014   .text.CalculateNetPulseFrequency:00000000 $t
  C:\Temp\cczXv9hx.s:3019   .text.CalculateNetPulseFrequency:00000000 CalculateNetPulseFrequency
  C:\Temp\cczXv9hx.s:3068   .text.CalculateNetPulseFrequency:0000003c $d
                            *COM*:00000004 f6time
                            *COM*:00000002 f6count
                            *COM*:00000004 NetPulseFrequency
  C:\Temp\cczXv9hx.s:3076   .text.CalculateNetPulsesPerLayer:00000000 $t
  C:\Temp\cczXv9hx.s:3081   .text.CalculateNetPulsesPerLayer:00000000 CalculateNetPulsesPerLayer
  C:\Temp\cczXv9hx.s:3144   .text.CalculateNetPulsesPerLayer:00000050 $d
                            *COM*:00000004 NetPulsesPerLayer
  C:\Temp\cczXv9hx.s:3154   .text.CalculateTargetNetPulses:00000000 $t
  C:\Temp\cczXv9hx.s:3159   .text.CalculateTargetNetPulses:00000000 CalculateTargetNetPulses
  C:\Temp\cczXv9hx.s:3201   .text.CalculateTargetNetPulses:00000038 $d
                            *COM*:00000002 TargetNetPulses
  C:\Temp\cczXv9hx.s:3210   .text.Sequence:00000000 $t
  C:\Temp\cczXv9hx.s:3215   .text.Sequence:00000000 Sequence
  C:\Temp\cczXv9hx.s:3256   .rodata.Sequence:00000000 $d
  C:\Temp\cczXv9hx.s:3764   .text.Sequence:00000360 $d
                            *COM*:00000001 AllTime
  C:\Temp\cczXv9hx.s:3787   .text.Sequence:000003b4 $t
  C:\Temp\cczXv9hx.s:4335   .text.Sequence:00000700 $d
                            *COM*:00000001 IP4PulsesStoppedCount
                            *COM*:00000004 NetPulseCountAtLastCheck
  C:\Temp\cczXv9hx.s:4371   .text.Sequence:00000788 $t
  C:\Temp\cczXv9hx.s:4891   .text.Sequence:00000ab8 $d
  C:\Temp\cczXv9hx.s:4927   .text.Sequence:00000b40 $t
  C:\Temp\cczXv9hx.s:5422   .text.Sequence:00000e50 $d
                            *COM*:00000001 BalerFullDelayTime
  C:\Temp\cczXv9hx.s:5458   .text.Sequence:00000ed8 $t
  C:\Temp\cczXv9hx.s:5790   .text.Sequence:000010c8 $d
                            *COM*:00000001 RollEngageTurnedOnInManMode
                            *COM*:00000001 Kniv1_IPClosed
                            *COM*:00000004 KeyOpOn
                            *COM*:00000004 KeyOpOff
  C:\Temp\cczXv9hx.s:5825   .text.CalculateAnalogInputRollingAverages:00000000 $t
  C:\Temp\cczXv9hx.s:5830   .text.CalculateAnalogInputRollingAverages:00000000 CalculateAnalogInputRollingAverages
  C:\Temp\cczXv9hx.s:6254   .text.CalculateAnalogInputRollingAverages:000002d8 $d
                            *COM*:00000004 BaleDiaVoltsTotAccumMultSamples
                            *COM*:00000004 DensityPresVoltsTotAccumMultSamples
                            *COM*:00000004 BaleShapeVoltsTotAccumMultSamples
                            *COM*:00000004 BaleShapeVolts
                            *COM*:00000004 KnifePresVoltsTotAccumMultSamples
  C:\Temp\cczXv9hx.s:6956   .IRamNV:00000000 pFac
  C:\Temp\cczXv9hx.s:6960   .IRamNV:00000120 pRun
                            *COM*:00000048 mcm
                            *COM*:00000002 tl_confimation_delay
                            *COM*:00000002 tl_target_count
  C:\Temp\cczXv9hx.s:7272   .data.RollerTimer:00000000 RollerTimer
                            *COM*:00000004 NetPulseCountPrev
                            *COM*:00000004 cal_speed_pulses
                            *COM*:00000001 knivesdelay
                            *COM*:00000004 TC1_count0
                            *COM*:00000004 off_length
                            *COM*:00000004 TC1_millisec_count
                            *COM*:00000001 newf6
                            *COM*:00000004 f0time
                            *COM*:00000002 f0count
                            *COM*:00000004 EOC7_interrupt_count
                            *COM*:00000004 TC1_interrupt_count
                            *COM*:00000001 PowerSwitchedOff
                            *COM*:00000001 RunFactorStatus
                            *COM*:00000001 SavecalDelayWithinMenus
                            *COM*:00000010 number
                            *COM*:00000001 valuechanged
                            *COM*:00000001 editing
                            *COM*:00000001 savecal
                            *COM*:00000080 PreviousWindow
                            *COM*:00000001 offtime
                            *COM*:00000001 reverttime
                            *COM*:00000001 deftime
                            *COM*:00000001 nextwindow
                            *COM*:00000001 windowdepth
                            *COM*:00000001 leaf
                            *COM*:00000001 escape
                            *COM*:00000001 selection
                            *COM*:00000001 startup
                            *COM*:00000a80 buffer
  C:\Temp\cczXv9hx.s:7395   .rodata.PinOption:00000000 PinOption
  C:\Temp\cczXv9hx.s:7278   .rodata.Bar:00000000 Bar
  C:\Temp\cczXv9hx.s:7109   .rodata.PresetNetLayers:00000000 PresetNetLayers
  C:\Temp\cczXv9hx.s:7012   .rodata.PresetFormation2Density:00000000 PresetFormation2Density
  C:\Temp\cczXv9hx.s:7389   .rodata.PresetFormation2Diameter:00000000 PresetFormation2Diameter
  C:\Temp\cczXv9hx.s:6967   .rodata.PresetFormationDensity:00000000 PresetFormationDensity
  C:\Temp\cczXv9hx.s:7404   .rodata.PresetFormationDiameter:00000000 PresetFormationDiameter
  C:\Temp\cczXv9hx.s:6530   .rodata.PresetBaleDensity:00000000 PresetBaleDensity
  C:\Temp\cczXv9hx.s:7083   .rodata.PresetBaleDiameter:00000000 PresetBaleDiameter
  C:\Temp\cczXv9hx.s:6738   .rodata.PresetCoreDensity:00000000 PresetCoreDensity
  C:\Temp\cczXv9hx.s:6665   .rodata.PresetCoreDiameter:00000000 PresetCoreDiameter
  C:\Temp\cczXv9hx.s:6675   .rodata.PF_GW302_ChoppingKnivesFitted:00000000 PF_GW302_ChoppingKnivesFitted
  C:\Temp\cczXv9hx.s:7293   .rodata.PF_GW302_Formation2Diameter:00000000 PF_GW302_Formation2Diameter
  C:\Temp\cczXv9hx.s:6766   .rodata.PF_GW302_Formation2Density:00000000 PF_GW302_Formation2Density
  C:\Temp\cczXv9hx.s:7245   .rodata.PF_GW302_FormationDiameter:00000000 PF_GW302_FormationDiameter
  C:\Temp\cczXv9hx.s:6713   .rodata.PF_GW302_FormationDensity:00000000 PF_GW302_FormationDensity
  C:\Temp\cczXv9hx.s:7354   .rodata.PF_GW302_DiverterDelay:00000000 PF_GW302_DiverterDelay
  C:\Temp\cczXv9hx.s:7236   .rodata.PF_GW302_KnifePresWarn:00000000 PF_GW302_KnifePresWarn
  C:\Temp\cczXv9hx.s:6520   .rodata.PF_GW302_KnifePressure:00000000 PF_GW302_KnifePressure
  C:\Temp\cczXv9hx.s:6805   .rodata.PF_GW302_Density10:00000000 PF_GW302_Density10
  C:\Temp\cczXv9hx.s:7227   .rodata.PF_GW302_Density9:00000000 PF_GW302_Density9
  C:\Temp\cczXv9hx.s:6875   .rodata.PF_GW302_Density8:00000000 PF_GW302_Density8
  C:\Temp\cczXv9hx.s:7218   .rodata.PF_GW302_Density7:00000000 PF_GW302_Density7
  C:\Temp\cczXv9hx.s:7209   .rodata.PF_GW302_Density6:00000000 PF_GW302_Density6
  C:\Temp\cczXv9hx.s:6848   .rodata.PF_GW302_Density5:00000000 PF_GW302_Density5
  C:\Temp\cczXv9hx.s:7200   .rodata.PF_GW302_Density4:00000000 PF_GW302_Density4
  C:\Temp\cczXv9hx.s:6832   .rodata.PF_GW302_Density3:00000000 PF_GW302_Density3
  C:\Temp\cczXv9hx.s:6823   .rodata.PF_GW302_Density2:00000000 PF_GW302_Density2
  C:\Temp\cczXv9hx.s:6814   .rodata.PF_GW302_Density1:00000000 PF_GW302_Density1
  C:\Temp\cczXv9hx.s:7002   .rodata.PF_GW302_KnifePresSmoothingFactor:00000000 PF_GW302_KnifePresSmoothingFactor
  C:\Temp\cczXv9hx.s:6857   .rodata.PF_GW302_BaleShapeSmoothingFactor:00000000 PF_GW302_BaleShapeSmoothingFactor
  C:\Temp\cczXv9hx.s:7175   .rodata.PF_GW302_DensityPresSmoothingFactor:00000000 PF_GW302_DensityPresSmoothingFactor
  C:\Temp\cczXv9hx.s:7311   .rodata.PF_GW302_BaleDiaSmoothingFactor:00000000 PF_GW302_BaleDiaSmoothingFactor
  C:\Temp\cczXv9hx.s:7040   .rodata.PF_GW302_DiaCorrection:00000000 PF_GW302_DiaCorrection
  C:\Temp\cczXv9hx.s:6621   .rodata.PF_GW302_DiameterMax:00000000 PF_GW302_DiameterMax
  C:\Temp\cczXv9hx.s:6646   .rodata.PF_GW302_DiameterMin:00000000 PF_GW302_DiameterMin
  C:\Temp\cczXv9hx.s:6612   .rodata.PF_GW302_TwineOption:00000000 PF_GW302_TwineOption
  C:\Temp\cczXv9hx.s:7345   .rodata.PF_GW302_BeakEngage:00000000 PF_GW302_BeakEngage
  C:\Temp\cczXv9hx.s:7191   .rodata.PF_GW302_NetSystem:00000000 PF_GW302_NetSystem
  C:\Temp\cczXv9hx.s:6540   .rodata.PF_GW302_PreNetPulse:00000000 PF_GW302_PreNetPulse
  C:\Temp\cczXv9hx.s:6511   .rodata.PF_GW302_NoNetPulse:00000000 PF_GW302_NoNetPulse
  C:\Temp\cczXv9hx.s:6945   .rodata.PF_GW302_NetFactor:00000000 PF_GW302_NetFactor
  C:\Temp\cczXv9hx.s:7254   .rodata.PF_GW302_MaxDiaPulsPerLay:00000000 PF_GW302_MaxDiaPulsPerLay
  C:\Temp\cczXv9hx.s:6775   .rodata.PF_GW302_MinDiaPulsPerLay:00000000 PF_GW302_MinDiaPulsPerLay
  C:\Temp\cczXv9hx.s:6603   .rodata.PF_GW302_NetCutTime:00000000 PF_GW302_NetCutTime
  C:\Temp\cczXv9hx.s:6977   .rodata.PF_GW302_NetCutPulse:00000000 PF_GW302_NetCutPulse
  C:\Temp\cczXv9hx.s:7327   .rodata.PF_GW302_NetOn:00000000 PF_GW302_NetOn
  C:\Temp\cczXv9hx.s:6655   .rodata.PF_GW302_RollerDelay:00000000 PF_GW302_RollerDelay
  C:\Temp\cczXv9hx.s:6748   .rodata.PF_GW302_BaleIndicator:00000000 PF_GW302_BaleIndicator
  C:\Temp\cczXv9hx.s:6927   .rodata.PF_GW302_EngageDiameter:00000000 PF_GW302_EngageDiameter
  C:\Temp\cczXv9hx.s:7022   .rodata.PF_GW302_FillPotIgnore:00000000 PF_GW302_FillPotIgnore
  C:\Temp\cczXv9hx.s:7336   .rodata.PF_GW302_FillPotRange:00000000 PF_GW302_FillPotRange
  C:\Temp\cczXv9hx.s:6784   .rodata.PF_GW302_BaleSizeFactor:00000000 PF_GW302_BaleSizeFactor
  C:\Temp\cczXv9hx.s:7363   .rodata.PF_GW302_DoorClosed:00000000 PF_GW302_DoorClosed
  C:\Temp\cczXv9hx.s:6918   .rodata.PF_GW302_PresSwDelay:00000000 PF_GW302_PresSwDelay
  C:\Temp\cczXv9hx.s:6936   .rodata.PF_GW302_NetSpeed:00000000 PF_GW302_NetSpeed
  C:\Temp\cczXv9hx.s:6757   .rodata.PF_GW302_PresDeadband:00000000 PF_GW302_PresDeadband
  C:\Temp\cczXv9hx.s:6993   .rodata.PF_GW302_LubeAlarm:00000000 PF_GW302_LubeAlarm
  C:\Temp\cczXv9hx.s:6691   .rodata.PF_GW302_NetTwineOption:00000000 PF_GW302_NetTwineOption
  C:\Temp\cczXv9hx.s:7031   .rodata.PF_GW302_NetDelay:00000000 PF_GW302_NetDelay
  C:\Temp\cczXv9hx.s:6722   .rodata.PF_GW302_PreWarningBeep:00000000 PF_GW302_PreWarningBeep
  C:\Temp\cczXv9hx.s:6909   .rodata.PF_GW302_TotalNetMetres:00000000 PF_GW302_TotalNetMetres
  C:\Temp\cczXv9hx.s:7149   .rodata.PF_GW302_BaleShapeIndicatorZero:00000000 PF_GW302_BaleShapeIndicatorZero
  C:\Temp\cczXv9hx.s:6891   .rodata.PF_GW302_BaleShapeIndicator:00000000 PF_GW302_BaleShapeIndicator
  C:\Temp\cczXv9hx.s:7073   .rodata.PF_GW302_DiameterCorrection:00000000 PF_GW302_DiameterCorrection
  C:\Temp\cczXv9hx.s:7158   .rodata.PF_GW302_DiaPotZero:00000000 PF_GW302_DiaPotZero
  C:\Temp\cczXv9hx.s:6594   .rodata.PF_GW302_GrandBaleTotal:00000000 PF_GW302_GrandBaleTotal
  C:\Temp\cczXv9hx.s:6900   .rodata.PF_GW302_BaleStore:00000000 PF_GW302_BaleStore
  C:\Temp\cczXv9hx.s:6866   .rodata.PF_GW302_BaleTotal:00000000 PF_GW302_BaleTotal
  C:\Temp\cczXv9hx.s:6630   .rodata.PF_GW302_NetLayers:00000000 PF_GW302_NetLayers
  C:\Temp\cczXv9hx.s:7302   .rodata.PF_GW302_CoreDensity:00000000 PF_GW302_CoreDensity
  C:\Temp\cczXv9hx.s:7119   .rodata.PF_GW302_BaleDensity:00000000 PF_GW302_BaleDensity
  C:\Temp\cczXv9hx.s:7379   .rodata.PF_GW302_CoreDiameter:00000000 PF_GW302_CoreDiameter
  C:\Temp\cczXv9hx.s:7057   .rodata.PF_GW302_BaleDiameter:00000000 PF_GW302_BaleDiameter
  C:\Temp\cczXv9hx.s:7263   .rodata.PF_GW302_BaleProfile:00000000 PF_GW302_BaleProfile
  C:\Temp\cczXv9hx.s:6986   .rodata.op_status:00000000 op_status
  C:\Temp\cczXv9hx.s:6706   .rodata.ip_status:00000000 ip_status
  C:\Temp\cczXv9hx.s:6700   .rodata.NCkey:00000000 NCkey
  C:\Temp\cczXv9hx.s:7049   .rodata.LCkey:00000000 LCkey
  C:\Temp\cczXv9hx.s:7167   .rodata.UCkey:00000000 UCkey
  C:\Temp\cczXv9hx.s:7093   .rodata.Store:00000000 Store
  C:\Temp\cczXv9hx.s:7410   .rodata.MonthofYear:00000000 MonthofYear
  C:\Temp\cczXv9hx.s:6793   .rodata.DayofWeek:00000000 DayofWeek
  C:\Temp\cczXv9hx.s:7128   .rodata.binHex:00000000 binHex
                            *COM*:00000004 POWERtaskhandle
                            *COM*:00000004 TWItaskhandle
                            *COM*:00000004 SetTime
  C:\Temp\cczXv9hx.s:6496   .rodata:00000000 $d
  C:\Temp\cczXv9hx.s:6508   .rodata.PF_GW302_NoNetPulse:00000000 $d
  C:\Temp\cczXv9hx.s:6517   .rodata.PF_GW302_KnifePressure:00000000 $d
  C:\Temp\cczXv9hx.s:6526   .rodata.PresetBaleDensity:00000000 $d
  C:\Temp\cczXv9hx.s:6537   .rodata.PF_GW302_PreNetPulse:00000000 $d
  C:\Temp\cczXv9hx.s:6546   .rodata.str1.4:00000000 $d
  C:\Temp\cczXv9hx.s:6591   .rodata.PF_GW302_GrandBaleTotal:00000000 $d
  C:\Temp\cczXv9hx.s:6600   .rodata.PF_GW302_NetCutTime:00000000 $d
  C:\Temp\cczXv9hx.s:6609   .rodata.PF_GW302_TwineOption:00000000 $d
  C:\Temp\cczXv9hx.s:6618   .rodata.PF_GW302_DiameterMax:00000000 $d
  C:\Temp\cczXv9hx.s:6627   .rodata.PF_GW302_NetLayers:00000000 $d
  C:\Temp\cczXv9hx.s:6636   .bss.dutyLast.9531:00000000 $d
  C:\Temp\cczXv9hx.s:6640   .bss.dutyLast.9531:00000000 dutyLast.9531
  C:\Temp\cczXv9hx.s:6643   .rodata.PF_GW302_DiameterMin:00000000 $d
  C:\Temp\cczXv9hx.s:6652   .rodata.PF_GW302_RollerDelay:00000000 $d
  C:\Temp\cczXv9hx.s:6661   .rodata.PresetCoreDiameter:00000000 $d
  C:\Temp\cczXv9hx.s:6672   .rodata.PF_GW302_ChoppingKnivesFitted:00000000 $d
  C:\Temp\cczXv9hx.s:6681   .bss.BaleShapeVoltsRollAvSample.9647:00000000 $d
  C:\Temp\cczXv9hx.s:6685   .bss.BaleShapeVoltsRollAvSample.9647:00000000 BaleShapeVoltsRollAvSample.9647
  C:\Temp\cczXv9hx.s:6688   .rodata.PF_GW302_NetTwineOption:00000000 $d
  C:\Temp\cczXv9hx.s:6697   .rodata.NCkey:00000000 $d
  C:\Temp\cczXv9hx.s:6703   .rodata.ip_status:00000000 $d
  C:\Temp\cczXv9hx.s:6710   .rodata.PF_GW302_FormationDensity:00000000 $d
  C:\Temp\cczXv9hx.s:6719   .rodata.PF_GW302_PreWarningBeep:00000000 $d
  C:\Temp\cczXv9hx.s:6731   .bss.Kniv1_IPOpenTime.9600:00000000 Kniv1_IPOpenTime.9600
  C:\Temp\cczXv9hx.s:6732   .bss.Kniv1_IPOpenTime.9600:00000000 $d
  C:\Temp\cczXv9hx.s:6734   .rodata.PresetCoreDensity:00000000 $d
  C:\Temp\cczXv9hx.s:6745   .rodata.PF_GW302_BaleIndicator:00000000 $d
  C:\Temp\cczXv9hx.s:6754   .rodata.PF_GW302_PresDeadband:00000000 $d
  C:\Temp\cczXv9hx.s:6763   .rodata.PF_GW302_Formation2Density:00000000 $d
  C:\Temp\cczXv9hx.s:6772   .rodata.PF_GW302_MinDiaPulsPerLay:00000000 $d
  C:\Temp\cczXv9hx.s:6781   .rodata.PF_GW302_BaleSizeFactor:00000000 $d
  C:\Temp\cczXv9hx.s:6790   .rodata.DayofWeek:00000000 $d
  C:\Temp\cczXv9hx.s:6802   .rodata.PF_GW302_Density10:00000000 $d
  C:\Temp\cczXv9hx.s:6811   .rodata.PF_GW302_Density1:00000000 $d
  C:\Temp\cczXv9hx.s:6820   .rodata.PF_GW302_Density2:00000000 $d
  C:\Temp\cczXv9hx.s:6829   .rodata.PF_GW302_Density3:00000000 $d
  C:\Temp\cczXv9hx.s:6838   .bss.BaleDiaVoltsRollAvSample.9645:00000000 $d
  C:\Temp\cczXv9hx.s:6842   .bss.BaleDiaVoltsRollAvSample.9645:00000000 BaleDiaVoltsRollAvSample.9645
  C:\Temp\cczXv9hx.s:6845   .rodata.PF_GW302_Density5:00000000 $d
  C:\Temp\cczXv9hx.s:6854   .rodata.PF_GW302_BaleShapeSmoothingFactor:00000000 $d
  C:\Temp\cczXv9hx.s:6863   .rodata.PF_GW302_BaleTotal:00000000 $d
  C:\Temp\cczXv9hx.s:6872   .rodata.PF_GW302_Density8:00000000 $d
  C:\Temp\cczXv9hx.s:6881   .bss.status.9530:00000000 $d
  C:\Temp\cczXv9hx.s:6885   .bss.status.9530:00000000 status.9530
  C:\Temp\cczXv9hx.s:6888   .rodata.PF_GW302_BaleShapeIndicator:00000000 $d
  C:\Temp\cczXv9hx.s:6897   .rodata.PF_GW302_BaleStore:00000000 $d
  C:\Temp\cczXv9hx.s:6906   .rodata.PF_GW302_TotalNetMetres:00000000 $d
  C:\Temp\cczXv9hx.s:6915   .rodata.PF_GW302_PresSwDelay:00000000 $d
  C:\Temp\cczXv9hx.s:6924   .rodata.PF_GW302_EngageDiameter:00000000 $d
  C:\Temp\cczXv9hx.s:6933   .rodata.PF_GW302_NetSpeed:00000000 $d
  C:\Temp\cczXv9hx.s:6942   .rodata.PF_GW302_NetFactor:00000000 $d
  C:\Temp\cczXv9hx.s:6951   .IRamNV:00000000 $d
  C:\Temp\cczXv9hx.s:6963   .rodata.PresetFormationDensity:00000000 $d
  C:\Temp\cczXv9hx.s:6974   .rodata.PF_GW302_NetCutPulse:00000000 $d
  C:\Temp\cczXv9hx.s:6983   .rodata.op_status:00000000 $d
  C:\Temp\cczXv9hx.s:6990   .rodata.PF_GW302_LubeAlarm:00000000 $d
  C:\Temp\cczXv9hx.s:6999   .rodata.PF_GW302_KnifePresSmoothingFactor:00000000 $d
  C:\Temp\cczXv9hx.s:7008   .rodata.PresetFormation2Density:00000000 $d
  C:\Temp\cczXv9hx.s:7019   .rodata.PF_GW302_FillPotIgnore:00000000 $d
  C:\Temp\cczXv9hx.s:7028   .rodata.PF_GW302_NetDelay:00000000 $d
  C:\Temp\cczXv9hx.s:7037   .rodata.PF_GW302_DiaCorrection:00000000 $d
  C:\Temp\cczXv9hx.s:7046   .rodata.LCkey:00000000 $d
  C:\Temp\cczXv9hx.s:7054   .rodata.PF_GW302_BaleDiameter:00000000 $d
  C:\Temp\cczXv9hx.s:7063   .bss.LastNetPulseCount.9601:00000000 $d
  C:\Temp\cczXv9hx.s:7067   .bss.LastNetPulseCount.9601:00000000 LastNetPulseCount.9601
  C:\Temp\cczXv9hx.s:7070   .rodata.PF_GW302_DiameterCorrection:00000000 $d
  C:\Temp\cczXv9hx.s:7079   .rodata.PresetBaleDiameter:00000000 $d
  C:\Temp\cczXv9hx.s:7090   .rodata.Store:00000000 $d
  C:\Temp\cczXv9hx.s:7105   .rodata.PresetNetLayers:00000000 $d
  C:\Temp\cczXv9hx.s:7116   .rodata.PF_GW302_BaleDensity:00000000 $d
  C:\Temp\cczXv9hx.s:7125   .rodata.binHex:00000000 $d
  C:\Temp\cczXv9hx.s:7146   .rodata.PF_GW302_BaleShapeIndicatorZero:00000000 $d
  C:\Temp\cczXv9hx.s:7155   .rodata.PF_GW302_DiaPotZero:00000000 $d
  C:\Temp\cczXv9hx.s:7164   .rodata.UCkey:00000000 $d
  C:\Temp\cczXv9hx.s:7172   .rodata.PF_GW302_DensityPresSmoothingFactor:00000000 $d
  C:\Temp\cczXv9hx.s:7181   .bss.DensityPresVoltsRollAvSample.9646:00000000 $d
  C:\Temp\cczXv9hx.s:7185   .bss.DensityPresVoltsRollAvSample.9646:00000000 DensityPresVoltsRollAvSample.9646
  C:\Temp\cczXv9hx.s:7188   .rodata.PF_GW302_NetSystem:00000000 $d
  C:\Temp\cczXv9hx.s:7197   .rodata.PF_GW302_Density4:00000000 $d
  C:\Temp\cczXv9hx.s:7206   .rodata.PF_GW302_Density6:00000000 $d
  C:\Temp\cczXv9hx.s:7215   .rodata.PF_GW302_Density7:00000000 $d
  C:\Temp\cczXv9hx.s:7224   .rodata.PF_GW302_Density9:00000000 $d
  C:\Temp\cczXv9hx.s:7233   .rodata.PF_GW302_KnifePresWarn:00000000 $d
  C:\Temp\cczXv9hx.s:7242   .rodata.PF_GW302_FormationDiameter:00000000 $d
  C:\Temp\cczXv9hx.s:7251   .rodata.PF_GW302_MaxDiaPulsPerLay:00000000 $d
  C:\Temp\cczXv9hx.s:7260   .rodata.PF_GW302_BaleProfile:00000000 $d
  C:\Temp\cczXv9hx.s:7275   .rodata.Bar:00000000 $d
  C:\Temp\cczXv9hx.s:7290   .rodata.PF_GW302_Formation2Diameter:00000000 $d
  C:\Temp\cczXv9hx.s:7299   .rodata.PF_GW302_CoreDensity:00000000 $d
  C:\Temp\cczXv9hx.s:7308   .rodata.PF_GW302_BaleDiaSmoothingFactor:00000000 $d
  C:\Temp\cczXv9hx.s:7317   .bss.KnifePresVoltsRollAvSample.9648:00000000 $d
  C:\Temp\cczXv9hx.s:7321   .bss.KnifePresVoltsRollAvSample.9648:00000000 KnifePresVoltsRollAvSample.9648
  C:\Temp\cczXv9hx.s:7324   .rodata.PF_GW302_NetOn:00000000 $d
  C:\Temp\cczXv9hx.s:7333   .rodata.PF_GW302_FillPotRange:00000000 $d
  C:\Temp\cczXv9hx.s:7342   .rodata.PF_GW302_BeakEngage:00000000 $d
  C:\Temp\cczXv9hx.s:7351   .rodata.PF_GW302_DiverterDelay:00000000 $d
  C:\Temp\cczXv9hx.s:7360   .rodata.PF_GW302_DoorClosed:00000000 $d
  C:\Temp\cczXv9hx.s:7369   .bss.freqLast.9532:00000000 $d
  C:\Temp\cczXv9hx.s:7373   .bss.freqLast.9532:00000000 freqLast.9532
  C:\Temp\cczXv9hx.s:7376   .rodata.PF_GW302_CoreDiameter:00000000 $d
  C:\Temp\cczXv9hx.s:7385   .rodata.PresetFormation2Diameter:00000000 $d
  C:\Temp\cczXv9hx.s:7392   .rodata.PinOption:00000000 $d
  C:\Temp\cczXv9hx.s:7400   .rodata.PresetFormationDiameter:00000000 $d
  C:\Temp\cczXv9hx.s:7407   .rodata.MonthofYear:00000000 $d
                     .debug_frame:00000010 $d
  C:\Temp\cczXv9hx.s:2187   .text.Inputs:0000056c $t
                           .group:00000000 wm4.1.e755308d0f97ac5a4d77c88bfa88161b
                           .group:00000000 wm4.Board.h.9.fb7d243db0e7e4c70fc5c5308962051c
                           .group:00000000 wm4.AT91SAM7A3.h.47.d520374ed0d352801eee6a21dd2220a3
                           .group:00000000 wm4.lib_AT91SAM7A3.h.43.b96965aef7b64d3c61b53421dff32f3d
                           .group:00000000 wm4.stddef.h.40.50cf36416e06376af8a9dca28536f2e4
                           .group:00000000 wm4.projdefs.h.55.cdae9ead80b5a2ac004f41bb277aad45
                           .group:00000000 wm4.FreeRTOSConfig.h.55.21a0bf6949661856eb9bd458ca526d69
                           .group:00000000 wm4.portmacro.h.78.312ea2a2591c2c784e5cb239eea0b39c
                           .group:00000000 wm4.portable.h.311.02653c2286cc0addcb8e7b32211fdde5
                           .group:00000000 wm4.mpu_wrappers.h.55.46a4a008a193040c38098e9a5f07ff9d
                           .group:00000000 wm4.FreeRTOS.h.136.ac0125896626c2d69b79b44ea315652b
                           .group:00000000 wm4.list.h.90.ffdb657f66139f74e2982d5a33457923
                           .group:00000000 wm4.task.h.75.6c9adf28cb16a37dd5593a2f9c33f128
                           .group:00000000 wm4.queue.h.62.c626e69c2c492f5b1e4920732a8be821
                           .group:00000000 wm4.semphr.h.65.030ef7caa4665b46960b9de8a1cccba7
                           .group:00000000 wm4.Board.h.1257.275975018c8e952526c2554b98141b95
                           .group:00000000 wm4.Board.h.1481.126b635f2c4daf829686312d1e66f9ec
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.95dee4059009fe3ab635a191bb73dc66
                           .group:00000000 wm4._default_types.h.6.1dbd2e581fd590860c7c17f21d147e91
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.161.c6104a0666cf681b6269ddc9b4f516d4
                           .group:00000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:00000000 wm4.cdefs.h.45.6b392759c8a421d1199268021d4987e3
                           .group:00000000 wm4.stddef.h.161.e50ff8a9d5d1abbc15641da28ac571bf
                           .group:00000000 wm4.string.h.118.0034ce03f0efcb6576b1b96865c749d5
                           .group:00000000 wm4.stdlib.h.13.603ed7eb09a1561ab06840b7c0fcff58
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.c69c7609933ff56d59c757cec2d13230
                           .group:00000000 wm4.stdio.h.27.f2ac352bab34f31f9f478442827b2ba6
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.4c41f90a958351ce40b14103f7ff82ee
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.63.dfdea6580b080784d08faace69b6ed76
                           .group:00000000 wm4.math.h.35.07c7797db9e98c6f49a07908290b45ed

UNDEFINED SYMBOLS
write_bitmap
sprintf
display_f1_text
draw_box
F1_CLK
SPI1FlashWrite
TextString
screen147
screen00
SecondScreen
__aeabi_uidiv
__aeabi_uidivmod
__aeabi_idiv
__aeabi_ui2f
__aeabi_f2d
__aeabi_dmul
__aeabi_ddiv
__aeabi_d2f
__aeabi_i2f
__aeabi_fmul
__aeabi_fadd
__aeabi_fsub
__aeabi_fdiv
__aeabi_fcmplt
__aeabi_fcmpgt
__aeabi_dadd
__aeabi_dcmpgt
__aeabi_dcmplt
MWarn
OKWarnBox
__aeabi_f2uiz
__aeabi_d2uiz
__aeabi_fcmpge
__aeabi_dsub
SWOPEN
SWCLOSED
BUTTON04
BUTTON01
screen141
