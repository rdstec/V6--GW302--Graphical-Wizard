   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"display.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.setPixel,"ax",%progbits
  18              		.align	2
  19              		.global	setPixel
  20              		.code	16
  21              		.thumb_func
  23              	setPixel:
  24              	.LFB376:
  25              		.file 1 "display.c"
   1:display.c     **** // -----------------------------------------------------------
   2:display.c     **** // Software:         GW302 - McHale V6 Fixed Chamber Round Baler
   3:display.c     **** // C Source File:    display.c
   4:display.c     **** // Description:      Graphic Wizard Display Routines
   5:display.c     **** // -----------------------------------------------------------
   6:display.c     **** 
   7:display.c     **** 
   8:display.c     **** // Include Standard files
   9:display.c     **** #include "Board.h"
  10:display.c     **** 
  11:display.c     **** #include "stdio.h"
  12:display.c     **** #include "stdlib.h"
  13:display.c     **** #include "string.h"
  14:display.c     **** #include "math.h"
  15:display.c     **** 
  16:display.c     **** 
  17:display.c     **** // functions
  18:display.c     **** 
  19:display.c     **** // -----------------------------------------------------------
  20:display.c     **** // Function Name       : setPixel
  21:display.c     **** // -----------------------------------------------------------
  22:display.c     **** void setPixel( unsigned char *buff, unsigned char x, unsigned char y, unsigned int method )
  23:display.c     **** {
  26              		.loc 1 23 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 10B5     		push	{r4, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 4, -8
  33              		.cfi_offset 14, -4
  24:display.c     **** 	unsigned char n;
  25:display.c     **** 	unsigned short int offset;
  26:display.c     **** 
  27:display.c     **** 	offset = (x / 8) + (y * COLUMNS);
  34              		.loc 1 27 0
  35 0002 9400     		lsl	r4, r2, #2
  36 0004 A218     		add	r2, r4, r2
  37              	.LVL1:
  38 0006 9200     		lsl	r2, r2, #2
  39 0008 CC08     		lsr	r4, r1, #3
  40 000a 1219     		add	r2, r2, r4
  41              	.LVL2:
  28:display.c     **** 	if( offset < GRAPHICS_SIZE )
  42              		.loc 1 28 0
  43 000c 0B4C     		ldr	r4, .L4
  44 000e A242     		cmp	r2, r4
  45 0010 10D8     		bhi	.L1
  29:display.c     **** 	{
  30:display.c     **** 		n = (unsigned char)0x80 >> (x % 8);
  46              		.loc 1 30 0
  47 0012 0724     		mov	r4, #7
  48 0014 2140     		and	r1, r4
  49              	.LVL3:
  50 0016 8024     		mov	r4, #128
  51 0018 0C41     		asr	r4, r4, r1
  52 001a 2106     		lsl	r1, r4, #24
  53 001c 090E     		lsr	r1, r1, #24
  54              	.LVL4:
  31:display.c     **** 
  32:display.c     **** 		if( method == CLEAR )
  55              		.loc 1 32 0
  56 001e 402B     		cmp	r3, #64
  57 0020 04D1     		bne	.L3
  33:display.c     **** 		{
  34:display.c     **** 			buff[offset] &= ~n;
  58              		.loc 1 34 0
  59 0022 8218     		add	r2, r0, r2
  60              	.LVL5:
  61 0024 1378     		ldrb	r3, [r2]
  62              	.LVL6:
  63 0026 8B43     		bic	r3, r1
  64 0028 1370     		strb	r3, [r2]
  65 002a 03E0     		b	.L1
  66              	.LVL7:
  67              	.L3:
  35:display.c     **** 		}
  36:display.c     **** 		else
  37:display.c     **** 		{
  38:display.c     **** 			buff[offset] |= n;
  68              		.loc 1 38 0
  69 002c 8218     		add	r2, r0, r2
  70              	.LVL8:
  71 002e 1378     		ldrb	r3, [r2]
  72              	.LVL9:
  73 0030 1943     		orr	r1, r3
  74              	.LVL10:
  75 0032 1170     		strb	r1, [r2]
  76              	.LVL11:
  77              	.L1:
  39:display.c     **** 		}
  40:display.c     **** 	}
  41:display.c     **** }
  78              		.loc 1 41 0
  79              		@ sp needed for prologue
  80 0034 10BC     		pop	{r4}
  81 0036 01BC     		pop	{r0}
  82 0038 0047     		bx	r0
  83              	.L5:
  84 003a C046     		.align	2
  85              	.L4:
  86 003c FF090000 		.word	2559
  87              		.cfi_endproc
  88              	.LFE376:
  90              		.section	.text.circlePoints,"ax",%progbits
  91              		.align	2
  92              		.global	circlePoints
  93              		.code	16
  94              		.thumb_func
  96              	circlePoints:
  97              	.LFB377:
  42:display.c     **** // -----------------------------------------------------------
  43:display.c     **** 
  44:display.c     **** 
  45:display.c     **** // -----------------------------------------------------------
  46:display.c     **** // Function Name       : circlePoints
  47:display.c     **** // -----------------------------------------------------------
  48:display.c     **** void circlePoints( unsigned char *buff, unsigned char cx, unsigned char cy,
  49:display.c     ****   unsigned char x, unsigned char y, unsigned int method )
  50:display.c     **** {
  98              		.loc 1 50 0
  99              		.cfi_startproc
 100              	.LVL12:
 101 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 102              	.LCFI1:
 103              		.cfi_def_cfa_offset 24
 104              		.cfi_offset 3, -24
 105              		.cfi_offset 4, -20
 106              		.cfi_offset 5, -16
 107              		.cfi_offset 6, -12
 108              		.cfi_offset 7, -8
 109              		.cfi_offset 14, -4
 110 0002 5F46     		mov	r7, fp
 111 0004 5646     		mov	r6, sl
 112 0006 4D46     		mov	r5, r9
 113 0008 4446     		mov	r4, r8
 114 000a F0B4     		push	{r4, r5, r6, r7}
 115              	.LCFI2:
 116              		.cfi_def_cfa_offset 40
 117              		.cfi_offset 8, -40
 118              		.cfi_offset 9, -36
 119              		.cfi_offset 10, -32
 120              		.cfi_offset 11, -28
 121 000c 071C     		mov	r7, r0
 122 000e 8946     		mov	r9, r1
 123 0010 161C     		mov	r6, r2
 124 0012 1C1C     		mov	r4, r3
 125 0014 0AAB     		add	r3, sp, #40
 126              	.LVL13:
 127 0016 1D78     		ldrb	r5, [r3]
  51:display.c     **** 
  52:display.c     **** 	if( x == 0 )
 128              		.loc 1 52 0
 129 0018 002C     		cmp	r4, #0
 130 001a 20D1     		bne	.L7
  53:display.c     **** 	{
  54:display.c     **** 		setPixel( buff, cx, cy + y, method );
 131              		.loc 1 54 0
 132 001c AA18     		add	r2, r5, r2
 133              	.LVL14:
 134 001e 1206     		lsl	r2, r2, #24
 135 0020 120E     		lsr	r2, r2, #24
 136 0022 0B9B     		ldr	r3, [sp, #44]
 137 0024 FFF7FEFF 		bl	setPixel
 138              	.LVL15:
  55:display.c     **** 		setPixel( buff, cx, cy - y, method );
 139              		.loc 1 55 0
 140 0028 721B     		sub	r2, r6, r5
 141 002a 1206     		lsl	r2, r2, #24
 142 002c 120E     		lsr	r2, r2, #24
 143 002e 381C     		mov	r0, r7
 144 0030 4946     		mov	r1, r9
 145 0032 0B9B     		ldr	r3, [sp, #44]
 146 0034 FFF7FEFF 		bl	setPixel
 147              	.LVL16:
  56:display.c     **** 		setPixel( buff, cx + y, cy, method );
 148              		.loc 1 56 0
 149 0038 4A46     		mov	r2, r9
 150 003a A918     		add	r1, r5, r2
 151 003c 0906     		lsl	r1, r1, #24
 152 003e 090E     		lsr	r1, r1, #24
 153 0040 381C     		mov	r0, r7
 154 0042 321C     		mov	r2, r6
 155 0044 0B9B     		ldr	r3, [sp, #44]
 156 0046 FFF7FEFF 		bl	setPixel
 157              	.LVL17:
  57:display.c     **** 		setPixel( buff, cx - y, cy, method );
 158              		.loc 1 57 0
 159 004a 4B46     		mov	r3, r9
 160 004c 591B     		sub	r1, r3, r5
 161 004e 0906     		lsl	r1, r1, #24
 162 0050 090E     		lsr	r1, r1, #24
 163 0052 381C     		mov	r0, r7
 164 0054 321C     		mov	r2, r6
 165 0056 0B9B     		ldr	r3, [sp, #44]
 166 0058 FFF7FEFF 		bl	setPixel
 167              	.LVL18:
 168 005c 7AE0     		b	.L6
 169              	.LVL19:
 170              	.L7:
  58:display.c     **** 	}
  59:display.c     **** 	else if( x == y )
 171              		.loc 1 59 0
 172 005e AC42     		cmp	r4, r5
 173 0060 26D1     		bne	.L9
  60:display.c     **** 	{
  61:display.c     **** 		setPixel( buff, cx + x, cy + y, method );
 174              		.loc 1 61 0
 175 0062 6318     		add	r3, r4, r1
 176 0064 1B06     		lsl	r3, r3, #24
 177 0066 1B0E     		lsr	r3, r3, #24
 178 0068 9A46     		mov	sl, r3
 179 006a A319     		add	r3, r4, r6
 180 006c 1B06     		lsl	r3, r3, #24
 181 006e 1B0E     		lsr	r3, r3, #24
 182 0070 9B46     		mov	fp, r3
 183 0072 5146     		mov	r1, sl
 184              	.LVL20:
 185 0074 1A1C     		mov	r2, r3
 186              	.LVL21:
 187 0076 0B9B     		ldr	r3, [sp, #44]
 188 0078 FFF7FEFF 		bl	setPixel
 189              	.LVL22:
  62:display.c     **** 		setPixel( buff, cx - x, cy + y, method );
 190              		.loc 1 62 0
 191 007c 4B46     		mov	r3, r9
 192 007e 1D1B     		sub	r5, r3, r4
 193 0080 2D06     		lsl	r5, r5, #24
 194 0082 2D0E     		lsr	r5, r5, #24
 195 0084 381C     		mov	r0, r7
 196 0086 291C     		mov	r1, r5
 197 0088 5A46     		mov	r2, fp
 198 008a 0B9B     		ldr	r3, [sp, #44]
 199 008c FFF7FEFF 		bl	setPixel
 200              	.LVL23:
  63:display.c     **** 		setPixel( buff, cx + x, cy - y, method );
 201              		.loc 1 63 0
 202 0090 341B     		sub	r4, r6, r4
 203 0092 2406     		lsl	r4, r4, #24
 204 0094 240E     		lsr	r4, r4, #24
 205 0096 381C     		mov	r0, r7
 206 0098 5146     		mov	r1, sl
 207 009a 221C     		mov	r2, r4
 208 009c 0B9B     		ldr	r3, [sp, #44]
 209 009e FFF7FEFF 		bl	setPixel
 210              	.LVL24:
  64:display.c     **** 		setPixel( buff, cx - x, cy - y, method );
 211              		.loc 1 64 0
 212 00a2 381C     		mov	r0, r7
 213 00a4 291C     		mov	r1, r5
 214 00a6 221C     		mov	r2, r4
 215 00a8 0B9B     		ldr	r3, [sp, #44]
 216 00aa FFF7FEFF 		bl	setPixel
 217              	.LVL25:
 218 00ae 51E0     		b	.L6
 219              	.LVL26:
 220              	.L9:
  65:display.c     **** 	}
  66:display.c     **** 	else if( x < y )
 221              		.loc 1 66 0
 222 00b0 AC42     		cmp	r4, r5
 223 00b2 4FD2     		bcs	.L6
  67:display.c     **** 	{
  68:display.c     **** 		setPixel( buff, cx + x, cy + y, method );
 224              		.loc 1 68 0
 225 00b4 6318     		add	r3, r4, r1
 226 00b6 1B06     		lsl	r3, r3, #24
 227 00b8 1B0E     		lsr	r3, r3, #24
 228 00ba 9B46     		mov	fp, r3
 229 00bc AB19     		add	r3, r5, r6
 230 00be 1B06     		lsl	r3, r3, #24
 231 00c0 1B0E     		lsr	r3, r3, #24
 232 00c2 9A46     		mov	sl, r3
 233 00c4 5946     		mov	r1, fp
 234              	.LVL27:
 235 00c6 1A1C     		mov	r2, r3
 236              	.LVL28:
 237 00c8 0B9B     		ldr	r3, [sp, #44]
 238 00ca FFF7FEFF 		bl	setPixel
 239              	.LVL29:
  69:display.c     **** 		setPixel( buff, cx - x, cy + y, method );
 240              		.loc 1 69 0
 241 00ce 4A46     		mov	r2, r9
 242 00d0 131B     		sub	r3, r2, r4
 243 00d2 1B06     		lsl	r3, r3, #24
 244 00d4 1B0E     		lsr	r3, r3, #24
 245 00d6 9846     		mov	r8, r3
 246 00d8 381C     		mov	r0, r7
 247 00da 191C     		mov	r1, r3
 248 00dc 5246     		mov	r2, sl
 249 00de 0B9B     		ldr	r3, [sp, #44]
 250 00e0 FFF7FEFF 		bl	setPixel
 251              	.LVL30:
  70:display.c     **** 		setPixel( buff, cx + x, cy - y, method );
 252              		.loc 1 70 0
 253 00e4 731B     		sub	r3, r6, r5
 254 00e6 1B06     		lsl	r3, r3, #24
 255 00e8 1B0E     		lsr	r3, r3, #24
 256 00ea 9A46     		mov	sl, r3
 257 00ec 381C     		mov	r0, r7
 258 00ee 5946     		mov	r1, fp
 259 00f0 1A1C     		mov	r2, r3
 260 00f2 0B9B     		ldr	r3, [sp, #44]
 261 00f4 FFF7FEFF 		bl	setPixel
 262              	.LVL31:
  71:display.c     **** 		setPixel( buff, cx - x, cy - y, method );
 263              		.loc 1 71 0
 264 00f8 381C     		mov	r0, r7
 265 00fa 4146     		mov	r1, r8
 266 00fc 5246     		mov	r2, sl
 267 00fe 0B9B     		ldr	r3, [sp, #44]
 268 0100 FFF7FEFF 		bl	setPixel
 269              	.LVL32:
  72:display.c     **** 		setPixel( buff, cx + y, cy + x, method );
 270              		.loc 1 72 0
 271 0104 4A46     		mov	r2, r9
 272 0106 AB18     		add	r3, r5, r2
 273 0108 1B06     		lsl	r3, r3, #24
 274 010a 1B0E     		lsr	r3, r3, #24
 275 010c 9A46     		mov	sl, r3
 276 010e A319     		add	r3, r4, r6
 277 0110 1B06     		lsl	r3, r3, #24
 278 0112 1B0E     		lsr	r3, r3, #24
 279 0114 9B46     		mov	fp, r3
 280 0116 381C     		mov	r0, r7
 281 0118 5146     		mov	r1, sl
 282 011a 1A1C     		mov	r2, r3
 283 011c 0B9B     		ldr	r3, [sp, #44]
 284 011e FFF7FEFF 		bl	setPixel
 285              	.LVL33:
  73:display.c     **** 		setPixel( buff, cx - y, cy + x, method );
 286              		.loc 1 73 0
 287 0122 4B46     		mov	r3, r9
 288 0124 5D1B     		sub	r5, r3, r5
 289 0126 2D06     		lsl	r5, r5, #24
 290 0128 2D0E     		lsr	r5, r5, #24
 291 012a 381C     		mov	r0, r7
 292 012c 291C     		mov	r1, r5
 293 012e 5A46     		mov	r2, fp
 294 0130 0B9B     		ldr	r3, [sp, #44]
 295 0132 FFF7FEFF 		bl	setPixel
 296              	.LVL34:
  74:display.c     **** 		setPixel( buff, cx + y, cy - x, method );
 297              		.loc 1 74 0
 298 0136 341B     		sub	r4, r6, r4
 299 0138 2406     		lsl	r4, r4, #24
 300 013a 240E     		lsr	r4, r4, #24
 301 013c 381C     		mov	r0, r7
 302 013e 5146     		mov	r1, sl
 303 0140 221C     		mov	r2, r4
 304 0142 0B9B     		ldr	r3, [sp, #44]
 305 0144 FFF7FEFF 		bl	setPixel
 306              	.LVL35:
  75:display.c     **** 		setPixel( buff, cx - y, cy - x, method );
 307              		.loc 1 75 0
 308 0148 381C     		mov	r0, r7
 309 014a 291C     		mov	r1, r5
 310 014c 221C     		mov	r2, r4
 311 014e 0B9B     		ldr	r3, [sp, #44]
 312 0150 FFF7FEFF 		bl	setPixel
 313              	.LVL36:
 314              	.L6:
  76:display.c     **** 	}
  77:display.c     **** }
 315              		.loc 1 77 0
 316              		@ sp needed for prologue
 317              	.LVL37:
 318 0154 3CBC     		pop	{r2, r3, r4, r5}
 319 0156 9046     		mov	r8, r2
 320 0158 9946     		mov	r9, r3
 321 015a A246     		mov	sl, r4
 322 015c AB46     		mov	fp, r5
 323 015e F8BC     		pop	{r3, r4, r5, r6, r7}
 324 0160 01BC     		pop	{r0}
 325 0162 0047     		bx	r0
 326              		.cfi_endproc
 327              	.LFE377:
 329              		.section	.text.circleMidpoint,"ax",%progbits
 330              		.align	2
 331              		.global	circleMidpoint
 332              		.code	16
 333              		.thumb_func
 335              	circleMidpoint:
 336              	.LFB378:
  78:display.c     **** // -----------------------------------------------------------
  79:display.c     **** 
  80:display.c     **** 
  81:display.c     **** // -----------------------------------------------------------
  82:display.c     **** // Function Name       : circleMidpoint
  83:display.c     **** // -----------------------------------------------------------
  84:display.c     **** void circleMidpoint( unsigned char *buff, unsigned char xCenter, unsigned char yCenter,
  85:display.c     ****   unsigned char radius, unsigned int method )
  86:display.c     **** {
 337              		.loc 1 86 0
 338              		.cfi_startproc
 339              	.LVL38:
 340 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 341              	.LCFI3:
 342              		.cfi_def_cfa_offset 20
 343              		.cfi_offset 4, -20
 344              		.cfi_offset 5, -16
 345              		.cfi_offset 6, -12
 346              		.cfi_offset 7, -8
 347              		.cfi_offset 14, -4
 348 0002 5746     		mov	r7, sl
 349 0004 4E46     		mov	r6, r9
 350 0006 4546     		mov	r5, r8
 351 0008 E0B4     		push	{r5, r6, r7}
 352              	.LCFI4:
 353              		.cfi_def_cfa_offset 32
 354              		.cfi_offset 8, -32
 355              		.cfi_offset 9, -28
 356              		.cfi_offset 10, -24
 357 000a 82B0     		sub	sp, sp, #8
 358              	.LCFI5:
 359              		.cfi_def_cfa_offset 40
 360 000c 071C     		mov	r7, r0
 361 000e 8846     		mov	r8, r1
 362 0010 9146     		mov	r9, r2
 363 0012 1D1C     		mov	r5, r3
 364 0014 0A9B     		ldr	r3, [sp, #40]
 365              	.LVL39:
 366 0016 9A46     		mov	sl, r3
 367              	.LVL40:
  87:display.c     **** 	unsigned char x = 0;
  88:display.c     **** 	unsigned char y = radius;
  89:display.c     **** 	signed int p = (5 - (radius*4)) / 4;
 368              		.loc 1 89 0
 369 0018 AB00     		lsl	r3, r5, #2
 370 001a 5B42     		neg	r3, r3
 371 001c 0533     		add	r3, r3, #5
 372 001e DE17     		asr	r6, r3, #31
 373 0020 B60F     		lsr	r6, r6, #30
 374 0022 F618     		add	r6, r6, r3
 375 0024 B610     		asr	r6, r6, #2
 376              	.LVL41:
  90:display.c     **** 
  91:display.c     **** 	circlePoints( buff, xCenter, yCenter, x, y, method );
 377              		.loc 1 91 0
 378 0026 0095     		str	r5, [sp]
 379 0028 5346     		mov	r3, sl
 380 002a 0193     		str	r3, [sp, #4]
 381 002c 0023     		mov	r3, #0
 382 002e FFF7FEFF 		bl	circlePoints
 383              	.LVL42:
  92:display.c     **** 	while( x < y )
 384              		.loc 1 92 0
 385 0032 002D     		cmp	r5, #0
 386 0034 1BD0     		beq	.L10
  87:display.c     **** 	unsigned char x = 0;
 387              		.loc 1 87 0
 388 0036 0024     		mov	r4, #0
 389              	.LVL43:
 390              	.L14:
  93:display.c     **** 	{
  94:display.c     **** 		x++;
 391              		.loc 1 94 0
 392 0038 0134     		add	r4, r4, #1
 393 003a 2406     		lsl	r4, r4, #24
 394 003c 240E     		lsr	r4, r4, #24
 395              	.LVL44:
  95:display.c     **** 		if( p < 0 )
 396              		.loc 1 95 0
 397 003e 002E     		cmp	r6, #0
 398 0040 03DA     		bge	.L12
  96:display.c     **** 		{
  97:display.c     **** 			p += ((2 * x) + 1);
 399              		.loc 1 97 0
 400 0042 6300     		lsl	r3, r4, #1
 401 0044 0133     		add	r3, r3, #1
 402 0046 F618     		add	r6, r6, r3
 403              	.LVL45:
 404 0048 06E0     		b	.L13
 405              	.L12:
  98:display.c     **** 		}
  99:display.c     **** 		else
 100:display.c     **** 		{
 101:display.c     **** 			y--;
 406              		.loc 1 101 0
 407 004a 013D     		sub	r5, r5, #1
 408 004c 2D06     		lsl	r5, r5, #24
 409 004e 2D0E     		lsr	r5, r5, #24
 410              	.LVL46:
 102:display.c     **** 			p += ((2*(x-y)) + 1);
 411              		.loc 1 102 0
 412 0050 631B     		sub	r3, r4, r5
 413 0052 5B00     		lsl	r3, r3, #1
 414 0054 0133     		add	r3, r3, #1
 415 0056 F618     		add	r6, r6, r3
 416              	.LVL47:
 417              	.L13:
 103:display.c     **** 		}
 104:display.c     **** 		circlePoints( buff, xCenter, yCenter, x, y, method );
 418              		.loc 1 104 0
 419 0058 0095     		str	r5, [sp]
 420 005a 5346     		mov	r3, sl
 421 005c 0193     		str	r3, [sp, #4]
 422 005e 381C     		mov	r0, r7
 423 0060 4146     		mov	r1, r8
 424 0062 4A46     		mov	r2, r9
 425 0064 231C     		mov	r3, r4
 426 0066 FFF7FEFF 		bl	circlePoints
 427              	.LVL48:
  92:display.c     **** 	while( x < y )
 428              		.loc 1 92 0
 429 006a A542     		cmp	r5, r4
 430 006c E4D8     		bhi	.L14
 431              	.LVL49:
 432              	.L10:
 105:display.c     **** 	}
 106:display.c     **** }
 433              		.loc 1 106 0
 434 006e 02B0     		add	sp, sp, #8
 435              		@ sp needed for prologue
 436              	.LVL50:
 437              	.LVL51:
 438 0070 1CBC     		pop	{r2, r3, r4}
 439 0072 9046     		mov	r8, r2
 440 0074 9946     		mov	r9, r3
 441 0076 A246     		mov	sl, r4
 442 0078 F0BC     		pop	{r4, r5, r6, r7}
 443 007a 01BC     		pop	{r0}
 444 007c 0047     		bx	r0
 445              		.cfi_endproc
 446              	.LFE378:
 448 007e C046     		.section	.text.greatest,"ax",%progbits
 449              		.align	2
 450              		.global	greatest
 451              		.code	16
 452              		.thumb_func
 454              	greatest:
 455              	.LFB379:
 107:display.c     **** // -----------------------------------------------------------
 108:display.c     **** 
 109:display.c     **** 
 110:display.c     **** // -----------------------------------------------------------
 111:display.c     **** // Function Name       : greatest
 112:display.c     **** // -----------------------------------------------------------
 113:display.c     **** unsigned char greatest( unsigned char *a, unsigned char *b )
 114:display.c     **** {
 456              		.loc 1 114 0
 457              		.cfi_startproc
 458              	.LVL52:
 459 0000 00B5     		push	{lr}
 460              	.LCFI6:
 461              		.cfi_def_cfa_offset 4
 462              		.cfi_offset 14, -4
 115:display.c     **** 	unsigned char c;
 116:display.c     **** 
 117:display.c     **** 	if ( *a < *b )
 463              		.loc 1 117 0
 464 0002 0278     		ldrb	r2, [r0]
 465 0004 0B78     		ldrb	r3, [r1]
 466 0006 9A42     		cmp	r2, r3
 467 0008 01D2     		bcs	.L17
 468              	.LVL53:
 118:display.c     **** 	{
 119:display.c     **** 		c = *b;
 120:display.c     **** 		*b = *a;
 469              		.loc 1 120 0
 470 000a 0A70     		strb	r2, [r1]
 121:display.c     **** 		*a = c;
 471              		.loc 1 121 0
 472 000c 0370     		strb	r3, [r0]
 473              	.LVL54:
 474              	.L17:
 122:display.c     **** 	}
 123:display.c     **** 
 124:display.c     **** 	return( *a - *b );
 475              		.loc 1 124 0
 476 000e 0078     		ldrb	r0, [r0]
 477              	.LVL55:
 478 0010 0B78     		ldrb	r3, [r1]
 479 0012 C01A     		sub	r0, r0, r3
 480 0014 0006     		lsl	r0, r0, #24
 481 0016 000E     		lsr	r0, r0, #24
 125:display.c     **** }
 482              		.loc 1 125 0
 483              		@ sp needed for prologue
 484 0018 02BC     		pop	{r1}
 485 001a 0847     		bx	r1
 486              		.cfi_endproc
 487              	.LFE379:
 489              		.section	.text.draw_line,"ax",%progbits
 490              		.align	2
 491              		.global	draw_line
 492              		.code	16
 493              		.thumb_func
 495              	draw_line:
 496              	.LFB380:
 126:display.c     **** // -----------------------------------------------------------
 127:display.c     **** 
 128:display.c     **** 
 129:display.c     **** // -----------------------------------------------------------
 130:display.c     **** // Function Name       : draw_line
 131:display.c     **** // -----------------------------------------------------------
 132:display.c     **** void draw_line( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 133:display.c     ****   unsigned char xp2, unsigned char yp2, unsigned int method )
 134:display.c     **** {
 497              		.loc 1 134 0
 498              		.cfi_startproc
 499              	.LVL56:
 500 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 501              	.LCFI7:
 502              		.cfi_def_cfa_offset 20
 503              		.cfi_offset 4, -20
 504              		.cfi_offset 5, -16
 505              		.cfi_offset 6, -12
 506              		.cfi_offset 7, -8
 507              		.cfi_offset 14, -4
 508 0002 5F46     		mov	r7, fp
 509 0004 5646     		mov	r6, sl
 510 0006 4D46     		mov	r5, r9
 511 0008 4446     		mov	r4, r8
 512 000a F0B4     		push	{r4, r5, r6, r7}
 513              	.LCFI8:
 514              		.cfi_def_cfa_offset 36
 515              		.cfi_offset 8, -36
 516              		.cfi_offset 9, -32
 517              		.cfi_offset 10, -28
 518              		.cfi_offset 11, -24
 519 000c 87B0     		sub	sp, sp, #28
 520              	.LCFI9:
 521              		.cfi_def_cfa_offset 64
 522 000e 061C     		mov	r6, r0
 523 0010 119D     		ldr	r5, [sp, #68]
 524 0012 6846     		mov	r0, sp
 525              	.LVL57:
 526 0014 C175     		strb	r1, [r0, #23]
 527 0016 6846     		mov	r0, sp
 528 0018 8275     		strb	r2, [r0, #22]
 529 001a 6A46     		mov	r2, sp
 530              	.LVL58:
 531 001c 5375     		strb	r3, [r2, #21]
 135:display.c     **** 	unsigned char n, x, y, dx, dy, dir;
 136:display.c     **** 	unsigned short int offset;
 137:display.c     **** 
 138:display.c     **** 	if ( xp1 > 159 )
 532              		.loc 1 138 0
 533 001e 9F29     		cmp	r1, #159
 534 0020 02D9     		bls	.L19
 139:display.c     **** 		xp1 = 159;
 535              		.loc 1 139 0
 536 0022 9F22     		mov	r2, #159
 537 0024 6B46     		mov	r3, sp
 538 0026 DA75     		strb	r2, [r3, #23]
 539              	.LVL59:
 540              	.L19:
 140:display.c     **** 	if ( xp2 > 159 )
 541              		.loc 1 140 0
 542 0028 6B46     		mov	r3, sp
 543 002a 1533     		add	r3, r3, #21
 544 002c 1B78     		ldrb	r3, [r3]
 545              	.LVL60:
 546 002e 9F2B     		cmp	r3, #159
 547 0030 02D9     		bls	.L20
 548              	.LVL61:
 141:display.c     **** 		xp2 = 159;
 549              		.loc 1 141 0
 550 0032 9F22     		mov	r2, #159
 551 0034 6B46     		mov	r3, sp
 552              	.LVL62:
 553 0036 5A75     		strb	r2, [r3, #21]
 554              	.LVL63:
 555              	.L20:
 142:display.c     **** 	if ( yp1 > 127 )
 556              		.loc 1 142 0
 557 0038 6B46     		mov	r3, sp
 558 003a 1633     		add	r3, r3, #22
 559              	.LVL64:
 560 003c 1B78     		ldrb	r3, [r3]
 561              	.LVL65:
 562 003e 7F2B     		cmp	r3, #127
 563 0040 02D9     		bls	.L21
 564              	.LVL66:
 143:display.c     **** 		yp1 = 127;
 565              		.loc 1 143 0
 566 0042 7F22     		mov	r2, #127
 567 0044 6B46     		mov	r3, sp
 568              	.LVL67:
 569 0046 9A75     		strb	r2, [r3, #22]
 570              	.LVL68:
 571              	.L21:
 144:display.c     **** 	if ( yp2 > 127 )
 572              		.loc 1 144 0
 573 0048 10AB     		add	r3, sp, #64
 574 004a 1B78     		ldrb	r3, [r3]
 575              	.LVL69:
 576 004c 7F2B     		cmp	r3, #127
 577 004e 02D9     		bls	.L22
 578              	.LVL70:
 145:display.c     **** 		yp2 = 127;
 579              		.loc 1 145 0
 580 0050 7F22     		mov	r2, #127
 581 0052 10AB     		add	r3, sp, #64
 582              	.LVL71:
 583 0054 1A70     		strb	r2, [r3]
 584              	.LVL72:
 585              	.L22:
 146:display.c     **** 
 147:display.c     **** 	if ( ((xp2 >= xp1) && (yp2 >= yp1)) || ((xp2 < xp1) && (yp2 < yp1)) )
 586              		.loc 1 147 0
 587 0056 6B46     		mov	r3, sp
 588 0058 587D     		ldrb	r0, [r3, #21]
 589 005a 6B46     		mov	r3, sp
 590 005c D97D     		ldrb	r1, [r3, #23]
 591 005e 10AB     		add	r3, sp, #64
 592 0060 1A78     		ldrb	r2, [r3]
 593 0062 2A3B     		sub	r3, r3, #42
 594              	.LVL73:
 595 0064 1B78     		ldrb	r3, [r3]
 596 0066 9A42     		cmp	r2, r3
 597 0068 02D3     		bcc	.L39
 598 006a 8842     		cmp	r0, r1
 599 006c 00D3     		bcc	.LCB603
 600 006e EBE0     		b	.L23	@long jump
 601              	.LCB603:
 602              	.L39:
 603              		.loc 1 147 0 is_stmt 0 discriminator 1
 604 0070 9A42     		cmp	r2, r3
 605 0072 9B41     		sbc	r3, r3, r3
 606 0074 5B42     		neg	r3, r3
 607 0076 8842     		cmp	r0, r1
 608 0078 A441     		sbc	r4, r4, r4
 609 007a 6442     		neg	r4, r4
 610 007c 1C40     		and	r4, r3
 611              	.LVL74:
 148:display.c     **** 		dir = 0;
 149:display.c     **** 	else
 150:display.c     **** 		dir = 1;
 151:display.c     **** 
 152:display.c     **** 	dx = greatest( &xp2, &xp1 );
 612              		.loc 1 152 0 is_stmt 1 discriminator 1
 613 007e 6846     		mov	r0, sp
 614 0080 1530     		add	r0, r0, #21
 615 0082 6946     		mov	r1, sp
 616 0084 1731     		add	r1, r1, #23
 617 0086 FFF7FEFF 		bl	greatest
 618              	.LVL75:
 619 008a 0390     		str	r0, [sp, #12]
 620              	.LVL76:
 153:display.c     **** 	dy = greatest( &yp2, &yp1 );
 621              		.loc 1 153 0 discriminator 1
 622 008c 10A8     		add	r0, sp, #64
 623              	.LVL77:
 624 008e 6946     		mov	r1, sp
 625 0090 1631     		add	r1, r1, #22
 626 0092 FFF7FEFF 		bl	greatest
 627              	.LVL78:
 628 0096 0190     		str	r0, [sp, #4]
 629              	.LVL79:
 154:display.c     **** 
 155:display.c     **** 	if( dir )
 630              		.loc 1 155 0 discriminator 1
 631 0098 002C     		cmp	r4, #0
 632 009a 6BD1     		bne	.L25
 156:display.c     **** 	{
 157:display.c     **** 		x = xp2;
 633              		.loc 1 157 0
 634 009c 6B46     		mov	r3, sp
 635 009e 1533     		add	r3, r3, #21
 636              	.LVL80:
 637 00a0 1B78     		ldrb	r3, [r3]
 638 00a2 0293     		str	r3, [sp, #8]
 639              	.LVL81:
 158:display.c     **** 		for ( y = 0; y <= dy; y++ )
 159:display.c     **** 		{
 160:display.c     **** 			offset = (x / 8) + ((y + yp1) * COLUMNS);
 640              		.loc 1 160 0
 641 00a4 6B46     		mov	r3, sp
 642 00a6 1633     		add	r3, r3, #22
 643 00a8 1B78     		ldrb	r3, [r3]
 644 00aa 0493     		str	r3, [sp, #16]
 161:display.c     **** 			n = (unsigned char)0x80 >> (x % 8);
 162:display.c     **** 			while ( ((y * dx) >= ((xp2 - x) * dy)) && (x >= xp1) )
 645              		.loc 1 162 0
 646 00ac 6B46     		mov	r3, sp
 647 00ae 1733     		add	r3, r3, #23
 648              	.LVL82:
 649 00b0 1B78     		ldrb	r3, [r3]
 650 00b2 9C46     		mov	ip, r3
 157:display.c     **** 		x = xp2;
 651              		.loc 1 157 0
 652 00b4 029B     		ldr	r3, [sp, #8]
 158:display.c     **** 		for ( y = 0; y <= dy; y++ )
 653              		.loc 1 158 0
 654 00b6 0021     		mov	r1, #0
 655 00b8 8B46     		mov	fp, r1
 656              		.loc 1 162 0
 657 00ba 9946     		mov	r9, r3
 658 00bc 8046     		mov	r8, r0
 163:display.c     **** 			{
 164:display.c     **** 
 165:display.c     **** 				if ( method == CLEAR )
 166:display.c     **** 					buff[offset] &= ~n;
 167:display.c     **** 				else
 168:display.c     **** 					buff[offset] |= n;
 169:display.c     **** 				if ( !(n <<= 1) )
 170:display.c     **** 				{
 171:display.c     **** 					n = 0x01;
 659              		.loc 1 171 0
 660 00be 0127     		mov	r7, #1
 661 00c0 BA46     		mov	sl, r7
 662 00c2 2A1C     		mov	r2, r5
 663 00c4 6546     		mov	r5, ip
 664 00c6 9446     		mov	ip, r2
 665              	.LVL83:
 666              	.L31:
 160:display.c     **** 			offset = (x / 8) + ((y + yp1) * COLUMNS);
 667              		.loc 1 160 0
 668 00c8 0499     		ldr	r1, [sp, #16]
 669 00ca 0A1C     		mov	r2, r1
 670 00cc 5A44     		add	r2, r2, fp
 671 00ce 9100     		lsl	r1, r2, #2
 672 00d0 8A18     		add	r2, r1, r2
 673 00d2 9200     		lsl	r2, r2, #2
 674 00d4 D908     		lsr	r1, r3, #3
 675 00d6 5018     		add	r0, r2, r1
 676 00d8 0004     		lsl	r0, r0, #16
 677 00da 000C     		lsr	r0, r0, #16
 678              	.LVL84:
 161:display.c     **** 			n = (unsigned char)0x80 >> (x % 8);
 679              		.loc 1 161 0
 680 00dc 0722     		mov	r2, #7
 681 00de 1A40     		and	r2, r3
 682 00e0 8024     		mov	r4, #128
 683 00e2 1441     		asr	r4, r4, r2
 684 00e4 2206     		lsl	r2, r4, #24
 685 00e6 120E     		lsr	r2, r2, #24
 686              	.LVL85:
 162:display.c     **** 			while ( ((y * dx) >= ((xp2 - x) * dy)) && (x >= xp1) )
 687              		.loc 1 162 0
 688 00e8 039C     		ldr	r4, [sp, #12]
 689 00ea 5F46     		mov	r7, fp
 690 00ec 6743     		mul	r7, r4
 691 00ee 029C     		ldr	r4, [sp, #8]
 692 00f0 E11A     		sub	r1, r4, r3
 693 00f2 019C     		ldr	r4, [sp, #4]
 694 00f4 6143     		mul	r1, r4
 695 00f6 8F42     		cmp	r7, r1
 696 00f8 30DB     		blt	.L26
 697 00fa AB42     		cmp	r3, r5
 698 00fc 2ED3     		bcc	.L26
 699 00fe 0097     		str	r7, [sp]
 700 0100 6446     		mov	r4, ip
 701 0102 AC46     		mov	ip, r5
 702 0104 4D46     		mov	r5, r9
 703              	.LVL86:
 704              	.L40:
 165:display.c     **** 				if ( method == CLEAR )
 705              		.loc 1 165 0
 706 0106 402C     		cmp	r4, #64
 707 0108 04D1     		bne	.L27
 166:display.c     **** 					buff[offset] &= ~n;
 708              		.loc 1 166 0
 709 010a 3718     		add	r7, r6, r0
 710 010c 3978     		ldrb	r1, [r7]
 711 010e 9143     		bic	r1, r2
 712 0110 3970     		strb	r1, [r7]
 713 0112 03E0     		b	.L28
 714              	.L27:
 168:display.c     **** 					buff[offset] |= n;
 715              		.loc 1 168 0
 716 0114 3118     		add	r1, r6, r0
 717 0116 0F78     		ldrb	r7, [r1]
 718 0118 1743     		orr	r7, r2
 719 011a 0F70     		strb	r7, [r1]
 720              	.L28:
 169:display.c     **** 				if ( !(n <<= 1) )
 721              		.loc 1 169 0
 722 011c 5206     		lsl	r2, r2, #25
 723 011e 120E     		lsr	r2, r2, #24
 724              	.LVL87:
 725 0120 03D1     		bne	.L29
 726              	.LVL88:
 172:display.c     **** 					offset--;
 727              		.loc 1 172 0
 728 0122 0138     		sub	r0, r0, #1
 729 0124 0004     		lsl	r0, r0, #16
 730 0126 000C     		lsr	r0, r0, #16
 731              	.LVL89:
 171:display.c     **** 					n = 0x01;
 732              		.loc 1 171 0
 733 0128 5246     		mov	r2, sl
 734              	.LVL90:
 735              	.L29:
 173:display.c     **** 				}
 174:display.c     **** 				if( x )
 736              		.loc 1 174 0
 737 012a 002B     		cmp	r3, #0
 738 012c 0FD0     		beq	.L46
 175:display.c     **** 					x--;
 739              		.loc 1 175 0
 740 012e 013B     		sub	r3, r3, #1
 741 0130 1B06     		lsl	r3, r3, #24
 742 0132 1B0E     		lsr	r3, r3, #24
 743              	.LVL91:
 162:display.c     **** 			while ( ((y * dx) >= ((xp2 - x) * dy)) && (x >= xp1) )
 744              		.loc 1 162 0
 745 0134 E91A     		sub	r1, r5, r3
 746 0136 0F1C     		mov	r7, r1
 747 0138 4146     		mov	r1, r8
 748 013a 7943     		mul	r1, r7
 749 013c 009F     		ldr	r7, [sp]
 750 013e B942     		cmp	r1, r7
 751 0140 09DC     		bgt	.L47
 162:display.c     **** 			while ( ((y * dx) >= ((xp2 - x) * dy)) && (x >= xp1) )
 752              		.loc 1 162 0 is_stmt 0 discriminator 2
 753 0142 6345     		cmp	r3, ip
 754 0144 DFD2     		bcs	.L40
 755 0146 A946     		mov	r9, r5
 756 0148 6546     		mov	r5, ip
 757 014a A446     		mov	ip, r4
 758 014c 06E0     		b	.L26
 759              	.LVL92:
 760              	.L46:
 761 014e A946     		mov	r9, r5
 762 0150 6546     		mov	r5, ip
 763 0152 A446     		mov	ip, r4
 764 0154 02E0     		b	.L26
 765              	.LVL93:
 766              	.L47:
 767 0156 A946     		mov	r9, r5
 768 0158 6546     		mov	r5, ip
 769 015a A446     		mov	ip, r4
 770              	.LVL94:
 771              	.L26:
 176:display.c     **** 				else
 177:display.c     **** 					break;
 178:display.c     **** 			}
 179:display.c     **** 			x++;
 772              		.loc 1 179 0 is_stmt 1
 773 015c 0133     		add	r3, r3, #1
 774 015e 1B06     		lsl	r3, r3, #24
 775 0160 1B0E     		lsr	r3, r3, #24
 776              	.LVL95:
 158:display.c     **** 		for ( y = 0; y <= dy; y++ )
 777              		.loc 1 158 0
 778 0162 5A46     		mov	r2, fp
 779 0164 0132     		add	r2, r2, #1
 780 0166 1206     		lsl	r2, r2, #24
 781 0168 120E     		lsr	r2, r2, #24
 782 016a 9346     		mov	fp, r2
 783              	.LVL96:
 784 016c 0199     		ldr	r1, [sp, #4]
 785 016e 9142     		cmp	r1, r2
 786 0170 AAD2     		bcs	.L31
 787 0172 77E0     		b	.L18
 788              	.LVL97:
 789              	.L25:
 180:display.c     **** 		}
 181:display.c     **** 	}
 182:display.c     **** 	else
 183:display.c     **** 	{
 184:display.c     **** 		x = xp1;
 790              		.loc 1 184 0
 791 0174 6B46     		mov	r3, sp
 792 0176 1733     		add	r3, r3, #23
 793 0178 1B78     		ldrb	r3, [r3]
 794 017a 0293     		str	r3, [sp, #8]
 795              	.LVL98:
 185:display.c     **** 		for ( y = 0; y <= dy; y++ )
 186:display.c     **** 		{
 187:display.c     **** 			offset = (x / 8) + ((y + yp1) * COLUMNS);
 796              		.loc 1 187 0
 797 017c 6B46     		mov	r3, sp
 798 017e 1633     		add	r3, r3, #22
 799 0180 1B78     		ldrb	r3, [r3]
 800 0182 0493     		str	r3, [sp, #16]
 188:display.c     **** 			n = (unsigned char)0x01 << (7 - (x % 8));
 189:display.c     **** 			while ( ((y * dx) >= ((x - xp1) * dy)) && (x <= xp2) )
 801              		.loc 1 189 0
 802 0184 6B46     		mov	r3, sp
 803 0186 1533     		add	r3, r3, #21
 804 0188 1B78     		ldrb	r3, [r3]
 805 018a 9C46     		mov	ip, r3
 184:display.c     **** 		x = xp1;
 806              		.loc 1 184 0
 807 018c 029A     		ldr	r2, [sp, #8]
 185:display.c     **** 		for ( y = 0; y <= dy; y++ )
 808              		.loc 1 185 0
 809 018e 0023     		mov	r3, #0
 810 0190 9B46     		mov	fp, r3
 811              		.loc 1 189 0
 812 0192 9146     		mov	r9, r2
 813 0194 019F     		ldr	r7, [sp, #4]
 814 0196 B846     		mov	r8, r7
 190:display.c     **** 			{
 191:display.c     **** 				if ( method == CLEAR )
 192:display.c     **** 					buff[offset] &= ~n;
 193:display.c     **** 				else
 194:display.c     **** 					buff[offset] |= n;
 195:display.c     **** 				if ( !(n >>= 1) )
 196:display.c     **** 				{
 197:display.c     **** 					n = 0x80;
 815              		.loc 1 197 0
 816 0198 8021     		mov	r1, #128
 817 019a 8A46     		mov	sl, r1
 818 019c 2B1C     		mov	r3, r5
 819 019e 6546     		mov	r5, ip
 820 01a0 B446     		mov	ip, r6
 821 01a2 1E1C     		mov	r6, r3
 822              	.LVL99:
 823              	.L38:
 187:display.c     **** 			offset = (x / 8) + ((y + yp1) * COLUMNS);
 824              		.loc 1 187 0
 825 01a4 049C     		ldr	r4, [sp, #16]
 826 01a6 231C     		mov	r3, r4
 827 01a8 5B44     		add	r3, r3, fp
 828 01aa 9900     		lsl	r1, r3, #2
 829 01ac CB18     		add	r3, r1, r3
 830 01ae 9B00     		lsl	r3, r3, #2
 831 01b0 D108     		lsr	r1, r2, #3
 832 01b2 5818     		add	r0, r3, r1
 833 01b4 0004     		lsl	r0, r0, #16
 834 01b6 000C     		lsr	r0, r0, #16
 835              	.LVL100:
 188:display.c     **** 			n = (unsigned char)0x01 << (7 - (x % 8));
 836              		.loc 1 188 0
 837 01b8 0723     		mov	r3, #7
 838 01ba 9343     		bic	r3, r2
 839 01bc 0127     		mov	r7, #1
 840 01be 9F40     		lsl	r7, r7, r3
 841 01c0 3B06     		lsl	r3, r7, #24
 842 01c2 1B0E     		lsr	r3, r3, #24
 843              	.LVL101:
 189:display.c     **** 			while ( ((y * dx) >= ((x - xp1) * dy)) && (x <= xp2) )
 844              		.loc 1 189 0
 845 01c4 039C     		ldr	r4, [sp, #12]
 846 01c6 5F46     		mov	r7, fp
 847 01c8 6743     		mul	r7, r4
 848 01ca 029C     		ldr	r4, [sp, #8]
 849 01cc 111B     		sub	r1, r2, r4
 850 01ce 019C     		ldr	r4, [sp, #4]
 851 01d0 6143     		mul	r1, r4
 852 01d2 8F42     		cmp	r7, r1
 853 01d4 2CDB     		blt	.L33
 854 01d6 AA42     		cmp	r2, r5
 855 01d8 2AD8     		bhi	.L33
 856 01da 0097     		str	r7, [sp]
 857 01dc 4C46     		mov	r4, r9
 858 01de 4146     		mov	r1, r8
 859 01e0 A846     		mov	r8, r5
 860 01e2 0D1C     		mov	r5, r1
 861              	.LVL102:
 862              	.L41:
 191:display.c     **** 				if ( method == CLEAR )
 863              		.loc 1 191 0
 864 01e4 402E     		cmp	r6, #64
 865 01e6 05D1     		bne	.L34
 192:display.c     **** 					buff[offset] &= ~n;
 866              		.loc 1 192 0
 867 01e8 6146     		mov	r1, ip
 868 01ea 0F18     		add	r7, r1, r0
 869 01ec 3978     		ldrb	r1, [r7]
 870 01ee 9943     		bic	r1, r3
 871 01f0 3970     		strb	r1, [r7]
 872 01f2 04E0     		b	.L35
 873              	.L34:
 194:display.c     **** 					buff[offset] |= n;
 874              		.loc 1 194 0
 875 01f4 6746     		mov	r7, ip
 876 01f6 3918     		add	r1, r7, r0
 877 01f8 0F78     		ldrb	r7, [r1]
 878 01fa 1F43     		orr	r7, r3
 879 01fc 0F70     		strb	r7, [r1]
 880              	.L35:
 195:display.c     **** 				if ( !(n >>= 1) )
 881              		.loc 1 195 0
 882 01fe 5B08     		lsr	r3, r3, #1
 883              	.LVL103:
 884 0200 03D1     		bne	.L36
 885              	.LVL104:
 198:display.c     **** 					offset++;
 886              		.loc 1 198 0
 887 0202 0130     		add	r0, r0, #1
 888 0204 0004     		lsl	r0, r0, #16
 889 0206 000C     		lsr	r0, r0, #16
 890              	.LVL105:
 197:display.c     **** 					n = 0x80;
 891              		.loc 1 197 0
 892 0208 5346     		mov	r3, sl
 893              	.LVL106:
 894              	.L36:
 199:display.c     **** 				}
 200:display.c     **** 				x++;
 895              		.loc 1 200 0
 896 020a 0132     		add	r2, r2, #1
 897 020c 1206     		lsl	r2, r2, #24
 898 020e 120E     		lsr	r2, r2, #24
 899              	.LVL107:
 189:display.c     **** 			while ( ((y * dx) >= ((x - xp1) * dy)) && (x <= xp2) )
 900              		.loc 1 189 0
 901 0210 111B     		sub	r1, r2, r4
 902 0212 6943     		mul	r1, r5
 903 0214 009F     		ldr	r7, [sp]
 904 0216 B942     		cmp	r1, r7
 905 0218 06DC     		bgt	.L48
 189:display.c     **** 			while ( ((y * dx) >= ((x - xp1) * dy)) && (x <= xp2) )
 906              		.loc 1 189 0 is_stmt 0 discriminator 2
 907 021a 4245     		cmp	r2, r8
 908 021c E2D9     		bls	.L41
 909 021e A146     		mov	r9, r4
 910 0220 2B1C     		mov	r3, r5
 911              	.LVL108:
 912 0222 4546     		mov	r5, r8
 913 0224 9846     		mov	r8, r3
 914 0226 03E0     		b	.L33
 915              	.LVL109:
 916              	.L48:
 917 0228 A146     		mov	r9, r4
 918 022a 2B1C     		mov	r3, r5
 919              	.LVL110:
 920 022c 4546     		mov	r5, r8
 921 022e 9846     		mov	r8, r3
 922              	.LVL111:
 923              	.L33:
 201:display.c     **** 			}
 202:display.c     **** 			x--;
 924              		.loc 1 202 0 is_stmt 1
 925 0230 013A     		sub	r2, r2, #1
 926 0232 1206     		lsl	r2, r2, #24
 927 0234 120E     		lsr	r2, r2, #24
 928              	.LVL112:
 185:display.c     **** 		for ( y = 0; y <= dy; y++ )
 929              		.loc 1 185 0
 930 0236 5B46     		mov	r3, fp
 931 0238 0133     		add	r3, r3, #1
 932 023a 1B06     		lsl	r3, r3, #24
 933 023c 1B0E     		lsr	r3, r3, #24
 934 023e 9B46     		mov	fp, r3
 935              	.LVL113:
 936 0240 0199     		ldr	r1, [sp, #4]
 937 0242 9942     		cmp	r1, r3
 938 0244 AED2     		bcs	.L38
 939 0246 0DE0     		b	.L18
 940              	.LVL114:
 941              	.L23:
 152:display.c     **** 	dx = greatest( &xp2, &xp1 );
 942              		.loc 1 152 0
 943 0248 6846     		mov	r0, sp
 944 024a 1530     		add	r0, r0, #21
 945 024c 6946     		mov	r1, sp
 946 024e 1731     		add	r1, r1, #23
 947 0250 FFF7FEFF 		bl	greatest
 948              	.LVL115:
 949 0254 0390     		str	r0, [sp, #12]
 950              	.LVL116:
 153:display.c     **** 	dy = greatest( &yp2, &yp1 );
 951              		.loc 1 153 0
 952 0256 10A8     		add	r0, sp, #64
 953              	.LVL117:
 954 0258 6946     		mov	r1, sp
 955 025a 1631     		add	r1, r1, #22
 956 025c FFF7FEFF 		bl	greatest
 957              	.LVL118:
 958 0260 0190     		str	r0, [sp, #4]
 959              	.LVL119:
 960 0262 87E7     		b	.L25
 961              	.LVL120:
 962              	.L18:
 203:display.c     **** 		}
 204:display.c     **** 	}
 205:display.c     **** 
 206:display.c     **** }
 963              		.loc 1 206 0
 964 0264 07B0     		add	sp, sp, #28
 965              		@ sp needed for prologue
 966 0266 3CBC     		pop	{r2, r3, r4, r5}
 967 0268 9046     		mov	r8, r2
 968 026a 9946     		mov	r9, r3
 969 026c A246     		mov	sl, r4
 970 026e AB46     		mov	fp, r5
 971 0270 F0BC     		pop	{r4, r5, r6, r7}
 972 0272 01BC     		pop	{r0}
 973 0274 0047     		bx	r0
 974              		.cfi_endproc
 975              	.LFE380:
 977 0276 C046     		.section	.text.draw_box,"ax",%progbits
 978              		.align	2
 979              		.global	draw_box
 980              		.code	16
 981              		.thumb_func
 983              	draw_box:
 984              	.LFB381:
 207:display.c     **** // -----------------------------------------------------------
 208:display.c     **** 
 209:display.c     **** 
 210:display.c     **** // -----------------------------------------------------------
 211:display.c     **** // Function Name       : draw_box
 212:display.c     **** // -----------------------------------------------------------
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 214:display.c     ****   unsigned char xp2, unsigned char yp2, unsigned int method )
 215:display.c     **** {
 985              		.loc 1 215 0
 986              		.cfi_startproc
 987              	.LVL121:
 988 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 989              	.LCFI10:
 990              		.cfi_def_cfa_offset 20
 991              		.cfi_offset 4, -20
 992              		.cfi_offset 5, -16
 993              		.cfi_offset 6, -12
 994              		.cfi_offset 7, -8
 995              		.cfi_offset 14, -4
 996 0002 5F46     		mov	r7, fp
 997 0004 5646     		mov	r6, sl
 998 0006 4D46     		mov	r5, r9
 999 0008 4446     		mov	r4, r8
 1000 000a F0B4     		push	{r4, r5, r6, r7}
 1001              	.LCFI11:
 1002              		.cfi_def_cfa_offset 36
 1003              		.cfi_offset 8, -36
 1004              		.cfi_offset 9, -32
 1005              		.cfi_offset 10, -28
 1006              		.cfi_offset 11, -24
 1007 000c 89B0     		sub	sp, sp, #36
 1008              	.LCFI12:
 1009              		.cfi_def_cfa_offset 72
 1010 000e 041C     		mov	r4, r0
 1011 0010 6846     		mov	r0, sp
 1012              	.LVL122:
 1013 0012 C177     		strb	r1, [r0, #31]
 1014 0014 6846     		mov	r0, sp
 1015 0016 8277     		strb	r2, [r0, #30]
 1016 0018 6A46     		mov	r2, sp
 1017              	.LVL123:
 1018 001a 5377     		strb	r3, [r2, #29]
 216:display.c     **** 	/* GREY, CLEAR, FULL, INV or EMPTY(default), */
 217:display.c     **** 
 218:display.c     **** 	unsigned char start_byte, end_byte, right_shift, left_shift, dx, bytes;
 219:display.c     **** 	unsigned char n, c, x, y, cc, nn, mask;
 220:display.c     **** 	unsigned short int offset, point;
 221:display.c     **** 
 222:display.c     **** 	if ( xp1 > 159 )
 1019              		.loc 1 222 0
 1020 001c 9F29     		cmp	r1, #159
 1021 001e 02D9     		bls	.L50
 223:display.c     **** 		xp1 = 159;
 1022              		.loc 1 223 0
 1023 0020 9F22     		mov	r2, #159
 1024 0022 6B46     		mov	r3, sp
 1025 0024 DA77     		strb	r2, [r3, #31]
 1026              	.LVL124:
 1027              	.L50:
 224:display.c     **** 	if ( xp2 > 159 )
 1028              		.loc 1 224 0
 1029 0026 6B46     		mov	r3, sp
 1030 0028 1D33     		add	r3, r3, #29
 1031 002a 1B78     		ldrb	r3, [r3]
 1032              	.LVL125:
 1033 002c 9F2B     		cmp	r3, #159
 1034 002e 02D9     		bls	.L51
 1035              	.LVL126:
 225:display.c     **** 		xp2 = 159;
 1036              		.loc 1 225 0
 1037 0030 9F22     		mov	r2, #159
 1038 0032 6B46     		mov	r3, sp
 1039              	.LVL127:
 1040 0034 5A77     		strb	r2, [r3, #29]
 1041              	.LVL128:
 1042              	.L51:
 226:display.c     **** 	if ( yp1 > 127 )
 1043              		.loc 1 226 0
 1044 0036 6B46     		mov	r3, sp
 1045 0038 1E33     		add	r3, r3, #30
 1046              	.LVL129:
 1047 003a 1B78     		ldrb	r3, [r3]
 1048              	.LVL130:
 1049 003c 7F2B     		cmp	r3, #127
 1050 003e 02D9     		bls	.L52
 1051              	.LVL131:
 227:display.c     **** 		yp1 = 127;
 1052              		.loc 1 227 0
 1053 0040 7F22     		mov	r2, #127
 1054 0042 6B46     		mov	r3, sp
 1055              	.LVL132:
 1056 0044 9A77     		strb	r2, [r3, #30]
 1057              	.LVL133:
 1058              	.L52:
 228:display.c     **** 	if ( yp2 > 127 )
 1059              		.loc 1 228 0
 1060 0046 12AB     		add	r3, sp, #72
 1061 0048 1B78     		ldrb	r3, [r3]
 1062              	.LVL134:
 1063 004a 7F2B     		cmp	r3, #127
 1064 004c 02D9     		bls	.L53
 1065              	.LVL135:
 229:display.c     **** 		yp2 = 127;
 1066              		.loc 1 229 0
 1067 004e 7F22     		mov	r2, #127
 1068 0050 12AB     		add	r3, sp, #72
 1069              	.LVL136:
 1070 0052 1A70     		strb	r2, [r3]
 1071              	.LVL137:
 1072              	.L53:
 230:display.c     **** 
 231:display.c     **** 	dx = greatest( &xp2, &xp1 );
 1073              		.loc 1 231 0
 1074 0054 6846     		mov	r0, sp
 1075 0056 1D30     		add	r0, r0, #29
 1076 0058 6946     		mov	r1, sp
 1077 005a 1F31     		add	r1, r1, #31
 1078 005c FFF7FEFF 		bl	greatest
 1079              	.LVL138:
 1080 0060 051C     		mov	r5, r0
 1081              	.LVL139:
 232:display.c     **** 	greatest( &yp2, &yp1 );
 1082              		.loc 1 232 0
 1083 0062 12A8     		add	r0, sp, #72
 1084              	.LVL140:
 1085 0064 6946     		mov	r1, sp
 1086 0066 1E31     		add	r1, r1, #30
 1087 0068 FFF7FEFF 		bl	greatest
 1088              	.LVL141:
 233:display.c     **** 
 234:display.c     **** 	if ( !dx )
 1089              		.loc 1 234 0
 1090 006c 002D     		cmp	r5, #0
 1091 006e 0FD1     		bne	.L54
 235:display.c     **** 	{
 236:display.c     **** 		draw_line( buff, xp1, yp1, xp1, yp2, method );
 1092              		.loc 1 236 0
 1093 0070 6B46     		mov	r3, sp
 1094 0072 1F33     		add	r3, r3, #31
 1095              	.LVL142:
 1096 0074 1B78     		ldrb	r3, [r3]
 1097 0076 6A46     		mov	r2, sp
 1098 0078 1E32     		add	r2, r2, #30
 1099              	.LVL143:
 1100 007a 1278     		ldrb	r2, [r2]
 1101              	.LVL144:
 1102 007c 12A9     		add	r1, sp, #72
 1103              	.LVL145:
 1104 007e 0978     		ldrb	r1, [r1]
 1105              	.LVL146:
 1106 0080 0091     		str	r1, [sp]
 1107              	.LVL147:
 1108 0082 139E     		ldr	r6, [sp, #76]
 1109 0084 0196     		str	r6, [sp, #4]
 1110 0086 201C     		mov	r0, r4
 1111 0088 191C     		mov	r1, r3
 1112              	.LVL148:
 1113 008a FFF7FEFF 		bl	draw_line
 1114              	.LVL149:
 237:display.c     **** 		return;
 1115              		.loc 1 237 0
 1116 008e 4DE2     		b	.L49
 1117              	.LVL150:
 1118              	.L54:
 238:display.c     **** 	}
 239:display.c     **** 	else if ( dx == 1)
 1119              		.loc 1 239 0
 1120 0090 012D     		cmp	r5, #1
 1121 0092 1AD1     		bne	.L56
 240:display.c     **** 	{
 241:display.c     **** 		draw_line( buff, xp1, yp1, xp1, yp2, method );
 1122              		.loc 1 241 0
 1123 0094 6B46     		mov	r3, sp
 1124 0096 1F33     		add	r3, r3, #31
 1125 0098 1B78     		ldrb	r3, [r3]
 1126 009a 6D46     		mov	r5, sp
 1127              	.LVL151:
 1128 009c AA7F     		ldrb	r2, [r5, #30]
 1129              	.LVL152:
 1130 009e 12A9     		add	r1, sp, #72
 1131 00a0 0978     		ldrb	r1, [r1]
 1132              	.LVL153:
 1133 00a2 0091     		str	r1, [sp]
 1134              	.LVL154:
 1135 00a4 139F     		ldr	r7, [sp, #76]
 1136 00a6 0197     		str	r7, [sp, #4]
 1137 00a8 201C     		mov	r0, r4
 1138 00aa 191C     		mov	r1, r3
 1139              	.LVL155:
 1140 00ac FFF7FEFF 		bl	draw_line
 1141              	.LVL156:
 242:display.c     **** 		draw_line( buff, xp2, yp1, xp2, yp2, method );
 1142              		.loc 1 242 0
 1143 00b0 6B46     		mov	r3, sp
 1144 00b2 1D33     		add	r3, r3, #29
 1145              	.LVL157:
 1146 00b4 1B78     		ldrb	r3, [r3]
 1147              	.LVL158:
 1148 00b6 AA7F     		ldrb	r2, [r5, #30]
 1149              	.LVL159:
 1150 00b8 12A9     		add	r1, sp, #72
 1151              	.LVL160:
 1152 00ba 0978     		ldrb	r1, [r1]
 1153              	.LVL161:
 1154 00bc 0091     		str	r1, [sp]
 1155              	.LVL162:
 1156 00be 0197     		str	r7, [sp, #4]
 1157 00c0 201C     		mov	r0, r4
 1158 00c2 191C     		mov	r1, r3
 1159              	.LVL163:
 1160 00c4 FFF7FEFF 		bl	draw_line
 1161              	.LVL164:
 243:display.c     **** 		return;
 1162              		.loc 1 243 0
 1163 00c8 30E2     		b	.L49
 1164              	.LVL165:
 1165              	.L56:
 244:display.c     **** 	}
 245:display.c     **** 
 246:display.c     **** 	start_byte = xp1 / 8;
 1166              		.loc 1 246 0
 1167 00ca 6B46     		mov	r3, sp
 1168 00cc DD7F     		ldrb	r5, [r3, #31]
 1169              	.LVL166:
 1170 00ce E908     		lsr	r1, r5, #3
 1171              	.LVL167:
 247:display.c     **** 	right_shift = xp1 % 8;
 248:display.c     **** 	end_byte = xp2 / 8;
 1172              		.loc 1 248 0
 1173 00d0 6B46     		mov	r3, sp
 1174 00d2 5A7F     		ldrb	r2, [r3, #29]
 1175 00d4 D008     		lsr	r0, r2, #3
 1176 00d6 8346     		mov	fp, r0
 1177              	.LVL168:
 249:display.c     **** 	left_shift = 7-(xp2 % 8);
 250:display.c     **** 	bytes = end_byte - start_byte;
 1178              		.loc 1 250 0
 1179 00d8 471A     		sub	r7, r0, r1
 1180 00da 3F06     		lsl	r7, r7, #24
 1181 00dc 3F0E     		lsr	r7, r7, #24
 1182              	.LVL169:
 247:display.c     **** 	right_shift = xp1 % 8;
 1183              		.loc 1 247 0
 1184 00de 0720     		mov	r0, #7
 1185              	.LVL170:
 251:display.c     **** 
 252:display.c     **** 	c = (unsigned char)0xff >> right_shift;
 1186              		.loc 1 252 0
 1187 00e0 0540     		and	r5, r0
 1188              	.LVL171:
 1189 00e2 FF23     		mov	r3, #255
 1190              	.LVL172:
 1191 00e4 1E1C     		mov	r6, r3
 1192 00e6 2E41     		asr	r6, r6, r5
 1193 00e8 3606     		lsl	r6, r6, #24
 1194 00ea 360E     		lsr	r6, r6, #24
 1195 00ec B446     		mov	ip, r6
 1196              	.LVL173:
 253:display.c     **** 	n = (unsigned char)0xff << left_shift;
 1197              		.loc 1 253 0
 1198 00ee 9043     		bic	r0, r2
 1199 00f0 8340     		lsl	r3, r3, r0
 1200 00f2 1B06     		lsl	r3, r3, #24
 1201 00f4 1B0E     		lsr	r3, r3, #24
 1202 00f6 9A46     		mov	sl, r3
 1203              	.LVL174:
 254:display.c     **** 
 255:display.c     **** 	switch ( method )
 1204              		.loc 1 255 0
 1205 00f8 139E     		ldr	r6, [sp, #76]
 1206              	.LVL175:
 1207 00fa 402E     		cmp	r6, #64
 1208 00fc 73D0     		beq	.L60
 1209 00fe 06D8     		bhi	.L62
 1210 0100 042E     		cmp	r6, #4
 1211 0102 00D1     		bne	.LCB1274
 1212 0104 04E1     		b	.L58	@long jump
 1213              	.LCB1274:
 1214 0106 202E     		cmp	r6, #32
 1215 0108 00D0     		beq	.LCB1276
 1216 010a 4FE1     		b	.L57	@long jump
 1217              	.LCB1276:
 1218 010c B4E0     		b	.L59
 1219              	.L62:
 1220 010e 139E     		ldr	r6, [sp, #76]
 1221 0110 802E     		cmp	r6, #128
 1222 0112 05D0     		beq	.L61
 1223 0114 8023     		mov	r3, #128
 1224              	.LVL176:
 1225 0116 5B00     		lsl	r3, r3, #1
 1226 0118 9E42     		cmp	r6, r3
 1227 011a 00D0     		beq	.LCB1288
 1228 011c 46E1     		b	.L57	@long jump
 1229              	.LCB1288:
 1230 011e F7E0     		b	.L58
 1231              	.LVL177:
 1232              	.L61:
 256:display.c     **** 	{
 257:display.c     **** 	case GREY:
 258:display.c     **** 		for ( y = yp1; y <= yp2; y++ )
 1233              		.loc 1 258 0
 1234 0120 6B46     		mov	r3, sp
 1235              	.LVL178:
 1236 0122 9E7F     		ldrb	r6, [r3, #30]
 1237              	.LVL179:
 1238 0124 12AB     		add	r3, sp, #72
 1239 0126 1B78     		ldrb	r3, [r3]
 1240 0128 0393     		str	r3, [sp, #12]
 1241 012a 9E42     		cmp	r6, r3
 1242 012c 00D9     		bls	.LCB1302
 1243 012e FDE1     		b	.L49	@long jump
 1244              	.LCB1302:
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1245              		.loc 1 213 0
 1246 0130 5B46     		mov	r3, fp
 1247 0132 023B     		sub	r3, r3, #2
 1248 0134 5B1A     		sub	r3, r3, r1
 1249 0136 1B06     		lsl	r3, r3, #24
 1250 0138 1B0E     		lsr	r3, r3, #24
 1251 013a 0493     		str	r3, [sp, #16]
 1252 013c 0233     		add	r3, r3, #2
 1253 013e 0693     		str	r3, [sp, #24]
 1254 0140 8946     		mov	r9, r1
 1255 0142 5946     		mov	r1, fp
 1256              	.LVL180:
 1257 0144 0591     		str	r1, [sp, #20]
 1258 0146 BB46     		mov	fp, r7
 1259              	.LVL181:
 1260              	.L93:
 259:display.c     **** 		{
 260:display.c     **** 			mask = (y & 1) ? 0xaa : 0x55;
 1261              		.loc 1 260 0
 1262 0148 5525     		mov	r5, #85
 1263 014a 0122     		mov	r2, #1
 1264 014c 3242     		tst	r2, r6
 1265 014e 00D0     		beq	.L64
 1266 0150 AA25     		mov	r5, #170
 1267              	.L64:
 1268              	.LVL182:
 261:display.c     **** 			cc = c & mask;
 1269              		.loc 1 261 0 discriminator 3
 1270 0152 6346     		mov	r3, ip
 1271 0154 2B40     		and	r3, r5
 1272              	.LVL183:
 262:display.c     **** 			nn = n & mask;
 1273              		.loc 1 262 0 discriminator 3
 1274 0156 5746     		mov	r7, sl
 1275 0158 2F40     		and	r7, r5
 1276 015a B846     		mov	r8, r7
 1277              	.LVL184:
 263:display.c     **** 
 264:display.c     **** 			offset = start_byte + (y * COLUMNS);
 1278              		.loc 1 264 0 discriminator 3
 1279 015c B100     		lsl	r1, r6, #2
 1280 015e 8919     		add	r1, r1, r6
 1281 0160 8900     		lsl	r1, r1, #2
 1282 0162 4944     		add	r1, r1, r9
 1283 0164 0904     		lsl	r1, r1, #16
 1284 0166 090C     		lsr	r1, r1, #16
 1285              	.LVL185:
 265:display.c     **** 			if ( !bytes )
 1286              		.loc 1 265 0 discriminator 3
 1287 0168 5846     		mov	r0, fp
 1288 016a 0028     		cmp	r0, #0
 1289 016c 0AD1     		bne	.L65
 1290              	.LVL186:
 266:display.c     **** 				buff[offset++] &= ((cc & nn) | ~(c & n));
 1291              		.loc 1 266 0
 1292 016e 6118     		add	r1, r4, r1
 1293              	.LVL187:
 1294 0170 3B40     		and	r3, r7
 1295              	.LVL188:
 1296 0172 6246     		mov	r2, ip
 1297 0174 5746     		mov	r7, sl
 1298              	.LVL189:
 1299 0176 3A40     		and	r2, r7
 1300 0178 D243     		mvn	r2, r2
 1301 017a 1343     		orr	r3, r2
 1302 017c 0A78     		ldrb	r2, [r1]
 1303 017e 1340     		and	r3, r2
 1304 0180 0B70     		strb	r3, [r1]
 1305              	.LVL190:
 1306 0182 29E0     		b	.L66
 1307              	.LVL191:
 1308              	.L65:
 267:display.c     **** 			else
 268:display.c     **** 			{
 269:display.c     **** 				buff[offset++] &= (cc | ~c);
 1309              		.loc 1 269 0
 1310 0184 6218     		add	r2, r4, r1
 1311 0186 6746     		mov	r7, ip
 1312              	.LVL192:
 1313 0188 F843     		mvn	r0, r7
 1314              	.LVL193:
 1315 018a 0343     		orr	r3, r0
 1316              	.LVL194:
 1317 018c 1078     		ldrb	r0, [r2]
 1318 018e 0340     		and	r3, r0
 1319 0190 1370     		strb	r3, [r2]
 1320 0192 4F1C     		add	r7, r1, #1
 1321 0194 3F04     		lsl	r7, r7, #16
 1322 0196 3F0C     		lsr	r7, r7, #16
 1323              	.LVL195:
 270:display.c     **** 				for ( x = start_byte+1; x < end_byte; x++ )
 1324              		.loc 1 270 0
 1325 0198 4B46     		mov	r3, r9
 1326 019a 0133     		add	r3, r3, #1
 1327 019c 0598     		ldr	r0, [sp, #20]
 1328 019e 9842     		cmp	r0, r3
 1329 01a0 12D9     		bls	.L67
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1330              		.loc 1 213 0
 1331 01a2 069A     		ldr	r2, [sp, #24]
 1332 01a4 8918     		add	r1, r1, r2
 1333 01a6 0904     		lsl	r1, r1, #16
 1334 01a8 090C     		lsr	r1, r1, #16
 269:display.c     **** 				buff[offset++] &= (cc | ~c);
 1335              		.loc 1 269 0
 1336 01aa 3B1C     		mov	r3, r7
 1337              	.LVL196:
 1338              	.L68:
 271:display.c     **** 					buff[offset++] &= mask;
 1339              		.loc 1 271 0 discriminator 2
 1340 01ac E218     		add	r2, r4, r3
 1341 01ae 1078     		ldrb	r0, [r2]
 1342 01b0 2840     		and	r0, r5
 1343 01b2 1070     		strb	r0, [r2]
 1344 01b4 0133     		add	r3, r3, #1
 1345 01b6 1B04     		lsl	r3, r3, #16
 1346 01b8 1B0C     		lsr	r3, r3, #16
 1347              	.LVL197:
 270:display.c     **** 				for ( x = start_byte+1; x < end_byte; x++ )
 1348              		.loc 1 270 0 discriminator 2
 1349 01ba 8B42     		cmp	r3, r1
 1350 01bc F6D1     		bne	.L68
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1351              		.loc 1 213 0
 1352 01be 049B     		ldr	r3, [sp, #16]
 1353              	.LVL198:
 1354 01c0 0133     		add	r3, r3, #1
 1355 01c2 FF18     		add	r7, r7, r3
 1356 01c4 3F04     		lsl	r7, r7, #16
 1357 01c6 3F0C     		lsr	r7, r7, #16
 1358              	.L67:
 272:display.c     **** 				buff[offset] &= (nn | ~n);
 1359              		.loc 1 272 0
 1360 01c8 E719     		add	r7, r4, r7
 1361 01ca 5046     		mov	r0, sl
 1362 01cc C343     		mvn	r3, r0
 1363 01ce 4146     		mov	r1, r8
 1364 01d0 0B43     		orr	r3, r1
 1365 01d2 3A78     		ldrb	r2, [r7]
 1366 01d4 1340     		and	r3, r2
 1367 01d6 3B70     		strb	r3, [r7]
 1368              	.L66:
 258:display.c     **** 		for ( y = yp1; y <= yp2; y++ )
 1369              		.loc 1 258 0
 1370 01d8 0136     		add	r6, r6, #1
 1371 01da 3606     		lsl	r6, r6, #24
 1372 01dc 360E     		lsr	r6, r6, #24
 1373              	.LVL199:
 1374 01de 039A     		ldr	r2, [sp, #12]
 1375 01e0 9642     		cmp	r6, r2
 1376 01e2 B1D9     		bls	.L93
 1377 01e4 A2E1     		b	.L49
 1378              	.LVL200:
 1379              	.L60:
 273:display.c     **** 			}
 274:display.c     **** 		}
 275:display.c     **** 		break;
 276:display.c     **** 
 277:display.c     **** 	case CLEAR:
 278:display.c     **** 		for ( y = yp1; y <= yp2; y++ )
 1380              		.loc 1 278 0
 1381 01e6 6B46     		mov	r3, sp
 1382              	.LVL201:
 1383 01e8 9D7F     		ldrb	r5, [r3, #30]
 1384              	.LVL202:
 1385 01ea 12AB     		add	r3, sp, #72
 1386 01ec 1B78     		ldrb	r3, [r3]
 1387 01ee 9846     		mov	r8, r3
 1388 01f0 9D42     		cmp	r5, r3
 1389 01f2 00D9     		bls	.LCB1482
 1390 01f4 9AE1     		b	.L49	@long jump
 1391              	.LCB1482:
 279:display.c     **** 		{
 280:display.c     **** 			offset = start_byte + (y * COLUMNS);
 281:display.c     **** 			if ( !bytes )
 282:display.c     **** 				buff[offset++] &= ~(c & n);
 1392              		.loc 1 282 0
 1393 01f6 6346     		mov	r3, ip
 1394 01f8 5646     		mov	r6, sl
 1395 01fa 3340     		and	r3, r6
 1396 01fc 0393     		str	r3, [sp, #12]
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1397              		.loc 1 213 0
 1398 01fe 5B46     		mov	r3, fp
 1399 0200 023B     		sub	r3, r3, #2
 1400 0202 5B1A     		sub	r3, r3, r1
 1401 0204 1B06     		lsl	r3, r3, #24
 1402 0206 1B0E     		lsr	r3, r3, #24
 1403 0208 9946     		mov	r9, r3
 1404 020a 0233     		add	r3, r3, #2
 1405 020c 0493     		str	r3, [sp, #16]
 1406              	.LVL203:
 1407              	.L92:
 280:display.c     **** 			offset = start_byte + (y * COLUMNS);
 1408              		.loc 1 280 0
 1409 020e A800     		lsl	r0, r5, #2
 1410 0210 4019     		add	r0, r0, r5
 1411 0212 8000     		lsl	r0, r0, #2
 1412 0214 0818     		add	r0, r1, r0
 1413 0216 0004     		lsl	r0, r0, #16
 1414 0218 000C     		lsr	r0, r0, #16
 1415              	.LVL204:
 281:display.c     **** 			if ( !bytes )
 1416              		.loc 1 281 0
 1417 021a 002F     		cmp	r7, #0
 1418 021c 05D1     		bne	.L70
 1419              		.loc 1 282 0
 1420 021e 2018     		add	r0, r4, r0
 1421              	.LVL205:
 1422 0220 0378     		ldrb	r3, [r0]
 1423 0222 039A     		ldr	r2, [sp, #12]
 1424 0224 9343     		bic	r3, r2
 1425 0226 0370     		strb	r3, [r0]
 1426              	.LVL206:
 1427 0228 20E0     		b	.L71
 1428              	.LVL207:
 1429              	.L70:
 283:display.c     **** 			else
 284:display.c     **** 			{
 285:display.c     **** 				buff[offset++] &= ~c;
 1430              		.loc 1 285 0
 1431 022a 2318     		add	r3, r4, r0
 1432 022c 1A78     		ldrb	r2, [r3]
 1433 022e 6646     		mov	r6, ip
 1434 0230 B243     		bic	r2, r6
 1435 0232 1A70     		strb	r2, [r3]
 1436 0234 461C     		add	r6, r0, #1
 1437 0236 3604     		lsl	r6, r6, #16
 1438 0238 360C     		lsr	r6, r6, #16
 1439              	.LVL208:
 286:display.c     **** 				for ( x = start_byte+1; x < end_byte; x++ )
 1440              		.loc 1 286 0
 1441 023a 4B1C     		add	r3, r1, #1
 1442 023c 9B45     		cmp	fp, r3
 1443 023e 10D9     		bls	.L72
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1444              		.loc 1 213 0
 1445 0240 049A     		ldr	r2, [sp, #16]
 1446 0242 8018     		add	r0, r0, r2
 1447 0244 0004     		lsl	r0, r0, #16
 1448 0246 000C     		lsr	r0, r0, #16
 285:display.c     **** 				buff[offset++] &= ~c;
 1449              		.loc 1 285 0
 1450 0248 331C     		mov	r3, r6
 287:display.c     **** 					buff[offset++] = 0x00;
 1451              		.loc 1 287 0
 1452 024a 0022     		mov	r2, #0
 1453              	.LVL209:
 1454              	.L73:
 1455              		.loc 1 287 0 is_stmt 0 discriminator 2
 1456 024c E254     		strb	r2, [r4, r3]
 1457 024e 0133     		add	r3, r3, #1
 1458 0250 1B04     		lsl	r3, r3, #16
 1459 0252 1B0C     		lsr	r3, r3, #16
 1460              	.LVL210:
 286:display.c     **** 				for ( x = start_byte+1; x < end_byte; x++ )
 1461              		.loc 1 286 0 is_stmt 1 discriminator 2
 1462 0254 8342     		cmp	r3, r0
 1463 0256 F9D1     		bne	.L73
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1464              		.loc 1 213 0
 1465 0258 4B46     		mov	r3, r9
 1466              	.LVL211:
 1467 025a 0133     		add	r3, r3, #1
 1468 025c F618     		add	r6, r6, r3
 1469 025e 3604     		lsl	r6, r6, #16
 1470 0260 360C     		lsr	r6, r6, #16
 1471              	.L72:
 288:display.c     **** 				buff[offset] &= ~n;
 1472              		.loc 1 288 0
 1473 0262 A619     		add	r6, r4, r6
 1474 0264 3378     		ldrb	r3, [r6]
 1475 0266 5046     		mov	r0, sl
 1476 0268 8343     		bic	r3, r0
 1477 026a 3370     		strb	r3, [r6]
 1478              	.L71:
 278:display.c     **** 		for ( y = yp1; y <= yp2; y++ )
 1479              		.loc 1 278 0
 1480 026c 0135     		add	r5, r5, #1
 1481 026e 2D06     		lsl	r5, r5, #24
 1482 0270 2D0E     		lsr	r5, r5, #24
 1483              	.LVL212:
 1484 0272 4545     		cmp	r5, r8
 1485 0274 CBD9     		bls	.L92
 1486 0276 59E1     		b	.L49
 1487              	.LVL213:
 1488              	.L59:
 289:display.c     **** 			}
 290:display.c     **** 		}
 291:display.c     **** 		break;
 292:display.c     **** 
 293:display.c     **** 	case FULL:
 294:display.c     **** 		//case FULLCLP:
 295:display.c     **** 			for ( y = yp1; y <= yp2; y++ )
 1489              		.loc 1 295 0
 1490 0278 6B46     		mov	r3, sp
 1491              	.LVL214:
 1492 027a 9E7F     		ldrb	r6, [r3, #30]
 1493              	.LVL215:
 1494 027c 12AB     		add	r3, sp, #72
 1495 027e 1B78     		ldrb	r3, [r3]
 1496 0280 9946     		mov	r9, r3
 1497 0282 9E42     		cmp	r6, r3
 1498 0284 00D9     		bls	.LCB1605
 1499 0286 51E1     		b	.L49	@long jump
 1500              	.LCB1605:
 296:display.c     **** 			{
 297:display.c     **** 				offset = start_byte + (y * COLUMNS);
 298:display.c     **** 				if ( !bytes )
 299:display.c     **** 					buff[offset++] |= (c & n);
 1501              		.loc 1 299 0
 1502 0288 6246     		mov	r2, ip
 1503              	.LVL216:
 1504 028a 5346     		mov	r3, sl
 1505 028c 1A40     		and	r2, r3
 1506 028e 0492     		str	r2, [sp, #16]
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1507              		.loc 1 213 0
 1508 0290 5B46     		mov	r3, fp
 1509 0292 023B     		sub	r3, r3, #2
 1510 0294 5B1A     		sub	r3, r3, r1
 1511 0296 1B06     		lsl	r3, r3, #24
 1512 0298 1B0E     		lsr	r3, r3, #24
 1513 029a 0393     		str	r3, [sp, #12]
 1514 029c 0233     		add	r3, r3, #2
 1515 029e 0593     		str	r3, [sp, #20]
 1516 02a0 B846     		mov	r8, r7
 1517 02a2 0F1C     		mov	r7, r1
 1518              	.LVL217:
 1519              	.L96:
 297:display.c     **** 				offset = start_byte + (y * COLUMNS);
 1520              		.loc 1 297 0
 1521 02a4 B500     		lsl	r5, r6, #2
 1522 02a6 AD19     		add	r5, r5, r6
 1523 02a8 AD00     		lsl	r5, r5, #2
 1524 02aa 7D19     		add	r5, r7, r5
 1525 02ac 2D04     		lsl	r5, r5, #16
 1526 02ae 2D0C     		lsr	r5, r5, #16
 1527              	.LVL218:
 298:display.c     **** 				if ( !bytes )
 1528              		.loc 1 298 0
 1529 02b0 4046     		mov	r0, r8
 1530 02b2 0028     		cmp	r0, #0
 1531 02b4 05D1     		bne	.L75
 1532              	.LVL219:
 1533              		.loc 1 299 0
 1534 02b6 6519     		add	r5, r4, r5
 1535              	.LVL220:
 1536 02b8 2B78     		ldrb	r3, [r5]
 1537 02ba 0499     		ldr	r1, [sp, #16]
 1538 02bc 0B43     		orr	r3, r1
 1539 02be 2B70     		strb	r3, [r5]
 1540              	.LVL221:
 1541 02c0 20E0     		b	.L76
 1542              	.LVL222:
 1543              	.L75:
 300:display.c     **** 				else
 301:display.c     **** 				{
 302:display.c     **** 					buff[offset++] |= c;
 1544              		.loc 1 302 0
 1545 02c2 6319     		add	r3, r4, r5
 1546 02c4 1A78     		ldrb	r2, [r3]
 1547 02c6 6046     		mov	r0, ip
 1548              	.LVL223:
 1549 02c8 0243     		orr	r2, r0
 1550 02ca 1A70     		strb	r2, [r3]
 1551 02cc 691C     		add	r1, r5, #1
 1552 02ce 0904     		lsl	r1, r1, #16
 1553 02d0 090C     		lsr	r1, r1, #16
 1554              	.LVL224:
 303:display.c     **** 					for ( x = start_byte+1; x < end_byte; x++ )
 1555              		.loc 1 303 0
 1556 02d2 7B1C     		add	r3, r7, #1
 1557 02d4 9B45     		cmp	fp, r3
 1558 02d6 10D9     		bls	.L77
 1559              	.LVL225:
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1560              		.loc 1 213 0
 1561 02d8 059A     		ldr	r2, [sp, #20]
 1562 02da AD18     		add	r5, r5, r2
 1563 02dc 2D04     		lsl	r5, r5, #16
 1564 02de 2D0C     		lsr	r5, r5, #16
 302:display.c     **** 					buff[offset++] |= c;
 1565              		.loc 1 302 0
 1566 02e0 0B1C     		mov	r3, r1
 304:display.c     **** 						buff[offset++] |= 0xff;
 1567              		.loc 1 304 0
 1568 02e2 FF20     		mov	r0, #255
 1569              	.LVL226:
 1570              	.L78:
 1571              		.loc 1 304 0 is_stmt 0 discriminator 2
 1572 02e4 5A1C     		add	r2, r3, #1
 1573 02e6 1204     		lsl	r2, r2, #16
 1574              	.LVL227:
 1575 02e8 E054     		strb	r0, [r4, r3]
 1576 02ea 130C     		lsr	r3, r2, #16
 303:display.c     **** 					for ( x = start_byte+1; x < end_byte; x++ )
 1577              		.loc 1 303 0 is_stmt 1 discriminator 2
 1578 02ec AB42     		cmp	r3, r5
 1579 02ee F9D1     		bne	.L78
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1580              		.loc 1 213 0
 1581 02f0 039B     		ldr	r3, [sp, #12]
 1582 02f2 0133     		add	r3, r3, #1
 1583 02f4 C918     		add	r1, r1, r3
 1584 02f6 0904     		lsl	r1, r1, #16
 1585 02f8 090C     		lsr	r1, r1, #16
 1586              	.LVL228:
 1587              	.L77:
 305:display.c     **** 					buff[offset] |= n;
 1588              		.loc 1 305 0
 1589 02fa 6118     		add	r1, r4, r1
 1590 02fc 0B78     		ldrb	r3, [r1]
 1591 02fe 5046     		mov	r0, sl
 1592 0300 0343     		orr	r3, r0
 1593 0302 0B70     		strb	r3, [r1]
 1594              	.L76:
 295:display.c     **** 			for ( y = yp1; y <= yp2; y++ )
 1595              		.loc 1 295 0
 1596 0304 0136     		add	r6, r6, #1
 1597 0306 3606     		lsl	r6, r6, #24
 1598 0308 360E     		lsr	r6, r6, #24
 1599              	.LVL229:
 1600 030a 4E45     		cmp	r6, r9
 1601 030c CAD9     		bls	.L96
 1602 030e 0DE1     		b	.L49
 1603              	.LVL230:
 1604              	.L58:
 306:display.c     **** 				}
 307:display.c     **** 			}
 308:display.c     **** 			break;
 309:display.c     **** 
 310:display.c     **** 	case INV:
 311:display.c     **** 	case INVCLP:
 312:display.c     **** 		for( y = yp1; y <= yp2; y++ )
 1605              		.loc 1 312 0
 1606 0310 6B46     		mov	r3, sp
 1607 0312 9E7F     		ldrb	r6, [r3, #30]
 1608              	.LVL231:
 1609 0314 12AB     		add	r3, sp, #72
 1610 0316 1B78     		ldrb	r3, [r3]
 1611 0318 9946     		mov	r9, r3
 1612 031a 9E42     		cmp	r6, r3
 1613 031c 00D9     		bls	.LCB1736
 1614 031e D8E0     		b	.L80	@long jump
 1615              	.LCB1736:
 313:display.c     **** 		{
 314:display.c     **** 			offset = start_byte + (y * COLUMNS);
 315:display.c     **** 			if( !bytes )
 316:display.c     **** 			{
 317:display.c     **** 				//buff[offset] &= ~(c & n);
 318:display.c     **** 				//buff[offset] |= ~c ;
 319:display.c     **** 				//buff[offset++] |= ~n ;
 320:display.c     **** 				buff[offset] ^= (c & n);
 1616              		.loc 1 320 0
 1617 0320 6246     		mov	r2, ip
 1618              	.LVL232:
 1619 0322 5346     		mov	r3, sl
 1620 0324 1A40     		and	r2, r3
 1621 0326 0592     		str	r2, [sp, #20]
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1622              		.loc 1 213 0
 1623 0328 5B46     		mov	r3, fp
 1624 032a 023B     		sub	r3, r3, #2
 1625 032c 5B1A     		sub	r3, r3, r1
 1626 032e 1B06     		lsl	r3, r3, #24
 1627 0330 1B0E     		lsr	r3, r3, #24
 1628 0332 0493     		str	r3, [sp, #16]
 1629 0334 0233     		add	r3, r3, #2
 1630 0336 0693     		str	r3, [sp, #24]
 1631 0338 B846     		mov	r8, r7
 1632 033a 0F1C     		mov	r7, r1
 1633              	.LVL233:
 1634              	.L94:
 314:display.c     **** 			offset = start_byte + (y * COLUMNS);
 1635              		.loc 1 314 0
 1636 033c B500     		lsl	r5, r6, #2
 1637 033e AD19     		add	r5, r5, r6
 1638 0340 AD00     		lsl	r5, r5, #2
 1639 0342 7D19     		add	r5, r7, r5
 1640 0344 2D04     		lsl	r5, r5, #16
 1641 0346 2D0C     		lsr	r5, r5, #16
 1642              	.LVL234:
 315:display.c     **** 			if( !bytes )
 1643              		.loc 1 315 0
 1644 0348 4046     		mov	r0, r8
 1645 034a 0028     		cmp	r0, #0
 1646 034c 05D1     		bne	.L81
 1647              	.LVL235:
 1648              		.loc 1 320 0
 1649 034e 6519     		add	r5, r4, r5
 1650              	.LVL236:
 1651 0350 2B78     		ldrb	r3, [r5]
 1652 0352 0599     		ldr	r1, [sp, #20]
 1653 0354 4B40     		eor	r3, r1
 1654 0356 2B70     		strb	r3, [r5]
 1655 0358 22E0     		b	.L82
 1656              	.LVL237:
 1657              	.L81:
 321:display.c     **** 			}
 322:display.c     **** 			else
 323:display.c     **** 			{
 324:display.c     **** 				//cc = ~buff[offset];
 325:display.c     **** 				//cc &= c;
 326:display.c     **** 				//buff[offset] &= ~c;
 327:display.c     **** 				//buff[offset] |= cc;
 328:display.c     **** 				buff[offset] ^= c;
 1658              		.loc 1 328 0
 1659 035a 6319     		add	r3, r4, r5
 1660 035c 1A78     		ldrb	r2, [r3]
 1661 035e 6046     		mov	r0, ip
 1662              	.LVL238:
 1663 0360 4240     		eor	r2, r0
 1664 0362 1A70     		strb	r2, [r3]
 329:display.c     **** 
 330:display.c     **** 				offset++;
 1665              		.loc 1 330 0
 1666 0364 691C     		add	r1, r5, #1
 1667 0366 0904     		lsl	r1, r1, #16
 1668 0368 090C     		lsr	r1, r1, #16
 1669              	.LVL239:
 331:display.c     **** 
 332:display.c     **** 				for( x = start_byte + 1; x < end_byte; x++ )
 1670              		.loc 1 332 0
 1671 036a 7B1C     		add	r3, r7, #1
 1672 036c 9B45     		cmp	fp, r3
 1673 036e 12D9     		bls	.L83
 1674              	.LVL240:
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1675              		.loc 1 213 0
 1676 0370 069A     		ldr	r2, [sp, #24]
 1677 0372 AD18     		add	r5, r5, r2
 1678 0374 2D04     		lsl	r5, r5, #16
 1679 0376 2D0C     		lsr	r5, r5, #16
 330:display.c     **** 				offset++;
 1680              		.loc 1 330 0
 1681 0378 0B1C     		mov	r3, r1
 1682              	.LVL241:
 1683              	.L84:
 333:display.c     **** 				{
 334:display.c     **** 					buff[offset] ^= 0xff;
 1684              		.loc 1 334 0 discriminator 2
 1685 037a E218     		add	r2, r4, r3
 1686 037c 1078     		ldrb	r0, [r2]
 1687 037e C043     		mvn	r0, r0
 1688 0380 1070     		strb	r0, [r2]
 335:display.c     **** 					offset++;
 1689              		.loc 1 335 0 discriminator 2
 1690 0382 0133     		add	r3, r3, #1
 1691 0384 1B04     		lsl	r3, r3, #16
 1692 0386 1B0C     		lsr	r3, r3, #16
 1693              	.LVL242:
 332:display.c     **** 				for( x = start_byte + 1; x < end_byte; x++ )
 1694              		.loc 1 332 0 discriminator 2
 1695 0388 AB42     		cmp	r3, r5
 1696 038a F6D1     		bne	.L84
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1697              		.loc 1 213 0
 1698 038c 049B     		ldr	r3, [sp, #16]
 1699              	.LVL243:
 1700 038e 0133     		add	r3, r3, #1
 1701 0390 C918     		add	r1, r1, r3
 1702 0392 0904     		lsl	r1, r1, #16
 1703 0394 090C     		lsr	r1, r1, #16
 1704              	.L83:
 336:display.c     **** 				}
 337:display.c     **** 
 338:display.c     **** 				//nn = ~buff[offset];
 339:display.c     **** 				//nn &= n;
 340:display.c     **** 				//buff[offset] &= ~n;
 341:display.c     **** 				//buff[offset] |= nn;
 342:display.c     **** 				buff[offset] ^= n;
 1705              		.loc 1 342 0
 1706 0396 6118     		add	r1, r4, r1
 1707 0398 0B78     		ldrb	r3, [r1]
 1708 039a 5046     		mov	r0, sl
 1709 039c 4340     		eor	r3, r0
 1710 039e 0B70     		strb	r3, [r1]
 1711              	.L82:
 312:display.c     **** 		for( y = yp1; y <= yp2; y++ )
 1712              		.loc 1 312 0
 1713 03a0 0136     		add	r6, r6, #1
 1714 03a2 3606     		lsl	r6, r6, #24
 1715 03a4 360E     		lsr	r6, r6, #24
 1716              	.LVL244:
 1717 03a6 4E45     		cmp	r6, r9
 1718 03a8 C8D9     		bls	.L94
 1719 03aa 92E0     		b	.L80
 1720              	.LVL245:
 1721              	.L57:
 343:display.c     **** 
 344:display.c     **** 				offset++;
 345:display.c     **** 			}
 346:display.c     **** 		}
 347:display.c     **** 		break;
 348:display.c     **** 
 349:display.c     **** 		//case EMPTYCLP:
 350:display.c     **** 	default: /* EMPTY */
 351:display.c     **** 		offset = start_byte + (yp1 * COLUMNS);
 1722              		.loc 1 351 0
 1723 03ac 0A1C     		mov	r2, r1
 1724              	.LVL246:
 1725 03ae 6B46     		mov	r3, sp
 1726 03b0 1E33     		add	r3, r3, #30
 1727 03b2 1B78     		ldrb	r3, [r3]
 1728              	.LVL247:
 1729 03b4 9E00     		lsl	r6, r3, #2
 1730              	.LVL248:
 1731 03b6 F618     		add	r6, r6, r3
 1732 03b8 B600     		lsl	r6, r6, #2
 1733 03ba 8E19     		add	r6, r1, r6
 1734              	.LVL249:
 352:display.c     **** 		point =  start_byte + (yp2 * COLUMNS);
 1735              		.loc 1 352 0
 1736 03bc 12AB     		add	r3, sp, #72
 1737              	.LVL250:
 1738 03be 1B78     		ldrb	r3, [r3]
 1739 03c0 9946     		mov	r9, r3
 1740              	.LVL251:
 1741 03c2 9B00     		lsl	r3, r3, #2
 1742 03c4 9846     		mov	r8, r3
 1743 03c6 C844     		add	r8, r8, r9
 1744              	.LVL252:
 1745 03c8 4346     		mov	r3, r8
 1746 03ca 9B00     		lsl	r3, r3, #2
 1747 03cc 9846     		mov	r8, r3
 1748 03ce 8844     		add	r8, r8, r1
 1749              	.LVL253:
 353:display.c     **** 
 354:display.c     **** 		if ( !bytes )
 1750              		.loc 1 354 0
 1751 03d0 002F     		cmp	r7, #0
 1752 03d2 0CD1     		bne	.L86
 355:display.c     **** 		{
 356:display.c     **** 			c = c & n;
 1753              		.loc 1 356 0
 1754 03d4 6146     		mov	r1, ip
 1755              	.LVL254:
 1756 03d6 5746     		mov	r7, sl
 1757              	.LVL255:
 1758 03d8 3940     		and	r1, r7
 1759              	.LVL256:
 357:display.c     **** 			buff[offset++] |= c;
 1760              		.loc 1 357 0
 1761 03da A619     		add	r6, r4, r6
 1762              	.LVL257:
 1763 03dc 3378     		ldrb	r3, [r6]
 1764 03de 0B43     		orr	r3, r1
 1765 03e0 3370     		strb	r3, [r6]
 1766              	.LVL258:
 358:display.c     **** 			buff[point++] |= c;
 1767              		.loc 1 358 0
 1768 03e2 4646     		mov	r6, r8
 1769 03e4 A319     		add	r3, r4, r6
 1770 03e6 1E78     		ldrb	r6, [r3]
 1771 03e8 3143     		orr	r1, r6
 1772              	.LVL259:
 1773 03ea 1970     		strb	r1, [r3]
 1774              	.LVL260:
 1775 03ec 46E0     		b	.L87
 1776              	.LVL261:
 1777              	.L86:
 359:display.c     **** 		}
 360:display.c     **** 		else
 361:display.c     **** 		{
 362:display.c     **** 			buff[offset++] |= c;
 1778              		.loc 1 362 0
 1779 03ee A719     		add	r7, r4, r6
 1780              	.LVL262:
 1781 03f0 0397     		str	r7, [sp, #12]
 1782 03f2 3B78     		ldrb	r3, [r7]
 1783 03f4 6746     		mov	r7, ip
 1784 03f6 3B43     		orr	r3, r7
 1785 03f8 039F     		ldr	r7, [sp, #12]
 1786 03fa 3B70     		strb	r3, [r7]
 1787 03fc 731C     		add	r3, r6, #1
 1788 03fe 0393     		str	r3, [sp, #12]
 1789              	.LVL263:
 363:display.c     **** 			buff[point++] |= c;
 1790              		.loc 1 363 0
 1791 0400 4746     		mov	r7, r8
 1792 0402 E719     		add	r7, r4, r7
 1793 0404 0497     		str	r7, [sp, #16]
 1794 0406 3B78     		ldrb	r3, [r7]
 1795 0408 6746     		mov	r7, ip
 1796 040a 1F43     		orr	r7, r3
 1797 040c 049B     		ldr	r3, [sp, #16]
 1798 040e 1F70     		strb	r7, [r3]
 1799 0410 4746     		mov	r7, r8
 1800 0412 0137     		add	r7, r7, #1
 1801              	.LVL264:
 364:display.c     **** 
 365:display.c     **** 			for ( x = start_byte+1; x < end_byte; x++ )
 1802              		.loc 1 365 0
 1803 0414 4B1C     		add	r3, r1, #1
 1804 0416 9B45     		cmp	fp, r3
 1805 0418 26D9     		bls	.L88
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1806              		.loc 1 213 0
 1807 041a 5F46     		mov	r7, fp
 1808              	.LVL265:
 1809 041c 023F     		sub	r7, r7, #2
 1810 041e 791A     		sub	r1, r7, r1
 1811              	.LVL266:
 1812 0420 0906     		lsl	r1, r1, #24
 1813 0422 090E     		lsr	r1, r1, #24
 1814 0424 0491     		str	r1, [sp, #16]
 1815 0426 B11C     		add	r1, r6, #2
 1816 0428 049F     		ldr	r7, [sp, #16]
 1817 042a 7F18     		add	r7, r7, r1
 366:display.c     **** 			{
 367:display.c     **** 				buff[offset++] |= 0xff;
 1818              		.loc 1 367 0
 1819 042c FF21     		mov	r1, #255
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1820              		.loc 1 213 0
 1821 042e 4346     		mov	r3, r8
 1822 0430 9B1B     		sub	r3, r3, r6
 1823 0432 0693     		str	r3, [sp, #24]
 1824 0434 039B     		ldr	r3, [sp, #12]
 1825 0436 0597     		str	r7, [sp, #20]
 1826 0438 9146     		mov	r9, r2
 1827              	.LVL267:
 1828 043a 069A     		ldr	r2, [sp, #24]
 1829              	.LVL268:
 1830 043c 8446     		mov	ip, r0
 1831              	.LVL269:
 1832 043e 101C     		mov	r0, r2
 1833 0440 3A1C     		mov	r2, r7
 1834              	.LVL270:
 1835              	.L89:
 1836              		.loc 1 367 0 discriminator 2
 1837 0442 5F1C     		add	r7, r3, #1
 1838 0444 3F04     		lsl	r7, r7, #16
 1839              	.LVL271:
 1840 0446 E154     		strb	r1, [r4, r3]
 1841              	.LVL272:
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1842              		.loc 1 213 0 discriminator 2
 1843 0448 1B18     		add	r3, r3, r0
 1844              	.LVL273:
 368:display.c     **** 				buff[point++] |= 0xff;
 1845              		.loc 1 368 0 discriminator 2
 1846 044a 1B04     		lsl	r3, r3, #16
 1847 044c 1B0C     		lsr	r3, r3, #16
 1848 044e E154     		strb	r1, [r4, r3]
 367:display.c     **** 				buff[offset++] |= 0xff;
 1849              		.loc 1 367 0 discriminator 2
 1850 0450 3B0C     		lsr	r3, r7, #16
 365:display.c     **** 			for ( x = start_byte+1; x < end_byte; x++ )
 1851              		.loc 1 365 0 discriminator 2
 1852 0452 9342     		cmp	r3, r2
 1853 0454 F5D1     		bne	.L89
 1854 0456 6046     		mov	r0, ip
 1855 0458 4A46     		mov	r2, r9
 213:display.c     **** void draw_box( unsigned char *buff, unsigned char xp1, unsigned char yp1,
 1856              		.loc 1 213 0
 1857 045a B31C     		add	r3, r6, #2
 1858 045c 0499     		ldr	r1, [sp, #16]
 1859              	.LVL274:
 1860 045e CB18     		add	r3, r1, r3
 1861 0460 0393     		str	r3, [sp, #12]
 1862 0462 4746     		mov	r7, r8
 1863              	.LVL275:
 1864 0464 0237     		add	r7, r7, #2
 1865 0466 CF19     		add	r7, r1, r7
 1866              	.LVL276:
 1867              	.L88:
 369:display.c     **** 			}
 370:display.c     **** 			buff[offset] |= n;
 1868              		.loc 1 370 0
 1869 0468 039E     		ldr	r6, [sp, #12]
 1870 046a A319     		add	r3, r4, r6
 1871 046c 1978     		ldrb	r1, [r3]
 1872 046e 5646     		mov	r6, sl
 1873 0470 3143     		orr	r1, r6
 1874 0472 1970     		strb	r1, [r3]
 371:display.c     **** 			buff[point] |= n;
 1875              		.loc 1 371 0
 1876 0474 E319     		add	r3, r4, r7
 1877 0476 1978     		ldrb	r1, [r3]
 1878 0478 3143     		orr	r1, r6
 1879 047a 1970     		strb	r1, [r3]
 1880              	.LVL277:
 1881              	.L87:
 372:display.c     **** 		}
 373:display.c     **** 
 374:display.c     **** 		c = (unsigned char)0x80 >> right_shift;
 1882              		.loc 1 374 0
 1883 047c 8027     		mov	r7, #128
 1884 047e 2F41     		asr	r7, r7, r5
 1885 0480 3F06     		lsl	r7, r7, #24
 1886 0482 3F0E     		lsr	r7, r7, #24
 1887              	.LVL278:
 375:display.c     **** 		n = (unsigned char)0x01 << left_shift;
 1888              		.loc 1 375 0
 1889 0484 8023     		mov	r3, #128
 1890 0486 5B04     		lsl	r3, r3, #17
 1891 0488 8340     		lsl	r3, r3, r0
 1892 048a 180E     		lsr	r0, r3, #24
 1893              	.LVL279:
 376:display.c     **** 
 377:display.c     **** 		for ( y = yp1+1; y < yp2; y++ )
 1894              		.loc 1 377 0
 1895 048c 6B46     		mov	r3, sp
 1896 048e 1E33     		add	r3, r3, #30
 1897              	.LVL280:
 1898 0490 1B78     		ldrb	r3, [r3]
 1899              	.LVL281:
 1900 0492 0133     		add	r3, r3, #1
 1901              	.LVL282:
 1902 0494 1B06     		lsl	r3, r3, #24
 1903 0496 1B0E     		lsr	r3, r3, #24
 1904              	.LVL283:
 1905 0498 12A9     		add	r1, sp, #72
 1906 049a 0E78     		ldrb	r6, [r1]
 1907 049c B342     		cmp	r3, r6
 1908 049e 18D2     		bcs	.L80
 1909 04a0 B446     		mov	ip, r6
 1910 04a2 061C     		mov	r6, r0
 1911 04a4 101C     		mov	r0, r2
 1912              	.LVL284:
 1913              	.L95:
 378:display.c     **** 		{
 379:display.c     **** 			offset = start_byte + (y * COLUMNS);
 1914              		.loc 1 379 0 discriminator 2
 1915 04a6 9900     		lsl	r1, r3, #2
 1916 04a8 C918     		add	r1, r1, r3
 1917 04aa 8900     		lsl	r1, r1, #2
 1918              	.LVL285:
 1919 04ac 0D18     		add	r5, r1, r0
 380:display.c     **** 			point =  end_byte + (y * COLUMNS);
 381:display.c     **** 			buff[offset] |= c;
 1920              		.loc 1 381 0 discriminator 2
 1921 04ae 2D04     		lsl	r5, r5, #16
 1922 04b0 2D0C     		lsr	r5, r5, #16
 1923 04b2 6519     		add	r5, r4, r5
 1924 04b4 2A78     		ldrb	r2, [r5]
 1925 04b6 3A43     		orr	r2, r7
 1926 04b8 2A70     		strb	r2, [r5]
 380:display.c     **** 			point =  end_byte + (y * COLUMNS);
 1927              		.loc 1 380 0 discriminator 2
 1928 04ba 5944     		add	r1, r1, fp
 1929              	.LVL286:
 382:display.c     **** 			buff[point] |= n;
 1930              		.loc 1 382 0 discriminator 2
 1931 04bc 0904     		lsl	r1, r1, #16
 1932 04be 090C     		lsr	r1, r1, #16
 1933 04c0 6118     		add	r1, r4, r1
 1934 04c2 0D78     		ldrb	r5, [r1]
 1935 04c4 3543     		orr	r5, r6
 1936 04c6 0D70     		strb	r5, [r1]
 377:display.c     **** 		for ( y = yp1+1; y < yp2; y++ )
 1937              		.loc 1 377 0 discriminator 2
 1938 04c8 0133     		add	r3, r3, #1
 1939              	.LVL287:
 1940 04ca 1B06     		lsl	r3, r3, #24
 1941              	.LVL288:
 1942 04cc 1B0E     		lsr	r3, r3, #24
 1943              	.LVL289:
 1944 04ce 6345     		cmp	r3, ip
 1945 04d0 E9D3     		bcc	.L95
 1946              	.LVL290:
 1947              	.L80:
 383:display.c     **** 		}
 384:display.c     **** 		break;
 385:display.c     **** 	}
 386:display.c     **** 
 387:display.c     **** 	if( ( method == INVCLP )/* || ( method == EMPTYCLP ) || ( method == FULLCLP ) */)
 1948              		.loc 1 387 0
 1949 04d2 8023     		mov	r3, #128
 1950 04d4 5B00     		lsl	r3, r3, #1
 1951 04d6 139E     		ldr	r6, [sp, #76]
 1952 04d8 9E42     		cmp	r6, r3
 1953 04da 27D1     		bne	.L49
 388:display.c     **** 	{ /* clip the corners off */
 389:display.c     **** 		draw_line( adm, xp1, yp1, xp1, yp1, CLEAR );
 1954              		.loc 1 389 0
 1955 04dc 6E46     		mov	r6, sp
 1956 04de F37F     		ldrb	r3, [r6, #31]
 1957 04e0 B27F     		ldrb	r2, [r6, #30]
 1958 04e2 174C     		ldr	r4, .L107
 1959              	.LVL291:
 1960 04e4 0092     		str	r2, [sp]
 1961 04e6 4020     		mov	r0, #64
 1962 04e8 8046     		mov	r8, r0
 1963 04ea 0190     		str	r0, [sp, #4]
 1964 04ec 201C     		mov	r0, r4
 1965 04ee 191C     		mov	r1, r3
 1966 04f0 FFF7FEFF 		bl	draw_line
 1967              	.LVL292:
 390:display.c     **** 		draw_line( adm, xp2, yp1, xp2, yp1, CLEAR );
 1968              		.loc 1 390 0
 1969 04f4 6D46     		mov	r5, sp
 1970 04f6 737F     		ldrb	r3, [r6, #29]
 1971 04f8 B27F     		ldrb	r2, [r6, #30]
 1972 04fa 0092     		str	r2, [sp]
 1973 04fc 4746     		mov	r7, r8
 1974 04fe 0197     		str	r7, [sp, #4]
 1975 0500 201C     		mov	r0, r4
 1976 0502 191C     		mov	r1, r3
 1977 0504 FFF7FEFF 		bl	draw_line
 1978              	.LVL293:
 391:display.c     **** 		draw_line( adm, xp1, yp2, xp1, yp2, CLEAR );
 1979              		.loc 1 391 0
 1980 0508 F37F     		ldrb	r3, [r6, #31]
 1981 050a 12AA     		add	r2, sp, #72
 1982              	.LVL294:
 1983 050c 1278     		ldrb	r2, [r2]
 1984 050e 0092     		str	r2, [sp]
 1985 0510 0197     		str	r7, [sp, #4]
 1986 0512 201C     		mov	r0, r4
 1987 0514 191C     		mov	r1, r3
 1988 0516 FFF7FEFF 		bl	draw_line
 1989              	.LVL295:
 392:display.c     **** 		draw_line( adm, xp2, yp2, xp2, yp2, CLEAR );
 1990              		.loc 1 392 0
 1991 051a 6B7F     		ldrb	r3, [r5, #29]
 1992 051c 12AA     		add	r2, sp, #72
 1993 051e 1278     		ldrb	r2, [r2]
 1994 0520 0092     		str	r2, [sp]
 1995 0522 0197     		str	r7, [sp, #4]
 1996 0524 201C     		mov	r0, r4
 1997 0526 191C     		mov	r1, r3
 1998 0528 FFF7FEFF 		bl	draw_line
 1999              	.LVL296:
 2000              	.L49:
 393:display.c     **** 	}
 394:display.c     **** }
 2001              		.loc 1 394 0
 2002 052c 09B0     		add	sp, sp, #36
 2003              		@ sp needed for prologue
 2004 052e 3CBC     		pop	{r2, r3, r4, r5}
 2005 0530 9046     		mov	r8, r2
 2006 0532 9946     		mov	r9, r3
 2007 0534 A246     		mov	sl, r4
 2008 0536 AB46     		mov	fp, r5
 2009 0538 F0BC     		pop	{r4, r5, r6, r7}
 2010 053a 01BC     		pop	{r0}
 2011 053c 0047     		bx	r0
 2012              	.L108:
 2013 053e C046     		.align	2
 2014              	.L107:
 2015 0540 00000000 		.word	adm
 2016              		.cfi_endproc
 2017              	.LFE381:
 2019              		.section	.text.clip_box,"ax",%progbits
 2020              		.align	2
 2021              		.global	clip_box
 2022              		.code	16
 2023              		.thumb_func
 2025              	clip_box:
 2026              	.LFB382:
 395:display.c     **** // -----------------------------------------------------------
 396:display.c     **** 
 397:display.c     **** 
 398:display.c     **** // -----------------------------------------------------------
 399:display.c     **** // Function Name       : clip_box
 400:display.c     **** // -----------------------------------------------------------
 401:display.c     **** void clip_box( unsigned char xp1, unsigned char yp1, unsigned char xp2, unsigned char yp2 )
 402:display.c     **** {
 2027              		.loc 1 402 0
 2028              		.cfi_startproc
 2029              	.LVL297:
 2030 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2031              	.LCFI13:
 2032              		.cfi_def_cfa_offset 20
 2033              		.cfi_offset 4, -20
 2034              		.cfi_offset 5, -16
 2035              		.cfi_offset 6, -12
 2036              		.cfi_offset 7, -8
 2037              		.cfi_offset 14, -4
 2038 0002 4F46     		mov	r7, r9
 2039 0004 4646     		mov	r6, r8
 2040 0006 C0B4     		push	{r6, r7}
 2041              	.LCFI14:
 2042              		.cfi_def_cfa_offset 28
 2043              		.cfi_offset 8, -28
 2044              		.cfi_offset 9, -24
 2045 0008 83B0     		sub	sp, sp, #12
 2046              	.LCFI15:
 2047              		.cfi_def_cfa_offset 40
 2048 000a 8046     		mov	r8, r0
 2049 000c 8946     		mov	r9, r1
 2050 000e 141C     		mov	r4, r2
 2051 0010 1D1C     		mov	r5, r3
 403:display.c     **** 	draw_line( adm, xp1, yp1, xp1, yp1, CLEAR );
 2052              		.loc 1 403 0
 2053 0012 154E     		ldr	r6, .L110
 2054 0014 0091     		str	r1, [sp]
 2055 0016 4027     		mov	r7, #64
 2056 0018 0197     		str	r7, [sp, #4]
 2057 001a 301C     		mov	r0, r6
 2058              	.LVL298:
 2059 001c 4146     		mov	r1, r8
 2060              	.LVL299:
 2061 001e 4A46     		mov	r2, r9
 2062              	.LVL300:
 2063 0020 4346     		mov	r3, r8
 2064              	.LVL301:
 2065 0022 FFF7FEFF 		bl	draw_line
 2066              	.LVL302:
 404:display.c     **** 	draw_line( adm, xp2, yp1, xp2, yp1, CLEAR );
 2067              		.loc 1 404 0
 2068 0026 4B46     		mov	r3, r9
 2069 0028 0093     		str	r3, [sp]
 2070 002a 0197     		str	r7, [sp, #4]
 2071 002c 301C     		mov	r0, r6
 2072 002e 211C     		mov	r1, r4
 2073 0030 4A46     		mov	r2, r9
 2074 0032 231C     		mov	r3, r4
 2075 0034 FFF7FEFF 		bl	draw_line
 2076              	.LVL303:
 405:display.c     **** 	draw_line( adm, xp1, yp2, xp1, yp2, CLEAR );
 2077              		.loc 1 405 0
 2078 0038 0095     		str	r5, [sp]
 2079 003a 0197     		str	r7, [sp, #4]
 2080 003c 301C     		mov	r0, r6
 2081 003e 4146     		mov	r1, r8
 2082 0040 2A1C     		mov	r2, r5
 2083 0042 4346     		mov	r3, r8
 2084 0044 FFF7FEFF 		bl	draw_line
 2085              	.LVL304:
 406:display.c     **** 	draw_line( adm, xp2, yp2, xp2, yp2, CLEAR );
 2086              		.loc 1 406 0
 2087 0048 0095     		str	r5, [sp]
 2088 004a 0197     		str	r7, [sp, #4]
 2089 004c 301C     		mov	r0, r6
 2090 004e 211C     		mov	r1, r4
 2091 0050 2A1C     		mov	r2, r5
 2092 0052 231C     		mov	r3, r4
 2093 0054 FFF7FEFF 		bl	draw_line
 2094              	.LVL305:
 407:display.c     **** }
 2095              		.loc 1 407 0
 2096 0058 03B0     		add	sp, sp, #12
 2097              		@ sp needed for prologue
 2098 005a 0CBC     		pop	{r2, r3}
 2099 005c 9046     		mov	r8, r2
 2100 005e 9946     		mov	r9, r3
 2101 0060 F0BC     		pop	{r4, r5, r6, r7}
 2102 0062 01BC     		pop	{r0}
 2103 0064 0047     		bx	r0
 2104              	.L111:
 2105 0066 C046     		.align	2
 2106              	.L110:
 2107 0068 00000000 		.word	adm
 2108              		.cfi_endproc
 2109              	.LFE382:
 2111              		.section	.text.write_bitmap,"ax",%progbits
 2112              		.align	2
 2113              		.global	write_bitmap
 2114              		.code	16
 2115              		.thumb_func
 2117              	write_bitmap:
 2118              	.LFB383:
 408:display.c     **** // -----------------------------------------------------------
 409:display.c     **** 
 410:display.c     **** 
 411:display.c     **** // -----------------------------------------------------------
 412:display.c     **** // Function Name       : write_bitmap
 413:display.c     **** // Output Parameters   : ptd - a buffer to write raster scan for display driver
 414:display.c     **** //                       pts - uncompressed bitmap array
 415:display.c     **** //                       pts[0] = bit width of bit map
 416:display.c     **** //                       pts[1] = bit height of bit map
 417:display.c     **** //                       xpos,ypos - x,y location on display, top left = 0,0
 418:display.c     **** //                       method - AND, OR, INV
 419:display.c     **** // -----------------------------------------------------------
 420:display.c     **** unsigned char write_bitmap( unsigned char *ptd, const unsigned char *pts,
 421:display.c     ****   unsigned char xpos, unsigned char ypos, unsigned int method )
 422:display.c     **** {
 2119              		.loc 1 422 0
 2120              		.cfi_startproc
 2121              	.LVL306:
 2122 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2123              	.LCFI16:
 2124              		.cfi_def_cfa_offset 20
 2125              		.cfi_offset 4, -20
 2126              		.cfi_offset 5, -16
 2127              		.cfi_offset 6, -12
 2128              		.cfi_offset 7, -8
 2129              		.cfi_offset 14, -4
 2130 0002 5F46     		mov	r7, fp
 2131 0004 5646     		mov	r6, sl
 2132 0006 4D46     		mov	r5, r9
 2133 0008 4446     		mov	r4, r8
 2134 000a F0B4     		push	{r4, r5, r6, r7}
 2135              	.LCFI17:
 2136              		.cfi_def_cfa_offset 36
 2137              		.cfi_offset 8, -36
 2138              		.cfi_offset 9, -32
 2139              		.cfi_offset 10, -28
 2140              		.cfi_offset 11, -24
 2141 000c 8DB0     		sub	sp, sp, #52
 2142              	.LCFI18:
 2143              		.cfi_def_cfa_offset 88
 2144 000e 0790     		str	r0, [sp, #28]
 2145 0010 0491     		str	r1, [sp, #16]
 2146 0012 0B92     		str	r2, [sp, #44]
 2147 0014 0893     		str	r3, [sp, #32]
 423:display.c     **** 	unsigned short int j;
 424:display.c     **** 	unsigned char *lptd, *lpts;
 425:display.c     **** 	unsigned char imL, imR, c, d, width, x, y, n;
 426:display.c     **** 
 427:display.c     **** 	if( method & INV )
 2148              		.loc 1 427 0
 2149 0016 1698     		ldr	r0, [sp, #88]
 2150              	.LVL307:
 2151 0018 4007     		lsl	r0, r0, #29
 2152 001a 0BD5     		bpl	.L127
 2153              	.LVL308:
 428:display.c     **** 	{
 429:display.c     **** 		imL = (unsigned char)0xff;
 430:display.c     **** 		imR = (unsigned char)0xff << (8-(pts[0] % 8));
 2154              		.loc 1 430 0
 2155 001c 0B78     		ldrb	r3, [r1]
 2156              	.LVL309:
 2157 001e 0722     		mov	r2, #7
 2158              	.LVL310:
 2159 0020 1A40     		and	r2, r3
 2160 0022 0823     		mov	r3, #8
 2161 0024 9A1A     		sub	r2, r3, r2
 2162 0026 FF23     		mov	r3, #255
 2163 0028 1B06     		lsl	r3, r3, #24
 2164 002a 9340     		lsl	r3, r3, r2
 2165 002c 1B0E     		lsr	r3, r3, #24
 2166 002e 0293     		str	r3, [sp, #8]
 2167              	.LVL311:
 429:display.c     **** 		imL = (unsigned char)0xff;
 2168              		.loc 1 429 0
 2169 0030 FF25     		mov	r5, #255
 2170 0032 02E0     		b	.L113
 2171              	.LVL312:
 2172              	.L127:
 431:display.c     **** 	}
 432:display.c     **** 	else
 433:display.c     **** 	{
 434:display.c     **** 		imL = 0;
 435:display.c     **** 		imR = 0;
 2173              		.loc 1 435 0
 2174 0034 0021     		mov	r1, #0
 2175              	.LVL313:
 2176 0036 0291     		str	r1, [sp, #8]
 434:display.c     **** 		imL = 0;
 2177              		.loc 1 434 0
 2178 0038 0025     		mov	r5, #0
 2179              	.LVL314:
 2180              	.L113:
 436:display.c     **** 	}
 437:display.c     **** 
 438:display.c     **** 	c = xpos % 8; // xpos adjust, right shift bitmap
 2181              		.loc 1 438 0
 2182 003a 0723     		mov	r3, #7
 2183 003c 0B9A     		ldr	r2, [sp, #44]
 2184 003e 1A40     		and	r2, r3
 2185 0040 0592     		str	r2, [sp, #20]
 2186              	.LVL315:
 439:display.c     **** 	d = 8 - c;
 2187              		.loc 1 439 0
 2188 0042 0827     		mov	r7, #8
 2189 0044 BF1A     		sub	r7, r7, r2
 2190 0046 3F06     		lsl	r7, r7, #24
 2191 0048 3F0E     		lsr	r7, r7, #24
 2192              	.LVL316:
 440:display.c     **** 	width = (pts[0] + 7) / 8;
 2193              		.loc 1 440 0
 2194 004a 049C     		ldr	r4, [sp, #16]
 2195 004c 2378     		ldrb	r3, [r4]
 2196 004e 0733     		add	r3, r3, #7
 2197 0050 DB10     		asr	r3, r3, #3
 2198 0052 0693     		str	r3, [sp, #24]
 2199              	.LVL317:
 441:display.c     **** 
 442:display.c     **** 
 443:display.c     **** 	lpts = (unsigned char *)&pts[2];
 2200              		.loc 1 443 0
 2201 0054 A246     		mov	sl, r4
 2202 0056 0226     		mov	r6, #2
 2203 0058 B244     		add	sl, sl, r6
 2204              	.LVL318:
 444:display.c     **** 	lptd = &buffer[0];
 445:display.c     **** 	for( y = 0; y < pts[1]; y++ )
 2205              		.loc 1 445 0
 2206 005a 6278     		ldrb	r2, [r4, #1]
 2207 005c 002A     		cmp	r2, #0
 2208 005e 00D1     		bne	.LCB2421
 2209 0060 BDE0     		b	.L114	@long jump
 2210              	.LCB2421:
 2211 0062 0020     		mov	r0, #0
 2212 0064 0390     		str	r0, [sp, #12]
 444:display.c     **** 	lptd = &buffer[0];
 2213              		.loc 1 444 0
 2214 0066 634C     		ldr	r4, .L133
 446:display.c     **** 	{
 447:display.c     **** 		*lptd++ = ((*lpts ^ imL) >> c);
 2215              		.loc 1 447 0
 2216 0068 0599     		ldr	r1, [sp, #20]
 2217 006a 8946     		mov	r9, r1
 420:display.c     **** unsigned char write_bitmap( unsigned char *ptd, const unsigned char *pts,
 2218              		.loc 1 420 0
 2219 006c 1A1C     		mov	r2, r3
 2220 006e 023A     		sub	r2, r2, #2
 2221 0070 1206     		lsl	r2, r2, #24
 2222 0072 120E     		lsr	r2, r2, #24
 2223 0074 0992     		str	r2, [sp, #36]
 2224 0076 0232     		add	r2, r2, #2
 2225 0078 0A92     		str	r2, [sp, #40]
 448:display.c     **** 		for( x = 1; x < width; x++ )
 449:display.c     **** 		{
 450:display.c     **** 			*lptd = ((*lpts ^ imL) << d);
 451:display.c     **** 			if( x == (width - 1) )
 2226              		.loc 1 451 0
 2227 007a 013B     		sub	r3, r3, #1
 2228 007c 9846     		mov	r8, r3
 2229              	.LVL319:
 2230              	.L119:
 447:display.c     **** 		*lptd++ = ((*lpts ^ imL) >> c);
 2231              		.loc 1 447 0
 2232 007e 5246     		mov	r2, sl
 2233 0080 1378     		ldrb	r3, [r2]
 2234 0082 6B40     		eor	r3, r5
 2235 0084 059E     		ldr	r6, [sp, #20]
 2236 0086 3341     		asr	r3, r3, r6
 2237 0088 2370     		strb	r3, [r4]
 2238 008a 601C     		add	r0, r4, #1
 2239 008c 8346     		mov	fp, r0
 2240              	.LVL320:
 448:display.c     **** 		for( x = 1; x < width; x++ )
 2241              		.loc 1 448 0
 2242 008e 0699     		ldr	r1, [sp, #24]
 2243 0090 0129     		cmp	r1, #1
 2244 0092 29D9     		bls	.L115
 2245 0094 011C     		mov	r1, r0
 420:display.c     **** unsigned char write_bitmap( unsigned char *ptd, const unsigned char *pts,
 2246              		.loc 1 420 0
 2247 0096 0132     		add	r2, r2, #1
 2248              	.LVL321:
 2249 0098 0A9B     		ldr	r3, [sp, #40]
 2250 009a 1B19     		add	r3, r3, r4
 2251 009c 9C46     		mov	ip, r3
 2252 009e 0023     		mov	r3, #0
 2253 00a0 0197     		str	r7, [sp, #4]
 2254 00a2 6046     		mov	r0, ip
 2255              	.LVL322:
 2256 00a4 0090     		str	r0, [sp]
 2257              	.LVL323:
 2258              	.L118:
 2259 00a6 0133     		add	r3, r3, #1
 2260 00a8 501E     		sub	r0, r2, #1
 450:display.c     **** 			*lptd = ((*lpts ^ imL) << d);
 2261              		.loc 1 450 0
 2262 00aa 0078     		ldrb	r0, [r0]
 2263 00ac 6840     		eor	r0, r5
 2264 00ae 019E     		ldr	r6, [sp, #4]
 2265 00b0 B040     		lsl	r0, r0, r6
 2266 00b2 E054     		strb	r0, [r4, r3]
 2267 00b4 0131     		add	r1, r1, #1
 2268              		.loc 1 451 0
 2269 00b6 4345     		cmp	r3, r8
 2270 00b8 07D1     		bne	.L116
 452:display.c     **** 			{
 453:display.c     **** 				*lptd++ |= ((*(++lpts) ^ imR) >> c);
 2271              		.loc 1 453 0
 2272 00ba 1778     		ldrb	r7, [r2]
 2273 00bc 029E     		ldr	r6, [sp, #8]
 2274 00be 7E40     		eor	r6, r7
 2275 00c0 4F46     		mov	r7, r9
 2276 00c2 3E41     		asr	r6, r6, r7
 2277 00c4 3043     		orr	r0, r6
 2278 00c6 E054     		strb	r0, [r4, r3]
 2279              	.LVL324:
 2280 00c8 05E0     		b	.L117
 2281              	.LVL325:
 2282              	.L116:
 454:display.c     **** 			}
 455:display.c     **** 			else
 456:display.c     **** 			{
 457:display.c     **** 				*lptd++ |= ((*(++lpts) ^ imL) >> c);
 2283              		.loc 1 457 0
 2284 00ca 1678     		ldrb	r6, [r2]
 2285 00cc 6E40     		eor	r6, r5
 2286 00ce 4F46     		mov	r7, r9
 2287 00d0 3E41     		asr	r6, r6, r7
 2288 00d2 3043     		orr	r0, r6
 2289 00d4 E054     		strb	r0, [r4, r3]
 2290              	.LVL326:
 2291              	.L117:
 2292 00d6 0132     		add	r2, r2, #1
 448:display.c     **** 		for( x = 1; x < width; x++ )
 2293              		.loc 1 448 0
 2294 00d8 0098     		ldr	r0, [sp]
 2295 00da 8142     		cmp	r1, r0
 2296 00dc E3D1     		bne	.L118
 2297 00de 019F     		ldr	r7, [sp, #4]
 420:display.c     **** unsigned char write_bitmap( unsigned char *ptd, const unsigned char *pts,
 2298              		.loc 1 420 0
 2299 00e0 099B     		ldr	r3, [sp, #36]
 2300 00e2 0133     		add	r3, r3, #1
 2301 00e4 9B44     		add	fp, fp, r3
 2302 00e6 9A44     		add	sl, sl, r3
 2303              	.L115:
 458:display.c     **** 			}
 459:display.c     **** 		}
 460:display.c     **** 		*lptd++ = ((*lpts++ ^ imR) << d);
 2304              		.loc 1 460 0
 2305 00e8 5146     		mov	r1, sl
 2306 00ea 0B78     		ldrb	r3, [r1]
 2307 00ec 029A     		ldr	r2, [sp, #8]
 2308 00ee 5340     		eor	r3, r2
 2309 00f0 BB40     		lsl	r3, r3, r7
 2310 00f2 5C46     		mov	r4, fp
 2311 00f4 2370     		strb	r3, [r4]
 2312 00f6 0134     		add	r4, r4, #1
 2313              	.LVL327:
 2314 00f8 0126     		mov	r6, #1
 2315 00fa B244     		add	sl, sl, r6
 2316              	.LVL328:
 445:display.c     **** 	for( y = 0; y < pts[1]; y++ )
 2317              		.loc 1 445 0
 2318 00fc 039B     		ldr	r3, [sp, #12]
 2319 00fe 0133     		add	r3, r3, #1
 2320 0100 1B06     		lsl	r3, r3, #24
 2321 0102 1B0E     		lsr	r3, r3, #24
 2322 0104 0393     		str	r3, [sp, #12]
 2323              	.LVL329:
 2324 0106 0498     		ldr	r0, [sp, #16]
 2325 0108 4378     		ldrb	r3, [r0, #1]
 2326 010a 0399     		ldr	r1, [sp, #12]
 2327 010c 8B42     		cmp	r3, r1
 2328 010e B6D8     		bhi	.L119
 461:display.c     **** 	}
 462:display.c     **** 
 463:display.c     **** 	width++;
 2329              		.loc 1 463 0
 2330 0110 069A     		ldr	r2, [sp, #24]
 2331 0112 9446     		mov	ip, r2
 2332 0114 B444     		add	ip, ip, r6
 2333              	.LVL330:
 464:display.c     **** 
 465:display.c     **** 	x = (xpos / 8);
 2334              		.loc 1 465 0
 2335 0116 0B9C     		ldr	r4, [sp, #44]
 2336              	.LVL331:
 2337 0118 E408     		lsr	r4, r4, #3
 2338 011a 0294     		str	r4, [sp, #8]
 2339              	.LVL332:
 466:display.c     **** 	lpts = &buffer[0];
 467:display.c     **** 	for( n = 0; n < pts[1]; n++ )
 2340              		.loc 1 467 0
 2341 011c 002B     		cmp	r3, #0
 2342 011e 5ED0     		beq	.L114
 2343 0120 0026     		mov	r6, #0
 2344 0122 B346     		mov	fp, r6
 2345              	.LVL333:
 466:display.c     **** 	lpts = &buffer[0];
 2346              		.loc 1 466 0
 2347 0124 334F     		ldr	r7, .L133
 468:display.c     **** 	{
 469:display.c     **** 		j = x + ((ypos + n) * COLUMNS);
 470:display.c     **** 		lptd = &ptd[j];
 471:display.c     **** 		for( c=0; (c < width) && (j < GRAPHICS_SIZE); c++ )
 2348              		.loc 1 471 0
 2349 0126 3448     		ldr	r0, .L133+4
 2350 0128 8046     		mov	r8, r0
 2351 012a 6146     		mov	r1, ip
 2352 012c 4B1E     		sub	r3, r1, #1
 2353 012e 9941     		sbc	r1, r1, r3
 2354 0130 0391     		str	r1, [sp, #12]
 472:display.c     **** 		{
 473:display.c     **** 			if( (method & OR) == OR )
 2355              		.loc 1 473 0
 2356 0132 0223     		mov	r3, #2
 2357 0134 169A     		ldr	r2, [sp, #88]
 2358 0136 1A40     		and	r2, r3
 2359 0138 9146     		mov	r9, r2
 474:display.c     **** 			{
 475:display.c     **** 				*lptd++ |= *lpts++;
 476:display.c     **** 			}
 477:display.c     **** 			else if ( (method & XOR) == XOR )
 2360              		.loc 1 477 0
 2361 013a 0823     		mov	r3, #8
 2362 013c 169C     		ldr	r4, [sp, #88]
 2363 013e 1C40     		and	r4, r3
 2364 0140 A246     		mov	sl, r4
 2365              	.LVL334:
 2366              	.L126:
 469:display.c     **** 		j = x + ((ypos + n) * COLUMNS);
 2367              		.loc 1 469 0
 2368 0142 089E     		ldr	r6, [sp, #32]
 2369 0144 331C     		mov	r3, r6
 2370 0146 5B44     		add	r3, r3, fp
 2371 0148 9E00     		lsl	r6, r3, #2
 2372 014a F618     		add	r6, r6, r3
 2373 014c B600     		lsl	r6, r6, #2
 2374 014e 0298     		ldr	r0, [sp, #8]
 2375 0150 8619     		add	r6, r0, r6
 2376 0152 3604     		lsl	r6, r6, #16
 2377 0154 360C     		lsr	r6, r6, #16
 2378              	.LVL335:
 470:display.c     **** 		lptd = &ptd[j];
 2379              		.loc 1 470 0
 2380 0156 079C     		ldr	r4, [sp, #28]
 2381 0158 A219     		add	r2, r4, r6
 2382              	.LVL336:
 471:display.c     **** 		for( c=0; (c < width) && (j < GRAPHICS_SIZE); c++ )
 2383              		.loc 1 471 0
 2384 015a B045     		cmp	r8, r6
 2385 015c 36D3     		bcc	.L120
 2386 015e 0398     		ldr	r0, [sp, #12]
 2387 0160 0028     		cmp	r0, #0
 2388 0162 33D0     		beq	.L120
 420:display.c     **** unsigned char write_bitmap( unsigned char *ptd, const unsigned char *pts,
 2389              		.loc 1 420 0
 2390 0164 781C     		add	r0, r7, #1
 2391 0166 391C     		mov	r1, r7
 469:display.c     **** 		j = x + ((ypos + n) * COLUMNS);
 2392              		.loc 1 469 0
 2393 0168 331C     		mov	r3, r6
 471:display.c     **** 		for( c=0; (c < width) && (j < GRAPHICS_SIZE); c++ )
 2394              		.loc 1 471 0
 2395 016a 0025     		mov	r5, #0
 2396 016c 0596     		str	r6, [sp, #20]
 2397 016e 6646     		mov	r6, ip
 2398              	.LVL337:
 2399              	.L124:
 473:display.c     **** 			if( (method & OR) == OR )
 2400              		.loc 1 473 0
 2401 0170 4C46     		mov	r4, r9
 2402 0172 002C     		cmp	r4, #0
 2403 0174 07D0     		beq	.L121
 475:display.c     **** 				*lptd++ |= *lpts++;
 2404              		.loc 1 475 0
 2405 0176 0F78     		ldrb	r7, [r1]
 2406 0178 BC46     		mov	ip, r7
 2407 017a 1778     		ldrb	r7, [r2]
 2408 017c 6446     		mov	r4, ip
 2409 017e 2743     		orr	r7, r4
 2410 0180 1770     		strb	r7, [r2]
 2411 0182 8446     		mov	ip, r0
 2412              	.LVL338:
 2413 0184 0BE0     		b	.L122
 2414              	.LVL339:
 2415              	.L121:
 2416              		.loc 1 477 0
 2417 0186 5746     		mov	r7, sl
 2418 0188 002F     		cmp	r7, #0
 2419 018a 05D0     		beq	.L123
 478:display.c     **** 			{
 479:display.c     **** 				*lptd++ ^= *lpts++;
 2420              		.loc 1 479 0
 2421 018c 0C78     		ldrb	r4, [r1]
 2422 018e 1778     		ldrb	r7, [r2]
 2423 0190 6740     		eor	r7, r4
 2424 0192 1770     		strb	r7, [r2]
 2425 0194 8446     		mov	ip, r0
 2426              	.LVL340:
 2427 0196 02E0     		b	.L122
 2428              	.LVL341:
 2429              	.L123:
 480:display.c     **** 			}
 481:display.c     **** 			else  //  default = AND
 482:display.c     **** 					{
 483:display.c     **** 				*lptd++ = *lpts++;
 2430              		.loc 1 483 0
 2431 0198 0C78     		ldrb	r4, [r1]
 2432 019a 1470     		strb	r4, [r2]
 2433 019c 8446     		mov	ip, r0
 2434              	.LVL342:
 2435              	.L122:
 484:display.c     **** 					}
 485:display.c     **** 			j++;
 2436              		.loc 1 485 0
 2437 019e 0133     		add	r3, r3, #1
 2438 01a0 1B04     		lsl	r3, r3, #16
 2439 01a2 1B0C     		lsr	r3, r3, #16
 2440              	.LVL343:
 2441 01a4 0132     		add	r2, r2, #1
 2442 01a6 0130     		add	r0, r0, #1
 2443              	.LVL344:
 2444 01a8 0131     		add	r1, r1, #1
 471:display.c     **** 		for( c=0; (c < width) && (j < GRAPHICS_SIZE); c++ )
 2445              		.loc 1 471 0
 2446 01aa 059F     		ldr	r7, [sp, #20]
 2447 01ac DC1B     		sub	r4, r3, r7
 2448 01ae 2406     		lsl	r4, r4, #24
 2449 01b0 240E     		lsr	r4, r4, #24
 2450 01b2 B442     		cmp	r4, r6
 2451 01b4 08D2     		bcs	.L132
 2452 01b6 2C1C     		mov	r4, r5
 2453 01b8 4746     		mov	r7, r8
 2454 01ba 9F42     		cmp	r7, r3
 2455 01bc 6C41     		adc	r4, r4, r5
 2456 01be 002C     		cmp	r4, #0
 2457 01c0 D6D1     		bne	.L124
 2458 01c2 6746     		mov	r7, ip
 2459 01c4 B446     		mov	ip, r6
 2460              	.LVL345:
 2461 01c6 01E0     		b	.L120
 2462              	.LVL346:
 2463              	.L132:
 2464 01c8 6746     		mov	r7, ip
 2465 01ca B446     		mov	ip, r6
 2466              	.LVL347:
 2467              	.L120:
 467:display.c     **** 	for( n = 0; n < pts[1]; n++ )
 2468              		.loc 1 467 0
 2469 01cc 5B46     		mov	r3, fp
 2470 01ce 0133     		add	r3, r3, #1
 2471 01d0 1B06     		lsl	r3, r3, #24
 2472 01d2 1B0E     		lsr	r3, r3, #24
 2473 01d4 9B46     		mov	fp, r3
 2474              	.LVL348:
 2475 01d6 0498     		ldr	r0, [sp, #16]
 2476 01d8 4378     		ldrb	r3, [r0, #1]
 2477              	.LVL349:
 2478 01da 5B45     		cmp	r3, fp
 2479 01dc B1D8     		bhi	.L126
 2480              	.LVL350:
 2481              	.L114:
 486:display.c     **** 		}
 487:display.c     **** 	}
 488:display.c     **** 
 489:display.c     **** 	return( pts[0] );
 2482              		.loc 1 489 0
 2483 01de 0499     		ldr	r1, [sp, #16]
 2484 01e0 0878     		ldrb	r0, [r1]
 490:display.c     **** }
 2485              		.loc 1 490 0
 2486 01e2 0DB0     		add	sp, sp, #52
 2487              		@ sp needed for prologue
 2488 01e4 3CBC     		pop	{r2, r3, r4, r5}
 2489 01e6 9046     		mov	r8, r2
 2490 01e8 9946     		mov	r9, r3
 2491 01ea A246     		mov	sl, r4
 2492 01ec AB46     		mov	fp, r5
 2493 01ee F0BC     		pop	{r4, r5, r6, r7}
 2494 01f0 02BC     		pop	{r1}
 2495 01f2 0847     		bx	r1
 2496              	.L134:
 2497              		.align	2
 2498              	.L133:
 2499 01f4 00000000 		.word	buffer
 2500 01f8 FF090000 		.word	2559
 2501              		.cfi_endproc
 2502              	.LFE383:
 2504              		.section	.text.display_f1_text,"ax",%progbits
 2505              		.align	2
 2506              		.global	display_f1_text
 2507              		.code	16
 2508              		.thumb_func
 2510              	display_f1_text:
 2511              	.LFB384:
 491:display.c     **** // -----------------------------------------------------------
 492:display.c     **** 
 493:display.c     **** 
 494:display.c     **** // -----------------------------------------------------------
 495:display.c     **** // Function Name       : display_f1_text
 496:display.c     **** // -----------------------------------------------------------
 497:display.c     **** unsigned char display_f1_text( const unsigned char *data, unsigned char max,
 498:display.c     ****   unsigned char co, unsigned char ro, unsigned char prog )
 499:display.c     **** {
 2512              		.loc 1 499 0
 2513              		.cfi_startproc
 2514              	.LVL351:
 2515 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2516              	.LCFI19:
 2517              		.cfi_def_cfa_offset 20
 2518              		.cfi_offset 4, -20
 2519              		.cfi_offset 5, -16
 2520              		.cfi_offset 6, -12
 2521              		.cfi_offset 7, -8
 2522              		.cfi_offset 14, -4
 2523 0002 5F46     		mov	r7, fp
 2524 0004 5646     		mov	r6, sl
 2525 0006 4D46     		mov	r5, r9
 2526 0008 4446     		mov	r4, r8
 2527 000a F0B4     		push	{r4, r5, r6, r7}
 2528              	.LCFI20:
 2529              		.cfi_def_cfa_offset 36
 2530              		.cfi_offset 8, -36
 2531              		.cfi_offset 9, -32
 2532              		.cfi_offset 10, -28
 2533              		.cfi_offset 11, -24
 2534 000c 89B0     		sub	sp, sp, #36
 2535              	.LCFI21:
 2536              		.cfi_def_cfa_offset 72
 2537 000e 071C     		mov	r7, r0
 2538 0010 0D1C     		mov	r5, r1
 2539 0012 0392     		str	r2, [sp, #12]
 2540 0014 9846     		mov	r8, r3
 2541 0016 12AB     		add	r3, sp, #72
 2542              	.LVL352:
 2543 0018 1B78     		ldrb	r3, [r3]
 2544 001a 0493     		str	r3, [sp, #16]
 500:display.c     **** 	static unsigned char pos, dstring[32];
 501:display.c     **** 
 502:display.c     **** 	struct fn1 const *font;
 503:display.c     **** 	unsigned short int i;
 504:display.c     **** 	unsigned char *pt, loc, chr, wid, lco, coo;
 505:display.c     **** 
 506:display.c     **** 	font = fnt1[pFac.pf.Lang];
 2545              		.loc 1 506 0
 2546 001c C04B     		ldr	r3, .L241
 2547 001e 1A7B     		ldrb	r2, [r3, #12]
 2548              	.LVL353:
 2549 0020 9200     		lsl	r2, r2, #2
 2550 0022 C04B     		ldr	r3, .L241+4
 2551 0024 D458     		ldr	r4, [r2, r3]
 2552              	.LVL354:
 507:display.c     **** 
 508:display.c     **** 	if( prog & EDIT )
 2553              		.loc 1 508 0
 2554 0026 0123     		mov	r3, #1
 2555 0028 0498     		ldr	r0, [sp, #16]
 2556              	.LVL355:
 2557 002a 1840     		and	r0, r3
 2558 002c 0590     		str	r0, [sp, #20]
 2559 002e 00D1     		bne	.LCB2830
 2560 0030 32E1     		b	.L136	@long jump
 2561              	.LCB2830:
 509:display.c     **** 	{
 510:display.c     **** 		if( editing )
 2562              		.loc 1 510 0
 2563 0032 BD4B     		ldr	r3, .L241+8
 2564 0034 1B78     		ldrb	r3, [r3]
 2565 0036 002B     		cmp	r3, #0
 2566 0038 00D1     		bne	.LCB2834
 2567 003a FEE0     		b	.L137	@long jump
 2568              	.LCB2834:
 511:display.c     **** 		{
 512:display.c     **** 			if( key & (SW_NEW | SW_REP) )
 2569              		.loc 1 512 0
 2570 003c BB4A     		ldr	r2, .L241+12
 2571 003e 1268     		ldr	r2, [r2]
 2572 0040 910F     		lsr	r1, r2, #30
 2573              	.LVL356:
 2574 0042 00D1     		bne	.LCB2841
 2575 0044 30E1     		b	.L140	@long jump
 2576              	.LCB2841:
 513:display.c     **** 			{
 514:display.c     **** 				key &= ~(SW_NEW | SW_REP); // mask off status bits
 2577              		.loc 1 514 0
 2578 0046 9200     		lsl	r2, r2, #2
 2579 0048 9208     		lsr	r2, r2, #2
 2580              	.LVL357:
 2581 004a B849     		ldr	r1, .L241+12
 2582 004c 0A60     		str	r2, [r1]
 2583              	.LVL358:
 515:display.c     **** 				if( key == SW_OR )
 2584              		.loc 1 515 0
 2585 004e 8021     		mov	r1, #128
 2586 0050 4900     		lsl	r1, r1, #1
 2587 0052 8A42     		cmp	r2, r1
 2588 0054 12D1     		bne	.L139
 516:display.c     **** 				{
 517:display.c     **** 					switch( editing )
 2589              		.loc 1 517 0
 2590 0056 022B     		cmp	r3, #2
 2591 0058 08D0     		beq	.L142
 2592 005a 032B     		cmp	r3, #3
 2593 005c 0AD0     		beq	.L143
 2594 005e 012B     		cmp	r3, #1
 2595 0060 00D0     		beq	.LCB2857
 2596 0062 21E1     		b	.L140	@long jump
 2597              	.LCB2857:
 518:display.c     **** 					{
 519:display.c     **** 					case EDIT_UPPER:
 520:display.c     **** 						editing = EDIT_LOWER;
 2598              		.loc 1 520 0
 2599 0064 0222     		mov	r2, #2
 2600              	.LVL359:
 2601 0066 B04B     		ldr	r3, .L241+8
 2602 0068 1A70     		strb	r2, [r3]
 521:display.c     **** 						break;
 2603              		.loc 1 521 0
 2604 006a 1DE1     		b	.L140
 2605              	.LVL360:
 2606              	.L142:
 522:display.c     **** 
 523:display.c     **** 					case EDIT_LOWER:
 524:display.c     **** 						editing = EDIT_NUMERIC;
 2607              		.loc 1 524 0
 2608 006c 0322     		mov	r2, #3
 2609              	.LVL361:
 2610 006e AE4B     		ldr	r3, .L241+8
 2611 0070 1A70     		strb	r2, [r3]
 525:display.c     **** 						break;
 2612              		.loc 1 525 0
 2613 0072 19E1     		b	.L140
 2614              	.LVL362:
 2615              	.L143:
 526:display.c     **** 
 527:display.c     **** 					case EDIT_NUMERIC:
 528:display.c     **** 						editing = EDIT_UPPER;
 2616              		.loc 1 528 0
 2617 0074 0122     		mov	r2, #1
 2618              	.LVL363:
 2619 0076 AC4B     		ldr	r3, .L241+8
 2620 0078 1A70     		strb	r2, [r3]
 529:display.c     **** 						break;
 2621              		.loc 1 529 0
 2622 007a 15E1     		b	.L140
 2623              	.LVL364:
 2624              	.L139:
 530:display.c     **** 					}
 531:display.c     **** 				}
 532:display.c     **** 				else if( key == SW_IR )
 2625              		.loc 1 532 0
 2626 007c 082A     		cmp	r2, #8
 2627 007e 17D1     		bne	.L144
 533:display.c     **** 				{
 534:display.c     **** 					editing = 0;
 2628              		.loc 1 534 0
 2629 0080 0022     		mov	r2, #0
 2630              	.LVL365:
 2631 0082 A94B     		ldr	r3, .L241+8
 2632 0084 1A70     		strb	r2, [r3]
 535:display.c     **** 					strcpy( (char *)data, dstring );
 2633              		.loc 1 535 0
 2634 0086 381C     		mov	r0, r7
 2635 0088 A949     		ldr	r1, .L241+16
 2636 008a FFF7FEFF 		bl	strcpy
 2637              	.LVL366:
 536:display.c     **** 					// if factor is in pFac address space then save to flash
 537:display.c     **** 					if( ((unsigned char *)data >= &(pFac.ch[0])) && ((unsigned char *)data < (unsigned char *)&(pF
 2638              		.loc 1 537 0
 2639 008e A44B     		ldr	r3, .L241
 2640 0090 9F42     		cmp	r7, r3
 2641 0092 05D3     		bcc	.L145
 2642              		.loc 1 537 0 is_stmt 0 discriminator 1
 2643 0094 A74B     		ldr	r3, .L241+20
 2644 0096 9F42     		cmp	r7, r3
 2645 0098 02D2     		bcs	.L145
 538:display.c     **** 					{
 539:display.c     **** 						savecal = 1;
 2646              		.loc 1 539 0 is_stmt 1
 2647 009a 0122     		mov	r2, #1
 2648 009c A64B     		ldr	r3, .L241+24
 2649 009e 1A70     		strb	r2, [r3]
 2650              	.L145:
 540:display.c     **** 					}
 541:display.c     **** 
 542:display.c     **** 					if( prog & EDSCAPE )
 2651              		.loc 1 542 0
 2652 00a0 0499     		ldr	r1, [sp, #16]
 2653 00a2 4906     		lsl	r1, r1, #25
 2654 00a4 00D4     		bmi	.LCB2912
 2655 00a6 FFE0     		b	.L140	@long jump
 2656              	.LCB2912:
 543:display.c     **** 					{
 544:display.c     **** 						escape = 3;
 2657              		.loc 1 544 0
 2658 00a8 0322     		mov	r2, #3
 2659 00aa A44B     		ldr	r3, .L241+28
 2660 00ac 1A70     		strb	r2, [r3]
 2661 00ae FBE0     		b	.L140
 2662              	.LVL367:
 2663              	.L144:
 545:display.c     **** 					}
 546:display.c     **** 				}
 547:display.c     **** 				else if( key == SW_CR )
 2664              		.loc 1 547 0
 2665 00b0 802A     		cmp	r2, #128
 2666 00b2 09D1     		bne	.L146
 548:display.c     **** 				{
 549:display.c     **** 					if( pos < (max - 1) )
 2667              		.loc 1 549 0
 2668 00b4 A24B     		ldr	r3, .L241+32
 2669 00b6 1B78     		ldrb	r3, [r3]
 2670 00b8 6A1E     		sub	r2, r5, #1
 2671              	.LVL368:
 2672 00ba 9342     		cmp	r3, r2
 2673 00bc 00DB     		blt	.LCB2930
 2674 00be F3E0     		b	.L140	@long jump
 2675              	.LCB2930:
 550:display.c     **** 					{
 551:display.c     **** 						pos++;
 2676              		.loc 1 551 0
 2677 00c0 0133     		add	r3, r3, #1
 2678 00c2 9F4A     		ldr	r2, .L241+32
 2679 00c4 1370     		strb	r3, [r2]
 2680 00c6 EFE0     		b	.L140
 2681              	.LVL369:
 2682              	.L146:
 552:display.c     **** 					}
 553:display.c     **** 				}
 554:display.c     **** 				else if( key == SW_CL )
 2683              		.loc 1 554 0
 2684 00c8 102A     		cmp	r2, #16
 2685 00ca 08D1     		bne	.L147
 555:display.c     **** 				{
 556:display.c     **** 					if( pos )
 2686              		.loc 1 556 0
 2687 00cc 9C4B     		ldr	r3, .L241+32
 2688 00ce 1B78     		ldrb	r3, [r3]
 2689 00d0 002B     		cmp	r3, #0
 2690 00d2 00D1     		bne	.LCB2944
 2691 00d4 E8E0     		b	.L140	@long jump
 2692              	.LCB2944:
 557:display.c     **** 					{
 558:display.c     **** 						pos--;
 2693              		.loc 1 558 0
 2694 00d6 013B     		sub	r3, r3, #1
 2695 00d8 994A     		ldr	r2, .L241+32
 2696              	.LVL370:
 2697 00da 1370     		strb	r3, [r2]
 2698 00dc E4E0     		b	.L140
 2699              	.LVL371:
 2700              	.L147:
 559:display.c     **** 					}
 560:display.c     **** 				}
 561:display.c     **** 				else if( key == SW_IL )
 2701              		.loc 1 561 0
 2702 00de 042A     		cmp	r2, #4
 2703 00e0 0AD1     		bne	.L148
 562:display.c     **** 				{
 563:display.c     **** 					editing = 0;
 2704              		.loc 1 563 0
 2705 00e2 0022     		mov	r2, #0
 2706              	.LVL372:
 2707 00e4 904B     		ldr	r3, .L241+8
 2708 00e6 1A70     		strb	r2, [r3]
 564:display.c     **** 					if( prog & EDSCAPE )
 2709              		.loc 1 564 0
 2710 00e8 049A     		ldr	r2, [sp, #16]
 2711 00ea 5206     		lsl	r2, r2, #25
 2712 00ec 00D4     		bmi	.LCB2966
 2713 00ee DBE0     		b	.L140	@long jump
 2714              	.LCB2966:
 565:display.c     **** 					{
 566:display.c     **** 						escape = 2;
 2715              		.loc 1 566 0
 2716 00f0 0222     		mov	r2, #2
 2717 00f2 924B     		ldr	r3, .L241+28
 2718 00f4 1A70     		strb	r2, [r3]
 2719 00f6 D7E0     		b	.L140
 2720              	.LVL373:
 2721              	.L148:
 567:display.c     **** 					}
 568:display.c     **** 				}
 569:display.c     **** 				else if( (key == SW_CU) || (key == SW_CD) )
 2722              		.loc 1 569 0
 2723 00f8 111C     		mov	r1, r2
 2724 00fa 2039     		sub	r1, r1, #32
 2725 00fc 4842     		neg	r0, r1
 2726 00fe 4841     		adc	r0, r0, r1
 2727 0100 8246     		mov	sl, r0
 2728 0102 402A     		cmp	r2, #64
 2729 0104 02D0     		beq	.L217
 2730 0106 0028     		cmp	r0, #0
 2731 0108 00D1     		bne	.LCB2988
 2732 010a CDE0     		b	.L140	@long jump
 2733              	.LCB2988:
 2734              	.L217:
 570:display.c     **** 				{
 571:display.c     **** 					chr = dstring[pos];
 2735              		.loc 1 571 0
 2736 010c 8C4A     		ldr	r2, .L241+32
 2737              	.LVL374:
 2738 010e 1278     		ldrb	r2, [r2]
 2739 0110 9346     		mov	fp, r2
 2740 0112 874A     		ldr	r2, .L241+16
 2741 0114 5946     		mov	r1, fp
 2742 0116 505C     		ldrb	r0, [r2, r1]
 2743              	.LVL375:
 572:display.c     **** 					i = 0;
 573:display.c     **** 					// find match in upper case data
 574:display.c     **** 					while( UCkey[i] && (UCkey[i] != chr) )
 2744              		.loc 1 574 0
 2745 0118 8A4A     		ldr	r2, .L241+36
 2746              	.LVL376:
 2747 011a 1278     		ldrb	r2, [r2]
 2748 011c 002A     		cmp	r2, #0
 2749 011e 12D0     		beq	.L150
 2750 0120 9042     		cmp	r0, r2
 2751 0122 00D1     		bne	.LCB3005
 2752 0124 2FE2     		b	.L200	@long jump
 2753              	.LCB3005:
 572:display.c     **** 					i = 0;
 2754              		.loc 1 572 0
 2755 0126 0022     		mov	r2, #0
 2756              		.loc 1 574 0
 2757 0128 8649     		ldr	r1, .L241+36
 2758              	.LVL377:
 2759 012a 8C46     		mov	ip, r1
 2760 012c 0693     		str	r3, [sp, #24]
 2761              	.LVL378:
 2762              	.L152:
 575:display.c     **** 					{
 576:display.c     **** 						i++;
 2763              		.loc 1 576 0
 2764 012e 0132     		add	r2, r2, #1
 2765 0130 1204     		lsl	r2, r2, #16
 2766 0132 120C     		lsr	r2, r2, #16
 2767              	.LVL379:
 574:display.c     **** 					while( UCkey[i] && (UCkey[i] != chr) )
 2768              		.loc 1 574 0
 2769 0134 6346     		mov	r3, ip
 2770 0136 995C     		ldrb	r1, [r3, r2]
 2771 0138 0029     		cmp	r1, #0
 2772 013a 03D0     		beq	.L232
 574:display.c     **** 					while( UCkey[i] && (UCkey[i] != chr) )
 2773              		.loc 1 574 0 is_stmt 0 discriminator 2
 2774 013c 8842     		cmp	r0, r1
 2775 013e F6D1     		bne	.L152
 2776 0140 069B     		ldr	r3, [sp, #24]
 2777 0142 21E2     		b	.L151
 2778              	.L232:
 2779 0144 069B     		ldr	r3, [sp, #24]
 2780              	.LVL380:
 2781              	.L150:
 577:display.c     **** 					}
 578:display.c     **** 					//  match
 579:display.c     **** 					if( UCkey[i] )
 580:display.c     **** 					{
 581:display.c     **** 						switch( editing )
 582:display.c     **** 						{
 583:display.c     **** 						case EDIT_UPPER:
 584:display.c     **** 							pt = (unsigned char *)&UCkey[0];
 585:display.c     **** 							loc = i;
 586:display.c     **** 							break;
 587:display.c     **** 
 588:display.c     **** 						case EDIT_LOWER:
 589:display.c     **** 							pt = (unsigned char *)&LCkey[0];
 590:display.c     **** 							loc = i;
 591:display.c     **** 							break;
 592:display.c     **** 
 593:display.c     **** 						case EDIT_NUMERIC:
 594:display.c     **** 							pt = (unsigned char *)&NCkey[0];
 595:display.c     **** 							loc = 0;
 596:display.c     **** 							break;
 597:display.c     **** 						}
 598:display.c     **** 					}
 599:display.c     **** 					else // no match
 600:display.c     **** 					{
 601:display.c     **** 						i = 0;
 602:display.c     **** 						// find match in lower case data
 603:display.c     **** 						while( LCkey[i] && (LCkey[i] != chr) )
 2782              		.loc 1 603 0 is_stmt 1 discriminator 1
 2783 0146 804A     		ldr	r2, .L241+40
 2784 0148 1178     		ldrb	r1, [r2]
 2785 014a 0029     		cmp	r1, #0
 2786 014c 1CD0     		beq	.L153
 2787              		.loc 1 603 0 is_stmt 0
 2788 014e 0022     		mov	r2, #0
 2789 0150 8842     		cmp	r0, r1
 2790 0152 0AD1     		bne	.L154
 2791 0154 21E2     		b	.L155
 2792              	.LVL381:
 2793              	.L156:
 585:display.c     **** 							loc = i;
 2794              		.loc 1 585 0 is_stmt 1
 2795 0156 1206     		lsl	r2, r2, #24
 2796 0158 120E     		lsr	r2, r2, #24
 2797 015a 9146     		mov	r9, r2
 2798              	.LVL382:
 584:display.c     **** 							pt = (unsigned char *)&UCkey[0];
 2799              		.loc 1 584 0
 2800 015c 794E     		ldr	r6, .L241+36
 586:display.c     **** 							break;
 2801              		.loc 1 586 0
 2802 015e 3CE0     		b	.L157
 2803              	.LVL383:
 2804              	.L158:
 590:display.c     **** 							loc = i;
 2805              		.loc 1 590 0
 2806 0160 1206     		lsl	r2, r2, #24
 2807 0162 120E     		lsr	r2, r2, #24
 2808 0164 9146     		mov	r9, r2
 2809              	.LVL384:
 589:display.c     **** 							pt = (unsigned char *)&LCkey[0];
 2810              		.loc 1 589 0
 2811 0166 784E     		ldr	r6, .L241+40
 591:display.c     **** 							break;
 2812              		.loc 1 591 0
 2813 0168 37E0     		b	.L157
 2814              	.LVL385:
 2815              	.L154:
 2816              		.loc 1 603 0
 2817 016a 7749     		ldr	r1, .L241+40
 2818 016c 8C46     		mov	ip, r1
 2819 016e 0693     		str	r3, [sp, #24]
 2820              	.LVL386:
 2821              	.L221:
 604:display.c     **** 						{
 605:display.c     **** 							i++;
 2822              		.loc 1 605 0
 2823 0170 0132     		add	r2, r2, #1
 2824 0172 1204     		lsl	r2, r2, #16
 2825 0174 120C     		lsr	r2, r2, #16
 2826              	.LVL387:
 603:display.c     **** 						while( LCkey[i] && (LCkey[i] != chr) )
 2827              		.loc 1 603 0
 2828 0176 6346     		mov	r3, ip
 2829 0178 995C     		ldrb	r1, [r3, r2]
 2830 017a 0029     		cmp	r1, #0
 2831 017c 03D0     		beq	.L233
 603:display.c     **** 						while( LCkey[i] && (LCkey[i] != chr) )
 2832              		.loc 1 603 0 is_stmt 0 discriminator 2
 2833 017e 8842     		cmp	r0, r1
 2834 0180 F6D1     		bne	.L221
 2835 0182 069B     		ldr	r3, [sp, #24]
 2836 0184 09E2     		b	.L155
 2837              	.L233:
 2838 0186 069B     		ldr	r3, [sp, #24]
 2839              	.LVL388:
 2840              	.L153:
 606:display.c     **** 						}
 607:display.c     **** 						if( LCkey[i] )
 608:display.c     **** 						{
 609:display.c     **** 							switch( editing )
 610:display.c     **** 							{
 611:display.c     **** 							case EDIT_UPPER:
 612:display.c     **** 								pt = (unsigned char *)&UCkey[0];
 613:display.c     **** 								loc = i;
 614:display.c     **** 								break;
 615:display.c     **** 
 616:display.c     **** 							case EDIT_LOWER:
 617:display.c     **** 								pt = (unsigned char *)&LCkey[0];
 618:display.c     **** 								loc = i;
 619:display.c     **** 								break;
 620:display.c     **** 
 621:display.c     **** 							case EDIT_NUMERIC:
 622:display.c     **** 								pt = (unsigned char *)&NCkey[0];
 623:display.c     **** 								loc = 0;
 624:display.c     **** 								break;
 625:display.c     **** 							}
 626:display.c     **** 						}
 627:display.c     **** 						else // no match
 628:display.c     **** 						{
 629:display.c     **** 							i = 0;
 630:display.c     **** 							// find match in numeric data
 631:display.c     **** 							while( NCkey[i] && (NCkey[i] != chr) )
 2841              		.loc 1 631 0 is_stmt 1 discriminator 1
 2842 0188 704A     		ldr	r2, .L241+44
 2843 018a 1178     		ldrb	r1, [r2]
 2844 018c 0029     		cmp	r1, #0
 2845 018e 00D1     		bne	.LCB3100
 2846 0190 17E2     		b	.L159	@long jump
 2847              	.LCB3100:
 2848              		.loc 1 631 0 is_stmt 0
 2849 0192 0022     		mov	r2, #0
 2850 0194 8842     		cmp	r0, r1
 2851 0196 0AD1     		bne	.L160
 2852 0198 08E2     		b	.L161
 2853              	.LVL389:
 2854              	.L162:
 613:display.c     **** 								loc = i;
 2855              		.loc 1 613 0 is_stmt 1
 2856 019a 1206     		lsl	r2, r2, #24
 2857 019c 120E     		lsr	r2, r2, #24
 2858 019e 9146     		mov	r9, r2
 2859              	.LVL390:
 612:display.c     **** 								pt = (unsigned char *)&UCkey[0];
 2860              		.loc 1 612 0
 2861 01a0 684E     		ldr	r6, .L241+36
 614:display.c     **** 								break;
 2862              		.loc 1 614 0
 2863 01a2 1AE0     		b	.L157
 2864              	.LVL391:
 2865              	.L163:
 618:display.c     **** 								loc = i;
 2866              		.loc 1 618 0
 2867 01a4 1206     		lsl	r2, r2, #24
 2868 01a6 120E     		lsr	r2, r2, #24
 2869 01a8 9146     		mov	r9, r2
 2870              	.LVL392:
 617:display.c     **** 								pt = (unsigned char *)&LCkey[0];
 2871              		.loc 1 617 0
 2872 01aa 674E     		ldr	r6, .L241+40
 619:display.c     **** 								break;
 2873              		.loc 1 619 0
 2874 01ac 15E0     		b	.L157
 2875              	.LVL393:
 2876              	.L160:
 2877              		.loc 1 631 0
 2878 01ae 6749     		ldr	r1, .L241+44
 2879 01b0 8C46     		mov	ip, r1
 2880 01b2 0693     		str	r3, [sp, #24]
 2881              	.LVL394:
 2882              	.L220:
 632:display.c     **** 							{
 633:display.c     **** 								i++;
 2883              		.loc 1 633 0
 2884 01b4 0132     		add	r2, r2, #1
 2885 01b6 1204     		lsl	r2, r2, #16
 2886 01b8 120C     		lsr	r2, r2, #16
 2887              	.LVL395:
 631:display.c     **** 							while( NCkey[i] && (NCkey[i] != chr) )
 2888              		.loc 1 631 0
 2889 01ba 6346     		mov	r3, ip
 2890 01bc 995C     		ldrb	r1, [r3, r2]
 2891 01be 0029     		cmp	r1, #0
 2892 01c0 00D1     		bne	.LCB3147
 2893 01c2 FDE1     		b	.L234	@long jump
 2894              	.LCB3147:
 631:display.c     **** 							while( NCkey[i] && (NCkey[i] != chr) )
 2895              		.loc 1 631 0 is_stmt 0 discriminator 2
 2896 01c4 8842     		cmp	r0, r1
 2897 01c6 F5D1     		bne	.L220
 2898 01c8 069B     		ldr	r3, [sp, #24]
 2899 01ca EFE1     		b	.L161
 2900              	.LVL396:
 2901              	.L164:
 634:display.c     **** 							}
 635:display.c     **** 							if( NCkey[i] )
 636:display.c     **** 							{
 637:display.c     **** 								switch( editing )
 638:display.c     **** 								{
 639:display.c     **** 								case EDIT_UPPER:
 640:display.c     **** 									pt = (unsigned char *)&UCkey[0];
 641:display.c     **** 									loc = 0;
 642:display.c     **** 									break;
 643:display.c     **** 
 644:display.c     **** 								case EDIT_LOWER:
 645:display.c     **** 									pt = (unsigned char *)&LCkey[0];
 646:display.c     **** 									loc = 0;
 647:display.c     **** 									break;
 648:display.c     **** 
 649:display.c     **** 								case EDIT_NUMERIC:
 650:display.c     **** 									pt = (unsigned char *)&NCkey[0];
 651:display.c     **** 									loc = i;
 2902              		.loc 1 651 0 is_stmt 1
 2903 01cc 1206     		lsl	r2, r2, #24
 2904 01ce 120E     		lsr	r2, r2, #24
 2905 01d0 9146     		mov	r9, r2
 2906              	.LVL397:
 650:display.c     **** 									pt = (unsigned char *)&NCkey[0];
 2907              		.loc 1 650 0
 2908 01d2 5E4E     		ldr	r6, .L241+44
 652:display.c     **** 									break;
 2909              		.loc 1 652 0
 2910 01d4 01E0     		b	.L157
 2911              	.LVL398:
 2912              	.L165:
 653:display.c     **** 								}
 654:display.c     **** 							}
 655:display.c     **** 							else // no match
 656:display.c     **** 							{
 657:display.c     **** 								switch( editing )
 658:display.c     **** 								{
 659:display.c     **** 								case EDIT_UPPER:
 660:display.c     **** 									pt = (unsigned char *)&UCkey[0];
 661:display.c     **** 									loc = 0;
 662:display.c     **** 									break;
 663:display.c     **** 
 664:display.c     **** 								case EDIT_LOWER:
 665:display.c     **** 									pt = (unsigned char *)&LCkey[0];
 666:display.c     **** 									loc = 0;
 667:display.c     **** 									break;
 668:display.c     **** 
 669:display.c     **** 								case EDIT_NUMERIC:
 670:display.c     **** 									pt = (unsigned char *)&NCkey[0];
 2913              		.loc 1 670 0
 2914 01d6 5D4E     		ldr	r6, .L241+44
 671:display.c     **** 									loc = 0;
 672:display.c     **** 									break;
 2915              		.loc 1 672 0
 2916 01d8 04E2     		b	.L166
 2917              	.LVL399:
 2918              	.L157:
 673:display.c     **** 								}
 674:display.c     **** 							}
 675:display.c     **** 						}
 676:display.c     **** 					}
 677:display.c     **** 
 678:display.c     **** 					if( key == SW_CU )
 2919              		.loc 1 678 0
 2920 01da 5046     		mov	r0, sl
 2921 01dc 0028     		cmp	r0, #0
 2922 01de 12D0     		beq	.L167
 2923 01e0 01E0     		b	.L197
 2924              	.LVL400:
 2925              	.L215:
 2926 01e2 0021     		mov	r1, #0
 2927 01e4 8946     		mov	r9, r1
 2928              	.LVL401:
 2929              	.L197:
 679:display.c     **** 					{
 680:display.c     **** 						// set next character or first
 681:display.c     **** 						loc++;
 2930              		.loc 1 681 0
 2931 01e6 4B46     		mov	r3, r9
 2932 01e8 0133     		add	r3, r3, #1
 682:display.c     **** 						if( *(pt + loc) )
 2933              		.loc 1 682 0
 2934 01ea 1B06     		lsl	r3, r3, #24
 2935 01ec 1B0E     		lsr	r3, r3, #24
 2936 01ee F35C     		ldrb	r3, [r6, r3]
 2937 01f0 002B     		cmp	r3, #0
 2938 01f2 03D0     		beq	.L168
 683:display.c     **** 						{
 684:display.c     **** 							dstring[pos] = *(pt + loc);
 2939              		.loc 1 684 0
 2940 01f4 4E4A     		ldr	r2, .L241+16
 2941              	.LVL402:
 2942 01f6 5846     		mov	r0, fp
 2943 01f8 1354     		strb	r3, [r2, r0]
 2944 01fa 55E0     		b	.L140
 2945              	.LVL403:
 2946              	.L168:
 685:display.c     **** 						}
 686:display.c     **** 						else
 687:display.c     **** 						{
 688:display.c     **** 							dstring[pos] = *pt;
 2947              		.loc 1 688 0
 2948 01fc 3278     		ldrb	r2, [r6]
 2949 01fe 4C4B     		ldr	r3, .L241+16
 2950              	.LVL404:
 2951 0200 5946     		mov	r1, fp
 2952 0202 5A54     		strb	r2, [r3, r1]
 2953 0204 50E0     		b	.L140
 2954              	.LVL405:
 2955              	.L167:
 689:display.c     **** 						}
 690:display.c     **** 
 691:display.c     **** 					}
 692:display.c     **** 					else // key == SW_CD
 693:display.c     **** 					{
 694:display.c     **** 						// set previous character or last
 695:display.c     **** 						if( loc )
 2956              		.loc 1 695 0
 2957 0206 4A46     		mov	r2, r9
 2958 0208 002A     		cmp	r2, #0
 2959 020a 03D1     		bne	.L169
 2960              	.LVL406:
 2961              	.L198:
 696:display.c     **** 						{
 697:display.c     **** 							loc--;
 698:display.c     **** 							dstring[pos] = *(pt + loc);
 699:display.c     **** 						}
 700:display.c     **** 						else
 701:display.c     **** 						{
 702:display.c     **** 							while( *pt )
 2962              		.loc 1 702 0 discriminator 1
 2963 020c 3378     		ldrb	r3, [r6]
 2964 020e 002B     		cmp	r3, #0
 2965 0210 09D1     		bne	.L219
 2966 0212 0CE0     		b	.L171
 2967              	.LVL407:
 2968              	.L169:
 697:display.c     **** 							loc--;
 2969              		.loc 1 697 0
 2970 0214 4B46     		mov	r3, r9
 2971 0216 013B     		sub	r3, r3, #1
 698:display.c     **** 							dstring[pos] = *(pt + loc);
 2972              		.loc 1 698 0
 2973 0218 1B06     		lsl	r3, r3, #24
 2974 021a 1B0E     		lsr	r3, r3, #24
 2975 021c F25C     		ldrb	r2, [r6, r3]
 2976              	.LVL408:
 2977 021e 444B     		ldr	r3, .L241+16
 2978              	.LVL409:
 2979 0220 5846     		mov	r0, fp
 2980 0222 1A54     		strb	r2, [r3, r0]
 2981 0224 40E0     		b	.L140
 2982              	.LVL410:
 2983              	.L219:
 703:display.c     **** 							{
 704:display.c     **** 								pt++;
 2984              		.loc 1 704 0
 2985 0226 0136     		add	r6, r6, #1
 2986              	.LVL411:
 702:display.c     **** 							while( *pt )
 2987              		.loc 1 702 0
 2988 0228 3378     		ldrb	r3, [r6]
 2989 022a 002B     		cmp	r3, #0
 2990 022c FBD1     		bne	.L219
 2991              	.L171:
 2992              	.LVL412:
 705:display.c     **** 							}
 706:display.c     **** 							pt--;
 707:display.c     **** 							dstring[pos] = *pt;
 2993              		.loc 1 707 0
 2994 022e 013E     		sub	r6, r6, #1
 2995              	.LVL413:
 2996 0230 3278     		ldrb	r2, [r6]
 2997 0232 3F4B     		ldr	r3, .L241+16
 2998              	.LVL414:
 2999 0234 5946     		mov	r1, fp
 3000 0236 5A54     		strb	r2, [r3, r1]
 3001 0238 36E0     		b	.L140
 3002              	.LVL415:
 3003              	.L137:
 708:display.c     **** 						}
 709:display.c     **** 					}
 710:display.c     **** 
 711:display.c     **** 				}
 712:display.c     **** 			}
 713:display.c     **** 		}
 714:display.c     **** 		else if( (prog & EDSCAPE) || (key == (SW_NEW | SW_CR)) )
 3004              		.loc 1 714 0
 3005 023a 049A     		ldr	r2, [sp, #16]
 3006 023c 5206     		lsl	r2, r2, #25
 3007 023e 04D4     		bmi	.L172
 3008              		.loc 1 714 0 is_stmt 0 discriminator 1
 3009 0240 3A4B     		ldr	r3, .L241+12
 3010 0242 1A68     		ldr	r2, [r3]
 3011 0244 424B     		ldr	r3, .L241+48
 3012 0246 9A42     		cmp	r2, r3
 3013 0248 2ED1     		bne	.L140
 3014              	.L172:
 715:display.c     **** 		{
 716:display.c     **** 			editing = EDIT_UPPER;
 3015              		.loc 1 716 0 is_stmt 1
 3016 024a 0122     		mov	r2, #1
 3017 024c 364B     		ldr	r3, .L241+8
 3018 024e 1A70     		strb	r2, [r3]
 717:display.c     **** 			pos = 0;
 3019              		.loc 1 717 0
 3020 0250 0023     		mov	r3, #0
 3021 0252 9946     		mov	r9, r3
 3022 0254 3A4B     		ldr	r3, .L241+32
 3023 0256 4846     		mov	r0, r9
 3024 0258 1870     		strb	r0, [r3]
 718:display.c     **** 			looptime = 0;
 3025              		.loc 1 718 0
 3026 025a 3E4B     		ldr	r3, .L241+52
 3027 025c 1870     		strb	r0, [r3]
 719:display.c     **** 			strcpy( dstring, data );
 3028              		.loc 1 719 0
 3029 025e 344E     		ldr	r6, .L241+16
 3030 0260 301C     		mov	r0, r6
 3031 0262 391C     		mov	r1, r7
 3032              	.LVL416:
 3033 0264 FFF7FEFF 		bl	strcpy
 3034              	.LVL417:
 720:display.c     **** 			i = max;
 721:display.c     **** 			dstring[i--] = 0x00;
 3035              		.loc 1 721 0
 3036 0268 4946     		mov	r1, r9
 3037 026a 7155     		strb	r1, [r6, r5]
 3038 026c 6B1E     		sub	r3, r5, #1
 3039 026e 1B04     		lsl	r3, r3, #16
 3040 0270 1B0C     		lsr	r3, r3, #16
 3041              	.LVL418:
 722:display.c     **** 			while( (dstring[i] == 0x00) && i )
 3042              		.loc 1 722 0
 3043 0272 1A1C     		mov	r2, r3
 3044 0274 F15C     		ldrb	r1, [r6, r3]
 3045 0276 0029     		cmp	r1, #0
 3046 0278 16D1     		bne	.L140
 3047 027a 002B     		cmp	r3, #0
 3048 027c 14D0     		beq	.L140
 723:display.c     **** 			{
 724:display.c     **** 				dstring[i--] = ' ';
 3049              		.loc 1 724 0
 3050 027e 2C49     		ldr	r1, .L241+16
 3051 0280 2026     		mov	r6, #32
 3052              	.LVL419:
 3053              	.L222:
 3054 0282 8E54     		strb	r6, [r1, r2]
 3055 0284 013B     		sub	r3, r3, #1
 3056 0286 1B04     		lsl	r3, r3, #16
 3057 0288 1B0C     		lsr	r3, r3, #16
 3058              	.LVL420:
 722:display.c     **** 			while( (dstring[i] == 0x00) && i )
 3059              		.loc 1 722 0
 3060 028a 1A1C     		mov	r2, r3
 3061 028c C85C     		ldrb	r0, [r1, r3]
 3062 028e 0028     		cmp	r0, #0
 3063 0290 0AD1     		bne	.L140
 722:display.c     **** 			while( (dstring[i] == 0x00) && i )
 3064              		.loc 1 722 0 is_stmt 0 discriminator 2
 3065 0292 002B     		cmp	r3, #0
 3066 0294 F5D1     		bne	.L222
 3067 0296 07E0     		b	.L140
 3068              	.LVL421:
 3069              	.L136:
 725:display.c     **** 			}
 726:display.c     **** 		}
 727:display.c     **** 	}
 728:display.c     **** 
 729:display.c     **** 	wid = 0;
 730:display.c     **** 	if( (prog & EDIT) && editing )
 731:display.c     **** 	{
 732:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 733:display.c     **** 		{
 734:display.c     **** 			wid += (font->f1[chr][0] + font->spc);
 735:display.c     **** 		}
 736:display.c     **** 	}
 737:display.c     **** 	else
 738:display.c     **** 	{
 739:display.c     **** 		for( i=0; (chr = *(data+i)) && (i < max); i++ )
 3070              		.loc 1 739 0 is_stmt 1 discriminator 1
 3071 0298 3A78     		ldrb	r2, [r7]
 3072              	.LVL422:
 3073 029a 002A     		cmp	r2, #0
 3074 029c 39D0     		beq	.L203
 3075              		.loc 1 739 0 is_stmt 0
 3076 029e 2E1C     		mov	r6, r5
 3077 02a0 0021     		mov	r1, #0
 3078 02a2 002D     		cmp	r5, #0
 3079 02a4 59D0     		beq	.L174
 3080 02a6 20E0     		b	.L175
 3081              	.LVL423:
 3082              	.L140:
 730:display.c     **** 	if( (prog & EDIT) && editing )
 3083              		.loc 1 730 0 is_stmt 1 discriminator 1
 3084 02a8 1F4B     		ldr	r3, .L241+8
 3085 02aa 1B78     		ldrb	r3, [r3]
 3086 02ac 002B     		cmp	r3, #0
 3087 02ae F3D0     		beq	.L136
 3088              	.LVL424:
 732:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3089              		.loc 1 732 0 discriminator 1
 3090 02b0 1F4B     		ldr	r3, .L241+16
 3091 02b2 1A78     		ldrb	r2, [r3]
 3092              	.LVL425:
 3093 02b4 002A     		cmp	r2, #0
 3094 02b6 2ED0     		beq	.L204
 732:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3095              		.loc 1 732 0 is_stmt 0
 3096 02b8 AC46     		mov	ip, r5
 3097 02ba 002D     		cmp	r5, #0
 3098 02bc 2DD0     		beq	.L205
 734:display.c     **** 			wid += (font->f1[chr][0] + font->spc);
 3099              		.loc 1 734 0 is_stmt 1
 3100 02be 2678     		ldrb	r6, [r4]
 3101 02c0 0021     		mov	r1, #0
 3102 02c2 0023     		mov	r3, #0
 3103              	.LVL426:
 732:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3104              		.loc 1 732 0
 3105 02c4 1A48     		ldr	r0, .L241+16
 3106              	.LVL427:
 3107              	.L176:
 734:display.c     **** 			wid += (font->f1[chr][0] + font->spc);
 3108              		.loc 1 734 0 discriminator 1
 3109 02c6 9200     		lsl	r2, r2, #2
 3110 02c8 A218     		add	r2, r4, r2
 3111 02ca 5268     		ldr	r2, [r2, #4]
 3112 02cc 1278     		ldrb	r2, [r2]
 3113 02ce B218     		add	r2, r6, r2
 3114 02d0 8918     		add	r1, r1, r2
 3115 02d2 0906     		lsl	r1, r1, #24
 3116 02d4 090E     		lsr	r1, r1, #24
 3117              	.LVL428:
 732:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3118              		.loc 1 732 0 discriminator 1
 3119 02d6 0133     		add	r3, r3, #1
 3120 02d8 1B04     		lsl	r3, r3, #16
 3121 02da 1B0C     		lsr	r3, r3, #16
 3122              	.LVL429:
 3123 02dc C25C     		ldrb	r2, [r0, r3]
 3124              	.LVL430:
 3125 02de 002A     		cmp	r2, #0
 3126 02e0 3AD0     		beq	.L237
 732:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3127              		.loc 1 732 0 is_stmt 0 discriminator 2
 3128 02e2 AB42     		cmp	r3, r5
 3129 02e4 EFD3     		bcc	.L176
 3130 02e6 6546     		mov	r5, ip
 3131 02e8 37E0     		b	.L174
 3132              	.LVL431:
 3133              	.L175:
 740:display.c     **** 		{
 741:display.c     **** 			wid += (font->f1[chr][0] + font->spc);
 3134              		.loc 1 741 0 is_stmt 1
 3135 02ea 2078     		ldrb	r0, [r4]
 3136 02ec 0021     		mov	r1, #0
 3137 02ee 0023     		mov	r3, #0
 3138              	.LVL432:
 3139              	.L177:
 3140              		.loc 1 741 0 is_stmt 0 discriminator 1
 3141 02f0 9200     		lsl	r2, r2, #2
 3142 02f2 A218     		add	r2, r4, r2
 3143 02f4 5268     		ldr	r2, [r2, #4]
 3144 02f6 1278     		ldrb	r2, [r2]
 3145 02f8 8218     		add	r2, r0, r2
 3146 02fa 8918     		add	r1, r1, r2
 3147 02fc 0906     		lsl	r1, r1, #24
 3148 02fe 090E     		lsr	r1, r1, #24
 3149              	.LVL433:
 739:display.c     **** 		for( i=0; (chr = *(data+i)) && (i < max); i++ )
 3150              		.loc 1 739 0 is_stmt 1 discriminator 1
 3151 0300 0133     		add	r3, r3, #1
 3152 0302 1B04     		lsl	r3, r3, #16
 3153 0304 1B0C     		lsr	r3, r3, #16
 3154              	.LVL434:
 3155 0306 FA5C     		ldrb	r2, [r7, r3]
 3156              	.LVL435:
 3157 0308 002A     		cmp	r2, #0
 3158 030a 26D0     		beq	.L174
 739:display.c     **** 		for( i=0; (chr = *(data+i)) && (i < max); i++ )
 3159              		.loc 1 739 0 is_stmt 0 discriminator 2
 3160 030c B342     		cmp	r3, r6
 3161 030e EFD3     		bcc	.L177
 3162 0310 23E0     		b	.L174
 3163              	.LVL436:
 3164              	.L203:
 739:display.c     **** 		for( i=0; (chr = *(data+i)) && (i < max); i++ )
 3165              		.loc 1 739 0
 3166 0312 0021     		mov	r1, #0
 3167 0314 21E0     		b	.L174
 3168              	.LVL437:
 3169              	.L204:
 732:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3170              		.loc 1 732 0 is_stmt 1
 3171 0316 0021     		mov	r1, #0
 3172 0318 1FE0     		b	.L174
 3173              	.L205:
 3174 031a 0021     		mov	r1, #0
 3175 031c 1DE0     		b	.L174
 3176              	.L242:
 3177 031e C046     		.align	2
 3178              	.L241:
 3179 0320 00000000 		.word	pFac
 3180 0324 00000000 		.word	fnt1
 3181 0328 00000000 		.word	editing
 3182 032c 00000000 		.word	key
 3183 0330 00000000 		.word	.LANCHOR0
 3184 0334 20010000 		.word	pFac+288
 3185 0338 00000000 		.word	savecal
 3186 033c 00000000 		.word	escape
 3187 0340 00000000 		.word	.LANCHOR1
 3188 0344 00000000 		.word	UCkey
 3189 0348 00000000 		.word	LCkey
 3190 034c 00000000 		.word	NCkey
 3191 0350 80000080 		.word	-2147483520
 3192 0354 00000000 		.word	looptime
 3193              	.LVL438:
 3194              	.L237:
 3195 0358 6546     		mov	r5, ip
 3196              	.LVL439:
 3197              	.L174:
 742:display.c     **** 		}
 743:display.c     **** 	}
 744:display.c     **** 	wid = wid - font->spc - 1;
 3198              		.loc 1 744 0
 3199 035a 2378     		ldrb	r3, [r4]
 3200 035c DB43     		mvn	r3, r3
 3201 035e C918     		add	r1, r1, r3
 3202              	.LVL440:
 3203 0360 0906     		lsl	r1, r1, #24
 3204 0362 090E     		lsr	r1, r1, #24
 3205              	.LVL441:
 745:display.c     **** 
 746:display.c     **** 	if( prog & CENTER )
 3206              		.loc 1 746 0
 3207 0364 049A     		ldr	r2, [sp, #16]
 3208 0366 9207     		lsl	r2, r2, #30
 3209 0368 05D5     		bpl	.L178
 747:display.c     **** 	{
 748:display.c     **** 		co = co - (wid / 2);
 3210              		.loc 1 748 0
 3211 036a 4B08     		lsr	r3, r1, #1
 3212 036c 0398     		ldr	r0, [sp, #12]
 3213 036e C31A     		sub	r3, r0, r3
 3214 0370 1B06     		lsl	r3, r3, #24
 3215 0372 1B0E     		lsr	r3, r3, #24
 3216 0374 0393     		str	r3, [sp, #12]
 3217              	.LVL442:
 3218              	.L178:
 749:display.c     **** 	}
 750:display.c     **** 	wid += co;
 3219              		.loc 1 750 0
 3220 0376 039A     		ldr	r2, [sp, #12]
 3221 0378 5118     		add	r1, r2, r1
 3222              	.LVL443:
 3223 037a 0906     		lsl	r1, r1, #24
 3224 037c 090E     		lsr	r1, r1, #24
 3225 037e 0691     		str	r1, [sp, #24]
 3226              	.LVL444:
 751:display.c     **** 
 752:display.c     **** 	if( (prog & EDIT) && editing )
 3227              		.loc 1 752 0
 3228 0380 059B     		ldr	r3, [sp, #20]
 3229 0382 002B     		cmp	r3, #0
 3230 0384 1AD0     		beq	.L179
 3231              		.loc 1 752 0 is_stmt 0 discriminator 1
 3232 0386 A44B     		ldr	r3, .L243
 3233 0388 1B78     		ldrb	r3, [r3]
 3234 038a 002B     		cmp	r3, #0
 3235 038c 16D0     		beq	.L179
 753:display.c     **** 	{
 754:display.c     **** 		draw_box( adm, co-1, ro-1, wid+1, ro+8, CLEAR );
 3236              		.loc 1 754 0 is_stmt 1
 3237 038e 111C     		mov	r1, r2
 3238 0390 0139     		sub	r1, r1, #1
 3239 0392 0906     		lsl	r1, r1, #24
 3240 0394 090E     		lsr	r1, r1, #24
 3241 0396 4246     		mov	r2, r8
 3242 0398 013A     		sub	r2, r2, #1
 3243 039a 1206     		lsl	r2, r2, #24
 3244 039c 120E     		lsr	r2, r2, #24
 3245 039e 069B     		ldr	r3, [sp, #24]
 3246 03a0 0133     		add	r3, r3, #1
 3247 03a2 1B06     		lsl	r3, r3, #24
 3248 03a4 1B0E     		lsr	r3, r3, #24
 3249 03a6 4046     		mov	r0, r8
 3250 03a8 0830     		add	r0, r0, #8
 3251 03aa 0006     		lsl	r0, r0, #24
 3252 03ac 000E     		lsr	r0, r0, #24
 3253 03ae 0090     		str	r0, [sp]
 3254 03b0 4020     		mov	r0, #64
 3255 03b2 0190     		str	r0, [sp, #4]
 3256 03b4 9948     		ldr	r0, .L243+4
 3257 03b6 FFF7FEFF 		bl	draw_box
 3258              	.LVL445:
 3259 03ba 15E0     		b	.L180
 3260              	.L179:
 755:display.c     **** 	}
 756:display.c     **** 	else
 757:display.c     **** 	{
 758:display.c     **** 		draw_box( adm, co-1, ro-1, wid+1, ro+7, CLEAR );
 3261              		.loc 1 758 0
 3262 03bc 0399     		ldr	r1, [sp, #12]
 3263 03be 0139     		sub	r1, r1, #1
 3264 03c0 0906     		lsl	r1, r1, #24
 3265 03c2 090E     		lsr	r1, r1, #24
 3266 03c4 4246     		mov	r2, r8
 3267 03c6 013A     		sub	r2, r2, #1
 3268 03c8 1206     		lsl	r2, r2, #24
 3269 03ca 120E     		lsr	r2, r2, #24
 3270 03cc 069B     		ldr	r3, [sp, #24]
 3271 03ce 0133     		add	r3, r3, #1
 3272 03d0 1B06     		lsl	r3, r3, #24
 3273 03d2 1B0E     		lsr	r3, r3, #24
 3274 03d4 4046     		mov	r0, r8
 3275 03d6 0730     		add	r0, r0, #7
 3276 03d8 0006     		lsl	r0, r0, #24
 3277 03da 000E     		lsr	r0, r0, #24
 3278 03dc 0090     		str	r0, [sp]
 3279 03de 4020     		mov	r0, #64
 3280 03e0 0190     		str	r0, [sp, #4]
 3281 03e2 8E48     		ldr	r0, .L243+4
 3282 03e4 FFF7FEFF 		bl	draw_box
 3283              	.LVL446:
 3284              	.L180:
 759:display.c     **** 	}
 760:display.c     **** 
 761:display.c     **** 	if( prog & INV )
 3285              		.loc 1 761 0
 3286 03e8 0423     		mov	r3, #4
 3287 03ea 0498     		ldr	r0, [sp, #16]
 3288 03ec 1840     		and	r0, r3
 3289 03ee 0790     		str	r0, [sp, #28]
 3290 03f0 15D0     		beq	.L181
 762:display.c     **** 	{
 763:display.c     **** 		draw_box( adm, co-1, ro-1, wid+1, ro+8, EMPTY );
 3291              		.loc 1 763 0
 3292 03f2 0399     		ldr	r1, [sp, #12]
 3293 03f4 0139     		sub	r1, r1, #1
 3294 03f6 0906     		lsl	r1, r1, #24
 3295 03f8 090E     		lsr	r1, r1, #24
 3296 03fa 4246     		mov	r2, r8
 3297 03fc 013A     		sub	r2, r2, #1
 3298 03fe 1206     		lsl	r2, r2, #24
 3299 0400 120E     		lsr	r2, r2, #24
 3300 0402 069B     		ldr	r3, [sp, #24]
 3301 0404 0133     		add	r3, r3, #1
 3302 0406 1B06     		lsl	r3, r3, #24
 3303 0408 1B0E     		lsr	r3, r3, #24
 3304 040a 4046     		mov	r0, r8
 3305 040c 0830     		add	r0, r0, #8
 3306 040e 0006     		lsl	r0, r0, #24
 3307 0410 000E     		lsr	r0, r0, #24
 3308 0412 0090     		str	r0, [sp]
 3309 0414 1020     		mov	r0, #16
 3310 0416 0190     		str	r0, [sp, #4]
 3311 0418 8048     		ldr	r0, .L243+4
 3312 041a FFF7FEFF 		bl	draw_box
 3313              	.LVL447:
 3314              	.L181:
 764:display.c     **** 	}
 765:display.c     **** 
 766:display.c     **** 	coo = co;
 767:display.c     **** 
 768:display.c     **** 	if( (prog & EDIT) && editing )
 3315              		.loc 1 768 0
 3316 041e 0599     		ldr	r1, [sp, #20]
 3317 0420 0029     		cmp	r1, #0
 3318 0422 06D1     		bne	.L182
 3319              	.L185:
 3320              	.LVL448:
 769:display.c     **** 	{
 770:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 771:display.c     **** 		{
 772:display.c     **** 			lco = co;
 773:display.c     **** 			co += (write_bitmap( adm, font->f1[chr], co, ro, OR ) + font->spc);
 774:display.c     **** 			if( (i == pos) && !half_second )
 775:display.c     **** 			{
 776:display.c     **** 				draw_box( adm, lco-1, ro-1, co-1, ro+8, INV );
 777:display.c     **** 			}
 778:display.c     **** 		}
 779:display.c     **** 	}
 780:display.c     **** 	else
 781:display.c     **** 	{
 782:display.c     **** 		for( i=0; (chr = *(data+i)) && (i < max); i++ )
 3321              		.loc 1 782 0 discriminator 1
 3322 0424 3B78     		ldrb	r3, [r7]
 3323              	.LVL449:
 3324 0426 002B     		cmp	r3, #0
 3325 0428 70D0     		beq	.L206
 3326              		.loc 1 782 0 is_stmt 0
 3327 042a 002D     		cmp	r5, #0
 3328 042c 4CD1     		bne	.L184
 3329 042e 039D     		ldr	r5, [sp, #12]
 3330 0430 6DE0     		b	.L183
 3331              	.LVL450:
 3332              	.L182:
 768:display.c     **** 	if( (prog & EDIT) && editing )
 3333              		.loc 1 768 0 is_stmt 1 discriminator 1
 3334 0432 794B     		ldr	r3, .L243
 3335 0434 1B78     		ldrb	r3, [r3]
 3336 0436 002B     		cmp	r3, #0
 3337 0438 F4D0     		beq	.L185
 3338              	.LVL451:
 770:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3339              		.loc 1 770 0 discriminator 1
 3340 043a 794B     		ldr	r3, .L243+8
 3341 043c 1B78     		ldrb	r3, [r3]
 3342              	.LVL452:
 3343 043e 002B     		cmp	r3, #0
 3344 0440 00D1     		bne	.LCB3662
 3345 0442 D4E0     		b	.L207	@long jump
 3346              	.LCB3662:
 770:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3347              		.loc 1 770 0 is_stmt 0
 3348 0444 AB46     		mov	fp, r5
 3349 0446 002D     		cmp	r5, #0
 3350 0448 00D1     		bne	.LCB3665
 3351 044a D2E0     		b	.L208	@long jump
 3352              	.LCB3665:
 3353 044c 039F     		ldr	r7, [sp, #12]
 3354              	.LVL453:
 3355 044e 0026     		mov	r6, #0
 776:display.c     **** 				draw_box( adm, lco-1, ro-1, co-1, ro+8, INV );
 3356              		.loc 1 776 0 is_stmt 1
 3357 0450 4246     		mov	r2, r8
 3358 0452 013A     		sub	r2, r2, #1
 3359 0454 1206     		lsl	r2, r2, #24
 3360 0456 120E     		lsr	r2, r2, #24
 3361 0458 9146     		mov	r9, r2
 3362 045a 191C     		mov	r1, r3
 3363              	.LVL454:
 3364              	.L188:
 773:display.c     **** 			co += (write_bitmap( adm, font->f1[chr], co, ro, OR ) + font->spc);
 3365              		.loc 1 773 0
 3366 045c 8900     		lsl	r1, r1, #2
 3367 045e 6118     		add	r1, r4, r1
 3368 0460 4968     		ldr	r1, [r1, #4]
 3369 0462 0223     		mov	r3, #2
 3370 0464 0093     		str	r3, [sp]
 3371 0466 6D48     		ldr	r0, .L243+4
 3372 0468 3A1C     		mov	r2, r7
 3373 046a 4346     		mov	r3, r8
 3374 046c FFF7FEFF 		bl	write_bitmap
 3375              	.LVL455:
 3376 0470 C519     		add	r5, r0, r7
 3377 0472 2D06     		lsl	r5, r5, #24
 3378 0474 2D0E     		lsr	r5, r5, #24
 3379 0476 2378     		ldrb	r3, [r4]
 3380 0478 ED18     		add	r5, r5, r3
 3381 047a 2D06     		lsl	r5, r5, #24
 3382 047c 2D0E     		lsr	r5, r5, #24
 3383              	.LVL456:
 774:display.c     **** 			if( (i == pos) && !half_second )
 3384              		.loc 1 774 0
 3385 047e 694B     		ldr	r3, .L243+12
 3386 0480 1B78     		ldrb	r3, [r3]
 3387 0482 B342     		cmp	r3, r6
 3388 0484 14D1     		bne	.L187
 774:display.c     **** 			if( (i == pos) && !half_second )
 3389              		.loc 1 774 0 is_stmt 0 discriminator 1
 3390 0486 684B     		ldr	r3, .L243+16
 3391 0488 1B78     		ldrb	r3, [r3]
 3392 048a 002B     		cmp	r3, #0
 3393 048c 10D1     		bne	.L187
 776:display.c     **** 				draw_box( adm, lco-1, ro-1, co-1, ro+8, INV );
 3394              		.loc 1 776 0 is_stmt 1
 3395 048e 791E     		sub	r1, r7, #1
 3396 0490 0906     		lsl	r1, r1, #24
 3397 0492 090E     		lsr	r1, r1, #24
 3398 0494 6B1E     		sub	r3, r5, #1
 3399 0496 1B06     		lsl	r3, r3, #24
 3400 0498 1B0E     		lsr	r3, r3, #24
 3401 049a 4246     		mov	r2, r8
 3402 049c 0832     		add	r2, r2, #8
 3403 049e 1206     		lsl	r2, r2, #24
 3404 04a0 120E     		lsr	r2, r2, #24
 3405 04a2 0092     		str	r2, [sp]
 3406 04a4 0422     		mov	r2, #4
 3407 04a6 0192     		str	r2, [sp, #4]
 3408 04a8 5C48     		ldr	r0, .L243+4
 3409 04aa 4A46     		mov	r2, r9
 3410 04ac FFF7FEFF 		bl	draw_box
 3411              	.LVL457:
 3412              	.L187:
 770:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3413              		.loc 1 770 0
 3414 04b0 0136     		add	r6, r6, #1
 3415 04b2 3604     		lsl	r6, r6, #16
 3416 04b4 360C     		lsr	r6, r6, #16
 3417              	.LVL458:
 3418 04b6 5A4B     		ldr	r3, .L243+8
 3419 04b8 995D     		ldrb	r1, [r3, r6]
 3420              	.LVL459:
 3421 04ba 0029     		cmp	r1, #0
 3422 04bc 00D1     		bne	.LCB3737
 3423 04be 99E0     		b	.L186	@long jump
 3424              	.LCB3737:
 773:display.c     **** 			co += (write_bitmap( adm, font->f1[chr], co, ro, OR ) + font->spc);
 3425              		.loc 1 773 0 discriminator 2
 3426 04c0 2F1C     		mov	r7, r5
 3427              	.LVL460:
 770:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3428              		.loc 1 770 0 discriminator 2
 3429 04c2 5E45     		cmp	r6, fp
 3430 04c4 CAD3     		bcc	.L188
 3431 04c6 95E0     		b	.L186
 3432              	.LVL461:
 3433              	.L184:
 497:display.c     **** unsigned char display_f1_text( const unsigned char *data, unsigned char max,
 3434              		.loc 1 497 0
 3435 04c8 0135     		add	r5, r5, #1
 3436 04ca AB46     		mov	fp, r5
 3437 04cc 039D     		ldr	r5, [sp, #12]
 3438 04ce 0126     		mov	r6, #1
 783:display.c     **** 		{
 784:display.c     **** 			co += (write_bitmap( adm, font->f1[chr], co, ro, OR ) + font->spc);
 3439              		.loc 1 784 0
 3440 04d0 524A     		ldr	r2, .L243+4
 3441 04d2 9246     		mov	sl, r2
 3442 04d4 0220     		mov	r0, #2
 3443 04d6 8146     		mov	r9, r0
 3444              	.LVL462:
 3445              	.L189:
 3446              		.loc 1 784 0 is_stmt 0 discriminator 1
 3447 04d8 9B00     		lsl	r3, r3, #2
 3448 04da E318     		add	r3, r4, r3
 3449 04dc 5968     		ldr	r1, [r3, #4]
 3450 04de 4A46     		mov	r2, r9
 3451 04e0 0092     		str	r2, [sp]
 3452 04e2 5046     		mov	r0, sl
 3453 04e4 2A1C     		mov	r2, r5
 3454 04e6 4346     		mov	r3, r8
 3455 04e8 FFF7FEFF 		bl	write_bitmap
 3456              	.LVL463:
 3457 04ec 4519     		add	r5, r0, r5
 3458 04ee 2D06     		lsl	r5, r5, #24
 3459 04f0 2D0E     		lsr	r5, r5, #24
 3460 04f2 2378     		ldrb	r3, [r4]
 3461 04f4 ED18     		add	r5, r5, r3
 3462 04f6 2D06     		lsl	r5, r5, #24
 3463 04f8 2D0E     		lsr	r5, r5, #24
 3464              	.LVL464:
 782:display.c     **** 		for( i=0; (chr = *(data+i)) && (i < max); i++ )
 3465              		.loc 1 782 0 is_stmt 1 discriminator 1
 3466 04fa BB5D     		ldrb	r3, [r7, r6]
 3467              	.LVL465:
 3468 04fc 002B     		cmp	r3, #0
 3469 04fe 06D0     		beq	.L183
 3470 0500 0136     		add	r6, r6, #1
 3471              	.LVL466:
 3472 0502 3604     		lsl	r6, r6, #16
 3473              	.LVL467:
 3474 0504 360C     		lsr	r6, r6, #16
 782:display.c     **** 		for( i=0; (chr = *(data+i)) && (i < max); i++ )
 3475              		.loc 1 782 0 is_stmt 0 discriminator 2
 3476 0506 5E45     		cmp	r6, fp
 3477 0508 E6D1     		bne	.L189
 3478 050a 00E0     		b	.L183
 3479              	.LVL468:
 3480              	.L206:
 782:display.c     **** 		for( i=0; (chr = *(data+i)) && (i < max); i++ )
 3481              		.loc 1 782 0
 3482 050c 039D     		ldr	r5, [sp, #12]
 3483              	.LVL469:
 3484              	.L183:
 785:display.c     **** 		}
 786:display.c     **** 	}
 787:display.c     **** 
 788:display.c     **** 	if( prog & GREY )
 3485              		.loc 1 788 0 is_stmt 1
 3486 050e 0498     		ldr	r0, [sp, #16]
 3487 0510 0306     		lsl	r3, r0, #24
 3488 0512 12D5     		bpl	.L190
 789:display.c     **** 	{
 790:display.c     **** 		draw_box( adm, coo, ro, wid, ro+((prog & EDIT) ? 8 : 6), GREY );
 3489              		.loc 1 790 0
 3490 0514 0623     		mov	r3, #6
 3491 0516 0599     		ldr	r1, [sp, #20]
 3492 0518 0029     		cmp	r1, #0
 3493 051a 02D0     		beq	.L191
 3494 051c 0823     		mov	r3, #8
 3495 051e 00E0     		b	.L191
 3496              	.LVL470:
 3497              	.L216:
 3498 0520 0823     		mov	r3, #8
 3499              	.LVL471:
 3500              	.L191:
 3501              		.loc 1 790 0 is_stmt 0 discriminator 3
 3502 0522 4344     		add	r3, r3, r8
 3503 0524 1B06     		lsl	r3, r3, #24
 3504 0526 1B0E     		lsr	r3, r3, #24
 3505 0528 0093     		str	r3, [sp]
 3506 052a 8023     		mov	r3, #128
 3507 052c 0193     		str	r3, [sp, #4]
 3508 052e 3B48     		ldr	r0, .L243+4
 3509 0530 0399     		ldr	r1, [sp, #12]
 3510 0532 4246     		mov	r2, r8
 3511 0534 069B     		ldr	r3, [sp, #24]
 3512 0536 FFF7FEFF 		bl	draw_box
 3513              	.LVL472:
 3514              	.L190:
 791:display.c     **** 	}
 792:display.c     **** 
 793:display.c     **** 	if( prog & INV )
 3515              		.loc 1 793 0 is_stmt 1
 3516 053a 079A     		ldr	r2, [sp, #28]
 3517 053c 002A     		cmp	r2, #0
 3518 053e 10D0     		beq	.L192
 794:display.c     **** 	{
 795:display.c     **** 		draw_box( adm, coo, ro, wid, ro+((prog & EDIT) ? 8 : 6), INV );
 3519              		.loc 1 795 0
 3520 0540 0623     		mov	r3, #6
 3521 0542 0598     		ldr	r0, [sp, #20]
 3522 0544 0028     		cmp	r0, #0
 3523 0546 00D0     		beq	.L193
 3524              	.L199:
 3525 0548 0823     		mov	r3, #8
 3526              	.L193:
 3527              		.loc 1 795 0 is_stmt 0 discriminator 3
 3528 054a 4344     		add	r3, r3, r8
 3529 054c 1B06     		lsl	r3, r3, #24
 3530 054e 1B0E     		lsr	r3, r3, #24
 3531 0550 0093     		str	r3, [sp]
 3532 0552 0423     		mov	r3, #4
 3533 0554 0193     		str	r3, [sp, #4]
 3534 0556 3148     		ldr	r0, .L243+4
 3535 0558 0399     		ldr	r1, [sp, #12]
 3536 055a 4246     		mov	r2, r8
 3537 055c 069B     		ldr	r3, [sp, #24]
 3538 055e FFF7FEFF 		bl	draw_box
 3539              	.LVL473:
 3540              	.L192:
 796:display.c     **** 	}
 797:display.c     **** 
 798:display.c     **** 	if( prog & UNDERLINED )
 3541              		.loc 1 798 0 is_stmt 1
 3542 0562 0499     		ldr	r1, [sp, #16]
 3543 0564 0907     		lsl	r1, r1, #28
 3544 0566 4CD5     		bpl	.L218
 799:display.c     **** 	{
 800:display.c     **** 		draw_line( adm, coo, ro+8, co-1, ro+8, OR );
 3545              		.loc 1 800 0
 3546 0568 4246     		mov	r2, r8
 3547 056a 0832     		add	r2, r2, #8
 3548 056c 1206     		lsl	r2, r2, #24
 3549 056e 120E     		lsr	r2, r2, #24
 3550 0570 6B1E     		sub	r3, r5, #1
 3551 0572 1B06     		lsl	r3, r3, #24
 3552 0574 1B0E     		lsr	r3, r3, #24
 3553 0576 0092     		str	r2, [sp]
 3554 0578 0221     		mov	r1, #2
 3555 057a 0191     		str	r1, [sp, #4]
 3556 057c 2748     		ldr	r0, .L243+4
 3557 057e 0399     		ldr	r1, [sp, #12]
 3558 0580 FFF7FEFF 		bl	draw_line
 3559              	.LVL474:
 3560 0584 3DE0     		b	.L218
 3561              	.LVL475:
 3562              	.L200:
 572:display.c     **** 					i = 0;
 3563              		.loc 1 572 0
 3564 0586 0022     		mov	r2, #0
 3565              	.LVL476:
 3566              	.L151:
 581:display.c     **** 						switch( editing )
 3567              		.loc 1 581 0
 3568 0588 022B     		cmp	r3, #2
 3569 058a 00D1     		bne	.LCB3914
 3570 058c E8E5     		b	.L158	@long jump
 3571              	.LCB3914:
 3572 058e 032B     		cmp	r3, #3
 3573 0590 21D0     		beq	.L211
 3574 0592 012B     		cmp	r3, #1
 3575 0594 00D0     		beq	.LCB3918
 3576 0596 20E6     		b	.L157	@long jump
 3577              	.LCB3918:
 3578 0598 DDE5     		b	.L156
 3579              	.L155:
 609:display.c     **** 							switch( editing )
 3580              		.loc 1 609 0
 3581 059a 022B     		cmp	r3, #2
 3582 059c 00D1     		bne	.LCB3924
 3583 059e 01E6     		b	.L163	@long jump
 3584              	.LCB3924:
 3585 05a0 032B     		cmp	r3, #3
 3586 05a2 1AD0     		beq	.L212
 3587 05a4 012B     		cmp	r3, #1
 3588 05a6 00D0     		beq	.LCB3928
 3589 05a8 17E6     		b	.L157	@long jump
 3590              	.LCB3928:
 3591 05aa F6E5     		b	.L162
 3592              	.L161:
 637:display.c     **** 								switch( editing )
 3593              		.loc 1 637 0
 3594 05ac 022B     		cmp	r3, #2
 3595 05ae 16D0     		beq	.L213
 3596 05b0 032B     		cmp	r3, #3
 3597 05b2 00D1     		bne	.LCB3936
 3598 05b4 0AE6     		b	.L164	@long jump
 3599              	.LCB3936:
 3600 05b6 012B     		cmp	r3, #1
 3601 05b8 00D0     		beq	.LCB3938
 3602 05ba 0EE6     		b	.L157	@long jump
 3603              	.LCB3938:
 640:display.c     **** 									pt = (unsigned char *)&UCkey[0];
 3604              		.loc 1 640 0
 3605 05bc 1B4E     		ldr	r6, .L243+20
 3606 05be 11E0     		b	.L166
 3607              	.LVL477:
 3608              	.L234:
 3609 05c0 069B     		ldr	r3, [sp, #24]
 3610              	.LVL478:
 3611              	.L159:
 657:display.c     **** 								switch( editing )
 3612              		.loc 1 657 0
 3613 05c2 022B     		cmp	r3, #2
 3614 05c4 0DD0     		beq	.L214
 3615 05c6 032B     		cmp	r3, #3
 3616 05c8 00D1     		bne	.LCB3952
 3617 05ca 04E6     		b	.L165	@long jump
 3618              	.LCB3952:
 3619 05cc 012B     		cmp	r3, #1
 3620 05ce 00D0     		beq	.LCB3954
 3621 05d0 03E6     		b	.L157	@long jump
 3622              	.LCB3954:
 660:display.c     **** 									pt = (unsigned char *)&UCkey[0];
 3623              		.loc 1 660 0
 3624 05d2 164E     		ldr	r6, .L243+20
 3625 05d4 06E0     		b	.L166
 3626              	.L211:
 594:display.c     **** 							pt = (unsigned char *)&NCkey[0];
 3627              		.loc 1 594 0
 3628 05d6 164E     		ldr	r6, .L243+24
 3629 05d8 04E0     		b	.L166
 3630              	.L212:
 622:display.c     **** 								pt = (unsigned char *)&NCkey[0];
 3631              		.loc 1 622 0
 3632 05da 154E     		ldr	r6, .L243+24
 3633 05dc 02E0     		b	.L166
 3634              	.L213:
 645:display.c     **** 									pt = (unsigned char *)&LCkey[0];
 3635              		.loc 1 645 0
 3636 05de 154E     		ldr	r6, .L243+28
 3637 05e0 00E0     		b	.L166
 3638              	.L214:
 665:display.c     **** 									pt = (unsigned char *)&LCkey[0];
 3639              		.loc 1 665 0
 3640 05e2 144E     		ldr	r6, .L243+28
 3641              	.L166:
 3642              	.LVL479:
 678:display.c     **** 					if( key == SW_CU )
 3643              		.loc 1 678 0
 3644 05e4 5246     		mov	r2, sl
 3645 05e6 002A     		cmp	r2, #0
 3646 05e8 00D1     		bne	.LCB3982
 3647 05ea 0FE6     		b	.L198	@long jump
 3648              	.LCB3982:
 3649 05ec F9E5     		b	.L215
 3650              	.LVL480:
 3651              	.L207:
 770:display.c     **** 		for( i=0; (chr = dstring[i]) && (i < max); i++ )
 3652              		.loc 1 770 0
 3653 05ee 039D     		ldr	r5, [sp, #12]
 3654 05f0 00E0     		b	.L186
 3655              	.L208:
 3656 05f2 039D     		ldr	r5, [sp, #12]
 3657              	.LVL481:
 3658              	.L186:
 788:display.c     **** 	if( prog & GREY )
 3659              		.loc 1 788 0
 3660 05f4 0498     		ldr	r0, [sp, #16]
 3661 05f6 0306     		lsl	r3, r0, #24
 3662 05f8 92D4     		bmi	.L216
 793:display.c     **** 	if( prog & INV )
 3663              		.loc 1 793 0
 3664 05fa 0799     		ldr	r1, [sp, #28]
 3665 05fc 0029     		cmp	r1, #0
 3666 05fe A3D1     		bne	.L199
 3667 0600 AFE7     		b	.L192
 3668              	.LVL482:
 3669              	.L218:
 801:display.c     **** 	}
 802:display.c     **** 
 803:display.c     **** 	return( co );
 804:display.c     **** }
 3670              		.loc 1 804 0
 3671 0602 281C     		mov	r0, r5
 3672 0604 09B0     		add	sp, sp, #36
 3673              		@ sp needed for prologue
 3674              	.LVL483:
 3675 0606 3CBC     		pop	{r2, r3, r4, r5}
 3676 0608 9046     		mov	r8, r2
 3677 060a 9946     		mov	r9, r3
 3678 060c A246     		mov	sl, r4
 3679 060e AB46     		mov	fp, r5
 3680 0610 F0BC     		pop	{r4, r5, r6, r7}
 3681 0612 02BC     		pop	{r1}
 3682 0614 0847     		bx	r1
 3683              	.L244:
 3684 0616 C046     		.align	2
 3685              	.L243:
 3686 0618 00000000 		.word	editing
 3687 061c 00000000 		.word	adm
 3688 0620 00000000 		.word	.LANCHOR0
 3689 0624 00000000 		.word	.LANCHOR1
 3690 0628 00000000 		.word	half_second
 3691 062c 00000000 		.word	UCkey
 3692 0630 00000000 		.word	NCkey
 3693 0634 00000000 		.word	LCkey
 3694              		.cfi_endproc
 3695              	.LFE384:
 3697              		.global	__aeabi_fmul
 3698              		.global	__aeabi_fcmpge
 3699              		.global	__aeabi_fcmplt
 3700              		.global	__aeabi_fadd
 3701              		.global	__aeabi_fcmpgt
 3702              		.global	__aeabi_fsub
 3703              		.global	__aeabi_f2d
 3704              		.global	__aeabi_idiv
 3705              		.global	__aeabi_f2uiz
 3706              		.global	__aeabi_fdiv
 3707              		.section	.text.display_number,"ax",%progbits
 3708              		.align	2
 3709              		.global	display_number
 3710              		.code	16
 3711              		.thumb_func
 3713              	display_number:
 3714              	.LFB385:
 805:display.c     **** // -----------------------------------------------------------
 806:display.c     **** 
 807:display.c     **** 
 808:display.c     **** // -----------------------------------------------------------
 809:display.c     **** // Function Name       : display_number
 810:display.c     **** // -----------------------------------------------------------
 811:display.c     **** unsigned char display_number( float data, float min, float max, float con,
 812:display.c     ****         unsigned char dp, unsigned char xc, unsigned char yc, unsigned char width, unsigned char ju
 813:display.c     ****         struct NumericFont const *font, void *factor, unsigned char ftype )
 814:display.c     **** {
 3715              		.loc 1 814 0
 3716              		.cfi_startproc
 3717              	.LVL484:
 3718 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 3719              	.LCFI22:
 3720              		.cfi_def_cfa_offset 20
 3721              		.cfi_offset 4, -20
 3722              		.cfi_offset 5, -16
 3723              		.cfi_offset 6, -12
 3724              		.cfi_offset 7, -8
 3725              		.cfi_offset 14, -4
 3726 0002 5F46     		mov	r7, fp
 3727 0004 5646     		mov	r6, sl
 3728 0006 4D46     		mov	r5, r9
 3729 0008 4446     		mov	r4, r8
 3730 000a F0B4     		push	{r4, r5, r6, r7}
 3731              	.LCFI23:
 3732              		.cfi_def_cfa_offset 36
 3733              		.cfi_offset 8, -36
 3734              		.cfi_offset 9, -32
 3735              		.cfi_offset 10, -28
 3736              		.cfi_offset 11, -24
 3737 000c 93B0     		sub	sp, sp, #76
 3738              	.LCFI24:
 3739              		.cfi_def_cfa_offset 112
 3740 000e 8046     		mov	r8, r0
 3741 0010 0C91     		str	r1, [sp, #48]
 3742 0012 0D92     		str	r2, [sp, #52]
 3743 0014 0B93     		str	r3, [sp, #44]
 3744 0016 1CAB     		add	r3, sp, #112
 3745              	.LVL485:
 3746 0018 1E78     		ldrb	r6, [r3]
 3747 001a 1DAB     		add	r3, sp, #116
 3748              	.LVL486:
 3749 001c 1F78     		ldrb	r7, [r3]
 3750 001e 1EAB     		add	r3, sp, #120
 3751 0020 1B78     		ldrb	r3, [r3]
 3752 0022 0393     		str	r3, [sp, #12]
 3753 0024 1FAB     		add	r3, sp, #124
 3754 0026 1B78     		ldrb	r3, [r3]
 3755 0028 9B46     		mov	fp, r3
 3756 002a 20AB     		add	r3, sp, #128
 3757 002c 1C78     		ldrb	r4, [r3]
 3758 002e 219D     		ldr	r5, [sp, #132]
 3759 0030 23AB     		add	r3, sp, #140
 3760 0032 1B78     		ldrb	r3, [r3]
 3761 0034 0A93     		str	r3, [sp, #40]
 815:display.c     **** 	static float sdata;
 816:display.c     **** 	static char len;
 817:display.c     **** 
 818:display.c     **** 	unsigned char ldp, ed, x1, x2, ch, wi, hi, *pt;
 819:display.c     **** 	unsigned char tstring[16];
 820:display.c     **** 
 821:display.c     **** 	// get edit box size
 822:display.c     **** 	hi = font->height + yc - 1;
 3762              		.loc 1 822 0
 3763 0036 6B78     		ldrb	r3, [r5, #1]
 3764 0038 0398     		ldr	r0, [sp, #12]
 3765              	.LVL487:
 3766 003a C318     		add	r3, r0, r3
 3767 003c 1B06     		lsl	r3, r3, #24
 3768 003e 1B0E     		lsr	r3, r3, #24
 3769 0040 0693     		str	r3, [sp, #24]
 3770              	.LVL488:
 823:display.c     **** 	if( (just & dn_JUST) == RIGHT )
 3771              		.loc 1 823 0
 3772 0042 1023     		mov	r3, #16
 3773 0044 2340     		and	r3, r4
 3774 0046 0593     		str	r3, [sp, #20]
 3775 0048 06D0     		beq	.L246
 824:display.c     **** 	{
 825:display.c     **** 		x1 = xc - width;
 3776              		.loc 1 825 0
 3777 004a 5946     		mov	r1, fp
 3778              	.LVL489:
 3779 004c 7B1A     		sub	r3, r7, r1
 3780 004e 1B06     		lsl	r3, r3, #24
 3781 0050 1B0E     		lsr	r3, r3, #24
 3782 0052 0893     		str	r3, [sp, #32]
 3783              	.LVL490:
 826:display.c     **** 		x2 = xc;
 3784              		.loc 1 826 0
 3785 0054 0997     		str	r7, [sp, #36]
 3786 0056 05E0     		b	.L247
 3787              	.LVL491:
 3788              	.L246:
 827:display.c     **** 	}
 828:display.c     **** 	else
 829:display.c     **** 	{
 830:display.c     **** 		x1 = xc;
 831:display.c     **** 		x2 = xc + width;
 3789              		.loc 1 831 0
 3790 0058 5A46     		mov	r2, fp
 3791              	.LVL492:
 3792 005a D319     		add	r3, r2, r7
 3793 005c 1B06     		lsl	r3, r3, #24
 3794 005e 1B0E     		lsr	r3, r3, #24
 3795 0060 0993     		str	r3, [sp, #36]
 3796              	.LVL493:
 830:display.c     **** 		x1 = xc;
 3797              		.loc 1 830 0
 3798 0062 0897     		str	r7, [sp, #32]
 3799              	.LVL494:
 3800              	.L247:
 832:display.c     **** 	}
 833:display.c     **** 
 834:display.c     **** 	// clear space for number (including invert box), leave xc at start
 835:display.c     **** 	draw_box( adm, x1, yc-1, x2, hi+1, CLEAR );
 3801              		.loc 1 835 0
 3802 0064 039B     		ldr	r3, [sp, #12]
 3803 0066 013B     		sub	r3, r3, #1
 3804 0068 1B06     		lsl	r3, r3, #24
 3805 006a 1B0E     		lsr	r3, r3, #24
 3806 006c 0793     		str	r3, [sp, #28]
 3807 006e 069B     		ldr	r3, [sp, #24]
 3808 0070 0093     		str	r3, [sp]
 3809 0072 4023     		mov	r3, #64
 3810 0074 0193     		str	r3, [sp, #4]
 3811 0076 B048     		ldr	r0, .L358
 3812 0078 0899     		ldr	r1, [sp, #32]
 3813 007a 079A     		ldr	r2, [sp, #28]
 3814 007c 099B     		ldr	r3, [sp, #36]
 3815 007e FFF7FEFF 		bl	draw_box
 3816              	.LVL495:
 836:display.c     **** 	//draw_box( adm, x1, yc, x2, hi, CLEAR );
 837:display.c     **** 
 838:display.c     **** 	data *= con;
 3817              		.loc 1 838 0
 3818 0082 4046     		mov	r0, r8
 3819 0084 0B99     		ldr	r1, [sp, #44]
 3820 0086 FFF7FEFF 		bl	__aeabi_fmul
 3821              	.LVL496:
 3822 008a 8146     		mov	r9, r0
 3823              	.LVL497:
 839:display.c     **** 
 840:display.c     **** 	ldp = dp;
 3824              		.loc 1 840 0
 3825 008c B246     		mov	sl, r6
 841:display.c     **** 	if( ldp )
 3826              		.loc 1 841 0
 3827 008e 002E     		cmp	r6, #0
 3828 0090 23D0     		beq	.L248
 842:display.c     **** 	{
 843:display.c     **** 		if( data >= 1000.0 )
 3829              		.loc 1 843 0
 3830 0092 AA49     		ldr	r1, .L358+4
 3831 0094 FFF7FEFF 		bl	__aeabi_fcmpge
 3832              	.LVL498:
 844:display.c     **** 		{
 845:display.c     **** 			ldp = 0;
 3833              		.loc 1 845 0
 3834 0098 0021     		mov	r1, #0
 3835 009a 8A46     		mov	sl, r1
 843:display.c     **** 		if( data >= 1000.0 )
 3836              		.loc 1 843 0
 3837 009c 0028     		cmp	r0, #0
 3838 009e 1CD1     		bne	.L248
 846:display.c     **** 		}
 847:display.c     **** 		else if( data >= 100.0 )
 3839              		.loc 1 847 0
 3840 00a0 4846     		mov	r0, r9
 3841 00a2 A749     		ldr	r1, .L358+8
 3842 00a4 FFF7FEFF 		bl	__aeabi_fcmpge
 3843              	.LVL499:
 3844 00a8 0028     		cmp	r0, #0
 3845 00aa 07D0     		beq	.L354
 3846 00ac 331C     		add	r3, r6, #0
 3847 00ae 002E     		cmp	r6, #0
 3848 00b0 00D0     		beq	.L251
 3849 00b2 0123     		mov	r3, #1
 3850              	.L251:
 3851 00b4 1B06     		lsl	r3, r3, #24
 3852 00b6 1B0E     		lsr	r3, r3, #24
 3853 00b8 9A46     		mov	sl, r3
 3854 00ba 0EE0     		b	.L248
 3855              	.L354:
 848:display.c     **** 		{
 849:display.c     **** 			if( ldp > 1 )
 850:display.c     **** 			{
 851:display.c     **** 				ldp = 1;
 852:display.c     **** 			}
 853:display.c     **** 		}
 854:display.c     **** 		else if( data >= 10.0 )
 3856              		.loc 1 854 0
 3857 00bc 4846     		mov	r0, r9
 3858 00be A149     		ldr	r1, .L358+12
 3859 00c0 FFF7FEFF 		bl	__aeabi_fcmpge
 3860              	.LVL500:
 840:display.c     **** 	ldp = dp;
 3861              		.loc 1 840 0
 3862 00c4 B246     		mov	sl, r6
 3863              		.loc 1 854 0
 3864 00c6 0028     		cmp	r0, #0
 3865 00c8 07D0     		beq	.L248
 3866 00ca 331C     		add	r3, r6, #0
 3867 00cc 022E     		cmp	r6, #2
 3868 00ce 00D9     		bls	.L253
 3869 00d0 0223     		mov	r3, #2
 3870              	.L253:
 3871 00d2 1B06     		lsl	r3, r3, #24
 3872 00d4 1B0E     		lsr	r3, r3, #24
 3873 00d6 9A46     		mov	sl, r3
 3874 00d8 FFE7     		b	.L248
 3875              	.L248:
 3876              	.LVL501:
 855:display.c     **** 		{
 856:display.c     **** 			if( ldp > 2 )
 857:display.c     **** 			{
 858:display.c     **** 				ldp = 2;
 859:display.c     **** 			}
 860:display.c     **** 		}
 861:display.c     **** 	}
 862:display.c     **** 
 863:display.c     **** 	if( (ftype & PINC) && (just & EDIT) ) // simple increment
 3877              		.loc 1 863 0
 3878 00da 0823     		mov	r3, #8
 3879 00dc 0A9A     		ldr	r2, [sp, #40]
 3880 00de 1A40     		and	r2, r3
 3881 00e0 9046     		mov	r8, r2
 3882 00e2 00D1     		bne	.LCB4249
 3883 00e4 28E3     		b	.L254	@long jump
 3884              	.LCB4249:
 3885              		.loc 1 863 0 is_stmt 0 discriminator 1
 3886 00e6 E307     		lsl	r3, r4, #31
 3887 00e8 53D5     		bpl	.L329
 864:display.c     **** 			{
 865:display.c     **** 		if( editing )
 3888              		.loc 1 865 0 is_stmt 1
 3889 00ea 974B     		ldr	r3, .L358+16
 3890 00ec 1B78     		ldrb	r3, [r3]
 3891 00ee 002B     		cmp	r3, #0
 3892 00f0 39D0     		beq	.L256
 866:display.c     **** 		{
 867:display.c     **** 			if( key & (SW_NEW | SW_REP) )
 3893              		.loc 1 867 0
 3894 00f2 964B     		ldr	r3, .L358+20
 3895 00f4 1B68     		ldr	r3, [r3]
 3896 00f6 9A0F     		lsr	r2, r3, #30
 3897 00f8 4BD0     		beq	.L329
 868:display.c     **** 			{
 869:display.c     **** 				key &= ~(SW_NEW | SW_REP); // mask off status bits
 3898              		.loc 1 869 0
 3899 00fa 9B00     		lsl	r3, r3, #2
 3900 00fc 9B08     		lsr	r3, r3, #2
 3901 00fe 934A     		ldr	r2, .L358+20
 3902 0100 1360     		str	r3, [r2]
 870:display.c     **** 				if( key == SW_CR )
 3903              		.loc 1 870 0
 3904 0102 802B     		cmp	r3, #128
 3905 0104 10D1     		bne	.L257
 871:display.c     **** 				{
 872:display.c     **** 					if( sdata < max )
 3906              		.loc 1 872 0
 3907 0106 924B     		ldr	r3, .L358+24
 3908 0108 1B68     		ldr	r3, [r3]
 3909 010a 0493     		str	r3, [sp, #16]
 3910 010c 181C     		add	r0, r3, #0
 3911 010e 0D99     		ldr	r1, [sp, #52]
 3912 0110 FFF7FEFF 		bl	__aeabi_fcmplt
 3913              	.LVL502:
 3914 0114 0028     		cmp	r0, #0
 3915 0116 3CD0     		beq	.L329
 873:display.c     **** 					{
 874:display.c     **** 						sdata++;
 3916              		.loc 1 874 0
 3917 0118 0498     		ldr	r0, [sp, #16]
 3918 011a FE21     		mov	r1, #254
 3919 011c 8905     		lsl	r1, r1, #22
 3920 011e FFF7FEFF 		bl	__aeabi_fadd
 3921              	.LVL503:
 3922 0122 8B4B     		ldr	r3, .L358+24
 3923 0124 1860     		str	r0, [r3]
 3924 0126 34E0     		b	.L329
 3925              	.L257:
 875:display.c     **** 					}
 876:display.c     **** 				}
 877:display.c     **** 				else if( key == SW_CL )
 3926              		.loc 1 877 0
 3927 0128 102B     		cmp	r3, #16
 3928 012a 10D1     		bne	.L259
 878:display.c     **** 				{
 879:display.c     **** 					if( sdata > min )
 3929              		.loc 1 879 0
 3930 012c 884B     		ldr	r3, .L358+24
 3931 012e 1B68     		ldr	r3, [r3]
 3932 0130 0493     		str	r3, [sp, #16]
 3933 0132 181C     		add	r0, r3, #0
 3934 0134 0C99     		ldr	r1, [sp, #48]
 3935 0136 FFF7FEFF 		bl	__aeabi_fcmpgt
 3936              	.LVL504:
 3937 013a 0028     		cmp	r0, #0
 3938 013c 29D0     		beq	.L329
 880:display.c     **** 					{
 881:display.c     **** 						sdata--;
 3939              		.loc 1 881 0
 3940 013e 0498     		ldr	r0, [sp, #16]
 3941 0140 FE21     		mov	r1, #254
 3942 0142 8905     		lsl	r1, r1, #22
 3943 0144 FFF7FEFF 		bl	__aeabi_fsub
 3944              	.LVL505:
 3945 0148 814B     		ldr	r3, .L358+24
 3946 014a 1860     		str	r0, [r3]
 3947 014c 21E0     		b	.L329
 3948              	.L259:
 882:display.c     **** 					}
 883:display.c     **** 				}
 884:display.c     **** 				else if( key == SW_IL )
 3949              		.loc 1 884 0
 3950 014e 042B     		cmp	r3, #4
 3951 0150 03D1     		bne	.L261
 885:display.c     **** 				{
 886:display.c     **** 					editing = 0xfe; // cancel editing without save - but still copy number to tstring
 3952              		.loc 1 886 0
 3953 0152 FE22     		mov	r2, #254
 3954 0154 7C4B     		ldr	r3, .L358+16
 3955 0156 1A70     		strb	r2, [r3]
 3956 0158 1BE0     		b	.L329
 3957              	.L261:
 887:display.c     **** 				}
 888:display.c     **** 				else if( key == SW_IR )
 3958              		.loc 1 888 0
 3959 015a 082B     		cmp	r3, #8
 3960 015c 19D1     		bne	.L329
 889:display.c     **** 				{
 890:display.c     **** 					editing = 0xff; // cancel editing with save - but still copy number to tstring
 3961              		.loc 1 890 0
 3962 015e FF22     		mov	r2, #255
 3963 0160 794B     		ldr	r3, .L358+16
 3964 0162 1A70     		strb	r2, [r3]
 3965 0164 15E0     		b	.L329
 3966              	.L256:
 891:display.c     **** 				}
 892:display.c     **** 			}
 893:display.c     **** 		}
 894:display.c     **** 		else if( (just & EDSCAPE) || (key == (SW_NEW | SW_IR)) )
 3967              		.loc 1 894 0
 3968 0166 6006     		lsl	r0, r4, #25
 3969 0168 04D4     		bmi	.L262
 3970              		.loc 1 894 0 is_stmt 0 discriminator 1
 3971 016a 784B     		ldr	r3, .L358+20
 3972 016c 1A68     		ldr	r2, [r3]
 3973 016e 794B     		ldr	r3, .L358+28
 3974 0170 9A42     		cmp	r2, r3
 3975 0172 0ED1     		bne	.L329
 3976              	.L262:
 895:display.c     **** 		{
 896:display.c     **** 			sdata = data;
 3977              		.loc 1 896 0 is_stmt 1
 3978 0174 764B     		ldr	r3, .L358+24
 3979 0176 4946     		mov	r1, r9
 3980 0178 1960     		str	r1, [r3]
 897:display.c     **** 			editing = 1;
 3981              		.loc 1 897 0
 3982 017a 0122     		mov	r2, #1
 3983 017c 724B     		ldr	r3, .L358+16
 3984 017e 1A70     		strb	r2, [r3]
 898:display.c     **** 			looptime = 0;
 3985              		.loc 1 898 0
 3986 0180 0022     		mov	r2, #0
 3987 0182 754B     		ldr	r3, .L358+32
 3988 0184 1A70     		strb	r2, [r3]
 3989 0186 04E0     		b	.L329
 3990              	.L328:
 899:display.c     **** 		}
 900:display.c     **** 			}
 901:display.c     **** 
 902:display.c     **** 	if( !(ftype & PINC) && (just & EDIT) && editing )  // digit program
 3991              		.loc 1 902 0 discriminator 1
 3992 0188 6F4B     		ldr	r3, .L358+16
 3993 018a 1B78     		ldrb	r3, [r3]
 3994 018c 002B     		cmp	r3, #0
 3995 018e 00D0     		beq	.LCB4361
 3996 0190 D6E2     		b	.L263	@long jump
 3997              	.LCB4361:
 3998              	.L329:
 903:display.c     **** 	{
 904:display.c     **** 		// editing string so no sprintf needed
 905:display.c     **** 	}
 906:display.c     **** 	else
 907:display.c     **** 	{
 908:display.c     **** 		if( (just & dn_SIGN) == NSIGN )
 3999              		.loc 1 908 0
 4000 0192 A206     		lsl	r2, r4, #26
 4001 0194 02D5     		bpl	.L336
 909:display.c     **** 		{
 910:display.c     **** 			pt = "%+.*f";
 4002              		.loc 1 910 0
 4003 0196 714B     		ldr	r3, .L358+36
 4004 0198 0493     		str	r3, [sp, #16]
 4005 019a 01E0     		b	.L264
 4006              	.L336:
 911:display.c     **** 		}
 912:display.c     **** 		else
 913:display.c     **** 		{
 914:display.c     **** 			pt = "%.*f";
 4007              		.loc 1 914 0
 4008 019c 7048     		ldr	r0, .L358+40
 4009 019e 0490     		str	r0, [sp, #16]
 4010              	.L264:
 4011              	.LVL506:
 915:display.c     **** 		}
 916:display.c     **** 		len = sprintf( tstring, pt, ldp, ((ftype & PINC) && (just & EDIT) && editing) ? sdata : data );
 4012              		.loc 1 916 0
 4013 01a0 4146     		mov	r1, r8
 4014 01a2 0029     		cmp	r1, #0
 4015 01a4 08D0     		beq	.L265
 4016              		.loc 1 916 0 is_stmt 0 discriminator 1
 4017 01a6 E207     		lsl	r2, r4, #31
 4018 01a8 06D5     		bpl	.L265
 4019 01aa 674B     		ldr	r3, .L358+16
 4020 01ac 1B78     		ldrb	r3, [r3]
 4021 01ae 002B     		cmp	r3, #0
 4022 01b0 02D0     		beq	.L265
 4023 01b2 674B     		ldr	r3, .L358+24
 4024 01b4 1B68     		ldr	r3, [r3]
 4025 01b6 9946     		mov	r9, r3
 4026              	.LVL507:
 4027              	.L265:
 4028              		.loc 1 916 0 discriminator 3
 4029 01b8 4846     		mov	r0, r9
 4030 01ba FFF7FEFF 		bl	__aeabi_f2d
 4031              	.LVL508:
 4032 01be 0090     		str	r0, [sp]
 4033 01c0 0191     		str	r1, [sp, #4]
 4034 01c2 0EA8     		add	r0, sp, #56
 4035 01c4 0499     		ldr	r1, [sp, #16]
 4036 01c6 5246     		mov	r2, sl
 4037 01c8 FFF7FEFF 		bl	sprintf
 4038              	.LVL509:
 4039 01cc 0006     		lsl	r0, r0, #24
 4040 01ce 000E     		lsr	r0, r0, #24
 4041 01d0 8146     		mov	r9, r0
 4042 01d2 644B     		ldr	r3, .L358+44
 4043 01d4 1870     		strb	r0, [r3]
 917:display.c     **** 
 918:display.c     **** 		// check for fit
 919:display.c     **** 		ch = font->gap - 1; // character spacing
 4044              		.loc 1 919 0 is_stmt 1 discriminator 3
 4045 01d6 2B78     		ldrb	r3, [r5]
 4046 01d8 013B     		sub	r3, r3, #1
 4047 01da 1B06     		lsl	r3, r3, #24
 4048 01dc 1B0E     		lsr	r3, r3, #24
 4049              	.LVL510:
 920:display.c     **** 		wi = font->bitmap[0][0] + ch; // character width + space
 921:display.c     **** 		ed = ((width + ch) / wi); // maximum length of string in characters
 4050              		.loc 1 921 0 discriminator 3
 4051 01de 5946     		mov	r1, fp
 4052 01e0 C818     		add	r0, r1, r3
 920:display.c     **** 		wi = font->bitmap[0][0] + ch; // character width + space
 4053              		.loc 1 920 0 discriminator 3
 4054 01e2 6A68     		ldr	r2, [r5, #4]
 4055 01e4 1178     		ldrb	r1, [r2]
 4056 01e6 5918     		add	r1, r3, r1
 4057              		.loc 1 921 0 discriminator 3
 4058 01e8 0906     		lsl	r1, r1, #24
 4059 01ea 090E     		lsr	r1, r1, #24
 4060 01ec FFF7FEFF 		bl	__aeabi_idiv
 4061              	.LVL511:
 4062 01f0 0306     		lsl	r3, r0, #24
 4063 01f2 1B0E     		lsr	r3, r3, #24
 4064              	.LVL512:
 922:display.c     **** 
 923:display.c     **** 		if( len > ed )
 4065              		.loc 1 923 0 discriminator 3
 4066 01f4 9945     		cmp	r9, r3
 4067 01f6 10D9     		bls	.L266
 924:display.c     **** 		{
 925:display.c     **** 			len = ed;
 4068              		.loc 1 925 0
 4069 01f8 5A4A     		ldr	r2, .L358+44
 4070 01fa 1370     		strb	r3, [r2]
 926:display.c     **** 			tstring[ed] = 0x00;
 4071              		.loc 1 926 0
 4072 01fc FF22     		mov	r2, #255
 4073 01fe 1040     		and	r0, r2
 4074 0200 0021     		mov	r1, #0
 4075 0202 0EAA     		add	r2, sp, #56
 4076 0204 1154     		strb	r1, [r2, r0]
 927:display.c     **** 			while( ed )
 4077              		.loc 1 927 0
 4078 0206 002B     		cmp	r3, #0
 4079 0208 07D0     		beq	.L266
 928:display.c     **** 			{
 929:display.c     **** 				ed--;
 930:display.c     **** 				tstring[ed] = '9';
 4080              		.loc 1 930 0
 4081 020a 3921     		mov	r1, #57
 4082              	.LVL513:
 4083              	.L348:
 929:display.c     **** 				ed--;
 4084              		.loc 1 929 0
 4085 020c 013B     		sub	r3, r3, #1
 4086 020e 1B06     		lsl	r3, r3, #24
 4087 0210 1B0E     		lsr	r3, r3, #24
 4088              	.LVL514:
 4089              		.loc 1 930 0
 4090 0212 0EAA     		add	r2, sp, #56
 4091 0214 D154     		strb	r1, [r2, r3]
 927:display.c     **** 			while( ed )
 4092              		.loc 1 927 0
 4093 0216 002B     		cmp	r3, #0
 4094 0218 F8D1     		bne	.L348
 4095              	.LVL515:
 4096              	.L266:
 931:display.c     **** 			}
 932:display.c     **** 		}
 933:display.c     **** 	}
 934:display.c     **** 
 935:display.c     **** 	if( !(ftype & PINC) && (just & EDIT) ) // digit program
 4097              		.loc 1 935 0
 4098 021a 4346     		mov	r3, r8
 4099 021c 002B     		cmp	r3, #0
 4100 021e 00D0     		beq	.LCB4463
 4101 0220 00E1     		b	.L268	@long jump
 4102              	.LCB4463:
 4103              		.loc 1 935 0 is_stmt 0 discriminator 1
 4104 0222 0123     		mov	r3, #1
 4105 0224 2340     		and	r3, r4
 4106 0226 0493     		str	r3, [sp, #16]
 4107 0228 00D1     		bne	.LCB4470
 4108 022a CAE1     		b	.L269	@long jump
 4109              	.LCB4470:
 4110              	.LVL516:
 4111              	.L332:
 936:display.c     **** 	{
 937:display.c     **** 		if( editing )
 4112              		.loc 1 937 0 is_stmt 1
 4113 022c 464B     		ldr	r3, .L358+16
 4114 022e 1B78     		ldrb	r3, [r3]
 4115 0230 002B     		cmp	r3, #0
 4116 0232 00D1     		bne	.LCB4479
 4117 0234 9AE0     		b	.L270	@long jump
 4118              	.LCB4479:
 938:display.c     **** 		{
 939:display.c     **** 			if( key & (SW_NEW | SW_REP) )
 4119              		.loc 1 939 0
 4120 0236 454A     		ldr	r2, .L358+20
 4121 0238 1268     		ldr	r2, [r2]
 4122 023a 910F     		lsr	r1, r2, #30
 4123 023c 00D1     		bne	.LCB4485
 4124 023e ECE0     		b	.L330	@long jump
 4125              	.LCB4485:
 940:display.c     **** 			{
 941:display.c     **** 				key &= ~(SW_NEW | SW_REP); // mask off status bits
 4126              		.loc 1 941 0
 4127 0240 9200     		lsl	r2, r2, #2
 4128 0242 9208     		lsr	r2, r2, #2
 4129 0244 4149     		ldr	r1, .L358+20
 4130 0246 0A60     		str	r2, [r1]
 942:display.c     **** 				pt = &number[editing - 1];
 4131              		.loc 1 942 0
 4132 0248 591E     		sub	r1, r3, #1
 4133 024a 4748     		ldr	r0, .L358+48
 4134 024c 0818     		add	r0, r1, r0
 4135              	.LVL517:
 943:display.c     **** 				/*if( ((window == screen132) && (key == SW_IL)) || ((window != screen132) && (key == SW_CU)) )*
 944:display.c     **** 				if( key == SW_IL )
 4136              		.loc 1 944 0
 4137 024e 042A     		cmp	r2, #4
 4138 0250 2AD1     		bne	.L272
 945:display.c     **** 				{
 946:display.c     **** 					if( *pt == '+' )
 4139              		.loc 1 946 0
 4140 0252 454A     		ldr	r2, .L358+48
 4141 0254 525C     		ldrb	r2, [r2, r1]
 4142 0256 2B2A     		cmp	r2, #43
 4143 0258 03D1     		bne	.L273
 947:display.c     **** 					{
 948:display.c     **** 						*pt = '-';
 4144              		.loc 1 948 0
 4145 025a 2D22     		mov	r2, #45
 4146 025c 424B     		ldr	r3, .L358+48
 4147 025e 5A54     		strb	r2, [r3, r1]
 4148 0260 D7E0     		b	.L274
 4149              	.L273:
 949:display.c     **** 					}
 950:display.c     **** 					else if( *pt == '-' )
 4150              		.loc 1 950 0
 4151 0262 2D2A     		cmp	r2, #45
 4152 0264 03D1     		bne	.L275
 951:display.c     **** 					{
 952:display.c     **** 						*pt = '+';
 4153              		.loc 1 952 0
 4154 0266 2B22     		mov	r2, #43
 4155 0268 3F4B     		ldr	r3, .L358+48
 4156 026a 5A54     		strb	r2, [r3, r1]
 4157 026c D1E0     		b	.L274
 4158              	.L275:
 953:display.c     **** 					}
 954:display.c     **** 					else if( *pt == '.' )
 4159              		.loc 1 954 0
 4160 026e 2E2A     		cmp	r2, #46
 4161 0270 0ED1     		bne	.L276
 955:display.c     **** 					{
 956:display.c     **** 						// increase multiplier if dp position < field width
 957:display.c     **** 						if( editing < (len - 1) )
 4162              		.loc 1 957 0
 4163 0272 3C4A     		ldr	r2, .L358+44
 4164 0274 1278     		ldrb	r2, [r2]
 4165 0276 013A     		sub	r2, r2, #1
 4166 0278 9342     		cmp	r3, r2
 4167 027a 00DB     		blt	.LCB4522
 4168 027c C9E0     		b	.L274	@long jump
 4169              	.LCB4522:
 958:display.c     **** 						{
 959:display.c     **** 							ch = *(pt + 1);
 4170              		.loc 1 959 0
 4171 027e 4678     		ldrb	r6, [r0, #1]
 4172              	.LVL518:
 960:display.c     **** 							*(pt + 1) = *pt;
 4173              		.loc 1 960 0
 4174 0280 2E22     		mov	r2, #46
 4175 0282 4270     		strb	r2, [r0, #1]
 961:display.c     **** 							*pt = ch;
 4176              		.loc 1 961 0
 4177 0284 384A     		ldr	r2, .L358+48
 4178 0286 5654     		strb	r6, [r2, r1]
 962:display.c     **** 							editing++;
 4179              		.loc 1 962 0
 4180 0288 0133     		add	r3, r3, #1
 4181 028a 2F4A     		ldr	r2, .L358+16
 4182 028c 1370     		strb	r3, [r2]
 4183 028e C0E0     		b	.L274
 4184              	.LVL519:
 4185              	.L276:
 963:display.c     **** 						}
 964:display.c     **** 					}
 965:display.c     **** 					else
 966:display.c     **** 					{
 967:display.c     **** 						(*pt)++;
 4186              		.loc 1 967 0
 4187 0290 531C     		add	r3, r2, #1
 4188 0292 1B06     		lsl	r3, r3, #24
 4189 0294 1B0E     		lsr	r3, r3, #24
 968:display.c     **** 						if( *pt > '9' )
 4190              		.loc 1 968 0
 4191 0296 392B     		cmp	r3, #57
 4192 0298 02D8     		bhi	.L277
 967:display.c     **** 						(*pt)++;
 4193              		.loc 1 967 0
 4194 029a 334A     		ldr	r2, .L358+48
 4195 029c 5354     		strb	r3, [r2, r1]
 4196 029e B8E0     		b	.L274
 4197              	.L277:
 969:display.c     **** 						{
 970:display.c     **** 							*pt = '0';
 4198              		.loc 1 970 0
 4199 02a0 3022     		mov	r2, #48
 4200 02a2 314B     		ldr	r3, .L358+48
 4201 02a4 5A54     		strb	r2, [r3, r1]
 4202 02a6 B4E0     		b	.L274
 4203              	.L272:
 971:display.c     **** 						}
 972:display.c     **** 					}
 973:display.c     **** 				}
 974:display.c     **** 				//else if( ((window != screen132)&& (key == SW_CD)) || ((window == screen132) && (key == SW_OL)
 975:display.c     **** 				else if( key == SW_CD )
 4204              		.loc 1 975 0
 4205 02a8 402A     		cmp	r2, #64
 4206 02aa 2BD1     		bne	.L278
 976:display.c     **** 				{
 977:display.c     **** 					if( *pt == '+' )
 4207              		.loc 1 977 0
 4208 02ac 2E4A     		ldr	r2, .L358+48
 4209 02ae 525C     		ldrb	r2, [r2, r1]
 4210 02b0 2B2A     		cmp	r2, #43
 4211 02b2 03D1     		bne	.L279
 978:display.c     **** 					{
 979:display.c     **** 						*pt = '-';
 4212              		.loc 1 979 0
 4213 02b4 2D22     		mov	r2, #45
 4214 02b6 2C4B     		ldr	r3, .L358+48
 4215 02b8 5A54     		strb	r2, [r3, r1]
 4216 02ba AAE0     		b	.L274
 4217              	.L279:
 980:display.c     **** 					}
 981:display.c     **** 					else if( *pt == '-' )
 4218              		.loc 1 981 0
 4219 02bc 2D2A     		cmp	r2, #45
 4220 02be 03D1     		bne	.L280
 982:display.c     **** 					{
 983:display.c     **** 						*pt = '+';
 4221              		.loc 1 983 0
 4222 02c0 2B22     		mov	r2, #43
 4223 02c2 294B     		ldr	r3, .L358+48
 4224 02c4 5A54     		strb	r2, [r3, r1]
 4225 02c6 A4E0     		b	.L274
 4226              	.L280:
 984:display.c     **** 					}
 985:display.c     **** 					else if( *pt == '.' )
 4227              		.loc 1 985 0
 4228 02c8 2E2A     		cmp	r2, #46
 4229 02ca 0FD1     		bne	.L281
 986:display.c     **** 					{
 987:display.c     **** 						// decrease multiplier if dp position >(field width - set precision)
 988:display.c     **** 						if( editing > (len - dp) )
 4230              		.loc 1 988 0
 4231 02cc 254A     		ldr	r2, .L358+44
 4232 02ce 1278     		ldrb	r2, [r2]
 4233 02d0 961B     		sub	r6, r2, r6
 4234 02d2 B342     		cmp	r3, r6
 4235 02d4 00DC     		bgt	.LCB4584
 4236 02d6 9CE0     		b	.L274	@long jump
 4237              	.LCB4584:
 989:display.c     **** 						{
 990:display.c     **** 							editing--;
 4238              		.loc 1 990 0
 4239 02d8 013B     		sub	r3, r3, #1
 4240 02da 1B4A     		ldr	r2, .L358+16
 4241 02dc 1370     		strb	r3, [r2]
 991:display.c     **** 							ch = *(pt - 1);
 4242              		.loc 1 991 0
 4243 02de 0138     		sub	r0, r0, #1
 4244              	.LVL520:
 4245 02e0 0278     		ldrb	r2, [r0]
 4246              	.LVL521:
 992:display.c     **** 							*(pt - 1) = *pt;
 4247              		.loc 1 992 0
 4248 02e2 2E23     		mov	r3, #46
 4249 02e4 0370     		strb	r3, [r0]
 993:display.c     **** 							*pt = ch;
 4250              		.loc 1 993 0
 4251 02e6 204B     		ldr	r3, .L358+48
 4252 02e8 5A54     		strb	r2, [r3, r1]
 4253 02ea 92E0     		b	.L274
 4254              	.LVL522:
 4255              	.L281:
 994:display.c     **** 						}
 995:display.c     **** 					}
 996:display.c     **** 					else
 997:display.c     **** 					{
 998:display.c     **** 						(*pt)--;
 4256              		.loc 1 998 0
 4257 02ec 531E     		sub	r3, r2, #1
 4258 02ee 1B06     		lsl	r3, r3, #24
 4259 02f0 1B0E     		lsr	r3, r3, #24
 999:display.c     **** 						if( *pt < '0' )
 4260              		.loc 1 999 0
 4261 02f2 2F2B     		cmp	r3, #47
 4262 02f4 02D9     		bls	.L282
 998:display.c     **** 						(*pt)--;
 4263              		.loc 1 998 0
 4264 02f6 1C4A     		ldr	r2, .L358+48
 4265 02f8 5354     		strb	r3, [r2, r1]
 4266 02fa 8AE0     		b	.L274
 4267              	.L282:
1000:display.c     **** 						{
1001:display.c     **** 							*pt = '9';
 4268              		.loc 1 1001 0
 4269 02fc 3922     		mov	r2, #57
 4270 02fe 1A4B     		ldr	r3, .L358+48
 4271 0300 5A54     		strb	r2, [r3, r1]
 4272 0302 86E0     		b	.L274
 4273              	.L278:
1002:display.c     **** 						}
1003:display.c     **** 					}
1004:display.c     **** 				}
1005:display.c     **** 				else if( key == SW_CL )
 4274              		.loc 1 1005 0
 4275 0304 102A     		cmp	r2, #16
 4276 0306 06D1     		bne	.L283
1006:display.c     **** 				{
1007:display.c     **** 					if( editing > 1 )
 4277              		.loc 1 1007 0
 4278 0308 012B     		cmp	r3, #1
 4279 030a 00D8     		bhi	.LCB4623
 4280 030c 81E0     		b	.L274	@long jump
 4281              	.LCB4623:
1008:display.c     **** 					{
1009:display.c     **** 						editing--;
 4282              		.loc 1 1009 0
 4283 030e 013B     		sub	r3, r3, #1
 4284 0310 0D4A     		ldr	r2, .L358+16
 4285 0312 1370     		strb	r3, [r2]
 4286 0314 7DE0     		b	.L274
 4287              	.L283:
1010:display.c     **** 					}
1011:display.c     **** 				}
1012:display.c     **** 				else if( key == SW_IL )
1013:display.c     **** 				{
1014:display.c     **** 					editing = 0xfe; // cancel editing without save - but still copy number to tstring
1015:display.c     **** 				}
1016:display.c     **** 				else if( key == SW_CR )
 4288              		.loc 1 1016 0
 4289 0316 802A     		cmp	r2, #128
 4290 0318 07D1     		bne	.L284
1017:display.c     **** 				{
1018:display.c     **** 					if( number[editing] != 0x00 ) // end of string
 4291              		.loc 1 1018 0
 4292 031a 134A     		ldr	r2, .L358+48
 4293 031c D25C     		ldrb	r2, [r2, r3]
 4294 031e 002A     		cmp	r2, #0
 4295 0320 77D0     		beq	.L274
1019:display.c     **** 					{
1020:display.c     **** 						editing++;
 4296              		.loc 1 1020 0
 4297 0322 0133     		add	r3, r3, #1
 4298 0324 084A     		ldr	r2, .L358+16
 4299 0326 1370     		strb	r3, [r2]
 4300 0328 73E0     		b	.L274
 4301              	.L284:
1021:display.c     **** 					}
1022:display.c     **** 				}
1023:display.c     **** 				else if( key == SW_IR )
 4302              		.loc 1 1023 0
 4303 032a 082A     		cmp	r2, #8
 4304 032c 71D1     		bne	.L274
1024:display.c     **** 				{
1025:display.c     **** 					editing = 0xff; // cancel editing with save - but still copy number to tstring
 4305              		.loc 1 1025 0
 4306 032e FF22     		mov	r2, #255
 4307 0330 054B     		ldr	r3, .L358+16
 4308 0332 1A70     		strb	r2, [r3]
 4309 0334 71E0     		b	.L330
 4310              	.L359:
 4311 0336 C046     		.align	2
 4312              	.L358:
 4313 0338 00000000 		.word	adm
 4314 033c 00007A44 		.word	1148846080
 4315 0340 0000C842 		.word	1120403456
 4316 0344 00002041 		.word	1092616192
 4317 0348 00000000 		.word	editing
 4318 034c 00000000 		.word	key
 4319 0350 00000000 		.word	.LANCHOR2
 4320 0354 08000080 		.word	-2147483640
 4321 0358 00000000 		.word	looptime
 4322 035c 00000000 		.word	.LC20
 4323 0360 08000000 		.word	.LC22
 4324 0364 00000000 		.word	.LANCHOR3
 4325 0368 00000000 		.word	number
 4326              	.LVL523:
 4327              	.L270:
1026:display.c     **** 				}
1027:display.c     **** 			}
1028:display.c     **** 		}
1029:display.c     **** 		else if( (just & EDSCAPE) || (key == (SW_NEW | SW_IR)) )
 4328              		.loc 1 1029 0
 4329 036c 6006     		lsl	r0, r4, #25
 4330 036e 04D4     		bmi	.L285
 4331              		.loc 1 1029 0 is_stmt 0 discriminator 1
 4332 0370 A44B     		ldr	r3, .L360
 4333 0372 1A68     		ldr	r2, [r3]
 4334 0374 A44B     		ldr	r3, .L360+4
 4335 0376 9A42     		cmp	r2, r3
 4336 0378 59D1     		bne	.L331
 4337              	.L285:
1030:display.c     **** 		{
1031:display.c     **** 			editing = 1;
 4338              		.loc 1 1031 0 is_stmt 1
 4339 037a 0122     		mov	r2, #1
 4340 037c A34B     		ldr	r3, .L360+8
 4341 037e 1A70     		strb	r2, [r3]
1032:display.c     **** 			looptime = 0;
 4342              		.loc 1 1032 0
 4343 0380 0022     		mov	r2, #0
 4344 0382 A34B     		ldr	r3, .L360+12
 4345 0384 1A70     		strb	r2, [r3]
1033:display.c     **** 			strcpy( number, tstring );
 4346              		.loc 1 1033 0
 4347 0386 A34E     		ldr	r6, .L360+16
 4348 0388 301C     		mov	r0, r6
 4349 038a 0EA9     		add	r1, sp, #56
 4350 038c FFF7FEFF 		bl	strcpy
 4351              	.LVL524:
1034:display.c     **** 			// insert leading zeros
1035:display.c     **** 			ch = strlen( number );
 4352              		.loc 1 1035 0
 4353 0390 301C     		mov	r0, r6
 4354 0392 FFF7FEFF 		bl	strlen
 4355              	.LVL525:
 4356 0396 061C     		mov	r6, r0
 4357 0398 0006     		lsl	r0, r0, #24
 4358 039a 000E     		lsr	r0, r0, #24
 4359 039c 8146     		mov	r9, r0
 4360              	.LVL526:
1036:display.c     **** 			wi = width / (font->bitmap[0][0] + font->gap - 1);
 4361              		.loc 1 1036 0
 4362 039e 6A68     		ldr	r2, [r5, #4]
 4363 03a0 1178     		ldrb	r1, [r2]
 4364 03a2 2B78     		ldrb	r3, [r5]
 4365 03a4 C918     		add	r1, r1, r3
 4366 03a6 0139     		sub	r1, r1, #1
 4367 03a8 5846     		mov	r0, fp
 4368              	.LVL527:
 4369 03aa FFF7FEFF 		bl	__aeabi_idiv
 4370              	.LVL528:
 4371 03ae 0306     		lsl	r3, r0, #24
 4372 03b0 1B0E     		lsr	r3, r3, #24
 4373 03b2 9C46     		mov	ip, r3
 4374              	.LVL529:
1037:display.c     **** 			len = wi;
 4375              		.loc 1 1037 0
 4376 03b4 984B     		ldr	r3, .L360+20
 4377              	.LVL530:
 4378 03b6 6146     		mov	r1, ip
 4379 03b8 1970     		strb	r1, [r3]
1038:display.c     **** 			if( ch < wi )
 4380              		.loc 1 1038 0
 4381 03ba E145     		cmp	r9, ip
 4382 03bc 29D2     		bcs	.L274
1039:display.c     **** 			{
1040:display.c     **** 				while( ch )
 4383              		.loc 1 1040 0 discriminator 1
 4384 03be 4A46     		mov	r2, r9
 4385 03c0 002A     		cmp	r2, #0
 4386 03c2 12D0     		beq	.L337
 4387              		.loc 1 1040 0 is_stmt 0
 4388 03c4 4B46     		mov	r3, r9
1041:display.c     **** 				{
1042:display.c     **** 					number[wi--] = number[ch--];
 4389              		.loc 1 1042 0 is_stmt 1
 4390 03c6 934A     		ldr	r2, .L360+16
 811:display.c     **** unsigned char display_number( float data, float min, float max, float con,
 4391              		.loc 1 811 0
 4392 03c8 861B     		sub	r6, r0, r6
 4393              	.LVL531:
 4394              	.L288:
 4395              		.loc 1 1042 0
 4396 03ca D05C     		ldrb	r0, [r2, r3]
 811:display.c     **** unsigned char display_number( float data, float min, float max, float con,
 4397              		.loc 1 811 0
 4398 03cc 9919     		add	r1, r3, r6
 4399              		.loc 1 1042 0
 4400 03ce 0906     		lsl	r1, r1, #24
 4401 03d0 090E     		lsr	r1, r1, #24
 4402 03d2 5054     		strb	r0, [r2, r1]
 4403 03d4 013B     		sub	r3, r3, #1
 4404 03d6 1B06     		lsl	r3, r3, #24
 4405 03d8 1B0E     		lsr	r3, r3, #24
 4406              	.LVL532:
1040:display.c     **** 				while( ch )
 4407              		.loc 1 1040 0
 4408 03da F6D1     		bne	.L288
 4409 03dc 6046     		mov	r0, ip
 4410 03de 4946     		mov	r1, r9
 4411 03e0 421A     		sub	r2, r0, r1
 4412 03e2 1206     		lsl	r2, r2, #24
 4413 03e4 120E     		lsr	r2, r2, #24
 4414 03e6 9446     		mov	ip, r2
 4415 03e8 00E0     		b	.L287
 4416              	.LVL533:
 4417              	.L337:
 4418 03ea 4B46     		mov	r3, r9
 4419              	.LVL534:
 4420              	.L287:
1043:display.c     **** 				}
1044:display.c     **** 				number[wi--] = number[ch--];
 4421              		.loc 1 1044 0
 4422 03ec 894A     		ldr	r2, .L360+16
 4423 03ee D35C     		ldrb	r3, [r2, r3]
 4424 03f0 6046     		mov	r0, ip
 4425 03f2 1354     		strb	r3, [r2, r0]
 4426 03f4 6346     		mov	r3, ip
 4427 03f6 013B     		sub	r3, r3, #1
 4428 03f8 1B06     		lsl	r3, r3, #24
 4429 03fa 1B0E     		lsr	r3, r3, #24
 4430              	.LVL535:
1045:display.c     **** 				while( wi )
 4431              		.loc 1 1045 0
 4432 03fc 06D0     		beq	.L289
1046:display.c     **** 				{
1047:display.c     **** 					number[wi--] = '0';
 4433              		.loc 1 1047 0
 4434 03fe 111C     		mov	r1, r2
 4435 0400 3022     		mov	r2, #48
 4436              	.LVL536:
 4437              	.L347:
 4438 0402 CA54     		strb	r2, [r1, r3]
 4439 0404 013B     		sub	r3, r3, #1
 4440 0406 1B06     		lsl	r3, r3, #24
 4441 0408 1B0E     		lsr	r3, r3, #24
 4442              	.LVL537:
1045:display.c     **** 				while( wi )
 4443              		.loc 1 1045 0
 4444 040a FAD1     		bne	.L347
 4445              	.LVL538:
 4446              	.L289:
1048:display.c     **** 				}
1049:display.c     **** 				number[wi] = '0';
 4447              		.loc 1 1049 0
 4448 040c 3021     		mov	r1, #48
 4449 040e 814A     		ldr	r2, .L360+16
 4450 0410 D154     		strb	r1, [r2, r3]
 4451              	.L274:
1050:display.c     **** 			}
1051:display.c     **** 		}
1052:display.c     **** 
1053:display.c     **** 		if( editing )
 4452              		.loc 1 1053 0
 4453 0412 7E4B     		ldr	r3, .L360+8
 4454 0414 1B78     		ldrb	r3, [r3]
 4455 0416 002B     		cmp	r3, #0
 4456 0418 09D0     		beq	.L331
 4457              	.L330:
1054:display.c     **** 		{
1055:display.c     **** 			strcpy( tstring, number );
 4458              		.loc 1 1055 0
 4459 041a 0EA8     		add	r0, sp, #56
 4460 041c 7D49     		ldr	r1, .L360+16
 4461 041e FFF7FEFF 		bl	strcpy
 4462              	.LVL539:
 4463 0422 04E0     		b	.L331
 4464              	.LVL540:
 4465              	.L268:
1056:display.c     **** 		}
1057:display.c     **** 	}
1058:display.c     **** 
1059:display.c     **** 	if( just & EDIT ) // digit & inc program
 4466              		.loc 1 1059 0
 4467 0424 0123     		mov	r3, #1
 4468 0426 2340     		and	r3, r4
 4469 0428 0493     		str	r3, [sp, #16]
 4470 042a 00D1     		bne	.LCB4820
 4471 042c C9E0     		b	.L269	@long jump
 4472              	.LCB4820:
 4473              	.LVL541:
 4474              	.L331:
1060:display.c     **** 	{
1061:display.c     **** 		if( editing == 0xfe )
 4475              		.loc 1 1061 0
 4476 042e 774B     		ldr	r3, .L360+8
 4477 0430 1B78     		ldrb	r3, [r3]
 4478 0432 FE2B     		cmp	r3, #254
 4479 0434 09D1     		bne	.L291
1062:display.c     **** 		{
1063:display.c     **** 			editing = 0;
 4480              		.loc 1 1063 0
 4481 0436 0022     		mov	r2, #0
 4482 0438 744B     		ldr	r3, .L360+8
 4483 043a 1A70     		strb	r2, [r3]
1064:display.c     **** 			if( just & EDSCAPE )
 4484              		.loc 1 1064 0
 4485 043c 6106     		lsl	r1, r4, #25
 4486 043e 00D4     		bmi	.LCB4838
 4487 0440 BFE0     		b	.L269	@long jump
 4488              	.LCB4838:
1065:display.c     **** 			{
1066:display.c     **** 				escape = 2;
 4489              		.loc 1 1066 0
 4490 0442 0222     		mov	r2, #2
 4491 0444 754B     		ldr	r3, .L360+24
 4492 0446 1A70     		strb	r2, [r3]
 4493 0448 BBE0     		b	.L269
 4494              	.L291:
1067:display.c     **** 			}
1068:display.c     **** 		}
1069:display.c     **** 		else if( editing == 0xff )
 4495              		.loc 1 1069 0
 4496 044a FF2B     		cmp	r3, #255
 4497 044c 00D0     		beq	.LCB4847
 4498 044e B8E0     		b	.L269	@long jump
 4499              	.LCB4847:
1070:display.c     **** 		{
1071:display.c     **** 			editing = 0;
 4500              		.loc 1 1071 0
 4501 0450 0022     		mov	r2, #0
 4502 0452 6E4B     		ldr	r3, .L360+8
 4503 0454 1A70     		strb	r2, [r3]
1072:display.c     **** 			if( just & EDSCAPE )
 4504              		.loc 1 1072 0
 4505 0456 6206     		lsl	r2, r4, #25
 4506 0458 02D5     		bpl	.L292
1073:display.c     **** 			{
1074:display.c     **** 				escape = 3;
 4507              		.loc 1 1074 0
 4508 045a 0322     		mov	r2, #3
 4509 045c 6F4B     		ldr	r3, .L360+24
 4510 045e 1A70     		strb	r2, [r3]
 4511              	.L292:
1075:display.c     **** 			}
1076:display.c     **** 
1077:display.c     **** 			if( factor != NULL )
 4512              		.loc 1 1077 0
 4513 0460 229B     		ldr	r3, [sp, #136]
 4514 0462 002B     		cmp	r3, #0
 4515 0464 00D1     		bne	.LCB4864
 4516 0466 ACE0     		b	.L269	@long jump
 4517              	.LCB4864:
1078:display.c     **** 			{
1079:display.c     **** 				switch( ftype & PTYPE )
 4518              		.loc 1 1079 0
 4519 0468 0723     		mov	r3, #7
 4520 046a 0A98     		ldr	r0, [sp, #40]
 4521 046c 0340     		and	r3, r0
 4522 046e 022B     		cmp	r3, #2
 4523 0470 30D0     		beq	.L295
 4524 0472 03D8     		bhi	.L298
 4525 0474 012B     		cmp	r3, #1
 4526 0476 00D0     		beq	.LCB4879
 4527 0478 96E0     		b	.L293	@long jump
 4528              	.LCB4879:
 4529 047a 05E0     		b	.L294
 4530              	.L298:
 4531 047c 032B     		cmp	r3, #3
 4532 047e 4FD0     		beq	.L296
 4533 0480 042B     		cmp	r3, #4
 4534 0482 00D0     		beq	.LCB4891
 4535 0484 90E0     		b	.L293	@long jump
 4536              	.LCB4891:
 4537 0486 6CE0     		b	.L297
 4538              	.L294:
1080:display.c     **** 				{
1081:display.c     **** 				case PCHAR:
1082:display.c     **** 					*(unsigned char *)factor = (ftype & PINC) ? (unsigned char)sdata : (unsigned char)atoi( number
 4539              		.loc 1 1082 0
 4540 0488 4146     		mov	r1, r8
 4541 048a 0029     		cmp	r1, #0
 4542 048c 06D0     		beq	.L299
 4543              		.loc 1 1082 0 is_stmt 0 discriminator 1
 4544 048e 644B     		ldr	r3, .L360+28
 4545 0490 1868     		ldr	r0, [r3]
 4546 0492 FFF7FEFF 		bl	__aeabi_f2uiz
 4547              	.LVL542:
 4548 0496 0406     		lsl	r4, r0, #24
 4549 0498 240E     		lsr	r4, r4, #24
 4550 049a 04E0     		b	.L300
 4551              	.L299:
 4552              		.loc 1 1082 0 discriminator 2
 4553 049c 5D48     		ldr	r0, .L360+16
 4554 049e FFF7FEFF 		bl	atoi
 4555              	.LVL543:
 4556 04a2 0406     		lsl	r4, r0, #24
 4557 04a4 240E     		lsr	r4, r4, #24
 4558              	.L300:
 4559              		.loc 1 1082 0 discriminator 3
 4560 04a6 229A     		ldr	r2, [sp, #136]
 4561 04a8 1470     		strb	r4, [r2]
1083:display.c     **** 					if( *(unsigned char *)factor > (unsigned char)max )
 4562              		.loc 1 1083 0 is_stmt 1 discriminator 3
 4563 04aa 0D98     		ldr	r0, [sp, #52]
 4564 04ac FFF7FEFF 		bl	__aeabi_f2uiz
 4565              	.LVL544:
 4566 04b0 0306     		lsl	r3, r0, #24
 4567 04b2 1B0E     		lsr	r3, r3, #24
 4568 04b4 9C42     		cmp	r4, r3
 4569 04b6 02D9     		bls	.L301
1084:display.c     **** 					{
1085:display.c     **** 						*(unsigned char *)factor = (unsigned char)max;
 4570              		.loc 1 1085 0
 4571 04b8 2298     		ldr	r0, [sp, #136]
 4572 04ba 0370     		strb	r3, [r0]
 4573 04bc 74E0     		b	.L293
 4574              	.L301:
1086:display.c     **** 					}
1087:display.c     **** 					else if( (unsigned char)min && (*(unsigned char *)factor < (unsigned char)min) )
 4575              		.loc 1 1087 0
 4576 04be 0C98     		ldr	r0, [sp, #48]
 4577 04c0 FFF7FEFF 		bl	__aeabi_f2uiz
 4578              	.LVL545:
 4579 04c4 0306     		lsl	r3, r0, #24
 4580 04c6 1B0E     		lsr	r3, r3, #24
 4581 04c8 6ED0     		beq	.L293
 4582              		.loc 1 1087 0 is_stmt 0 discriminator 1
 4583 04ca 9C42     		cmp	r4, r3
 4584 04cc 6CD2     		bcs	.L293
1088:display.c     **** 					{
1089:display.c     **** 						*(unsigned char *)factor = (unsigned char)min;
 4585              		.loc 1 1089 0 is_stmt 1
 4586 04ce 2299     		ldr	r1, [sp, #136]
 4587 04d0 0B70     		strb	r3, [r1]
 4588 04d2 69E0     		b	.L293
 4589              	.L295:
1090:display.c     **** 					}
1091:display.c     **** 					break;
1092:display.c     **** 
1093:display.c     **** 				case PSHORT:
1094:display.c     **** 					*(unsigned short int *)factor = (ftype & PINC) ? (unsigned short int)sdata : (unsigned short i
 4590              		.loc 1 1094 0
 4591 04d4 4246     		mov	r2, r8
 4592 04d6 002A     		cmp	r2, #0
 4593 04d8 06D0     		beq	.L302
 4594              		.loc 1 1094 0 is_stmt 0 discriminator 1
 4595 04da 514B     		ldr	r3, .L360+28
 4596 04dc 1868     		ldr	r0, [r3]
 4597 04de FFF7FEFF 		bl	__aeabi_f2uiz
 4598              	.LVL546:
 4599 04e2 0404     		lsl	r4, r0, #16
 4600 04e4 240C     		lsr	r4, r4, #16
 4601 04e6 04E0     		b	.L303
 4602              	.L302:
 4603              		.loc 1 1094 0 discriminator 2
 4604 04e8 4A48     		ldr	r0, .L360+16
 4605 04ea FFF7FEFF 		bl	atoi
 4606              	.LVL547:
 4607 04ee 0404     		lsl	r4, r0, #16
 4608 04f0 240C     		lsr	r4, r4, #16
 4609              	.L303:
 4610              		.loc 1 1094 0 discriminator 3
 4611 04f2 229B     		ldr	r3, [sp, #136]
 4612 04f4 1C80     		strh	r4, [r3]
1095:display.c     **** 					if( *(unsigned short int *)factor > (unsigned short int)max )
 4613              		.loc 1 1095 0 is_stmt 1 discriminator 3
 4614 04f6 0D98     		ldr	r0, [sp, #52]
 4615 04f8 FFF7FEFF 		bl	__aeabi_f2uiz
 4616              	.LVL548:
 4617 04fc 0304     		lsl	r3, r0, #16
 4618 04fe 1B0C     		lsr	r3, r3, #16
 4619 0500 9C42     		cmp	r4, r3
 4620 0502 02D9     		bls	.L304
1096:display.c     **** 					{
1097:display.c     **** 						*(unsigned short int *)factor = (unsigned short int)max;
 4621              		.loc 1 1097 0
 4622 0504 2298     		ldr	r0, [sp, #136]
 4623 0506 0380     		strh	r3, [r0]
 4624 0508 4EE0     		b	.L293
 4625              	.L304:
1098:display.c     **** 					}
1099:display.c     **** 					else if( (unsigned short int)min && (*(unsigned short int *)factor < (unsigned short int)min) 
 4626              		.loc 1 1099 0
 4627 050a 0C98     		ldr	r0, [sp, #48]
 4628 050c FFF7FEFF 		bl	__aeabi_f2uiz
 4629              	.LVL549:
 4630 0510 0304     		lsl	r3, r0, #16
 4631 0512 1B0C     		lsr	r3, r3, #16
 4632 0514 48D0     		beq	.L293
 4633              		.loc 1 1099 0 is_stmt 0 discriminator 1
 4634 0516 9C42     		cmp	r4, r3
 4635 0518 46D2     		bcs	.L293
1100:display.c     **** 					{
1101:display.c     **** 						*(unsigned short int *)factor = (unsigned short int)min;
 4636              		.loc 1 1101 0 is_stmt 1
 4637 051a 2299     		ldr	r1, [sp, #136]
 4638 051c 0B80     		strh	r3, [r1]
 4639 051e 43E0     		b	.L293
 4640              	.L296:
1102:display.c     **** 					}
1103:display.c     **** 					break;
1104:display.c     **** 
1105:display.c     **** 				case PLONG:
1106:display.c     **** 					*(unsigned long int *)factor = (ftype & PINC) ? (unsigned long int)sdata : (unsigned long int)
 4641              		.loc 1 1106 0
 4642 0520 4246     		mov	r2, r8
 4643 0522 002A     		cmp	r2, #0
 4644 0524 05D0     		beq	.L305
 4645              		.loc 1 1106 0 is_stmt 0 discriminator 1
 4646 0526 3E4B     		ldr	r3, .L360+28
 4647 0528 1868     		ldr	r0, [r3]
 4648 052a FFF7FEFF 		bl	__aeabi_f2uiz
 4649              	.LVL550:
 4650 052e 041C     		mov	r4, r0
 4651 0530 03E0     		b	.L306
 4652              	.L305:
 4653              		.loc 1 1106 0 discriminator 2
 4654 0532 3848     		ldr	r0, .L360+16
 4655 0534 FFF7FEFF 		bl	atol
 4656              	.LVL551:
 4657 0538 041C     		mov	r4, r0
 4658              	.L306:
 4659              		.loc 1 1106 0 discriminator 3
 4660 053a 229B     		ldr	r3, [sp, #136]
 4661 053c 1C60     		str	r4, [r3]
1107:display.c     **** 					if( *(unsigned long int *)factor > (unsigned long int)max )
 4662              		.loc 1 1107 0 is_stmt 1 discriminator 3
 4663 053e 0D98     		ldr	r0, [sp, #52]
 4664 0540 FFF7FEFF 		bl	__aeabi_f2uiz
 4665              	.LVL552:
 4666 0544 8442     		cmp	r4, r0
 4667 0546 02D9     		bls	.L307
1108:display.c     **** 					{
1109:display.c     **** 						*(unsigned long int *)factor = (unsigned long int)max;
 4668              		.loc 1 1109 0
 4669 0548 2299     		ldr	r1, [sp, #136]
 4670 054a 0860     		str	r0, [r1]
 4671 054c 2CE0     		b	.L293
 4672              	.L307:
1110:display.c     **** 					}
1111:display.c     **** 					else if( (unsigned long int)min && (*(unsigned long int *)factor < (unsigned long int)min) )
 4673              		.loc 1 1111 0
 4674 054e 0C98     		ldr	r0, [sp, #48]
 4675 0550 FFF7FEFF 		bl	__aeabi_f2uiz
 4676              	.LVL553:
 4677 0554 0028     		cmp	r0, #0
 4678 0556 27D0     		beq	.L293
 4679              		.loc 1 1111 0 is_stmt 0 discriminator 1
 4680 0558 8442     		cmp	r4, r0
 4681 055a 25D2     		bcs	.L293
1112:display.c     **** 					{
1113:display.c     **** 						*(unsigned long int *)factor = (unsigned long int)min;
 4682              		.loc 1 1113 0 is_stmt 1
 4683 055c 229A     		ldr	r2, [sp, #136]
 4684 055e 1060     		str	r0, [r2]
 4685 0560 22E0     		b	.L293
 4686              	.L297:
1114:display.c     **** 					}
1115:display.c     **** 					break;
1116:display.c     **** 
1117:display.c     **** 				case PFLOAT:
1118:display.c     **** 					*(float *)factor = ((ftype & PINC) ? sdata : atoff( number )) / con;
 4687              		.loc 1 1118 0
 4688 0562 4346     		mov	r3, r8
 4689 0564 002B     		cmp	r3, #0
 4690 0566 03D1     		bne	.L308
 4691              		.loc 1 1118 0 is_stmt 0 discriminator 1
 4692 0568 2A48     		ldr	r0, .L360+16
 4693 056a FFF7FEFF 		bl	atoff
 4694              	.LVL554:
 4695 056e 01E0     		b	.L309
 4696              	.L308:
 4697              		.loc 1 1118 0 discriminator 2
 4698 0570 2B4B     		ldr	r3, .L360+28
 4699 0572 1868     		ldr	r0, [r3]
 4700              	.L309:
 4701              		.loc 1 1118 0 discriminator 3
 4702 0574 0B99     		ldr	r1, [sp, #44]
 4703 0576 FFF7FEFF 		bl	__aeabi_fdiv
 4704              	.LVL555:
 4705 057a 041C     		add	r4, r0, #0
1119:display.c     **** 					if( *(float *)factor > max )
 4706              		.loc 1 1119 0 is_stmt 1 discriminator 3
 4707 057c 0D98     		ldr	r0, [sp, #52]
 4708 057e 211C     		add	r1, r4, #0
 4709 0580 FFF7FEFF 		bl	__aeabi_fcmplt
 4710              	.LVL556:
 4711 0584 0028     		cmp	r0, #0
 4712 0586 03D0     		beq	.L356
1120:display.c     **** 					{
1121:display.c     **** 						*(float *)factor = max;
 4713              		.loc 1 1121 0
 4714 0588 0D99     		ldr	r1, [sp, #52]
 4715 058a 2298     		ldr	r0, [sp, #136]
 4716 058c 0160     		str	r1, [r0]
 4717 058e 0BE0     		b	.L293
 4718              	.L356:
1122:display.c     **** 					}
1123:display.c     **** 					else if( *(float *)factor < min )
 4719              		.loc 1 1123 0
 4720 0590 0C98     		ldr	r0, [sp, #48]
 4721 0592 211C     		add	r1, r4, #0
 4722 0594 FFF7FEFF 		bl	__aeabi_fcmpgt
 4723              	.LVL557:
 4724 0598 0028     		cmp	r0, #0
 4725 059a 02D1     		bne	.L312
1118:display.c     **** 					*(float *)factor = ((ftype & PINC) ? sdata : atoff( number )) / con;
 4726              		.loc 1 1118 0
 4727 059c 229A     		ldr	r2, [sp, #136]
 4728 059e 1460     		str	r4, [r2]
 4729 05a0 02E0     		b	.L293
 4730              	.L312:
1124:display.c     **** 					{
1125:display.c     **** 						*(float *)factor = min;
 4731              		.loc 1 1125 0
 4732 05a2 0C98     		ldr	r0, [sp, #48]
 4733 05a4 229B     		ldr	r3, [sp, #136]
 4734 05a6 1860     		str	r0, [r3]
 4735              	.L293:
1126:display.c     **** 					}
1127:display.c     **** 					break;
1128:display.c     **** 				}
1129:display.c     **** 
1130:display.c     **** 				// if factor is in pFac address space then save to flash
1131:display.c     **** 				if( ((unsigned char *)factor >= &(pFac.ch[0])) && ((unsigned char *)factor < (unsigned char *)&
 4736              		.loc 1 1131 0
 4737 05a8 1E4B     		ldr	r3, .L360+32
 4738 05aa 2299     		ldr	r1, [sp, #136]
 4739 05ac 9942     		cmp	r1, r3
 4740 05ae 05D3     		bcc	.L313
 4741              		.loc 1 1131 0 is_stmt 0 discriminator 1
 4742 05b0 1D4B     		ldr	r3, .L360+36
 4743 05b2 9942     		cmp	r1, r3
 4744 05b4 02D2     		bcs	.L313
1132:display.c     **** 				{
1133:display.c     **** 					savecal = 1;
 4745              		.loc 1 1133 0 is_stmt 1
 4746 05b6 0122     		mov	r2, #1
 4747 05b8 1C4B     		ldr	r3, .L360+40
 4748 05ba 1A70     		strb	r2, [r3]
 4749              	.L313:
1134:display.c     **** 				}
1135:display.c     **** 				valuechanged = 1;
 4750              		.loc 1 1135 0
 4751 05bc 0122     		mov	r2, #1
 4752 05be 1C4B     		ldr	r3, .L360+44
 4753 05c0 1A70     		strb	r2, [r3]
 4754              	.L269:
1136:display.c     **** 			}
1137:display.c     **** 
1138:display.c     **** 		}
1139:display.c     **** 	}
1140:display.c     **** 
1141:display.c     **** 	wi = 0;
1142:display.c     **** 	pt = &tstring[0];
 4755              		.loc 1 1142 0 discriminator 1
 4756 05c2 0EAB     		add	r3, sp, #56
1143:display.c     **** 	while( *pt )
1144:display.c     **** 	{
1145:display.c     **** 		ch = *pt;
1146:display.c     **** 		switch( ch )
1147:display.c     **** 		{
1148:display.c     **** 		case '0':
1149:display.c     **** 		case '1':
1150:display.c     **** 		case '2':
1151:display.c     **** 		case '3':
1152:display.c     **** 		case '4':
1153:display.c     **** 		case '5':
1154:display.c     **** 		case '6':
1155:display.c     **** 		case '7':
1156:display.c     **** 		case '8':
1157:display.c     **** 		case '9':
1158:display.c     **** 			ch = ch - '0';
1159:display.c     **** 			break;
1160:display.c     **** 
1161:display.c     **** 		case '.':
1162:display.c     **** 			ch = 10;
1163:display.c     **** 			break;
1164:display.c     **** 
1165:display.c     **** 		case '+':
1166:display.c     **** 			ch = 11;
1167:display.c     **** 			break;
1168:display.c     **** 
1169:display.c     **** 		case '-':
1170:display.c     **** 			ch = 12;
1171:display.c     **** 			break;
1172:display.c     **** 
1173:display.c     **** 		default: // unknown
1174:display.c     **** 			ch = 13;
 4757              		.loc 1 1174 0 discriminator 1
 4758 05c4 0020     		mov	r0, #0
 4759 05c6 0D22     		mov	r2, #13
 4760 05c8 9346     		mov	fp, r2
1146:display.c     **** 		switch( ch )
 4761              		.loc 1 1146 0 discriminator 1
 4762 05ca 1A4E     		ldr	r6, .L360+48
1166:display.c     **** 			ch = 11;
 4763              		.loc 1 1166 0 discriminator 1
 4764 05cc 0B21     		mov	r1, #11
 4765 05ce 8A46     		mov	sl, r1
 4766              	.LVL558:
1170:display.c     **** 			ch = 12;
 4767              		.loc 1 1170 0 discriminator 1
 4768 05d0 0C22     		mov	r2, #12
 4769 05d2 9146     		mov	r9, r2
1162:display.c     **** 			ch = 10;
 4770              		.loc 1 1162 0 discriminator 1
 4771 05d4 0A21     		mov	r1, #10
 4772 05d6 8C46     		mov	ip, r1
 4773 05d8 41E0     		b	.L353
 4774              	.LVL559:
 4775              	.L322:
1146:display.c     **** 		switch( ch )
 4776              		.loc 1 1146 0
 4777 05da 111C     		mov	r1, r2
 4778 05dc 2B39     		sub	r1, r1, #43
 4779 05de 0C06     		lsl	r4, r1, #24
 4780 05e0 240E     		lsr	r4, r4, #24
 4781 05e2 0E2C     		cmp	r4, #14
 4782 05e4 0BD8     		bhi	.L315
 4783 05e6 0906     		lsl	r1, r1, #24
 4784 05e8 890D     		lsr	r1, r1, #22
 4785 05ea 7158     		ldr	r1, [r6, r1]
 4786 05ec 8F46     		mov	pc, r1
 4787              		.section	.rodata.display_number,"a",%progbits
 4788              		.align	2
 4789              	.L320:
 4790 0000 38060000 		.word	.L338
 4791 0004 FE050000 		.word	.L315
 4792 0008 FA050000 		.word	.L317
 4793 000c EE050000 		.word	.L318
 4794 0010 FE050000 		.word	.L315
 4795 0014 F2050000 		.word	.L319
 4796 0018 F2050000 		.word	.L319
 4797 001c F2050000 		.word	.L319
 4798 0020 F2050000 		.word	.L319
 4799 0024 F2050000 		.word	.L319
 4800 0028 F2050000 		.word	.L319
 4801 002c F2050000 		.word	.L319
 4802 0030 F2050000 		.word	.L319
 4803 0034 F2050000 		.word	.L319
 4804 0038 F2050000 		.word	.L319
 4805              		.section	.text.display_number
 4806              	.L318:
1162:display.c     **** 			ch = 10;
 4807              		.loc 1 1162 0
 4808 05ee 6246     		mov	r2, ip
 4809              	.LVL560:
 4810 05f0 23E0     		b	.L316
 4811              	.LVL561:
 4812              	.L319:
1158:display.c     **** 			ch = ch - '0';
 4813              		.loc 1 1158 0
 4814 05f2 303A     		sub	r2, r2, #48
 4815              	.LVL562:
 4816 05f4 1206     		lsl	r2, r2, #24
 4817              	.LVL563:
 4818 05f6 120E     		lsr	r2, r2, #24
 4819              	.LVL564:
1159:display.c     **** 			break;
 4820              		.loc 1 1159 0
 4821 05f8 1FE0     		b	.L316
 4822              	.L317:
 4823              	.LVL565:
1170:display.c     **** 			ch = 12;
 4824              		.loc 1 1170 0
 4825 05fa 4A46     		mov	r2, r9
1171:display.c     **** 			break;
 4826              		.loc 1 1171 0
 4827 05fc 1DE0     		b	.L316
 4828              	.LVL566:
 4829              	.L315:
 4830              		.loc 1 1174 0
 4831 05fe 5A46     		mov	r2, fp
1175:display.c     **** 			break;
 4832              		.loc 1 1175 0
 4833 0600 1BE0     		b	.L316
 4834              	.L361:
 4835 0602 C046     		.align	2
 4836              	.L360:
 4837 0604 00000000 		.word	key
 4838 0608 08000080 		.word	-2147483640
 4839 060c 00000000 		.word	editing
 4840 0610 00000000 		.word	looptime
 4841 0614 00000000 		.word	number
 4842 0618 00000000 		.word	.LANCHOR3
 4843 061c 00000000 		.word	escape
 4844 0620 00000000 		.word	.LANCHOR2
 4845 0624 00000000 		.word	pFac
 4846 0628 20010000 		.word	pFac+288
 4847 062c 00000000 		.word	savecal
 4848 0630 00000000 		.word	valuechanged
 4849 0634 00000000 		.word	.L320
 4850              	.LVL567:
 4851              	.L338:
1166:display.c     **** 			ch = 11;
 4852              		.loc 1 1166 0
 4853 0638 5246     		mov	r2, sl
 4854              	.LVL568:
 4855              	.L316:
1176:display.c     **** 		}
1177:display.c     **** 
1178:display.c     **** 		// save value + 1, so '0' is not 0x00
1179:display.c     **** 		*pt = ch + 1;
 4856              		.loc 1 1179 0
 4857 063a 511C     		add	r1, r2, #1
 4858 063c 1970     		strb	r1, [r3]
1180:display.c     **** 
1181:display.c     **** 		// width of character
1182:display.c     **** 		wi += font->bitmap[ch][0];
 4859              		.loc 1 1182 0
 4860 063e 9200     		lsl	r2, r2, #2
 4861              	.LVL569:
 4862 0640 AA18     		add	r2, r5, r2
 4863 0642 5268     		ldr	r2, [r2, #4]
 4864 0644 1278     		ldrb	r2, [r2]
 4865 0646 8018     		add	r0, r0, r2
 4866              	.LVL570:
 4867 0648 0006     		lsl	r0, r0, #24
 4868 064a 000E     		lsr	r0, r0, #24
 4869              	.LVL571:
1183:display.c     **** 
1184:display.c     **** 		pt++;
 4870              		.loc 1 1184 0
 4871 064c 0133     		add	r3, r3, #1
 4872              	.LVL572:
1185:display.c     **** 
1186:display.c     **** 		// last character needs no space
1187:display.c     **** 		if( *pt )
 4873              		.loc 1 1187 0
 4874 064e 1A78     		ldrb	r2, [r3]
 4875 0650 002A     		cmp	r2, #0
 4876 0652 04D0     		beq	.L353
1188:display.c     **** 		{
1189:display.c     **** 			wi += font->gap - 1;
 4877              		.loc 1 1189 0
 4878 0654 2A78     		ldrb	r2, [r5]
 4879 0656 013A     		sub	r2, r2, #1
 4880 0658 8018     		add	r0, r0, r2
 4881              	.LVL573:
 4882 065a 0006     		lsl	r0, r0, #24
 4883 065c 000E     		lsr	r0, r0, #24
 4884              	.LVL574:
 4885              	.L353:
1143:display.c     **** 	while( *pt )
 4886              		.loc 1 1143 0 discriminator 1
 4887 065e 1A78     		ldrb	r2, [r3]
 4888 0660 002A     		cmp	r2, #0
 4889 0662 BAD1     		bne	.L322
1190:display.c     **** 		}
1191:display.c     **** 	}
1192:display.c     **** 
1193:display.c     **** 	if( (just & dn_JUST) == RIGHT )
 4890              		.loc 1 1193 0
 4891 0664 059A     		ldr	r2, [sp, #20]
 4892 0666 002A     		cmp	r2, #0
 4893 0668 02D0     		beq	.L323
1194:display.c     **** 	{
1195:display.c     **** 		xc -= wi;
 4894              		.loc 1 1195 0
 4895 066a 3F1A     		sub	r7, r7, r0
 4896 066c 3F06     		lsl	r7, r7, #24
 4897 066e 3F0E     		lsr	r7, r7, #24
 4898              	.LVL575:
 4899              	.L323:
1196:display.c     **** 	}
1197:display.c     **** 
1198:display.c     **** 	pt = &tstring[0];
1199:display.c     **** 	ed = 1;
1200:display.c     **** 	while( *pt )
 4900              		.loc 1 1200 0 discriminator 1
 4901 0670 0EAB     		add	r3, sp, #56
 4902              	.LVL576:
 4903 0672 1B78     		ldrb	r3, [r3]
 4904              	.LVL577:
 4905 0674 002B     		cmp	r3, #0
 4906 0676 45D0     		beq	.L339
1198:display.c     **** 	pt = &tstring[0];
 4907              		.loc 1 1198 0
 4908 0678 0EAC     		add	r4, sp, #56
 4909              	.LVL578:
 811:display.c     **** unsigned char display_number( float data, float min, float max, float con,
 4910              		.loc 1 811 0
 4911 067a 0121     		mov	r1, #1
 4912 067c 091B     		sub	r1, r1, r4
 4913 067e 8B46     		mov	fp, r1
1201:display.c     **** 	{
1202:display.c     **** 		ch = *pt - 1;
1203:display.c     **** 
1204:display.c     **** 		write_bitmap( adm, font->bitmap[ch], xc, yc, OR );
 4914              		.loc 1 1204 0
 4915 0680 3648     		ldr	r0, .L362
 4916              	.LVL579:
 4917 0682 8246     		mov	sl, r0
 4918              	.LVL580:
 4919              	.L326:
 811:display.c     **** unsigned char display_number( float data, float min, float max, float con,
 4920              		.loc 1 811 0
 4921 0684 5946     		mov	r1, fp
 4922 0686 0A19     		add	r2, r1, r4
 4923 0688 1206     		lsl	r2, r2, #24
 4924 068a 120E     		lsr	r2, r2, #24
 4925 068c 9146     		mov	r9, r2
 4926              	.LVL581:
1202:display.c     **** 		ch = *pt - 1;
 4927              		.loc 1 1202 0
 4928 068e 5E1E     		sub	r6, r3, #1
 4929              		.loc 1 1204 0
 4930 0690 3606     		lsl	r6, r6, #24
 4931 0692 B60D     		lsr	r6, r6, #22
 4932 0694 AE19     		add	r6, r5, r6
 4933 0696 7168     		ldr	r1, [r6, #4]
 4934 0698 0223     		mov	r3, #2
 4935              	.LVL582:
 4936 069a 0093     		str	r3, [sp]
 4937 069c 5046     		mov	r0, sl
 4938 069e 3A1C     		mov	r2, r7
 4939 06a0 039B     		ldr	r3, [sp, #12]
 4940 06a2 FFF7FEFF 		bl	write_bitmap
 4941              	.LVL583:
1205:display.c     **** 		wi = xc;
1206:display.c     **** 		xc += font->bitmap[ch][0];
 4942              		.loc 1 1206 0
 4943 06a6 7368     		ldr	r3, [r6, #4]
 4944 06a8 1E78     		ldrb	r6, [r3]
 4945 06aa BE19     		add	r6, r7, r6
 4946 06ac 3606     		lsl	r6, r6, #24
 4947 06ae 360E     		lsr	r6, r6, #24
 4948              	.LVL584:
1207:display.c     **** 
1208:display.c     **** 		if( !(ftype & PINC) && (just & EDIT) && editing && (editing == ed) )
 4949              		.loc 1 1208 0
 4950 06b0 4246     		mov	r2, r8
 4951 06b2 002A     		cmp	r2, #0
 4952 06b4 1CD1     		bne	.L325
 4953              		.loc 1 1208 0 is_stmt 0 discriminator 1
 4954 06b6 049B     		ldr	r3, [sp, #16]
 4955 06b8 002B     		cmp	r3, #0
 4956 06ba 19D0     		beq	.L325
 4957 06bc 284B     		ldr	r3, .L362+4
 4958 06be 1B78     		ldrb	r3, [r3]
 4959 06c0 002B     		cmp	r3, #0
 4960 06c2 15D0     		beq	.L325
 4961 06c4 4B45     		cmp	r3, r9
 4962 06c6 13D1     		bne	.L325
1209:display.c     **** 		{
1210:display.c     **** 			if( !key && !half_second )
 4963              		.loc 1 1210 0 is_stmt 1
 4964 06c8 264B     		ldr	r3, .L362+8
 4965 06ca 1B68     		ldr	r3, [r3]
 4966 06cc 002B     		cmp	r3, #0
 4967 06ce 0FD1     		bne	.L325
 4968              		.loc 1 1210 0 is_stmt 0 discriminator 1
 4969 06d0 254B     		ldr	r3, .L362+12
 4970 06d2 1B78     		ldrb	r3, [r3]
 4971 06d4 002B     		cmp	r3, #0
 4972 06d6 0BD1     		bne	.L325
1211:display.c     **** 			{
1212:display.c     **** 				draw_box( adm, wi-1, yc-1, xc, hi+1, INV ); // invert character
 4973              		.loc 1 1212 0 is_stmt 1
 4974 06d8 791E     		sub	r1, r7, #1
 4975 06da 0906     		lsl	r1, r1, #24
 4976 06dc 090E     		lsr	r1, r1, #24
 4977 06de 0698     		ldr	r0, [sp, #24]
 4978 06e0 0090     		str	r0, [sp]
 4979 06e2 0423     		mov	r3, #4
 4980 06e4 0193     		str	r3, [sp, #4]
 4981 06e6 1D48     		ldr	r0, .L362
 4982 06e8 079A     		ldr	r2, [sp, #28]
 4983 06ea 331C     		mov	r3, r6
 4984 06ec FFF7FEFF 		bl	draw_box
 4985              	.LVL585:
 4986              	.L325:
1213:display.c     **** 				// draw_box( adm, x1, yc-1, x2, hi+1, INV ); // invert whole string
1214:display.c     **** 				//draw_box( adm, wi-1, yc-1, xc, hi+1, CLEAR ); // blank character
1215:display.c     **** 			}
1216:display.c     **** 			//draw_box( adm, wi, hi+1, xc-1, hi+2, ch ? EMPTY : CLEAR ); // underscore
1217:display.c     **** 		}
1218:display.c     **** 
1219:display.c     **** 		// check to see if last character, if not add gap
1220:display.c     **** 		pt++;
 4987              		.loc 1 1220 0
 4988 06f0 0134     		add	r4, r4, #1
 4989              	.LVL586:
1221:display.c     **** 		if( *pt )
 4990              		.loc 1 1221 0
 4991 06f2 2378     		ldrb	r3, [r4]
 4992 06f4 002B     		cmp	r3, #0
 4993 06f6 06D0     		beq	.L324
1222:display.c     **** 		{
1223:display.c     **** 			xc += font->gap - 1;
 4994              		.loc 1 1223 0
 4995 06f8 2F78     		ldrb	r7, [r5]
 4996              	.LVL587:
 4997 06fa 013F     		sub	r7, r7, #1
 4998 06fc F719     		add	r7, r6, r7
 4999 06fe 3F06     		lsl	r7, r7, #24
 5000 0700 3F0E     		lsr	r7, r7, #24
 5001              	.LVL588:
 5002 0702 BFE7     		b	.L326
 5003              	.LVL589:
 5004              	.L339:
1200:display.c     **** 	while( *pt )
 5005              		.loc 1 1200 0
 5006 0704 3E1C     		mov	r6, r7
 5007              	.LVL590:
 5008              	.L324:
1224:display.c     **** 		}
1225:display.c     **** 		ed++;
1226:display.c     **** 	}
1227:display.c     **** 
1228:display.c     **** 	if( (ftype & PINC) && (just & EDIT) && editing ) // simple increment & editing, flash all
 5009              		.loc 1 1228 0
 5010 0706 4146     		mov	r1, r8
 5011 0708 0029     		cmp	r1, #0
 5012 070a 1DD0     		beq	.L346
 5013              		.loc 1 1228 0 is_stmt 0 discriminator 1
 5014 070c 049A     		ldr	r2, [sp, #16]
 5015 070e 002A     		cmp	r2, #0
 5016 0710 1AD0     		beq	.L346
 5017 0712 134B     		ldr	r3, .L362+4
 5018 0714 1B78     		ldrb	r3, [r3]
 5019 0716 002B     		cmp	r3, #0
 5020 0718 16D0     		beq	.L346
1229:display.c     **** 	{
1230:display.c     **** 		if( !half_second )
 5021              		.loc 1 1230 0 is_stmt 1
 5022 071a 134B     		ldr	r3, .L362+12
 5023 071c 1B78     		ldrb	r3, [r3]
 5024 071e 002B     		cmp	r3, #0
 5025 0720 12D1     		bne	.L346
1231:display.c     **** 		{
1232:display.c     **** 			draw_box( adm, x1, yc-1, x2, hi+1, INV ); // flash all
 5026              		.loc 1 1232 0
 5027 0722 069B     		ldr	r3, [sp, #24]
 5028 0724 0093     		str	r3, [sp]
 5029 0726 0423     		mov	r3, #4
 5030 0728 0193     		str	r3, [sp, #4]
 5031 072a 0C48     		ldr	r0, .L362
 5032 072c 0899     		ldr	r1, [sp, #32]
 5033 072e 079A     		ldr	r2, [sp, #28]
 5034 0730 099B     		ldr	r3, [sp, #36]
 5035 0732 FFF7FEFF 		bl	draw_box
 5036              	.LVL591:
 5037 0736 07E0     		b	.L346
 5038              	.LVL592:
 5039              	.L254:
 902:display.c     **** 	if( !(ftype & PINC) && (just & EDIT) && editing )  // digit program
 5040              		.loc 1 902 0
 5041 0738 E007     		lsl	r0, r4, #31
 5042 073a 00D5     		bpl	.LCB5397
 5043 073c 24E5     		b	.L328	@long jump
 5044              	.LCB5397:
 5045 073e 28E5     		b	.L329
 5046              	.L263:
 935:display.c     **** 	if( !(ftype & PINC) && (just & EDIT) ) // digit program
 5047              		.loc 1 935 0
 5048 0740 0123     		mov	r3, #1
 5049 0742 2340     		and	r3, r4
 5050 0744 0493     		str	r3, [sp, #16]
 5051 0746 71E5     		b	.L332
 5052              	.LVL593:
 5053              	.L346:
1233:display.c     **** 		}
1234:display.c     **** 	}
1235:display.c     **** 
1236:display.c     **** 	//if( (just & EDIT) && !editing )
1237:display.c     **** 	//  {
1238:display.c     **** 	//  draw_box( adm, x1, yc-1, x2, hi+1, INV );
1239:display.c     **** 	//  }
1240:display.c     **** 
1241:display.c     **** 	return( xc );
1242:display.c     **** }
 5054              		.loc 1 1242 0
 5055 0748 301C     		mov	r0, r6
 5056 074a 13B0     		add	sp, sp, #76
 5057              		@ sp needed for prologue
 5058 074c 3CBC     		pop	{r2, r3, r4, r5}
 5059 074e 9046     		mov	r8, r2
 5060 0750 9946     		mov	r9, r3
 5061 0752 A246     		mov	sl, r4
 5062 0754 AB46     		mov	fp, r5
 5063 0756 F0BC     		pop	{r4, r5, r6, r7}
 5064 0758 02BC     		pop	{r1}
 5065 075a 0847     		bx	r1
 5066              	.L363:
 5067              		.align	2
 5068              	.L362:
 5069 075c 00000000 		.word	adm
 5070 0760 00000000 		.word	editing
 5071 0764 00000000 		.word	key
 5072 0768 00000000 		.word	half_second
 5073              		.cfi_endproc
 5074              	.LFE385:
 5076              		.section	.text.draw_frame,"ax",%progbits
 5077              		.align	2
 5078              		.global	draw_frame
 5079              		.code	16
 5080              		.thumb_func
 5082              	draw_frame:
 5083              	.LFB386:
1243:display.c     **** // -----------------------------------------------------------
1244:display.c     **** 
1245:display.c     **** 
1246:display.c     **** // -----------------------------------------------------------
1247:display.c     **** // Function Name       : draw_frame
1248:display.c     **** // -----------------------------------------------------------
1249:display.c     **** void draw_frame( unsigned char *pt )
1250:display.c     **** {
 5084              		.loc 1 1250 0
 5085              		.cfi_startproc
 5086              	.LVL594:
 5087 0000 70B5     		push	{r4, r5, r6, lr}
 5088              	.LCFI25:
 5089              		.cfi_def_cfa_offset 16
 5090              		.cfi_offset 4, -16
 5091              		.cfi_offset 5, -12
 5092              		.cfi_offset 6, -8
 5093              		.cfi_offset 14, -4
 5094 0002 82B0     		sub	sp, sp, #8
 5095              	.LCFI26:
 5096              		.cfi_def_cfa_offset 24
 5097 0004 041C     		mov	r4, r0
 5098              	.LVL595:
1251:display.c     **** 	unsigned int i;
1252:display.c     **** 
1253:display.c     **** 	// clear global display buffer
1254:display.c     **** 	for( i = 0; i < GRAPHICS_SIZE; i++ )
 5099              		.loc 1 1254 0
 5100 0006 0023     		mov	r3, #0
1255:display.c     **** 	{
1256:display.c     **** 		*(pt+i) = 0x00;
 5101              		.loc 1 1256 0
 5102 0008 0021     		mov	r1, #0
1254:display.c     **** 	for( i = 0; i < GRAPHICS_SIZE; i++ )
 5103              		.loc 1 1254 0
 5104 000a A022     		mov	r2, #160
 5105 000c 1201     		lsl	r2, r2, #4
 5106              	.LVL596:
 5107              	.L365:
 5108              		.loc 1 1256 0 discriminator 2
 5109 000e E154     		strb	r1, [r4, r3]
1254:display.c     **** 	for( i = 0; i < GRAPHICS_SIZE; i++ )
 5110              		.loc 1 1254 0 discriminator 2
 5111 0010 0133     		add	r3, r3, #1
 5112              	.LVL597:
 5113 0012 9342     		cmp	r3, r2
 5114 0014 FBD1     		bne	.L365
1257:display.c     **** 	}
1258:display.c     **** 	// draw empty frame
1259:display.c     **** 	draw_line( pt, 0,   0, 159,   0, OR );
 5115              		.loc 1 1259 0
 5116 0016 0023     		mov	r3, #0
 5117              	.LVL598:
 5118 0018 0093     		str	r3, [sp]
 5119 001a 0225     		mov	r5, #2
 5120 001c 0195     		str	r5, [sp, #4]
 5121 001e 201C     		mov	r0, r4
 5122              	.LVL599:
 5123 0020 0021     		mov	r1, #0
 5124 0022 0022     		mov	r2, #0
 5125 0024 9F23     		mov	r3, #159
 5126 0026 FFF7FEFF 		bl	draw_line
 5127              	.LVL600:
1260:display.c     **** 	draw_line( pt, 0,   0,   0, 127, OR );
 5128              		.loc 1 1260 0
 5129 002a 7F26     		mov	r6, #127
 5130 002c 0096     		str	r6, [sp]
 5131 002e 0195     		str	r5, [sp, #4]
 5132 0030 201C     		mov	r0, r4
 5133 0032 0021     		mov	r1, #0
 5134 0034 0022     		mov	r2, #0
 5135 0036 0023     		mov	r3, #0
 5136 0038 FFF7FEFF 		bl	draw_line
 5137              	.LVL601:
1261:display.c     **** 	draw_line( pt, 0, 127, 159, 127, OR );
 5138              		.loc 1 1261 0
 5139 003c 0096     		str	r6, [sp]
 5140 003e 0195     		str	r5, [sp, #4]
 5141 0040 201C     		mov	r0, r4
 5142 0042 0021     		mov	r1, #0
 5143 0044 7F22     		mov	r2, #127
 5144 0046 9F23     		mov	r3, #159
 5145 0048 FFF7FEFF 		bl	draw_line
 5146              	.LVL602:
1262:display.c     **** 	draw_line( pt, 159, 0, 159, 127, OR );
 5147              		.loc 1 1262 0
 5148 004c 0096     		str	r6, [sp]
 5149 004e 0195     		str	r5, [sp, #4]
 5150 0050 201C     		mov	r0, r4
 5151 0052 9F21     		mov	r1, #159
 5152 0054 0022     		mov	r2, #0
 5153 0056 9F23     		mov	r3, #159
 5154 0058 FFF7FEFF 		bl	draw_line
 5155              	.LVL603:
1263:display.c     **** }    
 5156              		.loc 1 1263 0
 5157 005c 02B0     		add	sp, sp, #8
 5158              		@ sp needed for prologue
 5159              	.LVL604:
 5160 005e 70BC     		pop	{r4, r5, r6}
 5161 0060 01BC     		pop	{r0}
 5162 0062 0047     		bx	r0
 5163              		.cfi_endproc
 5164              	.LFE386:
 5166              		.section	.text.SendToDisplay,"ax",%progbits
 5167              		.align	2
 5168              		.global	SendToDisplay
 5169              		.code	16
 5170              		.thumb_func
 5172              	SendToDisplay:
 5173              	.LFB387:
1264:display.c     **** // -----------------------------------------------------------
1265:display.c     **** 
1266:display.c     **** 
1267:display.c     **** #ifndef WINDOWS
1268:display.c     **** 
1269:display.c     **** // --- Hardware specific functions below --- 
1270:display.c     **** 
1271:display.c     **** // -----------------------------------------------------------
1272:display.c     **** // Function Name       : SendToDisplay
1273:display.c     **** // -----------------------------------------------------------
1274:display.c     **** void SendToDisplay( unsigned char *pbuffer, int count, char mode )
1275:display.c     **** {
 5174              		.loc 1 1275 0
 5175              		.cfi_startproc
 5176              	.LVL605:
 5177 0000 30B5     		push	{r4, r5, lr}
 5178              	.LCFI27:
 5179              		.cfi_def_cfa_offset 12
 5180              		.cfi_offset 4, -12
 5181              		.cfi_offset 5, -8
 5182              		.cfi_offset 14, -4
1276:display.c     **** 	// wait until SPI PDC ready
1277:display.c     **** 	while( !(AT91C_BASE_SPI0->SPI_SR & AT91C_SPI_TXBUFE) )
 5183              		.loc 1 1277 0
 5184 0002 094D     		ldr	r5, .L370
 5185 0004 8024     		mov	r4, #128
 5186              	.L368:
 5187              		.loc 1 1277 0 is_stmt 0 discriminator 1
 5188 0006 2B69     		ldr	r3, [r5, #16]
 5189 0008 1C42     		tst	r4, r3
 5190 000a FCD0     		beq	.L368
1278:display.c     **** 	{
1279:display.c     **** 	}
1280:display.c     **** 
1281:display.c     **** 	// set command or data mode
1282:display.c     **** 	AT91F_SPI_CfgMode( AT91C_BASE_SPI0,
1283:display.c     **** 			AT91C_SPI_MSTR |
1284:display.c     **** 			AT91C_SPI_PS_FIXED | (AT91C_SPI_PCS & ((unsigned int)mode << 16)) ); // CS1 == command/CS0 = dat
 5191              		.loc 1 1284 0 is_stmt 1
 5192 000c 1204     		lsl	r2, r2, #16
 5193              	.LVL606:
 5194 000e F023     		mov	r3, #240
 5195 0010 1B03     		lsl	r3, r3, #12
 5196 0012 1A40     		and	r2, r3
 5197 0014 0123     		mov	r3, #1
 5198 0016 1A43     		orr	r2, r3
 5199              	.LVL607:
 5200              	.LBB32:
 5201              	.LBB33:
 5202              		.file 2 "./include/lib_AT91SAM7A3.h"
   1:./include/lib_AT91SAM7A3.h **** //* ----------------------------------------------------------------------------
   2:./include/lib_AT91SAM7A3.h **** //*         ATMEL Microcontroller Software Support  -  ROUSSET  -
   3:./include/lib_AT91SAM7A3.h **** //* ----------------------------------------------------------------------------
   4:./include/lib_AT91SAM7A3.h **** //* DISCLAIMER:  THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
   5:./include/lib_AT91SAM7A3.h **** //* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   6:./include/lib_AT91SAM7A3.h **** //* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
   7:./include/lib_AT91SAM7A3.h **** //* DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
   8:./include/lib_AT91SAM7A3.h **** //* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   9:./include/lib_AT91SAM7A3.h **** //* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  10:./include/lib_AT91SAM7A3.h **** //* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  11:./include/lib_AT91SAM7A3.h **** //* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  12:./include/lib_AT91SAM7A3.h **** //* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  13:./include/lib_AT91SAM7A3.h **** //* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  14:./include/lib_AT91SAM7A3.h **** //* ----------------------------------------------------------------------------
  15:./include/lib_AT91SAM7A3.h **** //* File Name           : lib_AT91SAM7A3.h
  16:./include/lib_AT91SAM7A3.h **** //* Object              : AT91SAM7A3 inlined functions
  17:./include/lib_AT91SAM7A3.h **** //* Generated           : AT91 SW Application Group  01/16/2006 (16:35:45)
  18:./include/lib_AT91SAM7A3.h **** //*
  19:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_MC_SAM.h/1.3/Thu Mar 25 15:19:14 2004//
  20:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_pdc.h/1.2/Tue Jul  2 13:29:40 2002//
  21:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_dbgu.h/1.1/Thu Aug 25 12:56:22 2005//
  22:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_shdwc_6122A.h/1.1/Wed Oct  6 14:06:00 2004//
  23:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_spi2.h/1.2/Tue Aug 23 15:37:28 2005//
  24:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_ssc.h/1.4/Fri Jan 31 12:19:20 2003//
  25:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_PWM_SAM.h/1.3/Thu Jan 22 10:10:50 2004//
  26:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_tc_1753b.h/1.1/Fri Jan 31 12:20:02 2003//
  27:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_pitc_6079A.h/1.2/Tue Nov  9 14:43:56 2004//
  28:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_adc.h/1.6/Fri Oct 17 09:12:38 2003//
  29:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_pmc_SAM.h/1.10/Fri Nov  4 09:39:44 2005//
  30:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_rstc_6098A.h/1.1/Wed Oct  6 10:39:20 2004//
  31:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_pio.h/1.3/Fri Jan 31 12:18:56 2003//
  32:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_rttc_6081A.h/1.1/Wed Oct  6 10:39:38 2004//
  33:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_twi.h/1.3/Mon Jul 19 14:27:58 2004//
  34:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_usart.h/1.5/Thu Nov 21 16:01:54 2002//
  35:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_mci.h/1.7/Wed May 19 09:27:28 2004//
  36:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_wdtc_6080A.h/1.1/Wed Oct  6 10:38:30 2004//
  37:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_udp.h/1.5/Tue Aug 30 12:13:47 2005//
  38:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_aic_6075b.h/1.2/Thu Jul  7 07:48:22 2005//
  39:./include/lib_AT91SAM7A3.h **** //* CVS Reference       : /lib_can_AT91.h/1.5/Tue Aug 23 15:37:07 2005//
  40:./include/lib_AT91SAM7A3.h **** //* ----------------------------------------------------------------------------
  41:./include/lib_AT91SAM7A3.h **** 
  42:./include/lib_AT91SAM7A3.h **** #ifndef lib_AT91SAM7A3_H
  43:./include/lib_AT91SAM7A3.h **** #define lib_AT91SAM7A3_H
  44:./include/lib_AT91SAM7A3.h **** 
  45:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
  46:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR AIC
  47:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
  48:./include/lib_AT91SAM7A3.h **** #define AT91C_AIC_BRANCH_OPCODE ((void (*) ()) 0xE51FFF20) // ldr, pc, [pc, #-&F20]
  49:./include/lib_AT91SAM7A3.h **** 
  50:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  51:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_ConfigureIt
  52:./include/lib_AT91SAM7A3.h **** //* \brief Interrupt Handler Initialization
  53:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  54:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_AIC_ConfigureIt (
  55:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,  // \arg pointer to the AIC registers
  56:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id,     // \arg interrupt number to initialize
  57:./include/lib_AT91SAM7A3.h **** 	unsigned int priority,   // \arg priority to give to the interrupt
  58:./include/lib_AT91SAM7A3.h **** 	unsigned int src_type,   // \arg activation and sense of activation
  59:./include/lib_AT91SAM7A3.h **** 	void (*newHandler) () ) // \arg address of the interrupt handler
  60:./include/lib_AT91SAM7A3.h **** {
  61:./include/lib_AT91SAM7A3.h **** 	unsigned int oldHandler;
  62:./include/lib_AT91SAM7A3.h ****     unsigned int mask ;
  63:./include/lib_AT91SAM7A3.h **** 
  64:./include/lib_AT91SAM7A3.h ****     oldHandler = pAic->AIC_SVR[irq_id];
  65:./include/lib_AT91SAM7A3.h **** 
  66:./include/lib_AT91SAM7A3.h ****     mask = 0x1 << irq_id ;
  67:./include/lib_AT91SAM7A3.h ****     //* Disable the interrupt on the interrupt controller
  68:./include/lib_AT91SAM7A3.h ****     pAic->AIC_IDCR = mask ;
  69:./include/lib_AT91SAM7A3.h ****     //* Save the interrupt handler routine pointer and the interrupt priority
  70:./include/lib_AT91SAM7A3.h ****     pAic->AIC_SVR[irq_id] = (unsigned int) newHandler ;
  71:./include/lib_AT91SAM7A3.h ****     //* Store the Source Mode Register
  72:./include/lib_AT91SAM7A3.h ****     pAic->AIC_SMR[irq_id] = src_type | priority  ;
  73:./include/lib_AT91SAM7A3.h ****     //* Clear the interrupt on the interrupt controller
  74:./include/lib_AT91SAM7A3.h ****     pAic->AIC_ICCR = mask ;
  75:./include/lib_AT91SAM7A3.h **** 
  76:./include/lib_AT91SAM7A3.h **** 	return oldHandler;
  77:./include/lib_AT91SAM7A3.h **** }
  78:./include/lib_AT91SAM7A3.h **** 
  79:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  80:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_EnableIt
  81:./include/lib_AT91SAM7A3.h **** //* \brief Enable corresponding IT number
  82:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  83:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_EnableIt (
  84:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
  85:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id ) // \arg interrupt number to initialize
  86:./include/lib_AT91SAM7A3.h **** {
  87:./include/lib_AT91SAM7A3.h ****     //* Enable the interrupt on the interrupt controller
  88:./include/lib_AT91SAM7A3.h ****     pAic->AIC_IECR = 0x1 << irq_id ;
  89:./include/lib_AT91SAM7A3.h **** }
  90:./include/lib_AT91SAM7A3.h **** 
  91:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  92:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_DisableIt
  93:./include/lib_AT91SAM7A3.h **** //* \brief Disable corresponding IT number
  94:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
  95:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_DisableIt (
  96:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
  97:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id ) // \arg interrupt number to initialize
  98:./include/lib_AT91SAM7A3.h **** {
  99:./include/lib_AT91SAM7A3.h ****     unsigned int mask = 0x1 << irq_id;
 100:./include/lib_AT91SAM7A3.h ****     //* Disable the interrupt on the interrupt controller
 101:./include/lib_AT91SAM7A3.h ****     pAic->AIC_IDCR = mask ;
 102:./include/lib_AT91SAM7A3.h ****     //* Clear the interrupt on the Interrupt Controller ( if one is pending )
 103:./include/lib_AT91SAM7A3.h ****     pAic->AIC_ICCR = mask ;
 104:./include/lib_AT91SAM7A3.h **** }
 105:./include/lib_AT91SAM7A3.h **** 
 106:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 107:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_ClearIt
 108:./include/lib_AT91SAM7A3.h **** //* \brief Clear corresponding IT number
 109:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 110:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_ClearIt (
 111:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 112:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id) // \arg interrupt number to initialize
 113:./include/lib_AT91SAM7A3.h **** {
 114:./include/lib_AT91SAM7A3.h ****     //* Clear the interrupt on the Interrupt Controller ( if one is pending )
 115:./include/lib_AT91SAM7A3.h ****     pAic->AIC_ICCR = (0x1 << irq_id);
 116:./include/lib_AT91SAM7A3.h **** }
 117:./include/lib_AT91SAM7A3.h **** 
 118:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 119:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_AcknowledgeIt
 120:./include/lib_AT91SAM7A3.h **** //* \brief Acknowledge corresponding IT number
 121:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 122:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_AcknowledgeIt (
 123:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic)     // \arg pointer to the AIC registers
 124:./include/lib_AT91SAM7A3.h **** {
 125:./include/lib_AT91SAM7A3.h ****     pAic->AIC_EOICR = pAic->AIC_EOICR;
 126:./include/lib_AT91SAM7A3.h **** }
 127:./include/lib_AT91SAM7A3.h **** 
 128:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 129:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_SetExceptionVector
 130:./include/lib_AT91SAM7A3.h **** //* \brief Configure vector handler
 131:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 132:./include/lib_AT91SAM7A3.h **** __inline unsigned int  AT91F_AIC_SetExceptionVector (
 133:./include/lib_AT91SAM7A3.h **** 	unsigned int *pVector, // \arg pointer to the AIC registers
 134:./include/lib_AT91SAM7A3.h **** 	void (*Handler) () )   // \arg Interrupt Handler
 135:./include/lib_AT91SAM7A3.h **** {
 136:./include/lib_AT91SAM7A3.h **** 	unsigned int oldVector = *pVector;
 137:./include/lib_AT91SAM7A3.h **** 
 138:./include/lib_AT91SAM7A3.h **** 	if ((unsigned int) Handler == (unsigned int) AT91C_AIC_BRANCH_OPCODE)
 139:./include/lib_AT91SAM7A3.h **** 		*pVector = (unsigned int) AT91C_AIC_BRANCH_OPCODE;
 140:./include/lib_AT91SAM7A3.h **** 	else
 141:./include/lib_AT91SAM7A3.h **** 		*pVector = (((((unsigned int) Handler) - ((unsigned int) pVector) - 0x8) >> 2) & 0x00FFFFFF) | 0x
 142:./include/lib_AT91SAM7A3.h **** 
 143:./include/lib_AT91SAM7A3.h **** 	return oldVector;
 144:./include/lib_AT91SAM7A3.h **** }
 145:./include/lib_AT91SAM7A3.h **** 
 146:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 147:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_Trig
 148:./include/lib_AT91SAM7A3.h **** //* \brief Trig an IT
 149:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 150:./include/lib_AT91SAM7A3.h **** __inline void  AT91F_AIC_Trig (
 151:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 152:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id) // \arg interrupt number
 153:./include/lib_AT91SAM7A3.h **** {
 154:./include/lib_AT91SAM7A3.h **** 	pAic->AIC_ISCR = (0x1 << irq_id) ;
 155:./include/lib_AT91SAM7A3.h **** }
 156:./include/lib_AT91SAM7A3.h **** 
 157:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 158:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_IsActive
 159:./include/lib_AT91SAM7A3.h **** //* \brief Test if an IT is active
 160:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 161:./include/lib_AT91SAM7A3.h **** __inline unsigned int  AT91F_AIC_IsActive (
 162:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 163:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id) // \arg Interrupt Number
 164:./include/lib_AT91SAM7A3.h **** {
 165:./include/lib_AT91SAM7A3.h **** 	return (pAic->AIC_ISR & (0x1 << irq_id));
 166:./include/lib_AT91SAM7A3.h **** }
 167:./include/lib_AT91SAM7A3.h **** 
 168:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 169:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_IsPending
 170:./include/lib_AT91SAM7A3.h **** //* \brief Test if an IT is pending
 171:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 172:./include/lib_AT91SAM7A3.h **** __inline unsigned int  AT91F_AIC_IsPending (
 173:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 174:./include/lib_AT91SAM7A3.h **** 	unsigned int irq_id) // \arg Interrupt Number
 175:./include/lib_AT91SAM7A3.h **** {
 176:./include/lib_AT91SAM7A3.h **** 	return (pAic->AIC_IPR & (0x1 << irq_id));
 177:./include/lib_AT91SAM7A3.h **** }
 178:./include/lib_AT91SAM7A3.h **** 
 179:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 180:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_AIC_Open
 181:./include/lib_AT91SAM7A3.h **** //* \brief Set exception vectors and AIC registers to default values
 182:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 183:./include/lib_AT91SAM7A3.h **** __inline void AT91F_AIC_Open(
 184:./include/lib_AT91SAM7A3.h **** 	AT91PS_AIC pAic,        // \arg pointer to the AIC registers
 185:./include/lib_AT91SAM7A3.h **** 	void (*IrqHandler) (),  // \arg Default IRQ vector exception
 186:./include/lib_AT91SAM7A3.h **** 	void (*FiqHandler) (),  // \arg Default FIQ vector exception
 187:./include/lib_AT91SAM7A3.h **** 	void (*DefaultHandler)  (), // \arg Default Handler set in ISR
 188:./include/lib_AT91SAM7A3.h **** 	void (*SpuriousHandler) (), // \arg Default Spurious Handler
 189:./include/lib_AT91SAM7A3.h **** 	unsigned int protectMode)   // \arg Debug Control Register
 190:./include/lib_AT91SAM7A3.h **** {
 191:./include/lib_AT91SAM7A3.h **** 	int i;
 192:./include/lib_AT91SAM7A3.h **** 
 193:./include/lib_AT91SAM7A3.h **** 	// Disable all interrupts and set IVR to the default handler
 194:./include/lib_AT91SAM7A3.h **** 	for (i = 0; i < 32; ++i) {
 195:./include/lib_AT91SAM7A3.h **** 		AT91F_AIC_DisableIt(pAic, i);
 196:./include/lib_AT91SAM7A3.h **** 		AT91F_AIC_ConfigureIt(pAic, i, AT91C_AIC_PRIOR_LOWEST, AT91C_AIC_SRCTYPE_HIGH_LEVEL, DefaultHandl
 197:./include/lib_AT91SAM7A3.h **** 	}
 198:./include/lib_AT91SAM7A3.h **** 
 199:./include/lib_AT91SAM7A3.h **** 	// Set the IRQ exception vector
 200:./include/lib_AT91SAM7A3.h **** 	AT91F_AIC_SetExceptionVector((unsigned int *) 0x18, IrqHandler);
 201:./include/lib_AT91SAM7A3.h **** 	// Set the Fast Interrupt exception vector
 202:./include/lib_AT91SAM7A3.h **** 	AT91F_AIC_SetExceptionVector((unsigned int *) 0x1C, FiqHandler);
 203:./include/lib_AT91SAM7A3.h **** 
 204:./include/lib_AT91SAM7A3.h **** 	pAic->AIC_SPU = (unsigned int) SpuriousHandler;
 205:./include/lib_AT91SAM7A3.h **** 	pAic->AIC_DCR = protectMode;
 206:./include/lib_AT91SAM7A3.h **** }
 207:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
 208:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR PDC
 209:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
 210:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 211:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SetNextRx
 212:./include/lib_AT91SAM7A3.h **** //* \brief Set the next receive transfer descriptor
 213:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 214:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_SetNextRx (
 215:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,     // \arg pointer to a PDC controller
 216:./include/lib_AT91SAM7A3.h **** 	char *address,       // \arg address to the next bloc to be received
 217:./include/lib_AT91SAM7A3.h **** 	unsigned int bytes)  // \arg number of bytes to be received
 218:./include/lib_AT91SAM7A3.h **** {
 219:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RNPR = (unsigned int) address;
 220:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RNCR = bytes;
 221:./include/lib_AT91SAM7A3.h **** }
 222:./include/lib_AT91SAM7A3.h **** 
 223:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 224:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SetNextTx
 225:./include/lib_AT91SAM7A3.h **** //* \brief Set the next transmit transfer descriptor
 226:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 227:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_SetNextTx (
 228:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
 229:./include/lib_AT91SAM7A3.h **** 	char *address,         // \arg address to the next bloc to be transmitted
 230:./include/lib_AT91SAM7A3.h **** 	unsigned int bytes)    // \arg number of bytes to be transmitted
 231:./include/lib_AT91SAM7A3.h **** {
 232:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TNPR = (unsigned int) address;
 233:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TNCR = bytes;
 234:./include/lib_AT91SAM7A3.h **** }
 235:./include/lib_AT91SAM7A3.h **** 
 236:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 237:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SetRx
 238:./include/lib_AT91SAM7A3.h **** //* \brief Set the receive transfer descriptor
 239:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 240:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_SetRx (
 241:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
 242:./include/lib_AT91SAM7A3.h **** 	char *address,         // \arg address to the next bloc to be received
 243:./include/lib_AT91SAM7A3.h **** 	unsigned int bytes)    // \arg number of bytes to be received
 244:./include/lib_AT91SAM7A3.h **** {
 245:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RPR = (unsigned int) address;
 246:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RCR = bytes;
 247:./include/lib_AT91SAM7A3.h **** }
 248:./include/lib_AT91SAM7A3.h **** 
 249:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 250:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SetTx
 251:./include/lib_AT91SAM7A3.h **** //* \brief Set the transmit transfer descriptor
 252:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 253:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_SetTx (
 254:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
 255:./include/lib_AT91SAM7A3.h **** 	char *address,         // \arg address to the next bloc to be transmitted
 256:./include/lib_AT91SAM7A3.h **** 	unsigned int bytes)    // \arg number of bytes to be transmitted
 257:./include/lib_AT91SAM7A3.h **** {
 258:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TPR = (unsigned int) address;
 259:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TCR = bytes;
 260:./include/lib_AT91SAM7A3.h **** }
 261:./include/lib_AT91SAM7A3.h **** 
 262:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 263:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_EnableTx
 264:./include/lib_AT91SAM7A3.h **** //* \brief Enable transmit
 265:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 266:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_EnableTx (
 267:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 268:./include/lib_AT91SAM7A3.h **** {
 269:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_PTCR = AT91C_PDC_TXTEN;
 270:./include/lib_AT91SAM7A3.h **** }
 271:./include/lib_AT91SAM7A3.h **** 
 272:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 273:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_EnableRx
 274:./include/lib_AT91SAM7A3.h **** //* \brief Enable receive
 275:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 276:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_EnableRx (
 277:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 278:./include/lib_AT91SAM7A3.h **** {
 279:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_PTCR = AT91C_PDC_RXTEN;
 280:./include/lib_AT91SAM7A3.h **** }
 281:./include/lib_AT91SAM7A3.h **** 
 282:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 283:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_DisableTx
 284:./include/lib_AT91SAM7A3.h **** //* \brief Disable transmit
 285:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 286:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_DisableTx (
 287:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 288:./include/lib_AT91SAM7A3.h **** {
 289:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_PTCR = AT91C_PDC_TXTDIS;
 290:./include/lib_AT91SAM7A3.h **** }
 291:./include/lib_AT91SAM7A3.h **** 
 292:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 293:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_DisableRx
 294:./include/lib_AT91SAM7A3.h **** //* \brief Disable receive
 295:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 296:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_DisableRx (
 297:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 298:./include/lib_AT91SAM7A3.h **** {
 299:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_PTCR = AT91C_PDC_RXTDIS;
 300:./include/lib_AT91SAM7A3.h **** }
 301:./include/lib_AT91SAM7A3.h **** 
 302:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 303:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_IsTxEmpty
 304:./include/lib_AT91SAM7A3.h **** //* \brief Test if the current transfer descriptor has been sent
 305:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 306:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PDC_IsTxEmpty ( // \return return 1 if transfer is complete
 307:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 308:./include/lib_AT91SAM7A3.h **** {
 309:./include/lib_AT91SAM7A3.h **** 	return !(pPDC->PDC_TCR);
 310:./include/lib_AT91SAM7A3.h **** }
 311:./include/lib_AT91SAM7A3.h **** 
 312:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 313:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_IsNextTxEmpty
 314:./include/lib_AT91SAM7A3.h **** //* \brief Test if the next transfer descriptor has been moved to the current td
 315:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 316:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PDC_IsNextTxEmpty ( // \return return 1 if transfer is complete
 317:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 318:./include/lib_AT91SAM7A3.h **** {
 319:./include/lib_AT91SAM7A3.h **** 	return !(pPDC->PDC_TNCR);
 320:./include/lib_AT91SAM7A3.h **** }
 321:./include/lib_AT91SAM7A3.h **** 
 322:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 323:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_IsRxEmpty
 324:./include/lib_AT91SAM7A3.h **** //* \brief Test if the current transfer descriptor has been filled
 325:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 326:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PDC_IsRxEmpty ( // \return return 1 if transfer is complete
 327:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 328:./include/lib_AT91SAM7A3.h **** {
 329:./include/lib_AT91SAM7A3.h **** 	return !(pPDC->PDC_RCR);
 330:./include/lib_AT91SAM7A3.h **** }
 331:./include/lib_AT91SAM7A3.h **** 
 332:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 333:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_IsNextRxEmpty
 334:./include/lib_AT91SAM7A3.h **** //* \brief Test if the next transfer descriptor has been moved to the current td
 335:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 336:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PDC_IsNextRxEmpty ( // \return return 1 if transfer is complete
 337:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 338:./include/lib_AT91SAM7A3.h **** {
 339:./include/lib_AT91SAM7A3.h **** 	return !(pPDC->PDC_RNCR);
 340:./include/lib_AT91SAM7A3.h **** }
 341:./include/lib_AT91SAM7A3.h **** 
 342:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 343:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_Open
 344:./include/lib_AT91SAM7A3.h **** //* \brief Open PDC: disable TX and RX reset transfer descriptors, re-enable RX and TX
 345:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 346:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_Open (
 347:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
 348:./include/lib_AT91SAM7A3.h **** {
 349:./include/lib_AT91SAM7A3.h ****     //* Disable the RX and TX PDC transfer requests
 350:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_DisableRx(pPDC);
 351:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_DisableTx(pPDC);
 352:./include/lib_AT91SAM7A3.h **** 
 353:./include/lib_AT91SAM7A3.h **** 	//* Reset all Counter register Next buffer first
 354:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
 355:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
 356:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
 357:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
 358:./include/lib_AT91SAM7A3.h **** 
 359:./include/lib_AT91SAM7A3.h ****     //* Enable the RX and TX PDC transfer requests
 360:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_EnableRx(pPDC);
 361:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_EnableTx(pPDC);
 362:./include/lib_AT91SAM7A3.h **** }
 363:./include/lib_AT91SAM7A3.h **** 
 364:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 365:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_Close
 366:./include/lib_AT91SAM7A3.h **** //* \brief Close PDC: disable TX and RX reset transfer descriptors
 367:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 368:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PDC_Close (
 369:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
 370:./include/lib_AT91SAM7A3.h **** {
 371:./include/lib_AT91SAM7A3.h ****     //* Disable the RX and TX PDC transfer requests
 372:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_DisableRx(pPDC);
 373:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_DisableTx(pPDC);
 374:./include/lib_AT91SAM7A3.h **** 
 375:./include/lib_AT91SAM7A3.h **** 	//* Reset all Counter register Next buffer first
 376:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
 377:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
 378:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
 379:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
 380:./include/lib_AT91SAM7A3.h **** 
 381:./include/lib_AT91SAM7A3.h **** }
 382:./include/lib_AT91SAM7A3.h **** 
 383:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 384:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_SendFrame
 385:./include/lib_AT91SAM7A3.h **** //* \brief Close PDC: disable TX and RX reset transfer descriptors
 386:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 387:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PDC_SendFrame(
 388:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,
 389:./include/lib_AT91SAM7A3.h **** 	char *pBuffer,
 390:./include/lib_AT91SAM7A3.h **** 	unsigned int szBuffer,
 391:./include/lib_AT91SAM7A3.h **** 	char *pNextBuffer,
 392:./include/lib_AT91SAM7A3.h **** 	unsigned int szNextBuffer )
 393:./include/lib_AT91SAM7A3.h **** {
 394:./include/lib_AT91SAM7A3.h **** 	if (AT91F_PDC_IsTxEmpty(pPDC)) {
 395:./include/lib_AT91SAM7A3.h **** 		//* Buffer and next buffer can be initialized
 396:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetTx(pPDC, pBuffer, szBuffer);
 397:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetNextTx(pPDC, pNextBuffer, szNextBuffer);
 398:./include/lib_AT91SAM7A3.h **** 		return 2;
 399:./include/lib_AT91SAM7A3.h **** 	}
 400:./include/lib_AT91SAM7A3.h **** 	else if (AT91F_PDC_IsNextTxEmpty(pPDC)) {
 401:./include/lib_AT91SAM7A3.h **** 		//* Only one buffer can be initialized
 402:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetNextTx(pPDC, pBuffer, szBuffer);
 403:./include/lib_AT91SAM7A3.h **** 		return 1;
 404:./include/lib_AT91SAM7A3.h **** 	}
 405:./include/lib_AT91SAM7A3.h **** 	else {
 406:./include/lib_AT91SAM7A3.h **** 		//* All buffer are in use...
 407:./include/lib_AT91SAM7A3.h **** 		return 0;
 408:./include/lib_AT91SAM7A3.h **** 	}
 409:./include/lib_AT91SAM7A3.h **** }
 410:./include/lib_AT91SAM7A3.h **** 
 411:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 412:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PDC_ReceiveFrame
 413:./include/lib_AT91SAM7A3.h **** //* \brief Close PDC: disable TX and RX reset transfer descriptors
 414:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 415:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PDC_ReceiveFrame (
 416:./include/lib_AT91SAM7A3.h **** 	AT91PS_PDC pPDC,
 417:./include/lib_AT91SAM7A3.h **** 	char *pBuffer,
 418:./include/lib_AT91SAM7A3.h **** 	unsigned int szBuffer,
 419:./include/lib_AT91SAM7A3.h **** 	char *pNextBuffer,
 420:./include/lib_AT91SAM7A3.h **** 	unsigned int szNextBuffer )
 421:./include/lib_AT91SAM7A3.h **** {
 422:./include/lib_AT91SAM7A3.h **** 	if (AT91F_PDC_IsRxEmpty(pPDC)) {
 423:./include/lib_AT91SAM7A3.h **** 		//* Buffer and next buffer can be initialized
 424:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetRx(pPDC, pBuffer, szBuffer);
 425:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetNextRx(pPDC, pNextBuffer, szNextBuffer);
 426:./include/lib_AT91SAM7A3.h **** 		return 2;
 427:./include/lib_AT91SAM7A3.h **** 	}
 428:./include/lib_AT91SAM7A3.h **** 	else if (AT91F_PDC_IsNextRxEmpty(pPDC)) {
 429:./include/lib_AT91SAM7A3.h **** 		//* Only one buffer can be initialized
 430:./include/lib_AT91SAM7A3.h **** 		AT91F_PDC_SetNextRx(pPDC, pBuffer, szBuffer);
 431:./include/lib_AT91SAM7A3.h **** 		return 1;
 432:./include/lib_AT91SAM7A3.h **** 	}
 433:./include/lib_AT91SAM7A3.h **** 	else {
 434:./include/lib_AT91SAM7A3.h **** 		//* All buffer are in use...
 435:./include/lib_AT91SAM7A3.h **** 		return 0;
 436:./include/lib_AT91SAM7A3.h **** 	}
 437:./include/lib_AT91SAM7A3.h **** }
 438:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
 439:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR DBGU
 440:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
 441:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 442:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_DBGU_InterruptEnable
 443:./include/lib_AT91SAM7A3.h **** //* \brief Enable DBGU Interrupt
 444:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 445:./include/lib_AT91SAM7A3.h **** __inline void AT91F_DBGU_InterruptEnable(
 446:./include/lib_AT91SAM7A3.h ****         AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
 447:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  dbgu interrupt to be enabled
 448:./include/lib_AT91SAM7A3.h **** {
 449:./include/lib_AT91SAM7A3.h ****         pDbgu->DBGU_IER = flag;
 450:./include/lib_AT91SAM7A3.h **** }
 451:./include/lib_AT91SAM7A3.h **** 
 452:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 453:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_DBGU_InterruptDisable
 454:./include/lib_AT91SAM7A3.h **** //* \brief Disable DBGU Interrupt
 455:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 456:./include/lib_AT91SAM7A3.h **** __inline void AT91F_DBGU_InterruptDisable(
 457:./include/lib_AT91SAM7A3.h ****         AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
 458:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  dbgu interrupt to be disabled
 459:./include/lib_AT91SAM7A3.h **** {
 460:./include/lib_AT91SAM7A3.h ****         pDbgu->DBGU_IDR = flag;
 461:./include/lib_AT91SAM7A3.h **** }
 462:./include/lib_AT91SAM7A3.h **** 
 463:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 464:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_DBGU_GetInterruptMaskStatus
 465:./include/lib_AT91SAM7A3.h **** //* \brief Return DBGU Interrupt Mask Status
 466:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 467:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_DBGU_GetInterruptMaskStatus( // \return DBGU Interrupt Mask Status
 468:./include/lib_AT91SAM7A3.h ****         AT91PS_DBGU pDbgu) // \arg  pointer to a DBGU controller
 469:./include/lib_AT91SAM7A3.h **** {
 470:./include/lib_AT91SAM7A3.h ****         return pDbgu->DBGU_IMR;
 471:./include/lib_AT91SAM7A3.h **** }
 472:./include/lib_AT91SAM7A3.h **** 
 473:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 474:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_DBGU_IsInterruptMasked
 475:./include/lib_AT91SAM7A3.h **** //* \brief Test if DBGU Interrupt is Masked 
 476:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 477:./include/lib_AT91SAM7A3.h **** __inline int AT91F_DBGU_IsInterruptMasked(
 478:./include/lib_AT91SAM7A3.h ****         AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
 479:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 480:./include/lib_AT91SAM7A3.h **** {
 481:./include/lib_AT91SAM7A3.h ****         return (AT91F_DBGU_GetInterruptMaskStatus(pDbgu) & flag);
 482:./include/lib_AT91SAM7A3.h **** }
 483:./include/lib_AT91SAM7A3.h **** 
 484:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
 485:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR PIO
 486:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
 487:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 488:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgPeriph
 489:./include/lib_AT91SAM7A3.h **** //* \brief Enable pins to be drived by peripheral
 490:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 491:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgPeriph(
 492:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 493:./include/lib_AT91SAM7A3.h **** 	unsigned int periphAEnable,  // \arg PERIPH A to enable
 494:./include/lib_AT91SAM7A3.h **** 	unsigned int periphBEnable)  // \arg PERIPH B to enable
 495:./include/lib_AT91SAM7A3.h **** 
 496:./include/lib_AT91SAM7A3.h **** {
 497:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_ASR = periphAEnable;
 498:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_BSR = periphBEnable;
 499:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PDR = (periphAEnable | periphBEnable); // Set in Periph mode
 500:./include/lib_AT91SAM7A3.h **** }
 501:./include/lib_AT91SAM7A3.h **** 
 502:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 503:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgOutput
 504:./include/lib_AT91SAM7A3.h **** //* \brief Enable PIO in output mode
 505:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 506:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgOutput(
 507:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 508:./include/lib_AT91SAM7A3.h **** 	unsigned int pioEnable)      // \arg PIO to be enabled
 509:./include/lib_AT91SAM7A3.h **** {
 510:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PER = pioEnable; // Set in PIO mode
 511:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_OER = pioEnable; // Configure in Output
 512:./include/lib_AT91SAM7A3.h **** }
 513:./include/lib_AT91SAM7A3.h **** 
 514:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 515:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgInput
 516:./include/lib_AT91SAM7A3.h **** //* \brief Enable PIO in input mode
 517:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 518:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgInput(
 519:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 520:./include/lib_AT91SAM7A3.h **** 	unsigned int inputEnable)      // \arg PIO to be enabled
 521:./include/lib_AT91SAM7A3.h **** {
 522:./include/lib_AT91SAM7A3.h **** 	// Disable output
 523:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_ODR  = inputEnable;
 524:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PER  = inputEnable;
 525:./include/lib_AT91SAM7A3.h **** }
 526:./include/lib_AT91SAM7A3.h **** 
 527:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 528:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgOpendrain
 529:./include/lib_AT91SAM7A3.h **** //* \brief Configure PIO in open drain
 530:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 531:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgOpendrain(
 532:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 533:./include/lib_AT91SAM7A3.h **** 	unsigned int multiDrvEnable) // \arg pio to be configured in open drain
 534:./include/lib_AT91SAM7A3.h **** {
 535:./include/lib_AT91SAM7A3.h **** 	// Configure the multi-drive option
 536:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_MDDR = ~multiDrvEnable;
 537:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_MDER = multiDrvEnable;
 538:./include/lib_AT91SAM7A3.h **** }
 539:./include/lib_AT91SAM7A3.h **** 
 540:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 541:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgPullup
 542:./include/lib_AT91SAM7A3.h **** //* \brief Enable pullup on PIO
 543:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 544:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgPullup(
 545:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 546:./include/lib_AT91SAM7A3.h **** 	unsigned int pullupEnable)   // \arg enable pullup on PIO
 547:./include/lib_AT91SAM7A3.h **** {
 548:./include/lib_AT91SAM7A3.h **** 		// Connect or not Pullup
 549:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PPUDR = ~pullupEnable;
 550:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_PPUER = pullupEnable;
 551:./include/lib_AT91SAM7A3.h **** }
 552:./include/lib_AT91SAM7A3.h **** 
 553:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 554:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgDirectDrive
 555:./include/lib_AT91SAM7A3.h **** //* \brief Enable direct drive on PIO
 556:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 557:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgDirectDrive(
 558:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 559:./include/lib_AT91SAM7A3.h **** 	unsigned int directDrive)    // \arg PIO to be configured with direct drive
 560:./include/lib_AT91SAM7A3.h **** 
 561:./include/lib_AT91SAM7A3.h **** {
 562:./include/lib_AT91SAM7A3.h **** 	// Configure the Direct Drive
 563:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_OWDR  = ~directDrive;
 564:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_OWER  = directDrive;
 565:./include/lib_AT91SAM7A3.h **** }
 566:./include/lib_AT91SAM7A3.h **** 
 567:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 568:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_CfgInputFilter
 569:./include/lib_AT91SAM7A3.h **** //* \brief Enable input filter on input PIO
 570:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 571:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_CfgInputFilter(
 572:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 573:./include/lib_AT91SAM7A3.h **** 	unsigned int inputFilter)    // \arg PIO to be configured with input filter
 574:./include/lib_AT91SAM7A3.h **** 
 575:./include/lib_AT91SAM7A3.h **** {
 576:./include/lib_AT91SAM7A3.h **** 	// Configure the Direct Drive
 577:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_IFDR  = ~inputFilter;
 578:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_IFER  = inputFilter;
 579:./include/lib_AT91SAM7A3.h **** }
 580:./include/lib_AT91SAM7A3.h **** 
 581:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 582:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetInput
 583:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO input value
 584:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 585:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetInput( // \return PIO input
 586:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 587:./include/lib_AT91SAM7A3.h **** {
 588:./include/lib_AT91SAM7A3.h **** 	return pPio->PIO_PDSR;
 589:./include/lib_AT91SAM7A3.h **** }
 590:./include/lib_AT91SAM7A3.h **** 
 591:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 592:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsInputSet
 593:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO is input flag is active
 594:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 595:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsInputSet(
 596:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 597:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // \arg  flag to be tested
 598:./include/lib_AT91SAM7A3.h **** {
 599:./include/lib_AT91SAM7A3.h **** 	return (AT91F_PIO_GetInput(pPio) & flag);
 600:./include/lib_AT91SAM7A3.h **** }
 601:./include/lib_AT91SAM7A3.h **** 
 602:./include/lib_AT91SAM7A3.h **** 
 603:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 604:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_SetOutput
 605:./include/lib_AT91SAM7A3.h **** //* \brief Set to 1 output PIO
 606:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 607:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_SetOutput(
 608:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 609:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // \arg  output to be set
 610:./include/lib_AT91SAM7A3.h **** {
 611:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_SODR = flag;
 612:./include/lib_AT91SAM7A3.h **** }
 613:./include/lib_AT91SAM7A3.h **** 
 614:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 615:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_ClearOutput
 616:./include/lib_AT91SAM7A3.h **** //* \brief Set to 0 output PIO
 617:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 618:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_ClearOutput(
 619:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 620:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // \arg  output to be cleared
 621:./include/lib_AT91SAM7A3.h **** {
 622:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_CODR = flag;
 623:./include/lib_AT91SAM7A3.h **** }
 624:./include/lib_AT91SAM7A3.h **** 
 625:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 626:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_ForceOutput
 627:./include/lib_AT91SAM7A3.h **** //* \brief Force output when Direct drive option is enabled
 628:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 629:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_ForceOutput(
 630:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 631:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // \arg  output to be forced
 632:./include/lib_AT91SAM7A3.h **** {
 633:./include/lib_AT91SAM7A3.h **** 	pPio->PIO_ODSR = flag;
 634:./include/lib_AT91SAM7A3.h **** }
 635:./include/lib_AT91SAM7A3.h **** 
 636:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 637:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_Enable
 638:./include/lib_AT91SAM7A3.h **** //* \brief Enable PIO
 639:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 640:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_Enable(
 641:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 642:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio to be enabled 
 643:./include/lib_AT91SAM7A3.h **** {
 644:./include/lib_AT91SAM7A3.h ****         pPio->PIO_PER = flag;
 645:./include/lib_AT91SAM7A3.h **** }
 646:./include/lib_AT91SAM7A3.h **** 
 647:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 648:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_Disable
 649:./include/lib_AT91SAM7A3.h **** //* \brief Disable PIO
 650:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 651:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_Disable(
 652:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 653:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio to be disabled 
 654:./include/lib_AT91SAM7A3.h **** {
 655:./include/lib_AT91SAM7A3.h ****         pPio->PIO_PDR = flag;
 656:./include/lib_AT91SAM7A3.h **** }
 657:./include/lib_AT91SAM7A3.h **** 
 658:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 659:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetStatus
 660:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Status
 661:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 662:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetStatus( // \return PIO Status
 663:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 664:./include/lib_AT91SAM7A3.h **** {
 665:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_PSR;
 666:./include/lib_AT91SAM7A3.h **** }
 667:./include/lib_AT91SAM7A3.h **** 
 668:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 669:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsSet
 670:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO is Set
 671:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 672:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsSet(
 673:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 674:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 675:./include/lib_AT91SAM7A3.h **** {
 676:./include/lib_AT91SAM7A3.h ****         return (AT91F_PIO_GetStatus(pPio) & flag);
 677:./include/lib_AT91SAM7A3.h **** }
 678:./include/lib_AT91SAM7A3.h **** 
 679:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 680:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_OutputEnable
 681:./include/lib_AT91SAM7A3.h **** //* \brief Output Enable PIO
 682:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 683:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_OutputEnable(
 684:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 685:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio output to be enabled
 686:./include/lib_AT91SAM7A3.h **** {
 687:./include/lib_AT91SAM7A3.h ****         pPio->PIO_OER = flag;
 688:./include/lib_AT91SAM7A3.h **** }
 689:./include/lib_AT91SAM7A3.h **** 
 690:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 691:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_OutputDisable
 692:./include/lib_AT91SAM7A3.h **** //* \brief Output Enable PIO
 693:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 694:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_OutputDisable(
 695:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 696:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio output to be disabled
 697:./include/lib_AT91SAM7A3.h **** {
 698:./include/lib_AT91SAM7A3.h ****         pPio->PIO_ODR = flag;
 699:./include/lib_AT91SAM7A3.h **** }
 700:./include/lib_AT91SAM7A3.h **** 
 701:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 702:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetOutputStatus
 703:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Output Status
 704:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 705:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetOutputStatus( // \return PIO Output Status
 706:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 707:./include/lib_AT91SAM7A3.h **** {
 708:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_OSR;
 709:./include/lib_AT91SAM7A3.h **** }
 710:./include/lib_AT91SAM7A3.h **** 
 711:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 712:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsOuputSet
 713:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO Output is Set
 714:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 715:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsOutputSet(
 716:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 717:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 718:./include/lib_AT91SAM7A3.h **** {
 719:./include/lib_AT91SAM7A3.h ****         return (AT91F_PIO_GetOutputStatus(pPio) & flag);
 720:./include/lib_AT91SAM7A3.h **** }
 721:./include/lib_AT91SAM7A3.h **** 
 722:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 723:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_InputFilterEnable
 724:./include/lib_AT91SAM7A3.h **** //* \brief Input Filter Enable PIO
 725:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 726:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_InputFilterEnable(
 727:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 728:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio input filter to be enabled
 729:./include/lib_AT91SAM7A3.h **** {
 730:./include/lib_AT91SAM7A3.h ****         pPio->PIO_IFER = flag;
 731:./include/lib_AT91SAM7A3.h **** }
 732:./include/lib_AT91SAM7A3.h **** 
 733:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 734:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_InputFilterDisable
 735:./include/lib_AT91SAM7A3.h **** //* \brief Input Filter Disable PIO
 736:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 737:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_InputFilterDisable(
 738:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 739:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio input filter to be disabled
 740:./include/lib_AT91SAM7A3.h **** {
 741:./include/lib_AT91SAM7A3.h ****         pPio->PIO_IFDR = flag;
 742:./include/lib_AT91SAM7A3.h **** }
 743:./include/lib_AT91SAM7A3.h **** 
 744:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 745:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetInputFilterStatus
 746:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Input Filter Status
 747:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 748:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetInputFilterStatus( // \return PIO Input Filter Status
 749:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 750:./include/lib_AT91SAM7A3.h **** {
 751:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_IFSR;
 752:./include/lib_AT91SAM7A3.h **** }
 753:./include/lib_AT91SAM7A3.h **** 
 754:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 755:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsInputFilterSet
 756:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO Input filter is Set
 757:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 758:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsInputFilterSet(
 759:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 760:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 761:./include/lib_AT91SAM7A3.h **** {
 762:./include/lib_AT91SAM7A3.h ****         return (AT91F_PIO_GetInputFilterStatus(pPio) & flag);
 763:./include/lib_AT91SAM7A3.h **** }
 764:./include/lib_AT91SAM7A3.h **** 
 765:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 766:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetOutputDataStatus
 767:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Output Data Status 
 768:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 769:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetOutputDataStatus( // \return PIO Output Data Status 
 770:./include/lib_AT91SAM7A3.h **** 	AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 771:./include/lib_AT91SAM7A3.h **** {
 772:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_ODSR;
 773:./include/lib_AT91SAM7A3.h **** }
 774:./include/lib_AT91SAM7A3.h **** 
 775:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 776:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_InterruptEnable
 777:./include/lib_AT91SAM7A3.h **** //* \brief Enable PIO Interrupt
 778:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 779:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_InterruptEnable(
 780:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 781:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio interrupt to be enabled
 782:./include/lib_AT91SAM7A3.h **** {
 783:./include/lib_AT91SAM7A3.h ****         pPio->PIO_IER = flag;
 784:./include/lib_AT91SAM7A3.h **** }
 785:./include/lib_AT91SAM7A3.h **** 
 786:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 787:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_InterruptDisable
 788:./include/lib_AT91SAM7A3.h **** //* \brief Disable PIO Interrupt
 789:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 790:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_InterruptDisable(
 791:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 792:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio interrupt to be disabled
 793:./include/lib_AT91SAM7A3.h **** {
 794:./include/lib_AT91SAM7A3.h ****         pPio->PIO_IDR = flag;
 795:./include/lib_AT91SAM7A3.h **** }
 796:./include/lib_AT91SAM7A3.h **** 
 797:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 798:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetInterruptMaskStatus
 799:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Interrupt Mask Status
 800:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 801:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetInterruptMaskStatus( // \return PIO Interrupt Mask Status
 802:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 803:./include/lib_AT91SAM7A3.h **** {
 804:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_IMR;
 805:./include/lib_AT91SAM7A3.h **** }
 806:./include/lib_AT91SAM7A3.h **** 
 807:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 808:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetInterruptStatus
 809:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Interrupt Status
 810:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 811:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetInterruptStatus( // \return PIO Interrupt Status
 812:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 813:./include/lib_AT91SAM7A3.h **** {
 814:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_ISR;
 815:./include/lib_AT91SAM7A3.h **** }
 816:./include/lib_AT91SAM7A3.h **** 
 817:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 818:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsInterruptMasked
 819:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO Interrupt is Masked 
 820:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 821:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsInterruptMasked(
 822:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 823:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 824:./include/lib_AT91SAM7A3.h **** {
 825:./include/lib_AT91SAM7A3.h ****         return (AT91F_PIO_GetInterruptMaskStatus(pPio) & flag);
 826:./include/lib_AT91SAM7A3.h **** }
 827:./include/lib_AT91SAM7A3.h **** 
 828:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 829:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsInterruptSet
 830:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO Interrupt is Set
 831:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 832:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsInterruptSet(
 833:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 834:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 835:./include/lib_AT91SAM7A3.h **** {
 836:./include/lib_AT91SAM7A3.h ****         return (AT91F_PIO_GetInterruptStatus(pPio) & flag);
 837:./include/lib_AT91SAM7A3.h **** }
 838:./include/lib_AT91SAM7A3.h **** 
 839:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 840:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_MultiDriverEnable
 841:./include/lib_AT91SAM7A3.h **** //* \brief Multi Driver Enable PIO
 842:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 843:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_MultiDriverEnable(
 844:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 845:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio to be enabled
 846:./include/lib_AT91SAM7A3.h **** {
 847:./include/lib_AT91SAM7A3.h ****         pPio->PIO_MDER = flag;
 848:./include/lib_AT91SAM7A3.h **** }
 849:./include/lib_AT91SAM7A3.h **** 
 850:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 851:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_MultiDriverDisable
 852:./include/lib_AT91SAM7A3.h **** //* \brief Multi Driver Disable PIO
 853:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 854:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_MultiDriverDisable(
 855:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 856:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio to be disabled
 857:./include/lib_AT91SAM7A3.h **** {
 858:./include/lib_AT91SAM7A3.h ****         pPio->PIO_MDDR = flag;
 859:./include/lib_AT91SAM7A3.h **** }
 860:./include/lib_AT91SAM7A3.h **** 
 861:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 862:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetMultiDriverStatus
 863:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Multi Driver Status
 864:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 865:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetMultiDriverStatus( // \return PIO Multi Driver Status
 866:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 867:./include/lib_AT91SAM7A3.h **** {
 868:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_MDSR;
 869:./include/lib_AT91SAM7A3.h **** }
 870:./include/lib_AT91SAM7A3.h **** 
 871:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 872:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsMultiDriverSet
 873:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO MultiDriver is Set
 874:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 875:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsMultiDriverSet(
 876:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 877:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 878:./include/lib_AT91SAM7A3.h **** {
 879:./include/lib_AT91SAM7A3.h ****         return (AT91F_PIO_GetMultiDriverStatus(pPio) & flag);
 880:./include/lib_AT91SAM7A3.h **** }
 881:./include/lib_AT91SAM7A3.h **** 
 882:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 883:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_A_RegisterSelection
 884:./include/lib_AT91SAM7A3.h **** //* \brief PIO A Register Selection 
 885:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 886:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_A_RegisterSelection(
 887:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 888:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio A register selection
 889:./include/lib_AT91SAM7A3.h **** {
 890:./include/lib_AT91SAM7A3.h ****         pPio->PIO_ASR = flag;
 891:./include/lib_AT91SAM7A3.h **** }
 892:./include/lib_AT91SAM7A3.h **** 
 893:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 894:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_B_RegisterSelection
 895:./include/lib_AT91SAM7A3.h **** //* \brief PIO B Register Selection 
 896:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 897:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_B_RegisterSelection(
 898:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 899:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio B register selection 
 900:./include/lib_AT91SAM7A3.h **** {
 901:./include/lib_AT91SAM7A3.h ****         pPio->PIO_BSR = flag;
 902:./include/lib_AT91SAM7A3.h **** }
 903:./include/lib_AT91SAM7A3.h **** 
 904:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 905:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_Get_AB_RegisterStatus
 906:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Interrupt Status
 907:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 908:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_Get_AB_RegisterStatus( // \return PIO AB Register Status
 909:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 910:./include/lib_AT91SAM7A3.h **** {
 911:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_ABSR;
 912:./include/lib_AT91SAM7A3.h **** }
 913:./include/lib_AT91SAM7A3.h **** 
 914:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 915:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsAB_RegisterSet
 916:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO AB Register is Set
 917:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 918:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsAB_RegisterSet(
 919:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 920:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 921:./include/lib_AT91SAM7A3.h **** {
 922:./include/lib_AT91SAM7A3.h ****         return (AT91F_PIO_Get_AB_RegisterStatus(pPio) & flag);
 923:./include/lib_AT91SAM7A3.h **** }
 924:./include/lib_AT91SAM7A3.h **** 
 925:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 926:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_OutputWriteEnable
 927:./include/lib_AT91SAM7A3.h **** //* \brief Output Write Enable PIO
 928:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 929:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_OutputWriteEnable(
 930:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 931:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio output write to be enabled
 932:./include/lib_AT91SAM7A3.h **** {
 933:./include/lib_AT91SAM7A3.h ****         pPio->PIO_OWER = flag;
 934:./include/lib_AT91SAM7A3.h **** }
 935:./include/lib_AT91SAM7A3.h **** 
 936:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 937:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_OutputWriteDisable
 938:./include/lib_AT91SAM7A3.h **** //* \brief Output Write Disable PIO
 939:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 940:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PIO_OutputWriteDisable(
 941:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 942:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  pio output write to be disabled
 943:./include/lib_AT91SAM7A3.h **** {
 944:./include/lib_AT91SAM7A3.h ****         pPio->PIO_OWDR = flag;
 945:./include/lib_AT91SAM7A3.h **** }
 946:./include/lib_AT91SAM7A3.h **** 
 947:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 948:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetOutputWriteStatus
 949:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Output Write Status
 950:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 951:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetOutputWriteStatus( // \return PIO Output Write Status
 952:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 953:./include/lib_AT91SAM7A3.h **** {
 954:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_OWSR;
 955:./include/lib_AT91SAM7A3.h **** }
 956:./include/lib_AT91SAM7A3.h **** 
 957:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 958:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsOutputWriteSet
 959:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO OutputWrite is Set
 960:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 961:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsOutputWriteSet(
 962:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 963:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 964:./include/lib_AT91SAM7A3.h **** {
 965:./include/lib_AT91SAM7A3.h ****         return (AT91F_PIO_GetOutputWriteStatus(pPio) & flag);
 966:./include/lib_AT91SAM7A3.h **** }
 967:./include/lib_AT91SAM7A3.h **** 
 968:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 969:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_GetCfgPullup
 970:./include/lib_AT91SAM7A3.h **** //* \brief Return PIO Configuration Pullup
 971:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 972:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PIO_GetCfgPullup( // \return PIO Configuration Pullup 
 973:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 974:./include/lib_AT91SAM7A3.h **** {
 975:./include/lib_AT91SAM7A3.h ****         return pPio->PIO_PPUSR;
 976:./include/lib_AT91SAM7A3.h **** }
 977:./include/lib_AT91SAM7A3.h **** 
 978:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 979:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsOutputDataStatusSet
 980:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO Output Data Status is Set 
 981:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 982:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsOutputDataStatusSet(
 983:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 984:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 985:./include/lib_AT91SAM7A3.h **** {
 986:./include/lib_AT91SAM7A3.h ****         return (AT91F_PIO_GetOutputDataStatus(pPio) & flag);
 987:./include/lib_AT91SAM7A3.h **** }
 988:./include/lib_AT91SAM7A3.h **** 
 989:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 990:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PIO_IsCfgPullupStatusSet
 991:./include/lib_AT91SAM7A3.h **** //* \brief Test if PIO Configuration Pullup Status is Set
 992:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
 993:./include/lib_AT91SAM7A3.h **** __inline int AT91F_PIO_IsCfgPullupStatusSet(
 994:./include/lib_AT91SAM7A3.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 995:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
 996:./include/lib_AT91SAM7A3.h **** {
 997:./include/lib_AT91SAM7A3.h ****         return (~AT91F_PIO_GetCfgPullup(pPio) & flag);
 998:./include/lib_AT91SAM7A3.h **** }
 999:./include/lib_AT91SAM7A3.h **** 
1000:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
1001:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR PMC
1002:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
1003:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1004:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_CfgSysClkEnableReg
1005:./include/lib_AT91SAM7A3.h **** //* \brief Configure the System Clock Enable Register of the PMC controller
1006:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1007:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PMC_CfgSysClkEnableReg (
1008:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1009:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)
1010:./include/lib_AT91SAM7A3.h **** {
1011:./include/lib_AT91SAM7A3.h **** 	//* Write to the SCER register
1012:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_SCER = mode;
1013:./include/lib_AT91SAM7A3.h **** }
1014:./include/lib_AT91SAM7A3.h **** 
1015:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1016:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_CfgSysClkDisableReg
1017:./include/lib_AT91SAM7A3.h **** //* \brief Configure the System Clock Disable Register of the PMC controller
1018:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1019:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PMC_CfgSysClkDisableReg (
1020:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1021:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)
1022:./include/lib_AT91SAM7A3.h **** {
1023:./include/lib_AT91SAM7A3.h **** 	//* Write to the SCDR register
1024:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_SCDR = mode;
1025:./include/lib_AT91SAM7A3.h **** }
1026:./include/lib_AT91SAM7A3.h **** 
1027:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1028:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_GetSysClkStatusReg
1029:./include/lib_AT91SAM7A3.h **** //* \brief Return the System Clock Status Register of the PMC controller
1030:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1031:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PMC_GetSysClkStatusReg (
1032:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC // pointer to a CAN controller
1033:./include/lib_AT91SAM7A3.h **** 	)
1034:./include/lib_AT91SAM7A3.h **** {
1035:./include/lib_AT91SAM7A3.h **** 	return pPMC->PMC_SCSR;
1036:./include/lib_AT91SAM7A3.h **** }
1037:./include/lib_AT91SAM7A3.h **** 
1038:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1039:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_EnablePeriphClock
1040:./include/lib_AT91SAM7A3.h **** //* \brief Enable peripheral clock
1041:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1042:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PMC_EnablePeriphClock (
1043:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1044:./include/lib_AT91SAM7A3.h **** 	unsigned int periphIds)  // \arg IDs of peripherals
1045:./include/lib_AT91SAM7A3.h **** {
1046:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_PCER = periphIds;
1047:./include/lib_AT91SAM7A3.h **** }
1048:./include/lib_AT91SAM7A3.h **** 
1049:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1050:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_DisablePeriphClock
1051:./include/lib_AT91SAM7A3.h **** //* \brief Disable peripheral clock
1052:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1053:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PMC_DisablePeriphClock (
1054:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1055:./include/lib_AT91SAM7A3.h **** 	unsigned int periphIds)  // \arg IDs of peripherals
1056:./include/lib_AT91SAM7A3.h **** {
1057:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_PCDR = periphIds;
1058:./include/lib_AT91SAM7A3.h **** }
1059:./include/lib_AT91SAM7A3.h **** 
1060:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1061:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_GetPeriphClock
1062:./include/lib_AT91SAM7A3.h **** //* \brief Get peripheral clock status
1063:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1064:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PMC_GetPeriphClock (
1065:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC) // \arg pointer to PMC controller
1066:./include/lib_AT91SAM7A3.h **** {
1067:./include/lib_AT91SAM7A3.h **** 	return pPMC->PMC_PCSR;
1068:./include/lib_AT91SAM7A3.h **** }
1069:./include/lib_AT91SAM7A3.h **** 
1070:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1071:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CKGR_CfgMainOscillatorReg
1072:./include/lib_AT91SAM7A3.h **** //* \brief Cfg the main oscillator
1073:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1074:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CKGR_CfgMainOscillatorReg (
1075:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
1076:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)
1077:./include/lib_AT91SAM7A3.h **** {
1078:./include/lib_AT91SAM7A3.h **** 	pCKGR->CKGR_MOR = mode;
1079:./include/lib_AT91SAM7A3.h **** }
1080:./include/lib_AT91SAM7A3.h **** 
1081:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1082:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CKGR_GetMainOscillatorReg
1083:./include/lib_AT91SAM7A3.h **** //* \brief Cfg the main oscillator
1084:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1085:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CKGR_GetMainOscillatorReg (
1086:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
1087:./include/lib_AT91SAM7A3.h **** {
1088:./include/lib_AT91SAM7A3.h **** 	return pCKGR->CKGR_MOR;
1089:./include/lib_AT91SAM7A3.h **** }
1090:./include/lib_AT91SAM7A3.h **** 
1091:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1092:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CKGR_EnableMainOscillator
1093:./include/lib_AT91SAM7A3.h **** //* \brief Enable the main oscillator
1094:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1095:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CKGR_EnableMainOscillator(
1096:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
1097:./include/lib_AT91SAM7A3.h **** {
1098:./include/lib_AT91SAM7A3.h **** 	pCKGR->CKGR_MOR |= AT91C_CKGR_MOSCEN;
1099:./include/lib_AT91SAM7A3.h **** }
1100:./include/lib_AT91SAM7A3.h **** 
1101:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1102:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CKGR_DisableMainOscillator
1103:./include/lib_AT91SAM7A3.h **** //* \brief Disable the main oscillator
1104:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1105:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CKGR_DisableMainOscillator (
1106:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
1107:./include/lib_AT91SAM7A3.h **** {
1108:./include/lib_AT91SAM7A3.h **** 	pCKGR->CKGR_MOR &= ~AT91C_CKGR_MOSCEN;
1109:./include/lib_AT91SAM7A3.h **** }
1110:./include/lib_AT91SAM7A3.h **** 
1111:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1112:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CKGR_CfgMainOscStartUpTime
1113:./include/lib_AT91SAM7A3.h **** //* \brief Cfg MOR Register according to the main osc startup time
1114:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1115:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CKGR_CfgMainOscStartUpTime (
1116:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
1117:./include/lib_AT91SAM7A3.h **** 	unsigned int startup_time,  // \arg main osc startup time in microsecond (us)
1118:./include/lib_AT91SAM7A3.h **** 	unsigned int slowClock)  // \arg slowClock in Hz
1119:./include/lib_AT91SAM7A3.h **** {
1120:./include/lib_AT91SAM7A3.h **** 	pCKGR->CKGR_MOR &= ~AT91C_CKGR_OSCOUNT;
1121:./include/lib_AT91SAM7A3.h **** 	pCKGR->CKGR_MOR |= ((slowClock * startup_time)/(8*1000000)) << 8;
1122:./include/lib_AT91SAM7A3.h **** }
1123:./include/lib_AT91SAM7A3.h **** 
1124:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1125:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CKGR_GetMainClockFreqReg
1126:./include/lib_AT91SAM7A3.h **** //* \brief Cfg the main oscillator
1127:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1128:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CKGR_GetMainClockFreqReg (
1129:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
1130:./include/lib_AT91SAM7A3.h **** {
1131:./include/lib_AT91SAM7A3.h **** 	return pCKGR->CKGR_MCFR;
1132:./include/lib_AT91SAM7A3.h **** }
1133:./include/lib_AT91SAM7A3.h **** 
1134:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1135:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CKGR_GetMainClock
1136:./include/lib_AT91SAM7A3.h **** //* \brief Return Main clock in Hz
1137:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1138:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CKGR_GetMainClock (
1139:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
1140:./include/lib_AT91SAM7A3.h **** 	unsigned int slowClock)  // \arg slowClock in Hz
1141:./include/lib_AT91SAM7A3.h **** {
1142:./include/lib_AT91SAM7A3.h **** 	return ((pCKGR->CKGR_MCFR  & AT91C_CKGR_MAINF) * slowClock) >> 4;
1143:./include/lib_AT91SAM7A3.h **** }
1144:./include/lib_AT91SAM7A3.h **** 
1145:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1146:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_CfgMCKReg
1147:./include/lib_AT91SAM7A3.h **** //* \brief Cfg Master Clock Register
1148:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1149:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PMC_CfgMCKReg (
1150:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1151:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)
1152:./include/lib_AT91SAM7A3.h **** {
1153:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_MCKR = mode;
1154:./include/lib_AT91SAM7A3.h **** }
1155:./include/lib_AT91SAM7A3.h **** 
1156:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1157:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_GetMCKReg
1158:./include/lib_AT91SAM7A3.h **** //* \brief Return Master Clock Register
1159:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1160:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PMC_GetMCKReg(
1161:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC) // \arg pointer to PMC controller
1162:./include/lib_AT91SAM7A3.h **** {
1163:./include/lib_AT91SAM7A3.h **** 	return pPMC->PMC_MCKR;
1164:./include/lib_AT91SAM7A3.h **** }
1165:./include/lib_AT91SAM7A3.h **** 
1166:./include/lib_AT91SAM7A3.h **** //*------------------------------------------------------------------------------
1167:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_GetMasterClock
1168:./include/lib_AT91SAM7A3.h **** //* \brief Return master clock in Hz which correponds to processor clock for ARM7
1169:./include/lib_AT91SAM7A3.h **** //*------------------------------------------------------------------------------
1170:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PMC_GetMasterClock (
1171:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1172:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
1173:./include/lib_AT91SAM7A3.h **** 	unsigned int slowClock)  // \arg slowClock in Hz
1174:./include/lib_AT91SAM7A3.h **** {
1175:./include/lib_AT91SAM7A3.h **** 	unsigned int reg = pPMC->PMC_MCKR;
1176:./include/lib_AT91SAM7A3.h **** 	unsigned int prescaler = (1 << ((reg & AT91C_PMC_PRES) >> 2));
1177:./include/lib_AT91SAM7A3.h **** 	unsigned int pllDivider, pllMultiplier;
1178:./include/lib_AT91SAM7A3.h **** 
1179:./include/lib_AT91SAM7A3.h **** 	switch (reg & AT91C_PMC_CSS) {
1180:./include/lib_AT91SAM7A3.h **** 		case AT91C_PMC_CSS_SLOW_CLK: // Slow clock selected
1181:./include/lib_AT91SAM7A3.h **** 			return slowClock / prescaler;
1182:./include/lib_AT91SAM7A3.h **** 		case AT91C_PMC_CSS_MAIN_CLK: // Main clock is selected
1183:./include/lib_AT91SAM7A3.h **** 			return AT91F_CKGR_GetMainClock(pCKGR, slowClock) / prescaler;
1184:./include/lib_AT91SAM7A3.h **** 		case AT91C_PMC_CSS_PLL_CLK: // PLLB clock is selected
1185:./include/lib_AT91SAM7A3.h **** 			reg = pCKGR->CKGR_PLLR;
1186:./include/lib_AT91SAM7A3.h **** 			pllDivider    = (reg  & AT91C_CKGR_DIV);
1187:./include/lib_AT91SAM7A3.h **** 			pllMultiplier = ((reg  & AT91C_CKGR_MUL) >> 16) + 1;
1188:./include/lib_AT91SAM7A3.h **** 			return AT91F_CKGR_GetMainClock(pCKGR, slowClock) / pllDivider * pllMultiplier / prescaler;
1189:./include/lib_AT91SAM7A3.h **** 	}
1190:./include/lib_AT91SAM7A3.h **** 	return 0;
1191:./include/lib_AT91SAM7A3.h **** }
1192:./include/lib_AT91SAM7A3.h **** 
1193:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1194:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_EnablePCK
1195:./include/lib_AT91SAM7A3.h **** //* \brief Enable Programmable Clock x Output
1196:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1197:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PMC_EnablePCK (
1198:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1199:./include/lib_AT91SAM7A3.h **** 	unsigned int pck,  // \arg Programmable Clock x Output
1200:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)
1201:./include/lib_AT91SAM7A3.h **** {
1202:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_PCKR[pck] = mode;
1203:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_SCER = (1 << pck) << 8;
1204:./include/lib_AT91SAM7A3.h **** }
1205:./include/lib_AT91SAM7A3.h **** 
1206:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1207:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_DisablePCK
1208:./include/lib_AT91SAM7A3.h **** //* \brief Disable Programmable Clock x Output
1209:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1210:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PMC_DisablePCK (
1211:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1212:./include/lib_AT91SAM7A3.h **** 	unsigned int pck)  // \arg Programmable Clock x Output
1213:./include/lib_AT91SAM7A3.h **** {
1214:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_SCDR = (1 << pck) << 8;
1215:./include/lib_AT91SAM7A3.h **** }
1216:./include/lib_AT91SAM7A3.h **** 
1217:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1218:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_EnableIt
1219:./include/lib_AT91SAM7A3.h **** //* \brief Enable PMC interrupt
1220:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1221:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PMC_EnableIt (
1222:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC,     // pointer to a PMC controller
1223:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // IT to be enabled
1224:./include/lib_AT91SAM7A3.h **** {
1225:./include/lib_AT91SAM7A3.h **** 	//* Write to the IER register
1226:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_IER = flag;
1227:./include/lib_AT91SAM7A3.h **** }
1228:./include/lib_AT91SAM7A3.h **** 
1229:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1230:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_DisableIt
1231:./include/lib_AT91SAM7A3.h **** //* \brief Disable PMC interrupt
1232:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1233:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PMC_DisableIt (
1234:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC, // pointer to a PMC controller
1235:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // IT to be disabled
1236:./include/lib_AT91SAM7A3.h **** {
1237:./include/lib_AT91SAM7A3.h **** 	//* Write to the IDR register
1238:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_IDR = flag;
1239:./include/lib_AT91SAM7A3.h **** }
1240:./include/lib_AT91SAM7A3.h **** 
1241:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1242:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_GetStatus
1243:./include/lib_AT91SAM7A3.h **** //* \brief Return PMC Interrupt Status
1244:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1245:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PMC_GetStatus( // \return PMC Interrupt Status
1246:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC) // pointer to a PMC controller
1247:./include/lib_AT91SAM7A3.h **** {
1248:./include/lib_AT91SAM7A3.h **** 	return pPMC->PMC_SR;
1249:./include/lib_AT91SAM7A3.h **** }
1250:./include/lib_AT91SAM7A3.h **** 
1251:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1252:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_GetInterruptMaskStatus
1253:./include/lib_AT91SAM7A3.h **** //* \brief Return PMC Interrupt Mask Status
1254:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1255:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PMC_GetInterruptMaskStatus( // \return PMC Interrupt Mask Status
1256:./include/lib_AT91SAM7A3.h **** 	AT91PS_PMC pPMC) // pointer to a PMC controller
1257:./include/lib_AT91SAM7A3.h **** {
1258:./include/lib_AT91SAM7A3.h **** 	return pPMC->PMC_IMR;
1259:./include/lib_AT91SAM7A3.h **** }
1260:./include/lib_AT91SAM7A3.h **** 
1261:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1262:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_IsInterruptMasked
1263:./include/lib_AT91SAM7A3.h **** //* \brief Test if PMC Interrupt is Masked
1264:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1265:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PMC_IsInterruptMasked(
1266:./include/lib_AT91SAM7A3.h ****         AT91PS_PMC pPMC,   // \arg  pointer to a PMC controller
1267:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
1268:./include/lib_AT91SAM7A3.h **** {
1269:./include/lib_AT91SAM7A3.h **** 	return (AT91F_PMC_GetInterruptMaskStatus(pPMC) & flag);
1270:./include/lib_AT91SAM7A3.h **** }
1271:./include/lib_AT91SAM7A3.h **** 
1272:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1273:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PMC_IsStatusSet
1274:./include/lib_AT91SAM7A3.h **** //* \brief Test if PMC Status is Set
1275:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1276:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PMC_IsStatusSet(
1277:./include/lib_AT91SAM7A3.h ****         AT91PS_PMC pPMC,   // \arg  pointer to a PMC controller
1278:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
1279:./include/lib_AT91SAM7A3.h **** {
1280:./include/lib_AT91SAM7A3.h **** 	return (AT91F_PMC_GetStatus(pPMC) & flag);
1281:./include/lib_AT91SAM7A3.h **** }
1282:./include/lib_AT91SAM7A3.h **** 
1283:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
1284:./include/lib_AT91SAM7A3.h **** //  \fn    AT91F_CKGR_CfgPLLReg
1285:./include/lib_AT91SAM7A3.h **** //  \brief Cfg the PLL Register
1286:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
1287:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CKGR_CfgPLLReg (
1288:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
1289:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)
1290:./include/lib_AT91SAM7A3.h **** {
1291:./include/lib_AT91SAM7A3.h **** 	pCKGR->CKGR_PLLR = mode;
1292:./include/lib_AT91SAM7A3.h **** }
1293:./include/lib_AT91SAM7A3.h **** 
1294:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
1295:./include/lib_AT91SAM7A3.h **** //  \fn    AT91F_CKGR_GetPLLReg
1296:./include/lib_AT91SAM7A3.h **** //  \brief Get the PLL Register
1297:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
1298:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CKGR_GetPLLReg (
1299:./include/lib_AT91SAM7A3.h **** 	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
1300:./include/lib_AT91SAM7A3.h **** {
1301:./include/lib_AT91SAM7A3.h **** 	return pCKGR->CKGR_PLLR;
1302:./include/lib_AT91SAM7A3.h **** }
1303:./include/lib_AT91SAM7A3.h **** 
1304:./include/lib_AT91SAM7A3.h **** 
1305:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
1306:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR RSTC
1307:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
1308:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1309:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_RSTSoftReset
1310:./include/lib_AT91SAM7A3.h **** //* \brief Start Software Reset
1311:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1312:./include/lib_AT91SAM7A3.h **** __inline void AT91F_RSTSoftReset(
1313:./include/lib_AT91SAM7A3.h ****         AT91PS_RSTC pRSTC,
1314:./include/lib_AT91SAM7A3.h ****         unsigned int reset)
1315:./include/lib_AT91SAM7A3.h **** {
1316:./include/lib_AT91SAM7A3.h **** 	pRSTC->RSTC_RCR = (0xA5000000 | reset);
1317:./include/lib_AT91SAM7A3.h **** }
1318:./include/lib_AT91SAM7A3.h **** 
1319:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1320:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_RSTSetMode
1321:./include/lib_AT91SAM7A3.h **** //* \brief Set Reset Mode
1322:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1323:./include/lib_AT91SAM7A3.h **** __inline void AT91F_RSTSetMode(
1324:./include/lib_AT91SAM7A3.h ****         AT91PS_RSTC pRSTC,
1325:./include/lib_AT91SAM7A3.h ****         unsigned int mode)
1326:./include/lib_AT91SAM7A3.h **** {
1327:./include/lib_AT91SAM7A3.h **** 	pRSTC->RSTC_RMR = (0xA5000000 | mode);
1328:./include/lib_AT91SAM7A3.h **** }
1329:./include/lib_AT91SAM7A3.h **** 
1330:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1331:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_RSTGetMode
1332:./include/lib_AT91SAM7A3.h **** //* \brief Get Reset Mode
1333:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1334:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_RSTGetMode(
1335:./include/lib_AT91SAM7A3.h ****         AT91PS_RSTC pRSTC)
1336:./include/lib_AT91SAM7A3.h **** {
1337:./include/lib_AT91SAM7A3.h **** 	return (pRSTC->RSTC_RMR);
1338:./include/lib_AT91SAM7A3.h **** }
1339:./include/lib_AT91SAM7A3.h **** 
1340:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1341:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_RSTGetStatus
1342:./include/lib_AT91SAM7A3.h **** //* \brief Get Reset Status
1343:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1344:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_RSTGetStatus(
1345:./include/lib_AT91SAM7A3.h ****         AT91PS_RSTC pRSTC)
1346:./include/lib_AT91SAM7A3.h **** {
1347:./include/lib_AT91SAM7A3.h **** 	return (pRSTC->RSTC_RSR);
1348:./include/lib_AT91SAM7A3.h **** }
1349:./include/lib_AT91SAM7A3.h **** 
1350:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1351:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_RSTIsSoftRstActive
1352:./include/lib_AT91SAM7A3.h **** //* \brief Return !=0 if software reset is still not completed
1353:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1354:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_RSTIsSoftRstActive(
1355:./include/lib_AT91SAM7A3.h ****         AT91PS_RSTC pRSTC)
1356:./include/lib_AT91SAM7A3.h **** {
1357:./include/lib_AT91SAM7A3.h **** 	return ((pRSTC->RSTC_RSR) & AT91C_RSTC_SRCMP);
1358:./include/lib_AT91SAM7A3.h **** }
1359:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
1360:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR SHDWC
1361:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
1362:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1363:./include/lib_AT91SAM7A3.h **** //* Function Name       : AT91F_SHDWNSetMode()
1364:./include/lib_AT91SAM7A3.h **** //* Object              : Set the Shutdown mode register
1365:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1366:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_SHDWNSetMode(
1367:./include/lib_AT91SAM7A3.h ****         AT91PS_SHDWC pSHDWC,
1368:./include/lib_AT91SAM7A3.h ****         unsigned int mode)
1369:./include/lib_AT91SAM7A3.h **** {
1370:./include/lib_AT91SAM7A3.h **** 	pSHDWC->SHDWC_SHMR = mode;
1371:./include/lib_AT91SAM7A3.h **** 	return(pSHDWC->SHDWC_SHMR);
1372:./include/lib_AT91SAM7A3.h **** }
1373:./include/lib_AT91SAM7A3.h **** 
1374:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1375:./include/lib_AT91SAM7A3.h **** //* Function Name       : AT91F_SHDWNGetMode()
1376:./include/lib_AT91SAM7A3.h **** //* Object              : Get the Shutdown mode register
1377:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1378:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_SHDWNGetMode(
1379:./include/lib_AT91SAM7A3.h ****         AT91PS_SHDWC pSHDWC)
1380:./include/lib_AT91SAM7A3.h **** {
1381:./include/lib_AT91SAM7A3.h **** 	return(pSHDWC->SHDWC_SHMR);
1382:./include/lib_AT91SAM7A3.h **** }
1383:./include/lib_AT91SAM7A3.h **** 
1384:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1385:./include/lib_AT91SAM7A3.h **** //* Function Name       : AT91F_SHDWNEnable()
1386:./include/lib_AT91SAM7A3.h **** //* Object              : Enable Shutdown
1387:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1388:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SHDWNEnable(
1389:./include/lib_AT91SAM7A3.h ****         AT91PS_SHDWC pSHDWC)
1390:./include/lib_AT91SAM7A3.h **** {
1391:./include/lib_AT91SAM7A3.h **** 	pSHDWC->SHDWC_SHCR = 0xA5000001;
1392:./include/lib_AT91SAM7A3.h **** }
1393:./include/lib_AT91SAM7A3.h **** 
1394:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1395:./include/lib_AT91SAM7A3.h **** //* Function Name       : AT91F_SHDWNGetStatus()
1396:./include/lib_AT91SAM7A3.h **** //* Object              : Get Shutdown Status
1397:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1398:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_SHDWNGetStatus(
1399:./include/lib_AT91SAM7A3.h ****         AT91PS_SHDWC pSHDWC)
1400:./include/lib_AT91SAM7A3.h **** {
1401:./include/lib_AT91SAM7A3.h **** 	return(pSHDWC->SHDWC_SHSR);
1402:./include/lib_AT91SAM7A3.h **** }
1403:./include/lib_AT91SAM7A3.h **** 
1404:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
1405:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR RTTC
1406:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
1407:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1408:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_SetRTT_TimeBase()
1409:./include/lib_AT91SAM7A3.h **** //* \brief  Set the RTT prescaler according to the TimeBase in ms
1410:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1411:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_RTTSetTimeBase(
1412:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC, 
1413:./include/lib_AT91SAM7A3.h ****         unsigned int ms)
1414:./include/lib_AT91SAM7A3.h **** {
1415:./include/lib_AT91SAM7A3.h **** 	if (ms > 2000)
1416:./include/lib_AT91SAM7A3.h **** 		return 1;   // AT91C_TIME_OUT_OF_RANGE
1417:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTMR &= ~0xFFFF;	
1418:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTMR |= (((ms << 15) /1000) & 0xFFFF);	
1419:./include/lib_AT91SAM7A3.h **** 	return 0;
1420:./include/lib_AT91SAM7A3.h **** }
1421:./include/lib_AT91SAM7A3.h **** 
1422:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1423:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTTSetPrescaler()
1424:./include/lib_AT91SAM7A3.h **** //* \brief  Set the new prescaler value
1425:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1426:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_RTTSetPrescaler(
1427:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC, 
1428:./include/lib_AT91SAM7A3.h ****         unsigned int rtpres)
1429:./include/lib_AT91SAM7A3.h **** {
1430:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTMR &= ~0xFFFF;	
1431:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTMR |= (rtpres & 0xFFFF);	
1432:./include/lib_AT91SAM7A3.h **** 	return (pRTTC->RTTC_RTMR);
1433:./include/lib_AT91SAM7A3.h **** }
1434:./include/lib_AT91SAM7A3.h **** 
1435:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1436:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTTRestart()
1437:./include/lib_AT91SAM7A3.h **** //* \brief  Restart the RTT prescaler
1438:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1439:./include/lib_AT91SAM7A3.h **** __inline void AT91F_RTTRestart(
1440:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC)
1441:./include/lib_AT91SAM7A3.h **** {
1442:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTMR |= AT91C_RTTC_RTTRST;	
1443:./include/lib_AT91SAM7A3.h **** }
1444:./include/lib_AT91SAM7A3.h **** 
1445:./include/lib_AT91SAM7A3.h **** 
1446:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1447:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTT_SetAlarmINT()
1448:./include/lib_AT91SAM7A3.h **** //* \brief  Enable RTT Alarm Interrupt
1449:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1450:./include/lib_AT91SAM7A3.h **** __inline void AT91F_RTTSetAlarmINT(
1451:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC)
1452:./include/lib_AT91SAM7A3.h **** {
1453:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTMR |= AT91C_RTTC_ALMIEN;
1454:./include/lib_AT91SAM7A3.h **** }
1455:./include/lib_AT91SAM7A3.h **** 
1456:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1457:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTT_ClearAlarmINT()
1458:./include/lib_AT91SAM7A3.h **** //* \brief  Disable RTT Alarm Interrupt
1459:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1460:./include/lib_AT91SAM7A3.h **** __inline void AT91F_RTTClearAlarmINT(
1461:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC)
1462:./include/lib_AT91SAM7A3.h **** {
1463:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTMR &= ~AT91C_RTTC_ALMIEN;
1464:./include/lib_AT91SAM7A3.h **** }
1465:./include/lib_AT91SAM7A3.h **** 
1466:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1467:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTT_SetRttIncINT()
1468:./include/lib_AT91SAM7A3.h **** //* \brief  Enable RTT INC Interrupt
1469:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1470:./include/lib_AT91SAM7A3.h **** __inline void AT91F_RTTSetRttIncINT(
1471:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC)
1472:./include/lib_AT91SAM7A3.h **** {
1473:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTMR |= AT91C_RTTC_RTTINCIEN;
1474:./include/lib_AT91SAM7A3.h **** }
1475:./include/lib_AT91SAM7A3.h **** 
1476:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1477:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTT_ClearRttIncINT()
1478:./include/lib_AT91SAM7A3.h **** //* \brief  Disable RTT INC Interrupt
1479:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1480:./include/lib_AT91SAM7A3.h **** __inline void AT91F_RTTClearRttIncINT(
1481:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC)
1482:./include/lib_AT91SAM7A3.h **** {
1483:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTMR &= ~AT91C_RTTC_RTTINCIEN;
1484:./include/lib_AT91SAM7A3.h **** }
1485:./include/lib_AT91SAM7A3.h **** 
1486:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1487:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTT_SetAlarmValue()
1488:./include/lib_AT91SAM7A3.h **** //* \brief  Set RTT Alarm Value
1489:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1490:./include/lib_AT91SAM7A3.h **** __inline void AT91F_RTTSetAlarmValue(
1491:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC, unsigned int alarm)
1492:./include/lib_AT91SAM7A3.h **** {
1493:./include/lib_AT91SAM7A3.h **** 	pRTTC->RTTC_RTAR = alarm;
1494:./include/lib_AT91SAM7A3.h **** }
1495:./include/lib_AT91SAM7A3.h **** 
1496:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1497:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTT_GetAlarmValue()
1498:./include/lib_AT91SAM7A3.h **** //* \brief  Get RTT Alarm Value
1499:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1500:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_RTTGetAlarmValue(
1501:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC)
1502:./include/lib_AT91SAM7A3.h **** {
1503:./include/lib_AT91SAM7A3.h **** 	return(pRTTC->RTTC_RTAR);
1504:./include/lib_AT91SAM7A3.h **** }
1505:./include/lib_AT91SAM7A3.h **** 
1506:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1507:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTTGetStatus()
1508:./include/lib_AT91SAM7A3.h **** //* \brief  Read the RTT status
1509:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1510:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_RTTGetStatus(
1511:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC)
1512:./include/lib_AT91SAM7A3.h **** {
1513:./include/lib_AT91SAM7A3.h **** 	return(pRTTC->RTTC_RTSR);
1514:./include/lib_AT91SAM7A3.h **** }
1515:./include/lib_AT91SAM7A3.h **** 
1516:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1517:./include/lib_AT91SAM7A3.h **** //* \fn     AT91F_RTT_ReadValue()
1518:./include/lib_AT91SAM7A3.h **** //* \brief  Read the RTT value
1519:./include/lib_AT91SAM7A3.h **** //*--------------------------------------------------------------------------------------
1520:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_RTTReadValue(
1521:./include/lib_AT91SAM7A3.h ****         AT91PS_RTTC pRTTC)
1522:./include/lib_AT91SAM7A3.h **** {
1523:./include/lib_AT91SAM7A3.h ****         register volatile unsigned int val1,val2;
1524:./include/lib_AT91SAM7A3.h **** 	do
1525:./include/lib_AT91SAM7A3.h **** 	{
1526:./include/lib_AT91SAM7A3.h **** 		val1 = pRTTC->RTTC_RTVR;
1527:./include/lib_AT91SAM7A3.h **** 		val2 = pRTTC->RTTC_RTVR;
1528:./include/lib_AT91SAM7A3.h **** 	}	
1529:./include/lib_AT91SAM7A3.h **** 	while(val1 != val2);
1530:./include/lib_AT91SAM7A3.h **** 	return(val1);
1531:./include/lib_AT91SAM7A3.h **** }
1532:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
1533:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR PITC
1534:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
1535:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1536:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PITInit
1537:./include/lib_AT91SAM7A3.h **** //* \brief System timer init : period in second, system clock freq in MHz
1538:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1539:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PITInit(
1540:./include/lib_AT91SAM7A3.h ****         AT91PS_PITC pPITC,
1541:./include/lib_AT91SAM7A3.h ****         unsigned int period,
1542:./include/lib_AT91SAM7A3.h ****         unsigned int pit_frequency)
1543:./include/lib_AT91SAM7A3.h **** {
1544:./include/lib_AT91SAM7A3.h **** 	pPITC->PITC_PIMR = period? (period * pit_frequency + 8) >> 4 : 0; // +8 to avoid %10 and /10
1545:./include/lib_AT91SAM7A3.h **** 	pPITC->PITC_PIMR |= AT91C_PITC_PITEN;	 
1546:./include/lib_AT91SAM7A3.h **** }
1547:./include/lib_AT91SAM7A3.h **** 
1548:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1549:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PITSetPIV
1550:./include/lib_AT91SAM7A3.h **** //* \brief Set the PIT Periodic Interval Value 
1551:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1552:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PITSetPIV(
1553:./include/lib_AT91SAM7A3.h ****         AT91PS_PITC pPITC,
1554:./include/lib_AT91SAM7A3.h ****         unsigned int piv)
1555:./include/lib_AT91SAM7A3.h **** {
1556:./include/lib_AT91SAM7A3.h **** 	pPITC->PITC_PIMR = piv | (pPITC->PITC_PIMR & (AT91C_PITC_PITEN | AT91C_PITC_PITIEN));
1557:./include/lib_AT91SAM7A3.h **** }
1558:./include/lib_AT91SAM7A3.h **** 
1559:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1560:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PITEnableInt
1561:./include/lib_AT91SAM7A3.h **** //* \brief Enable PIT periodic interrupt
1562:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1563:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PITEnableInt(
1564:./include/lib_AT91SAM7A3.h ****         AT91PS_PITC pPITC)
1565:./include/lib_AT91SAM7A3.h **** {
1566:./include/lib_AT91SAM7A3.h **** 	pPITC->PITC_PIMR |= AT91C_PITC_PITIEN;	 
1567:./include/lib_AT91SAM7A3.h **** }
1568:./include/lib_AT91SAM7A3.h **** 
1569:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1570:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PITDisableInt
1571:./include/lib_AT91SAM7A3.h **** //* \brief Disable PIT periodic interrupt
1572:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1573:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PITDisableInt(
1574:./include/lib_AT91SAM7A3.h ****         AT91PS_PITC pPITC)
1575:./include/lib_AT91SAM7A3.h **** {
1576:./include/lib_AT91SAM7A3.h **** 	pPITC->PITC_PIMR &= ~AT91C_PITC_PITIEN;	 
1577:./include/lib_AT91SAM7A3.h **** }
1578:./include/lib_AT91SAM7A3.h **** 
1579:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1580:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PITGetMode
1581:./include/lib_AT91SAM7A3.h **** //* \brief Read PIT mode register
1582:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1583:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PITGetMode(
1584:./include/lib_AT91SAM7A3.h ****         AT91PS_PITC pPITC)
1585:./include/lib_AT91SAM7A3.h **** {
1586:./include/lib_AT91SAM7A3.h **** 	return(pPITC->PITC_PIMR);
1587:./include/lib_AT91SAM7A3.h **** }
1588:./include/lib_AT91SAM7A3.h **** 
1589:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1590:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PITGetStatus
1591:./include/lib_AT91SAM7A3.h **** //* \brief Read PIT status register
1592:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1593:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PITGetStatus(
1594:./include/lib_AT91SAM7A3.h ****         AT91PS_PITC pPITC)
1595:./include/lib_AT91SAM7A3.h **** {
1596:./include/lib_AT91SAM7A3.h **** 	return(pPITC->PITC_PISR);
1597:./include/lib_AT91SAM7A3.h **** }
1598:./include/lib_AT91SAM7A3.h **** 
1599:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1600:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PITGetPIIR
1601:./include/lib_AT91SAM7A3.h **** //* \brief Read PIT CPIV and PICNT without ressetting the counters
1602:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1603:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PITGetPIIR(
1604:./include/lib_AT91SAM7A3.h ****         AT91PS_PITC pPITC)
1605:./include/lib_AT91SAM7A3.h **** {
1606:./include/lib_AT91SAM7A3.h **** 	return(pPITC->PITC_PIIR);
1607:./include/lib_AT91SAM7A3.h **** }
1608:./include/lib_AT91SAM7A3.h **** 
1609:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1610:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PITGetPIVR
1611:./include/lib_AT91SAM7A3.h **** //* \brief Read System timer CPIV and PICNT without ressetting the counters
1612:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1613:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PITGetPIVR(
1614:./include/lib_AT91SAM7A3.h ****         AT91PS_PITC pPITC)
1615:./include/lib_AT91SAM7A3.h **** {
1616:./include/lib_AT91SAM7A3.h **** 	return(pPITC->PITC_PIVR);
1617:./include/lib_AT91SAM7A3.h **** }
1618:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
1619:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR WDTC
1620:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
1621:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1622:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_WDTSetMode
1623:./include/lib_AT91SAM7A3.h **** //* \brief Set Watchdog Mode Register
1624:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1625:./include/lib_AT91SAM7A3.h **** __inline void AT91F_WDTSetMode(
1626:./include/lib_AT91SAM7A3.h ****         AT91PS_WDTC pWDTC,
1627:./include/lib_AT91SAM7A3.h ****         unsigned int Mode)
1628:./include/lib_AT91SAM7A3.h **** {
1629:./include/lib_AT91SAM7A3.h **** 	pWDTC->WDTC_WDMR = Mode;
1630:./include/lib_AT91SAM7A3.h **** }
1631:./include/lib_AT91SAM7A3.h **** 
1632:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1633:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_WDTRestart
1634:./include/lib_AT91SAM7A3.h **** //* \brief Restart Watchdog
1635:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1636:./include/lib_AT91SAM7A3.h **** __inline void AT91F_WDTRestart(
1637:./include/lib_AT91SAM7A3.h ****         AT91PS_WDTC pWDTC)
1638:./include/lib_AT91SAM7A3.h **** {
1639:./include/lib_AT91SAM7A3.h **** 	pWDTC->WDTC_WDCR = 0xA5000001;
1640:./include/lib_AT91SAM7A3.h **** }
1641:./include/lib_AT91SAM7A3.h **** 
1642:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1643:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_WDTSGettatus
1644:./include/lib_AT91SAM7A3.h **** //* \brief Get Watchdog Status
1645:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1646:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_WDTSGettatus(
1647:./include/lib_AT91SAM7A3.h ****         AT91PS_WDTC pWDTC)
1648:./include/lib_AT91SAM7A3.h **** {
1649:./include/lib_AT91SAM7A3.h **** 	return(pWDTC->WDTC_WDSR & 0x3);
1650:./include/lib_AT91SAM7A3.h **** }
1651:./include/lib_AT91SAM7A3.h **** 
1652:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1653:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_WDTGetPeriod
1654:./include/lib_AT91SAM7A3.h **** //* \brief Translate ms into Watchdog Compatible value
1655:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1656:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_WDTGetPeriod(unsigned int ms)
1657:./include/lib_AT91SAM7A3.h **** {
1658:./include/lib_AT91SAM7A3.h **** 	if ((ms < 4) || (ms > 16000))
1659:./include/lib_AT91SAM7A3.h **** 		return 0;
1660:./include/lib_AT91SAM7A3.h **** 	return((ms << 8) / 1000);
1661:./include/lib_AT91SAM7A3.h **** }
1662:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
1663:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR MC
1664:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
1665:./include/lib_AT91SAM7A3.h **** 
1666:./include/lib_AT91SAM7A3.h **** #define AT91C_MC_CORRECT_KEY  ((unsigned int) 0x5A << 24) // (MC) Correct Protect Key
1667:./include/lib_AT91SAM7A3.h **** 
1668:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1669:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MC_Remap
1670:./include/lib_AT91SAM7A3.h **** //* \brief Make Remap
1671:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1672:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MC_Remap (void)     //  
1673:./include/lib_AT91SAM7A3.h **** {
1674:./include/lib_AT91SAM7A3.h ****     AT91PS_MC pMC = (AT91PS_MC) AT91C_BASE_MC;
1675:./include/lib_AT91SAM7A3.h ****     
1676:./include/lib_AT91SAM7A3.h ****     pMC->MC_RCR = AT91C_MC_RCB;
1677:./include/lib_AT91SAM7A3.h **** }
1678:./include/lib_AT91SAM7A3.h **** 
1679:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1680:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MC_EFC_CfgModeReg
1681:./include/lib_AT91SAM7A3.h **** //* \brief Configure the EFC Mode Register of the MC controller
1682:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1683:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MC_EFC_CfgModeReg (
1684:./include/lib_AT91SAM7A3.h **** 	AT91PS_MC pMC, // pointer to a MC controller
1685:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)        // mode register 
1686:./include/lib_AT91SAM7A3.h **** {
1687:./include/lib_AT91SAM7A3.h **** 	// Write to the FMR register
1688:./include/lib_AT91SAM7A3.h **** 	pMC->MC_FMR = mode;
1689:./include/lib_AT91SAM7A3.h **** }
1690:./include/lib_AT91SAM7A3.h **** 
1691:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1692:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MC_EFC_GetModeReg
1693:./include/lib_AT91SAM7A3.h **** //* \brief Return MC EFC Mode Regsiter
1694:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1695:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MC_EFC_GetModeReg(
1696:./include/lib_AT91SAM7A3.h **** 	AT91PS_MC pMC) // pointer to a MC controller
1697:./include/lib_AT91SAM7A3.h **** {
1698:./include/lib_AT91SAM7A3.h **** 	return pMC->MC_FMR;
1699:./include/lib_AT91SAM7A3.h **** }
1700:./include/lib_AT91SAM7A3.h **** 
1701:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1702:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MC_EFC_ComputeFMCN
1703:./include/lib_AT91SAM7A3.h **** //* \brief Return MC EFC Mode Regsiter
1704:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1705:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MC_EFC_ComputeFMCN(
1706:./include/lib_AT91SAM7A3.h **** 	int master_clock) // master clock in Hz
1707:./include/lib_AT91SAM7A3.h **** {
1708:./include/lib_AT91SAM7A3.h **** 	return (master_clock/1000000 +2);
1709:./include/lib_AT91SAM7A3.h **** }
1710:./include/lib_AT91SAM7A3.h **** 
1711:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1712:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MC_EFC_PerformCmd
1713:./include/lib_AT91SAM7A3.h **** //* \brief Perform EFC Command
1714:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1715:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MC_EFC_PerformCmd (
1716:./include/lib_AT91SAM7A3.h **** 	AT91PS_MC pMC, // pointer to a MC controller
1717:./include/lib_AT91SAM7A3.h ****     unsigned int transfer_cmd)
1718:./include/lib_AT91SAM7A3.h **** {
1719:./include/lib_AT91SAM7A3.h **** 	pMC->MC_FCR = transfer_cmd;	
1720:./include/lib_AT91SAM7A3.h **** }
1721:./include/lib_AT91SAM7A3.h **** 
1722:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1723:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MC_EFC_GetStatus
1724:./include/lib_AT91SAM7A3.h **** //* \brief Return MC EFC Status
1725:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1726:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MC_EFC_GetStatus(
1727:./include/lib_AT91SAM7A3.h **** 	AT91PS_MC pMC) // pointer to a MC controller
1728:./include/lib_AT91SAM7A3.h **** {
1729:./include/lib_AT91SAM7A3.h **** 	return pMC->MC_FSR;
1730:./include/lib_AT91SAM7A3.h **** }
1731:./include/lib_AT91SAM7A3.h **** 
1732:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1733:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MC_EFC_IsInterruptMasked
1734:./include/lib_AT91SAM7A3.h **** //* \brief Test if EFC MC Interrupt is Masked 
1735:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1736:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MC_EFC_IsInterruptMasked(
1737:./include/lib_AT91SAM7A3.h ****         AT91PS_MC pMC,   // \arg  pointer to a MC controller
1738:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
1739:./include/lib_AT91SAM7A3.h **** {
1740:./include/lib_AT91SAM7A3.h **** 	return (AT91F_MC_EFC_GetModeReg(pMC) & flag);
1741:./include/lib_AT91SAM7A3.h **** }
1742:./include/lib_AT91SAM7A3.h **** 
1743:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1744:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MC_EFC_IsInterruptSet
1745:./include/lib_AT91SAM7A3.h **** //* \brief Test if EFC MC Interrupt is Set
1746:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1747:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MC_EFC_IsInterruptSet(
1748:./include/lib_AT91SAM7A3.h ****         AT91PS_MC pMC,   // \arg  pointer to a MC controller
1749:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
1750:./include/lib_AT91SAM7A3.h **** {
1751:./include/lib_AT91SAM7A3.h **** 	return (AT91F_MC_EFC_GetStatus(pMC) & flag);
1752:./include/lib_AT91SAM7A3.h **** }
1753:./include/lib_AT91SAM7A3.h **** 
1754:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
1755:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR CAN
1756:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
1757:./include/lib_AT91SAM7A3.h **** #define	STANDARD_FORMAT 0
1758:./include/lib_AT91SAM7A3.h **** #define	EXTENDED_FORMAT 1
1759:./include/lib_AT91SAM7A3.h **** 
1760:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1761:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_InitMailboxRegisters()
1762:./include/lib_AT91SAM7A3.h **** //* \brief Configure the corresponding mailbox
1763:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1764:./include/lib_AT91SAM7A3.h **** __inline void AT91F_InitMailboxRegisters(AT91PS_CAN_MB	CAN_Mailbox,
1765:./include/lib_AT91SAM7A3.h **** 								int  			mode_reg,
1766:./include/lib_AT91SAM7A3.h **** 								int 			acceptance_mask_reg,
1767:./include/lib_AT91SAM7A3.h **** 								int  			id_reg,
1768:./include/lib_AT91SAM7A3.h **** 								int  			data_low_reg,
1769:./include/lib_AT91SAM7A3.h **** 								int  			data_high_reg,
1770:./include/lib_AT91SAM7A3.h **** 								int  			control_reg)
1771:./include/lib_AT91SAM7A3.h **** {
1772:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MCR 	= 0x0;
1773:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MMR 	= mode_reg;
1774:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MAM 	= acceptance_mask_reg;
1775:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MID 	= id_reg;
1776:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MDL 	= data_low_reg; 		
1777:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MDH 	= data_high_reg;
1778:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MCR 	= control_reg;
1779:./include/lib_AT91SAM7A3.h **** }
1780:./include/lib_AT91SAM7A3.h **** 
1781:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1782:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_EnableCAN()
1783:./include/lib_AT91SAM7A3.h **** //* \brief 
1784:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1785:./include/lib_AT91SAM7A3.h **** __inline void AT91F_EnableCAN(
1786:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN)     // pointer to a CAN controller
1787:./include/lib_AT91SAM7A3.h **** {
1788:./include/lib_AT91SAM7A3.h **** 	pCAN->CAN_MR |= AT91C_CAN_CANEN;
1789:./include/lib_AT91SAM7A3.h **** 
1790:./include/lib_AT91SAM7A3.h **** 	// Wait for WAKEUP flag raising <=> 11-recessive-bit were scanned by the transceiver
1791:./include/lib_AT91SAM7A3.h **** 	while( (pCAN->CAN_SR & AT91C_CAN_WAKEUP) != AT91C_CAN_WAKEUP );
1792:./include/lib_AT91SAM7A3.h **** }
1793:./include/lib_AT91SAM7A3.h **** 
1794:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1795:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_DisableCAN()
1796:./include/lib_AT91SAM7A3.h **** //* \brief 
1797:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1798:./include/lib_AT91SAM7A3.h **** __inline void AT91F_DisableCAN(
1799:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN)     // pointer to a CAN controller
1800:./include/lib_AT91SAM7A3.h **** {
1801:./include/lib_AT91SAM7A3.h **** 	pCAN->CAN_MR &= ~AT91C_CAN_CANEN;
1802:./include/lib_AT91SAM7A3.h **** }
1803:./include/lib_AT91SAM7A3.h **** 
1804:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1805:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_EnableIt
1806:./include/lib_AT91SAM7A3.h **** //* \brief Enable CAN interrupt
1807:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1808:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_EnableIt (
1809:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN,     // pointer to a CAN controller
1810:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // IT to be enabled
1811:./include/lib_AT91SAM7A3.h **** {
1812:./include/lib_AT91SAM7A3.h **** 	//* Write to the IER register
1813:./include/lib_AT91SAM7A3.h **** 	pCAN->CAN_IER = flag;
1814:./include/lib_AT91SAM7A3.h **** }
1815:./include/lib_AT91SAM7A3.h **** 
1816:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1817:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_DisableIt
1818:./include/lib_AT91SAM7A3.h **** //* \brief Disable CAN interrupt
1819:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1820:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_DisableIt (
1821:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN, // pointer to a CAN controller
1822:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // IT to be disabled
1823:./include/lib_AT91SAM7A3.h **** {
1824:./include/lib_AT91SAM7A3.h **** 	//* Write to the IDR register
1825:./include/lib_AT91SAM7A3.h **** 	pCAN->CAN_IDR = flag;
1826:./include/lib_AT91SAM7A3.h **** }
1827:./include/lib_AT91SAM7A3.h **** 
1828:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1829:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetStatus
1830:./include/lib_AT91SAM7A3.h **** //* \brief Return CAN Interrupt Status
1831:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1832:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetStatus( // \return CAN Interrupt Status
1833:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN) // pointer to a CAN controller
1834:./include/lib_AT91SAM7A3.h **** {
1835:./include/lib_AT91SAM7A3.h **** 	return pCAN->CAN_SR;
1836:./include/lib_AT91SAM7A3.h **** }
1837:./include/lib_AT91SAM7A3.h **** 
1838:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1839:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetInterruptMaskStatus
1840:./include/lib_AT91SAM7A3.h **** //* \brief Return CAN Interrupt Mask Status
1841:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1842:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetInterruptMaskStatus( // \return CAN Interrupt Mask Status
1843:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN) // pointer to a CAN controller
1844:./include/lib_AT91SAM7A3.h **** {
1845:./include/lib_AT91SAM7A3.h **** 	return pCAN->CAN_IMR;
1846:./include/lib_AT91SAM7A3.h **** }
1847:./include/lib_AT91SAM7A3.h **** 
1848:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1849:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_IsInterruptMasked
1850:./include/lib_AT91SAM7A3.h **** //* \brief Test if CAN Interrupt is Masked 
1851:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1852:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_IsInterruptMasked(
1853:./include/lib_AT91SAM7A3.h ****         AT91PS_CAN pCAN,   // \arg  pointer to a CAN controller
1854:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
1855:./include/lib_AT91SAM7A3.h **** {
1856:./include/lib_AT91SAM7A3.h **** 	return (AT91F_CAN_GetInterruptMaskStatus(pCAN) & flag);
1857:./include/lib_AT91SAM7A3.h **** }
1858:./include/lib_AT91SAM7A3.h **** 
1859:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1860:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_IsStatusSet
1861:./include/lib_AT91SAM7A3.h **** //* \brief Test if CAN Interrupt is Set
1862:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1863:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_IsStatusSet(
1864:./include/lib_AT91SAM7A3.h ****         AT91PS_CAN pCAN,   // \arg  pointer to a CAN controller
1865:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
1866:./include/lib_AT91SAM7A3.h **** {
1867:./include/lib_AT91SAM7A3.h **** 	return (AT91F_CAN_GetStatus(pCAN) & flag);
1868:./include/lib_AT91SAM7A3.h **** }
1869:./include/lib_AT91SAM7A3.h **** 
1870:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1871:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_CfgModeReg
1872:./include/lib_AT91SAM7A3.h **** //* \brief Configure the Mode Register of the CAN controller
1873:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1874:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_CfgModeReg (
1875:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN, // pointer to a CAN controller
1876:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)        // mode register 
1877:./include/lib_AT91SAM7A3.h **** {
1878:./include/lib_AT91SAM7A3.h **** 	//* Write to the MR register
1879:./include/lib_AT91SAM7A3.h **** 	pCAN->CAN_MR = mode;
1880:./include/lib_AT91SAM7A3.h **** }
1881:./include/lib_AT91SAM7A3.h **** 
1882:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1883:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetModeReg
1884:./include/lib_AT91SAM7A3.h **** //* \brief Return the Mode Register of the CAN controller value
1885:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1886:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetModeReg (
1887:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN // pointer to a CAN controller
1888:./include/lib_AT91SAM7A3.h **** 	)
1889:./include/lib_AT91SAM7A3.h **** {
1890:./include/lib_AT91SAM7A3.h **** 	return pCAN->CAN_MR;	
1891:./include/lib_AT91SAM7A3.h **** }
1892:./include/lib_AT91SAM7A3.h **** 
1893:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1894:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_CfgBaudrateReg
1895:./include/lib_AT91SAM7A3.h **** //* \brief Configure the Baudrate of the CAN controller for the network
1896:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1897:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_CfgBaudrateReg (
1898:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN, // pointer to a CAN controller
1899:./include/lib_AT91SAM7A3.h **** 	unsigned int baudrate_cfg)
1900:./include/lib_AT91SAM7A3.h **** {
1901:./include/lib_AT91SAM7A3.h **** 	//* Write to the BR register
1902:./include/lib_AT91SAM7A3.h **** 	pCAN->CAN_BR = baudrate_cfg;	
1903:./include/lib_AT91SAM7A3.h **** }
1904:./include/lib_AT91SAM7A3.h **** 
1905:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1906:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetBaudrate
1907:./include/lib_AT91SAM7A3.h **** //* \brief Return the Baudrate of the CAN controller for the network value
1908:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1909:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetBaudrate (
1910:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN // pointer to a CAN controller
1911:./include/lib_AT91SAM7A3.h **** 	)
1912:./include/lib_AT91SAM7A3.h **** {
1913:./include/lib_AT91SAM7A3.h **** 	return pCAN->CAN_BR;	
1914:./include/lib_AT91SAM7A3.h **** }
1915:./include/lib_AT91SAM7A3.h **** 
1916:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1917:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetInternalCounter
1918:./include/lib_AT91SAM7A3.h **** //* \brief Return CAN Timer Regsiter Value
1919:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1920:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetInternalCounter (
1921:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN // pointer to a CAN controller
1922:./include/lib_AT91SAM7A3.h **** 	)
1923:./include/lib_AT91SAM7A3.h **** {
1924:./include/lib_AT91SAM7A3.h **** 	return pCAN->CAN_TIM;	
1925:./include/lib_AT91SAM7A3.h **** }
1926:./include/lib_AT91SAM7A3.h **** 
1927:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1928:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetTimestamp
1929:./include/lib_AT91SAM7A3.h **** //* \brief Return CAN Timestamp Register Value
1930:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1931:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetTimestamp (
1932:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN // pointer to a CAN controller
1933:./include/lib_AT91SAM7A3.h **** 	)
1934:./include/lib_AT91SAM7A3.h **** {
1935:./include/lib_AT91SAM7A3.h **** 	return pCAN->CAN_TIMESTP;	
1936:./include/lib_AT91SAM7A3.h **** }
1937:./include/lib_AT91SAM7A3.h **** 
1938:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1939:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetErrorCounter
1940:./include/lib_AT91SAM7A3.h **** //* \brief Return CAN Error Counter Register Value
1941:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1942:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetErrorCounter (
1943:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN // pointer to a CAN controller
1944:./include/lib_AT91SAM7A3.h **** 	)
1945:./include/lib_AT91SAM7A3.h **** {
1946:./include/lib_AT91SAM7A3.h **** 	return pCAN->CAN_ECR;	
1947:./include/lib_AT91SAM7A3.h **** }
1948:./include/lib_AT91SAM7A3.h **** 
1949:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1950:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_InitTransferRequest
1951:./include/lib_AT91SAM7A3.h **** //* \brief Request for a transfer on the corresponding mailboxes
1952:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1953:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_InitTransferRequest (
1954:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN, // pointer to a CAN controller
1955:./include/lib_AT91SAM7A3.h ****     unsigned int transfer_cmd)
1956:./include/lib_AT91SAM7A3.h **** {
1957:./include/lib_AT91SAM7A3.h **** 	pCAN->CAN_TCR = transfer_cmd;	
1958:./include/lib_AT91SAM7A3.h **** }
1959:./include/lib_AT91SAM7A3.h **** 
1960:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1961:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_InitAbortRequest
1962:./include/lib_AT91SAM7A3.h **** //* \brief Abort the corresponding mailboxes
1963:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1964:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_InitAbortRequest (
1965:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN pCAN, // pointer to a CAN controller
1966:./include/lib_AT91SAM7A3.h ****     unsigned int abort_cmd)
1967:./include/lib_AT91SAM7A3.h **** {
1968:./include/lib_AT91SAM7A3.h **** 	pCAN->CAN_ACR = abort_cmd;	
1969:./include/lib_AT91SAM7A3.h **** }
1970:./include/lib_AT91SAM7A3.h **** 
1971:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1972:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_CfgMessageModeReg
1973:./include/lib_AT91SAM7A3.h **** //* \brief Program the Message Mode Register
1974:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1975:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_CfgMessageModeReg (
1976:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox, // pointer to a CAN Mailbox
1977:./include/lib_AT91SAM7A3.h ****     unsigned int mode)
1978:./include/lib_AT91SAM7A3.h **** {
1979:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MMR = mode;	
1980:./include/lib_AT91SAM7A3.h **** }
1981:./include/lib_AT91SAM7A3.h **** 
1982:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1983:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetMessageModeReg
1984:./include/lib_AT91SAM7A3.h **** //* \brief Return the Message Mode Register
1985:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1986:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetMessageModeReg (
1987:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox) // pointer to a CAN Mailbox
1988:./include/lib_AT91SAM7A3.h **** {
1989:./include/lib_AT91SAM7A3.h **** 	return CAN_Mailbox->CAN_MB_MMR;	
1990:./include/lib_AT91SAM7A3.h **** }
1991:./include/lib_AT91SAM7A3.h **** 
1992:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1993:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_CfgMessageIDReg
1994:./include/lib_AT91SAM7A3.h **** //* \brief Program the Message ID Register
1995:./include/lib_AT91SAM7A3.h **** //* \brief Version == 0 for Standard messsage, Version == 1 for Extended  
1996:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
1997:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_CfgMessageIDReg (
1998:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox, // pointer to a CAN Mailbox
1999:./include/lib_AT91SAM7A3.h ****     unsigned int id,
2000:./include/lib_AT91SAM7A3.h ****     unsigned char version)
2001:./include/lib_AT91SAM7A3.h **** {
2002:./include/lib_AT91SAM7A3.h **** 	if(version==0)	// IDvA Standard Format
2003:./include/lib_AT91SAM7A3.h **** 		CAN_Mailbox->CAN_MB_MID = id<<18;
2004:./include/lib_AT91SAM7A3.h **** 	else	// IDvB Extended Format
2005:./include/lib_AT91SAM7A3.h **** 		CAN_Mailbox->CAN_MB_MID = id | (1<<29);	// set MIDE bit
2006:./include/lib_AT91SAM7A3.h **** }
2007:./include/lib_AT91SAM7A3.h **** 
2008:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2009:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetMessageIDReg
2010:./include/lib_AT91SAM7A3.h **** //* \brief Return the Message ID Register
2011:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2012:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetMessageIDReg (
2013:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox) // pointer to a CAN Mailbox
2014:./include/lib_AT91SAM7A3.h **** {
2015:./include/lib_AT91SAM7A3.h **** 	return CAN_Mailbox->CAN_MB_MID;
2016:./include/lib_AT91SAM7A3.h **** }
2017:./include/lib_AT91SAM7A3.h **** 
2018:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2019:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_CfgMessageAcceptanceMaskReg
2020:./include/lib_AT91SAM7A3.h **** //* \brief Program the Message Acceptance Mask Register
2021:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2022:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_CfgMessageAcceptanceMaskReg (
2023:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox, // pointer to a CAN Mailbox
2024:./include/lib_AT91SAM7A3.h ****     unsigned int mask)
2025:./include/lib_AT91SAM7A3.h **** {
2026:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MAM = mask;
2027:./include/lib_AT91SAM7A3.h **** }
2028:./include/lib_AT91SAM7A3.h **** 
2029:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2030:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetMessageAcceptanceMaskReg
2031:./include/lib_AT91SAM7A3.h **** //* \brief Return the Message Acceptance Mask Register
2032:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2033:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetMessageAcceptanceMaskReg (
2034:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox) // pointer to a CAN Mailbox
2035:./include/lib_AT91SAM7A3.h **** {
2036:./include/lib_AT91SAM7A3.h **** 	return CAN_Mailbox->CAN_MB_MAM;
2037:./include/lib_AT91SAM7A3.h **** }
2038:./include/lib_AT91SAM7A3.h **** 
2039:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2040:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetFamilyID
2041:./include/lib_AT91SAM7A3.h **** //* \brief Return the Message ID Register
2042:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2043:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetFamilyID (
2044:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox) // pointer to a CAN Mailbox
2045:./include/lib_AT91SAM7A3.h **** {
2046:./include/lib_AT91SAM7A3.h **** 	return CAN_Mailbox->CAN_MB_MFID;	
2047:./include/lib_AT91SAM7A3.h **** }
2048:./include/lib_AT91SAM7A3.h **** 
2049:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2050:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_CfgMessageCtrl
2051:./include/lib_AT91SAM7A3.h **** //* \brief Request and config for a transfer on the corresponding mailbox
2052:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2053:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_CfgMessageCtrlReg (
2054:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox, // pointer to a CAN Mailbox
2055:./include/lib_AT91SAM7A3.h ****     unsigned int message_ctrl_cmd)
2056:./include/lib_AT91SAM7A3.h **** {
2057:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MCR = message_ctrl_cmd;	
2058:./include/lib_AT91SAM7A3.h **** }
2059:./include/lib_AT91SAM7A3.h **** 
2060:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2061:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetMessageStatus
2062:./include/lib_AT91SAM7A3.h **** //* \brief Return CAN Mailbox Status
2063:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2064:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetMessageStatus (
2065:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox) // pointer to a CAN Mailbox
2066:./include/lib_AT91SAM7A3.h **** {
2067:./include/lib_AT91SAM7A3.h **** 	return CAN_Mailbox->CAN_MB_MSR;	
2068:./include/lib_AT91SAM7A3.h **** }
2069:./include/lib_AT91SAM7A3.h **** 
2070:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2071:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_CfgMessageDataLow
2072:./include/lib_AT91SAM7A3.h **** //* \brief Program data low value
2073:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2074:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_CfgMessageDataLow (
2075:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox, // pointer to a CAN Mailbox
2076:./include/lib_AT91SAM7A3.h ****     unsigned int data)
2077:./include/lib_AT91SAM7A3.h **** {
2078:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MDL = data;	
2079:./include/lib_AT91SAM7A3.h **** }
2080:./include/lib_AT91SAM7A3.h **** 
2081:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2082:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetMessageDataLow
2083:./include/lib_AT91SAM7A3.h **** //* \brief Return data low value
2084:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2085:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetMessageDataLow (
2086:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox) // pointer to a CAN Mailbox
2087:./include/lib_AT91SAM7A3.h **** {
2088:./include/lib_AT91SAM7A3.h **** 	return CAN_Mailbox->CAN_MB_MDL;	
2089:./include/lib_AT91SAM7A3.h **** }
2090:./include/lib_AT91SAM7A3.h **** 
2091:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2092:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_CfgMessageDataHigh
2093:./include/lib_AT91SAM7A3.h **** //* \brief Program data high value
2094:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2095:./include/lib_AT91SAM7A3.h **** __inline void AT91F_CAN_CfgMessageDataHigh (
2096:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox, // pointer to a CAN Mailbox
2097:./include/lib_AT91SAM7A3.h ****     unsigned int data)
2098:./include/lib_AT91SAM7A3.h **** {
2099:./include/lib_AT91SAM7A3.h **** 	CAN_Mailbox->CAN_MB_MDH = data;	
2100:./include/lib_AT91SAM7A3.h **** }
2101:./include/lib_AT91SAM7A3.h **** 
2102:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2103:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_CAN_GetMessageDataHigh
2104:./include/lib_AT91SAM7A3.h **** //* \brief Return data high value
2105:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2106:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_CAN_GetMessageDataHigh (
2107:./include/lib_AT91SAM7A3.h **** 	AT91PS_CAN_MB	CAN_Mailbox) // pointer to a CAN Mailbox
2108:./include/lib_AT91SAM7A3.h **** {
2109:./include/lib_AT91SAM7A3.h **** 	return CAN_Mailbox->CAN_MB_MDH;	
2110:./include/lib_AT91SAM7A3.h **** }
2111:./include/lib_AT91SAM7A3.h **** 
2112:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
2113:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR TC
2114:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
2115:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2116:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_TC_InterruptEnable
2117:./include/lib_AT91SAM7A3.h **** //* \brief Enable TC Interrupt
2118:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2119:./include/lib_AT91SAM7A3.h **** __inline void AT91F_TC_InterruptEnable(
2120:./include/lib_AT91SAM7A3.h ****         AT91PS_TC pTc,   // \arg  pointer to a TC controller
2121:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  TC interrupt to be enabled
2122:./include/lib_AT91SAM7A3.h **** {
2123:./include/lib_AT91SAM7A3.h ****         pTc->TC_IER = flag;
2124:./include/lib_AT91SAM7A3.h **** }
2125:./include/lib_AT91SAM7A3.h **** 
2126:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2127:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_TC_InterruptDisable
2128:./include/lib_AT91SAM7A3.h **** //* \brief Disable TC Interrupt
2129:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2130:./include/lib_AT91SAM7A3.h **** __inline void AT91F_TC_InterruptDisable(
2131:./include/lib_AT91SAM7A3.h ****         AT91PS_TC pTc,   // \arg  pointer to a TC controller
2132:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  TC interrupt to be disabled
2133:./include/lib_AT91SAM7A3.h **** {
2134:./include/lib_AT91SAM7A3.h ****         pTc->TC_IDR = flag;
2135:./include/lib_AT91SAM7A3.h **** }
2136:./include/lib_AT91SAM7A3.h **** 
2137:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2138:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_TC_GetInterruptMaskStatus
2139:./include/lib_AT91SAM7A3.h **** //* \brief Return TC Interrupt Mask Status
2140:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2141:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_TC_GetInterruptMaskStatus( // \return TC Interrupt Mask Status
2142:./include/lib_AT91SAM7A3.h ****         AT91PS_TC pTc) // \arg  pointer to a TC controller
2143:./include/lib_AT91SAM7A3.h **** {
2144:./include/lib_AT91SAM7A3.h ****         return pTc->TC_IMR;
2145:./include/lib_AT91SAM7A3.h **** }
2146:./include/lib_AT91SAM7A3.h **** 
2147:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2148:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_TC_IsInterruptMasked
2149:./include/lib_AT91SAM7A3.h **** //* \brief Test if TC Interrupt is Masked 
2150:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2151:./include/lib_AT91SAM7A3.h **** __inline int AT91F_TC_IsInterruptMasked(
2152:./include/lib_AT91SAM7A3.h ****         AT91PS_TC pTc,   // \arg  pointer to a TC controller
2153:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
2154:./include/lib_AT91SAM7A3.h **** {
2155:./include/lib_AT91SAM7A3.h ****         return (AT91F_TC_GetInterruptMaskStatus(pTc) & flag);
2156:./include/lib_AT91SAM7A3.h **** }
2157:./include/lib_AT91SAM7A3.h **** 
2158:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
2159:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR MCI
2160:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
2161:./include/lib_AT91SAM7A3.h **** //* Classic MCI Data Timeout Register Configuration with 1048576 MCK cycles between 2 data transfer
2162:./include/lib_AT91SAM7A3.h **** #define AT91C_MCI_DTOR_1MEGA_CYCLES	(AT91C_MCI_DTOCYC | AT91C_MCI_DTOMUL)
2163:./include/lib_AT91SAM7A3.h **** 
2164:./include/lib_AT91SAM7A3.h **** //* Classic MCI SDCard Register Configuration with 1-bit data bus on slot A
2165:./include/lib_AT91SAM7A3.h **** #define AT91C_MCI_MMC_SLOTA	(AT91C_MCI_SCDSEL & 0x0)
2166:./include/lib_AT91SAM7A3.h **** 
2167:./include/lib_AT91SAM7A3.h **** //* Classic MCI SDCard Register Configuration with 1-bit data bus on slot B
2168:./include/lib_AT91SAM7A3.h **** #define AT91C_MCI_MMC_SLOTB	(AT91C_MCI_SCDSEL & 0x1)
2169:./include/lib_AT91SAM7A3.h **** 
2170:./include/lib_AT91SAM7A3.h **** //* Classic MCI SDCard Register Configuration with 4-bit data bus on slot A
2171:./include/lib_AT91SAM7A3.h **** #define AT91C_MCI_SDCARD_4BITS_SLOTA	( (AT91C_MCI_SCDSEL & 0x0) | AT91C_MCI_SCDBUS )
2172:./include/lib_AT91SAM7A3.h **** 
2173:./include/lib_AT91SAM7A3.h **** //* Classic MCI SDCard Register Configuration with 4-bit data bus on slot B
2174:./include/lib_AT91SAM7A3.h **** #define AT91C_MCI_SDCARD_4BITS_SLOTB	( (AT91C_MCI_SCDSEL & 0x1) | AT91C_MCI_SCDBUS )
2175:./include/lib_AT91SAM7A3.h **** 
2176:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2177:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_Configure
2178:./include/lib_AT91SAM7A3.h **** //* \brief Configure the MCI
2179:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2180:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_Configure (
2181:./include/lib_AT91SAM7A3.h ****         AT91PS_MCI pMCI,  			 // \arg pointer to a MCI controller
2182:./include/lib_AT91SAM7A3.h ****         unsigned int DTOR_register,  // \arg Data Timeout Register to be programmed
2183:./include/lib_AT91SAM7A3.h ****         unsigned int MR_register,  	 // \arg Mode Register to be programmed
2184:./include/lib_AT91SAM7A3.h ****         unsigned int SDCR_register)  // \arg SDCard Register to be programmed
2185:./include/lib_AT91SAM7A3.h **** {
2186:./include/lib_AT91SAM7A3.h ****     //* Disable the MCI
2187:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_CR = AT91C_MCI_MCIDIS | AT91C_MCI_PWSDIS;
2188:./include/lib_AT91SAM7A3.h **** 
2189:./include/lib_AT91SAM7A3.h ****     //* Disable all the interrupts
2190:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_IDR = 0xFFFFFFFF;
2191:./include/lib_AT91SAM7A3.h **** 
2192:./include/lib_AT91SAM7A3.h ****     //* Set the Data Timeout Register
2193:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_DTOR = DTOR_register;
2194:./include/lib_AT91SAM7A3.h **** 
2195:./include/lib_AT91SAM7A3.h ****     //* Set the Mode Register
2196:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_MR = MR_register;
2197:./include/lib_AT91SAM7A3.h **** 
2198:./include/lib_AT91SAM7A3.h ****     //* Set the SDCard Register
2199:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_SDCR = SDCR_register;
2200:./include/lib_AT91SAM7A3.h **** 
2201:./include/lib_AT91SAM7A3.h ****    //* Enable the MCI
2202:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_CR = AT91C_MCI_MCIEN | AT91C_MCI_PWSEN;
2203:./include/lib_AT91SAM7A3.h **** }
2204:./include/lib_AT91SAM7A3.h **** 
2205:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2206:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_EnableIt
2207:./include/lib_AT91SAM7A3.h **** //* \brief Enable MCI IT
2208:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2209:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_EnableIt (
2210:./include/lib_AT91SAM7A3.h ****         AT91PS_MCI pMCI, // \arg pointer to a MCI controller
2211:./include/lib_AT91SAM7A3.h ****         unsigned int flag)   // \arg IT to be enabled
2212:./include/lib_AT91SAM7A3.h **** {
2213:./include/lib_AT91SAM7A3.h ****     //* Write to the IER register
2214:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_IER = flag;
2215:./include/lib_AT91SAM7A3.h **** }
2216:./include/lib_AT91SAM7A3.h **** 
2217:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2218:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_DisableIt
2219:./include/lib_AT91SAM7A3.h **** //* \brief Disable MCI IT
2220:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2221:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_DisableIt (
2222:./include/lib_AT91SAM7A3.h ****         AT91PS_MCI pMCI, // \arg pointer to a MCI controller
2223:./include/lib_AT91SAM7A3.h ****         unsigned int flag)   // \arg IT to be disabled
2224:./include/lib_AT91SAM7A3.h **** {
2225:./include/lib_AT91SAM7A3.h ****     //* Write to the IDR register
2226:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_IDR = flag;
2227:./include/lib_AT91SAM7A3.h **** }
2228:./include/lib_AT91SAM7A3.h **** 
2229:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2230:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetStatus
2231:./include/lib_AT91SAM7A3.h **** //* \brief Return MCI Interrupt Status
2232:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2233:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetStatus( // \return MCI Interrupt Status
2234:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI) // pointer to a MCI controller
2235:./include/lib_AT91SAM7A3.h **** {
2236:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_SR;
2237:./include/lib_AT91SAM7A3.h **** }
2238:./include/lib_AT91SAM7A3.h **** 
2239:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2240:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetInterruptMaskStatus
2241:./include/lib_AT91SAM7A3.h **** //* \brief Return MCI Interrupt Mask Status
2242:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2243:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetInterruptMaskStatus( // \return MCI Interrupt Mask Status
2244:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI) // pointer to a MCI controller
2245:./include/lib_AT91SAM7A3.h **** {
2246:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_IMR;
2247:./include/lib_AT91SAM7A3.h **** }
2248:./include/lib_AT91SAM7A3.h **** 
2249:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2250:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_IsInterruptMasked
2251:./include/lib_AT91SAM7A3.h **** //* \brief Test if MCI Interrupt is Masked 
2252:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2253:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_IsInterruptMasked(
2254:./include/lib_AT91SAM7A3.h ****         AT91PS_MCI pMCI,   // \arg  pointer to a MCI controller
2255:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
2256:./include/lib_AT91SAM7A3.h **** {
2257:./include/lib_AT91SAM7A3.h **** 	return (AT91F_MCI_GetInterruptMaskStatus(pMCI) & flag);
2258:./include/lib_AT91SAM7A3.h **** }
2259:./include/lib_AT91SAM7A3.h **** 
2260:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2261:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_IsStatusSet
2262:./include/lib_AT91SAM7A3.h **** //* \brief Test if MCI Status is Set
2263:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2264:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_IsStatusSet(
2265:./include/lib_AT91SAM7A3.h ****         AT91PS_MCI pMCI,   // \arg  pointer to a MCI controller
2266:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
2267:./include/lib_AT91SAM7A3.h **** {
2268:./include/lib_AT91SAM7A3.h **** 	return (AT91F_MCI_GetStatus(pMCI) & flag);
2269:./include/lib_AT91SAM7A3.h **** }
2270:./include/lib_AT91SAM7A3.h **** 
2271:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2272:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_Enable
2273:./include/lib_AT91SAM7A3.h **** //* \brief Enable the MCI Interface
2274:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2275:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_Enable (
2276:./include/lib_AT91SAM7A3.h ****         AT91PS_MCI pMCI)     // \arg pointer to a MCI controller
2277:./include/lib_AT91SAM7A3.h **** {
2278:./include/lib_AT91SAM7A3.h ****     //* Enable the MCI
2279:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_CR = AT91C_MCI_MCIEN;
2280:./include/lib_AT91SAM7A3.h **** }
2281:./include/lib_AT91SAM7A3.h **** 
2282:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2283:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_Disable
2284:./include/lib_AT91SAM7A3.h **** //* \brief Disable the MCI Interface
2285:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2286:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_Disable (
2287:./include/lib_AT91SAM7A3.h ****         AT91PS_MCI pMCI)     // \arg pointer to a MCI controller
2288:./include/lib_AT91SAM7A3.h **** {
2289:./include/lib_AT91SAM7A3.h ****     //* Disable the MCI
2290:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_CR = AT91C_MCI_MCIDIS;
2291:./include/lib_AT91SAM7A3.h **** }
2292:./include/lib_AT91SAM7A3.h **** 
2293:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2294:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_SW_Reset
2295:./include/lib_AT91SAM7A3.h **** //* \brief Reset the MCI Interface
2296:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2297:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_SW_Reset (
2298:./include/lib_AT91SAM7A3.h ****         AT91PS_MCI pMCI)     // \arg pointer to a MCI controller
2299:./include/lib_AT91SAM7A3.h **** {
2300:./include/lib_AT91SAM7A3.h ****     //* Disable the MCI
2301:./include/lib_AT91SAM7A3.h ****     pMCI->MCI_CR = AT91C_MCI_SWRST;
2302:./include/lib_AT91SAM7A3.h **** }
2303:./include/lib_AT91SAM7A3.h **** 
2304:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2305:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_CfgModeReg
2306:./include/lib_AT91SAM7A3.h **** //* \brief Configure the Mode Register of the MCI controller
2307:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2308:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_CfgModeReg (
2309:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI, // pointer to a MCI controller
2310:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)        // mode register 
2311:./include/lib_AT91SAM7A3.h **** {
2312:./include/lib_AT91SAM7A3.h **** 	//* Write to the MR register
2313:./include/lib_AT91SAM7A3.h **** 	pMCI->MCI_MR = mode;
2314:./include/lib_AT91SAM7A3.h **** }
2315:./include/lib_AT91SAM7A3.h **** 
2316:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2317:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetModeReg
2318:./include/lib_AT91SAM7A3.h **** //* \brief Return the Mode Register of the MCI controller value
2319:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2320:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetModeReg (
2321:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI // pointer to a MCI controller
2322:./include/lib_AT91SAM7A3.h **** 	)
2323:./include/lib_AT91SAM7A3.h **** {
2324:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_MR;	
2325:./include/lib_AT91SAM7A3.h **** }
2326:./include/lib_AT91SAM7A3.h **** 
2327:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2328:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_CfgFrequency
2329:./include/lib_AT91SAM7A3.h **** //* \brief Configure the frequency MCCK of the MCI controller
2330:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2331:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_CfgFrequency (
2332:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI, // pointer to a MCI controller
2333:./include/lib_AT91SAM7A3.h **** 	unsigned int mck_clock, // in MHz 
2334:./include/lib_AT91SAM7A3.h **** 	unsigned int mci_clock)	// in MHz  
2335:./include/lib_AT91SAM7A3.h **** {
2336:./include/lib_AT91SAM7A3.h **** 	unsigned int prescal;
2337:./include/lib_AT91SAM7A3.h **** 	
2338:./include/lib_AT91SAM7A3.h **** 	prescal = mck_clock/(2*mci_clock) - 1;
2339:./include/lib_AT91SAM7A3.h **** 	
2340:./include/lib_AT91SAM7A3.h **** 	//* Write to the MR register
2341:./include/lib_AT91SAM7A3.h **** 	pMCI->MCI_MR &= ~AT91C_MCI_CLKDIV;
2342:./include/lib_AT91SAM7A3.h **** 	pMCI->MCI_MR |= (prescal & AT91C_MCI_CLKDIV);
2343:./include/lib_AT91SAM7A3.h **** }
2344:./include/lib_AT91SAM7A3.h **** 
2345:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2346:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_CfgDataTimeOutReg
2347:./include/lib_AT91SAM7A3.h **** //* \brief Configure the Data TimeOut Register of the MCI controller
2348:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2349:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_CfgDataTimeOutReg (
2350:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI, // pointer to a MCI controller
2351:./include/lib_AT91SAM7A3.h **** 	unsigned int cfg)
2352:./include/lib_AT91SAM7A3.h **** {
2353:./include/lib_AT91SAM7A3.h **** 	//* Write to the DTOR register
2354:./include/lib_AT91SAM7A3.h **** 	pMCI->MCI_DTOR = cfg;
2355:./include/lib_AT91SAM7A3.h **** }
2356:./include/lib_AT91SAM7A3.h **** 
2357:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2358:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetDataTimeOutReg
2359:./include/lib_AT91SAM7A3.h **** //* \brief Return the Data TimeOut Register of the MCI controller value
2360:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2361:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetDataTimeOutReg (
2362:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI // pointer to a MCI controller
2363:./include/lib_AT91SAM7A3.h **** 	)
2364:./include/lib_AT91SAM7A3.h **** {
2365:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_DTOR;	
2366:./include/lib_AT91SAM7A3.h **** }
2367:./include/lib_AT91SAM7A3.h **** 
2368:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2369:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_CfgSDCardReg
2370:./include/lib_AT91SAM7A3.h **** //* \brief Configure the SDCard Register of the MCI controller
2371:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2372:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_CfgSDCardReg (
2373:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI, // pointer to a MCI controller
2374:./include/lib_AT91SAM7A3.h **** 	unsigned int cfg)
2375:./include/lib_AT91SAM7A3.h **** {
2376:./include/lib_AT91SAM7A3.h **** 	//* Write to the SDCR register
2377:./include/lib_AT91SAM7A3.h **** 	pMCI->MCI_SDCR = cfg;
2378:./include/lib_AT91SAM7A3.h **** }
2379:./include/lib_AT91SAM7A3.h **** 
2380:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2381:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetSDCardReg
2382:./include/lib_AT91SAM7A3.h **** //* \brief Return the SDCard Register of the MCI controller value
2383:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2384:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetSDCardReg (
2385:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI // pointer to a MCI controller
2386:./include/lib_AT91SAM7A3.h **** 	)
2387:./include/lib_AT91SAM7A3.h **** {
2388:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_SDCR;	
2389:./include/lib_AT91SAM7A3.h **** }
2390:./include/lib_AT91SAM7A3.h **** 
2391:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2392:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_CfgARGReg
2393:./include/lib_AT91SAM7A3.h **** //* \brief Configure the Command ARGUMENT Register of the MCI controller
2394:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2395:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_CfgARGReg (
2396:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI, // pointer to a MCI controller
2397:./include/lib_AT91SAM7A3.h **** 	unsigned int arg)
2398:./include/lib_AT91SAM7A3.h **** {
2399:./include/lib_AT91SAM7A3.h **** 	//* Write to the ARG register
2400:./include/lib_AT91SAM7A3.h **** 	pMCI->MCI_ARGR = arg;
2401:./include/lib_AT91SAM7A3.h **** }
2402:./include/lib_AT91SAM7A3.h **** 
2403:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2404:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetARGReg
2405:./include/lib_AT91SAM7A3.h **** //* \brief Return the Command ARGUMENT Register of the MCI controller value
2406:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2407:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetARGReg (
2408:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI // pointer to a MCI controller
2409:./include/lib_AT91SAM7A3.h **** 	)
2410:./include/lib_AT91SAM7A3.h **** {
2411:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_ARGR;	
2412:./include/lib_AT91SAM7A3.h **** }
2413:./include/lib_AT91SAM7A3.h **** 
2414:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2415:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_CfgCMDReg
2416:./include/lib_AT91SAM7A3.h **** //* \brief Configure the COMMAND Register of the MCI controller
2417:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2418:./include/lib_AT91SAM7A3.h **** __inline void AT91F_MCI_CfgCMDReg (
2419:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI, // pointer to a MCI controller
2420:./include/lib_AT91SAM7A3.h **** 	unsigned int cmd)
2421:./include/lib_AT91SAM7A3.h **** {
2422:./include/lib_AT91SAM7A3.h **** 	//* Write to the ARG register
2423:./include/lib_AT91SAM7A3.h **** 	pMCI->MCI_CMDR = cmd;
2424:./include/lib_AT91SAM7A3.h **** }
2425:./include/lib_AT91SAM7A3.h **** 
2426:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2427:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetRSP0Reg
2428:./include/lib_AT91SAM7A3.h **** //* \brief Return the RESPONSE Register 0 of the MCI controller value
2429:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2430:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetRSP0Reg (
2431:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI // pointer to a MCI controller
2432:./include/lib_AT91SAM7A3.h **** 	)
2433:./include/lib_AT91SAM7A3.h **** {
2434:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_RSPR[0];	
2435:./include/lib_AT91SAM7A3.h **** }
2436:./include/lib_AT91SAM7A3.h **** 
2437:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2438:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetRSP1Reg
2439:./include/lib_AT91SAM7A3.h **** //* \brief Return the RESPONSE Register 1 of the MCI controller value
2440:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2441:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetRSP1Reg (
2442:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI // pointer to a MCI controller
2443:./include/lib_AT91SAM7A3.h **** 	)
2444:./include/lib_AT91SAM7A3.h **** {
2445:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_RSPR[0];	
2446:./include/lib_AT91SAM7A3.h **** }
2447:./include/lib_AT91SAM7A3.h **** 
2448:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2449:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetRSP2Reg
2450:./include/lib_AT91SAM7A3.h **** //* \brief Return the RESPONSE Register 2 of the MCI controller value
2451:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2452:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetRSP2Reg (
2453:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI // pointer to a MCI controller
2454:./include/lib_AT91SAM7A3.h **** 	)
2455:./include/lib_AT91SAM7A3.h **** {
2456:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_RSPR[0];	
2457:./include/lib_AT91SAM7A3.h **** }
2458:./include/lib_AT91SAM7A3.h **** 
2459:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2460:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_MCI_GetRSP3Reg
2461:./include/lib_AT91SAM7A3.h **** //* \brief Return the RESPONSE Register 3 of the MCI controller value
2462:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2463:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_MCI_GetRSP3Reg (
2464:./include/lib_AT91SAM7A3.h **** 	AT91PS_MCI pMCI // pointer to a MCI controller
2465:./include/lib_AT91SAM7A3.h **** 	)
2466:./include/lib_AT91SAM7A3.h **** {
2467:./include/lib_AT91SAM7A3.h **** 	return pMCI->MCI_RSPR[0];	
2468:./include/lib_AT91SAM7A3.h **** }
2469:./include/lib_AT91SAM7A3.h **** 
2470:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
2471:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR UDP
2472:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
2473:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2474:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_EnableIt
2475:./include/lib_AT91SAM7A3.h **** //* \brief Enable UDP IT
2476:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2477:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_EnableIt (
2478:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
2479:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg IT to be enabled
2480:./include/lib_AT91SAM7A3.h **** {
2481:./include/lib_AT91SAM7A3.h **** 	//* Write to the IER register
2482:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_IER = flag;
2483:./include/lib_AT91SAM7A3.h **** }
2484:./include/lib_AT91SAM7A3.h **** 
2485:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2486:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_DisableIt
2487:./include/lib_AT91SAM7A3.h **** //* \brief Disable UDP IT
2488:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2489:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_DisableIt (
2490:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
2491:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg IT to be disabled
2492:./include/lib_AT91SAM7A3.h **** {
2493:./include/lib_AT91SAM7A3.h **** 	//* Write to the IDR register
2494:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_IDR = flag;
2495:./include/lib_AT91SAM7A3.h **** }
2496:./include/lib_AT91SAM7A3.h **** 
2497:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2498:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_SetAddress
2499:./include/lib_AT91SAM7A3.h **** //* \brief Set UDP functional address
2500:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2501:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_SetAddress (
2502:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
2503:./include/lib_AT91SAM7A3.h **** 	unsigned char address)   // \arg new UDP address
2504:./include/lib_AT91SAM7A3.h **** {
2505:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_FADDR = (AT91C_UDP_FEN | address);
2506:./include/lib_AT91SAM7A3.h **** }
2507:./include/lib_AT91SAM7A3.h **** 
2508:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2509:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_EnableEp
2510:./include/lib_AT91SAM7A3.h **** //* \brief Enable Endpoint
2511:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2512:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_EnableEp (
2513:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
2514:./include/lib_AT91SAM7A3.h **** 	unsigned char endpoint)   // \arg endpoint number
2515:./include/lib_AT91SAM7A3.h **** {
2516:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_CSR[endpoint] |= AT91C_UDP_EPEDS;
2517:./include/lib_AT91SAM7A3.h **** }
2518:./include/lib_AT91SAM7A3.h **** 
2519:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2520:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_DisableEp
2521:./include/lib_AT91SAM7A3.h **** //* \brief Enable Endpoint
2522:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2523:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_DisableEp (
2524:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
2525:./include/lib_AT91SAM7A3.h **** 	unsigned char endpoint)   // \arg endpoint number
2526:./include/lib_AT91SAM7A3.h **** {
2527:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_CSR[endpoint] &= ~AT91C_UDP_EPEDS;
2528:./include/lib_AT91SAM7A3.h **** }
2529:./include/lib_AT91SAM7A3.h **** 
2530:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2531:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_SetState
2532:./include/lib_AT91SAM7A3.h **** //* \brief Set UDP Device state
2533:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2534:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_SetState (
2535:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
2536:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg new UDP address
2537:./include/lib_AT91SAM7A3.h **** {
2538:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_GLBSTATE  &= ~(AT91C_UDP_FADDEN | AT91C_UDP_CONFG);
2539:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_GLBSTATE  |= flag;
2540:./include/lib_AT91SAM7A3.h **** }
2541:./include/lib_AT91SAM7A3.h **** 
2542:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2543:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_GetState
2544:./include/lib_AT91SAM7A3.h **** //* \brief return UDP Device state
2545:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2546:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_UDP_GetState ( // \return the UDP device state
2547:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP)     // \arg pointer to a UDP controller
2548:./include/lib_AT91SAM7A3.h **** {
2549:./include/lib_AT91SAM7A3.h **** 	return (pUDP->UDP_GLBSTATE  & (AT91C_UDP_FADDEN | AT91C_UDP_CONFG));
2550:./include/lib_AT91SAM7A3.h **** }
2551:./include/lib_AT91SAM7A3.h **** 
2552:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2553:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_ResetEp
2554:./include/lib_AT91SAM7A3.h **** //* \brief Reset UDP endpoint
2555:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2556:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_ResetEp ( // \return the UDP device state
2557:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
2558:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg Endpoints to be reset
2559:./include/lib_AT91SAM7A3.h **** {
2560:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_RSTEP = flag;
2561:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_RSTEP = 0;
2562:./include/lib_AT91SAM7A3.h **** }
2563:./include/lib_AT91SAM7A3.h **** 
2564:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2565:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_EpStall
2566:./include/lib_AT91SAM7A3.h **** //* \brief Endpoint will STALL requests
2567:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2568:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_EpStall(
2569:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
2570:./include/lib_AT91SAM7A3.h **** 	unsigned char endpoint)   // \arg endpoint number
2571:./include/lib_AT91SAM7A3.h **** {
2572:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_CSR[endpoint] |= AT91C_UDP_FORCESTALL;
2573:./include/lib_AT91SAM7A3.h **** }
2574:./include/lib_AT91SAM7A3.h **** 
2575:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2576:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_EpWrite
2577:./include/lib_AT91SAM7A3.h **** //* \brief Write value in the DPR
2578:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2579:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_EpWrite(
2580:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
2581:./include/lib_AT91SAM7A3.h **** 	unsigned char endpoint,  // \arg endpoint number
2582:./include/lib_AT91SAM7A3.h **** 	unsigned char value)     // \arg value to be written in the DPR
2583:./include/lib_AT91SAM7A3.h **** {
2584:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_FDR[endpoint] = value;
2585:./include/lib_AT91SAM7A3.h **** }
2586:./include/lib_AT91SAM7A3.h **** 
2587:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2588:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_EpRead
2589:./include/lib_AT91SAM7A3.h **** //* \brief Return value from the DPR
2590:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2591:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_UDP_EpRead(
2592:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
2593:./include/lib_AT91SAM7A3.h **** 	unsigned char endpoint)  // \arg endpoint number
2594:./include/lib_AT91SAM7A3.h **** {
2595:./include/lib_AT91SAM7A3.h **** 	return pUDP->UDP_FDR[endpoint];
2596:./include/lib_AT91SAM7A3.h **** }
2597:./include/lib_AT91SAM7A3.h **** 
2598:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2599:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_EpEndOfWr
2600:./include/lib_AT91SAM7A3.h **** //* \brief Notify the UDP that values in DPR are ready to be sent
2601:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2602:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_EpEndOfWr(
2603:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
2604:./include/lib_AT91SAM7A3.h **** 	unsigned char endpoint)  // \arg endpoint number
2605:./include/lib_AT91SAM7A3.h **** {
2606:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_CSR[endpoint] |= AT91C_UDP_TXPKTRDY;
2607:./include/lib_AT91SAM7A3.h **** }
2608:./include/lib_AT91SAM7A3.h **** 
2609:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2610:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_EpClear
2611:./include/lib_AT91SAM7A3.h **** //* \brief Clear flag in the endpoint CSR register
2612:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2613:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_EpClear(
2614:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
2615:./include/lib_AT91SAM7A3.h **** 	unsigned char endpoint,  // \arg endpoint number
2616:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)       // \arg flag to be cleared
2617:./include/lib_AT91SAM7A3.h **** {
2618:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_CSR[endpoint] &= ~(flag);
2619:./include/lib_AT91SAM7A3.h **** }
2620:./include/lib_AT91SAM7A3.h **** 
2621:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2622:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_EpSet
2623:./include/lib_AT91SAM7A3.h **** //* \brief Set flag in the endpoint CSR register
2624:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2625:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_EpSet(
2626:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
2627:./include/lib_AT91SAM7A3.h **** 	unsigned char endpoint,  // \arg endpoint number
2628:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)       // \arg flag to be cleared
2629:./include/lib_AT91SAM7A3.h **** {
2630:./include/lib_AT91SAM7A3.h **** 	pUDP->UDP_CSR[endpoint] |= flag;
2631:./include/lib_AT91SAM7A3.h **** }
2632:./include/lib_AT91SAM7A3.h **** 
2633:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2634:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_EpStatus
2635:./include/lib_AT91SAM7A3.h **** //* \brief Return the endpoint CSR register
2636:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2637:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_UDP_EpStatus(
2638:./include/lib_AT91SAM7A3.h **** 	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
2639:./include/lib_AT91SAM7A3.h **** 	unsigned char endpoint)  // \arg endpoint number
2640:./include/lib_AT91SAM7A3.h **** {
2641:./include/lib_AT91SAM7A3.h **** 	return pUDP->UDP_CSR[endpoint];
2642:./include/lib_AT91SAM7A3.h **** }
2643:./include/lib_AT91SAM7A3.h **** 
2644:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2645:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_GetInterruptMaskStatus
2646:./include/lib_AT91SAM7A3.h **** //* \brief Return UDP Interrupt Mask Status
2647:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2648:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_UDP_GetInterruptMaskStatus(
2649:./include/lib_AT91SAM7A3.h ****   AT91PS_UDP pUdp)        // \arg  pointer to a UDP controller
2650:./include/lib_AT91SAM7A3.h **** {
2651:./include/lib_AT91SAM7A3.h ****   return pUdp->UDP_IMR;
2652:./include/lib_AT91SAM7A3.h **** }
2653:./include/lib_AT91SAM7A3.h **** 
2654:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2655:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_UDP_IsInterruptMasked
2656:./include/lib_AT91SAM7A3.h **** //* \brief Test if UDP Interrupt is Masked 
2657:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2658:./include/lib_AT91SAM7A3.h **** __inline int AT91F_UDP_IsInterruptMasked(
2659:./include/lib_AT91SAM7A3.h ****   AT91PS_UDP pUdp,       // \arg  pointer to a UDP controller
2660:./include/lib_AT91SAM7A3.h ****   unsigned int flag)     // \arg  flag to be tested
2661:./include/lib_AT91SAM7A3.h **** {
2662:./include/lib_AT91SAM7A3.h ****   return (AT91F_UDP_GetInterruptMaskStatus(pUdp) & flag);
2663:./include/lib_AT91SAM7A3.h **** }
2664:./include/lib_AT91SAM7A3.h **** 
2665:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
2666:./include/lib_AT91SAM7A3.h **** //  \fn    AT91F_UDP_InterruptStatusRegister
2667:./include/lib_AT91SAM7A3.h **** //  \brief Return the Interrupt Status Register
2668:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
2669:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_UDP_InterruptStatusRegister( 
2670:./include/lib_AT91SAM7A3.h ****   AT91PS_UDP pUDP )      // \arg  pointer to a UDP controller
2671:./include/lib_AT91SAM7A3.h **** {
2672:./include/lib_AT91SAM7A3.h ****   return pUDP->UDP_ISR;
2673:./include/lib_AT91SAM7A3.h **** }
2674:./include/lib_AT91SAM7A3.h **** 
2675:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
2676:./include/lib_AT91SAM7A3.h **** //  \fn    AT91F_UDP_InterruptClearRegister
2677:./include/lib_AT91SAM7A3.h **** //  \brief Clear Interrupt Register
2678:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
2679:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_InterruptClearRegister (
2680:./include/lib_AT91SAM7A3.h ****   AT91PS_UDP pUDP,       // \arg pointer to UDP controller
2681:./include/lib_AT91SAM7A3.h ****   unsigned int flag)     // \arg IT to be cleat
2682:./include/lib_AT91SAM7A3.h **** {
2683:./include/lib_AT91SAM7A3.h ****   pUDP->UDP_ICR = flag; 
2684:./include/lib_AT91SAM7A3.h **** }
2685:./include/lib_AT91SAM7A3.h **** 
2686:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
2687:./include/lib_AT91SAM7A3.h **** //  \fn    AT91F_UDP_EnableTransceiver
2688:./include/lib_AT91SAM7A3.h **** //  \brief Enable transceiver
2689:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
2690:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_EnableTransceiver( 
2691:./include/lib_AT91SAM7A3.h ****   AT91PS_UDP pUDP )      // \arg  pointer to a UDP controller
2692:./include/lib_AT91SAM7A3.h **** {
2693:./include/lib_AT91SAM7A3.h ****     pUDP->UDP_TXVC &= ~AT91C_UDP_TXVDIS; 
2694:./include/lib_AT91SAM7A3.h **** }
2695:./include/lib_AT91SAM7A3.h **** 
2696:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
2697:./include/lib_AT91SAM7A3.h **** //  \fn    AT91F_UDP_DisableTransceiver
2698:./include/lib_AT91SAM7A3.h **** //  \brief Disable transceiver
2699:./include/lib_AT91SAM7A3.h **** // ----------------------------------------------------------------------------
2700:./include/lib_AT91SAM7A3.h **** __inline void AT91F_UDP_DisableTransceiver( 
2701:./include/lib_AT91SAM7A3.h ****   AT91PS_UDP pUDP )      // \arg  pointer to a UDP controller
2702:./include/lib_AT91SAM7A3.h **** {
2703:./include/lib_AT91SAM7A3.h ****     pUDP->UDP_TXVC = AT91C_UDP_TXVDIS; 
2704:./include/lib_AT91SAM7A3.h **** }
2705:./include/lib_AT91SAM7A3.h **** 
2706:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
2707:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR TWI
2708:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
2709:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2710:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_TWI_EnableIt
2711:./include/lib_AT91SAM7A3.h **** //* \brief Enable TWI IT
2712:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2713:./include/lib_AT91SAM7A3.h **** __inline void AT91F_TWI_EnableIt (
2714:./include/lib_AT91SAM7A3.h **** 	AT91PS_TWI pTWI, // \arg pointer to a TWI controller
2715:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg IT to be enabled
2716:./include/lib_AT91SAM7A3.h **** {
2717:./include/lib_AT91SAM7A3.h **** 	//* Write to the IER register
2718:./include/lib_AT91SAM7A3.h **** 	pTWI->TWI_IER = flag;
2719:./include/lib_AT91SAM7A3.h **** }
2720:./include/lib_AT91SAM7A3.h **** 
2721:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2722:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_TWI_DisableIt
2723:./include/lib_AT91SAM7A3.h **** //* \brief Disable TWI IT
2724:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2725:./include/lib_AT91SAM7A3.h **** __inline void AT91F_TWI_DisableIt (
2726:./include/lib_AT91SAM7A3.h **** 	AT91PS_TWI pTWI, // \arg pointer to a TWI controller
2727:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg IT to be disabled
2728:./include/lib_AT91SAM7A3.h **** {
2729:./include/lib_AT91SAM7A3.h **** 	//* Write to the IDR register
2730:./include/lib_AT91SAM7A3.h **** 	pTWI->TWI_IDR = flag;
2731:./include/lib_AT91SAM7A3.h **** }
2732:./include/lib_AT91SAM7A3.h **** 
2733:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2734:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_TWI_Configure
2735:./include/lib_AT91SAM7A3.h **** //* \brief Configure TWI in master mode
2736:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2737:./include/lib_AT91SAM7A3.h **** __inline void AT91F_TWI_Configure ( AT91PS_TWI pTWI )          // \arg pointer to a TWI controller
2738:./include/lib_AT91SAM7A3.h **** {
2739:./include/lib_AT91SAM7A3.h ****     //* Disable interrupts
2740:./include/lib_AT91SAM7A3.h **** 	pTWI->TWI_IDR = (unsigned int) -1;
2741:./include/lib_AT91SAM7A3.h **** 
2742:./include/lib_AT91SAM7A3.h ****     //* Reset peripheral
2743:./include/lib_AT91SAM7A3.h **** 	pTWI->TWI_CR = AT91C_TWI_SWRST;
2744:./include/lib_AT91SAM7A3.h **** 
2745:./include/lib_AT91SAM7A3.h **** 	//* Set Master mode
2746:./include/lib_AT91SAM7A3.h **** 	pTWI->TWI_CR = AT91C_TWI_MSEN;
2747:./include/lib_AT91SAM7A3.h **** 
2748:./include/lib_AT91SAM7A3.h **** }
2749:./include/lib_AT91SAM7A3.h **** 
2750:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2751:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_TWI_GetInterruptMaskStatus
2752:./include/lib_AT91SAM7A3.h **** //* \brief Return TWI Interrupt Mask Status
2753:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2754:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_TWI_GetInterruptMaskStatus( // \return TWI Interrupt Mask Status
2755:./include/lib_AT91SAM7A3.h ****         AT91PS_TWI pTwi) // \arg  pointer to a TWI controller
2756:./include/lib_AT91SAM7A3.h **** {
2757:./include/lib_AT91SAM7A3.h ****         return pTwi->TWI_IMR;
2758:./include/lib_AT91SAM7A3.h **** }
2759:./include/lib_AT91SAM7A3.h **** 
2760:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2761:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_TWI_IsInterruptMasked
2762:./include/lib_AT91SAM7A3.h **** //* \brief Test if TWI Interrupt is Masked 
2763:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2764:./include/lib_AT91SAM7A3.h **** __inline int AT91F_TWI_IsInterruptMasked(
2765:./include/lib_AT91SAM7A3.h ****         AT91PS_TWI pTwi,   // \arg  pointer to a TWI controller
2766:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
2767:./include/lib_AT91SAM7A3.h **** {
2768:./include/lib_AT91SAM7A3.h ****         return (AT91F_TWI_GetInterruptMaskStatus(pTwi) & flag);
2769:./include/lib_AT91SAM7A3.h **** }
2770:./include/lib_AT91SAM7A3.h **** 
2771:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
2772:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR USART
2773:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
2774:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2775:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_Baudrate
2776:./include/lib_AT91SAM7A3.h **** //* \brief Calculate the baudrate
2777:./include/lib_AT91SAM7A3.h **** //* Standard Asynchronous Mode : 8 bits , 1 stop , no parity
2778:./include/lib_AT91SAM7A3.h **** #define AT91C_US_ASYNC_MODE ( AT91C_US_USMODE_NORMAL + \
2779:./include/lib_AT91SAM7A3.h ****                         AT91C_US_NBSTOP_1_BIT + \
2780:./include/lib_AT91SAM7A3.h ****                         AT91C_US_PAR_NONE + \
2781:./include/lib_AT91SAM7A3.h ****                         AT91C_US_CHRL_8_BITS + \
2782:./include/lib_AT91SAM7A3.h ****                         AT91C_US_CLKS_CLOCK )
2783:./include/lib_AT91SAM7A3.h **** 
2784:./include/lib_AT91SAM7A3.h **** //* Standard External Asynchronous Mode : 8 bits , 1 stop , no parity
2785:./include/lib_AT91SAM7A3.h **** #define AT91C_US_ASYNC_SCK_MODE ( AT91C_US_USMODE_NORMAL + \
2786:./include/lib_AT91SAM7A3.h ****                             AT91C_US_NBSTOP_1_BIT + \
2787:./include/lib_AT91SAM7A3.h ****                             AT91C_US_PAR_NONE + \
2788:./include/lib_AT91SAM7A3.h ****                             AT91C_US_CHRL_8_BITS + \
2789:./include/lib_AT91SAM7A3.h ****                             AT91C_US_CLKS_EXT )
2790:./include/lib_AT91SAM7A3.h **** 
2791:./include/lib_AT91SAM7A3.h **** //* Standard Synchronous Mode : 8 bits , 1 stop , no parity
2792:./include/lib_AT91SAM7A3.h **** #define AT91C_US_SYNC_MODE ( AT91C_US_SYNC + \
2793:./include/lib_AT91SAM7A3.h ****                        AT91C_US_USMODE_NORMAL + \
2794:./include/lib_AT91SAM7A3.h ****                        AT91C_US_NBSTOP_1_BIT + \
2795:./include/lib_AT91SAM7A3.h ****                        AT91C_US_PAR_NONE + \
2796:./include/lib_AT91SAM7A3.h ****                        AT91C_US_CHRL_8_BITS + \
2797:./include/lib_AT91SAM7A3.h ****                        AT91C_US_CLKS_CLOCK )
2798:./include/lib_AT91SAM7A3.h **** 
2799:./include/lib_AT91SAM7A3.h **** //* SCK used Label
2800:./include/lib_AT91SAM7A3.h **** #define AT91C_US_SCK_USED (AT91C_US_CKLO | AT91C_US_CLKS_EXT)
2801:./include/lib_AT91SAM7A3.h **** 
2802:./include/lib_AT91SAM7A3.h **** //* Standard ISO T=0 Mode : 8 bits , 1 stop , parity
2803:./include/lib_AT91SAM7A3.h **** #define AT91C_US_ISO_READER_MODE ( AT91C_US_USMODE_ISO7816_0 + \
2804:./include/lib_AT91SAM7A3.h **** 					   		 AT91C_US_CLKS_CLOCK +\
2805:./include/lib_AT91SAM7A3.h ****                        		 AT91C_US_NBSTOP_1_BIT + \
2806:./include/lib_AT91SAM7A3.h ****                        		 AT91C_US_PAR_EVEN + \
2807:./include/lib_AT91SAM7A3.h ****                        		 AT91C_US_CHRL_8_BITS + \
2808:./include/lib_AT91SAM7A3.h ****                        		 AT91C_US_CKLO +\
2809:./include/lib_AT91SAM7A3.h ****                        		 AT91C_US_OVER)
2810:./include/lib_AT91SAM7A3.h **** 
2811:./include/lib_AT91SAM7A3.h **** //* Standard IRDA mode
2812:./include/lib_AT91SAM7A3.h **** #define AT91C_US_ASYNC_IRDA_MODE (  AT91C_US_USMODE_IRDA + \
2813:./include/lib_AT91SAM7A3.h ****                             AT91C_US_NBSTOP_1_BIT + \
2814:./include/lib_AT91SAM7A3.h ****                             AT91C_US_PAR_NONE + \
2815:./include/lib_AT91SAM7A3.h ****                             AT91C_US_CHRL_8_BITS + \
2816:./include/lib_AT91SAM7A3.h ****                             AT91C_US_CLKS_CLOCK )
2817:./include/lib_AT91SAM7A3.h **** 
2818:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2819:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_Baudrate
2820:./include/lib_AT91SAM7A3.h **** //* \brief Caluculate baud_value according to the main clock and the baud rate
2821:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2822:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_US_Baudrate (
2823:./include/lib_AT91SAM7A3.h **** 	const unsigned int main_clock, // \arg peripheral clock
2824:./include/lib_AT91SAM7A3.h **** 	const unsigned int baud_rate)  // \arg UART baudrate
2825:./include/lib_AT91SAM7A3.h **** {
2826:./include/lib_AT91SAM7A3.h **** 	unsigned int baud_value = ((main_clock*10)/(baud_rate * 16));
2827:./include/lib_AT91SAM7A3.h **** 	if ((baud_value % 10) >= 5)
2828:./include/lib_AT91SAM7A3.h **** 		baud_value = (baud_value / 10) + 1;
2829:./include/lib_AT91SAM7A3.h **** 	else
2830:./include/lib_AT91SAM7A3.h **** 		baud_value /= 10;
2831:./include/lib_AT91SAM7A3.h **** 	return baud_value;
2832:./include/lib_AT91SAM7A3.h **** }
2833:./include/lib_AT91SAM7A3.h **** 
2834:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2835:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_SetBaudrate
2836:./include/lib_AT91SAM7A3.h **** //* \brief Set the baudrate according to the CPU clock
2837:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2838:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_SetBaudrate (
2839:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART,    // \arg pointer to a USART controller
2840:./include/lib_AT91SAM7A3.h **** 	unsigned int mainClock, // \arg peripheral clock
2841:./include/lib_AT91SAM7A3.h **** 	unsigned int speed)     // \arg UART baudrate
2842:./include/lib_AT91SAM7A3.h **** {
2843:./include/lib_AT91SAM7A3.h **** 	//* Define the baud rate divisor register
2844:./include/lib_AT91SAM7A3.h **** 	pUSART->US_BRGR = AT91F_US_Baudrate(mainClock, speed);
2845:./include/lib_AT91SAM7A3.h **** }
2846:./include/lib_AT91SAM7A3.h **** 
2847:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2848:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_SetTimeguard
2849:./include/lib_AT91SAM7A3.h **** //* \brief Set USART timeguard
2850:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2851:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_SetTimeguard (
2852:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART,    // \arg pointer to a USART controller
2853:./include/lib_AT91SAM7A3.h **** 	unsigned int timeguard) // \arg timeguard value
2854:./include/lib_AT91SAM7A3.h **** {
2855:./include/lib_AT91SAM7A3.h **** 	//* Write the Timeguard Register
2856:./include/lib_AT91SAM7A3.h **** 	pUSART->US_TTGR = timeguard ;
2857:./include/lib_AT91SAM7A3.h **** }
2858:./include/lib_AT91SAM7A3.h **** 
2859:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2860:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_EnableIt
2861:./include/lib_AT91SAM7A3.h **** //* \brief Enable USART IT
2862:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2863:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_EnableIt (
2864:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART, // \arg pointer to a USART controller
2865:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg IT to be enabled
2866:./include/lib_AT91SAM7A3.h **** {
2867:./include/lib_AT91SAM7A3.h **** 	//* Write to the IER register
2868:./include/lib_AT91SAM7A3.h **** 	pUSART->US_IER = flag;
2869:./include/lib_AT91SAM7A3.h **** }
2870:./include/lib_AT91SAM7A3.h **** 
2871:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2872:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_DisableIt
2873:./include/lib_AT91SAM7A3.h **** //* \brief Disable USART IT
2874:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2875:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_DisableIt (
2876:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART, // \arg pointer to a USART controller
2877:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg IT to be disabled
2878:./include/lib_AT91SAM7A3.h **** {
2879:./include/lib_AT91SAM7A3.h **** 	//* Write to the IER register
2880:./include/lib_AT91SAM7A3.h **** 	pUSART->US_IDR = flag;
2881:./include/lib_AT91SAM7A3.h **** }
2882:./include/lib_AT91SAM7A3.h **** 
2883:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2884:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_Configure
2885:./include/lib_AT91SAM7A3.h **** //* \brief Configure USART
2886:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2887:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_Configure (
2888:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART,     // \arg pointer to a USART controller
2889:./include/lib_AT91SAM7A3.h **** 	unsigned int mainClock,  // \arg peripheral clock
2890:./include/lib_AT91SAM7A3.h **** 	unsigned int mode ,      // \arg mode Register to be programmed
2891:./include/lib_AT91SAM7A3.h **** 	unsigned int baudRate ,  // \arg baudrate to be programmed
2892:./include/lib_AT91SAM7A3.h **** 	unsigned int timeguard ) // \arg timeguard to be programmed
2893:./include/lib_AT91SAM7A3.h **** {
2894:./include/lib_AT91SAM7A3.h ****     //* Disable interrupts
2895:./include/lib_AT91SAM7A3.h ****     pUSART->US_IDR = (unsigned int) -1;
2896:./include/lib_AT91SAM7A3.h **** 
2897:./include/lib_AT91SAM7A3.h ****     //* Reset receiver and transmitter
2898:./include/lib_AT91SAM7A3.h ****     pUSART->US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX | AT91C_US_RXDIS | AT91C_US_TXDIS ;
2899:./include/lib_AT91SAM7A3.h **** 
2900:./include/lib_AT91SAM7A3.h **** 	//* Define the baud rate divisor register
2901:./include/lib_AT91SAM7A3.h **** 	AT91F_US_SetBaudrate(pUSART, mainClock, baudRate);
2902:./include/lib_AT91SAM7A3.h **** 
2903:./include/lib_AT91SAM7A3.h **** 	//* Write the Timeguard Register
2904:./include/lib_AT91SAM7A3.h **** 	AT91F_US_SetTimeguard(pUSART, timeguard);
2905:./include/lib_AT91SAM7A3.h **** 
2906:./include/lib_AT91SAM7A3.h ****     //* Clear Transmit and Receive Counters
2907:./include/lib_AT91SAM7A3.h ****     AT91F_PDC_Open((AT91PS_PDC) &(pUSART->US_RPR));
2908:./include/lib_AT91SAM7A3.h **** 
2909:./include/lib_AT91SAM7A3.h ****     //* Define the USART mode
2910:./include/lib_AT91SAM7A3.h ****     pUSART->US_MR = mode  ;
2911:./include/lib_AT91SAM7A3.h **** 
2912:./include/lib_AT91SAM7A3.h **** }
2913:./include/lib_AT91SAM7A3.h **** 
2914:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2915:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_EnableRx
2916:./include/lib_AT91SAM7A3.h **** //* \brief Enable receiving characters
2917:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2918:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_EnableRx (
2919:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2920:./include/lib_AT91SAM7A3.h **** {
2921:./include/lib_AT91SAM7A3.h ****     //* Enable receiver
2922:./include/lib_AT91SAM7A3.h ****     pUSART->US_CR = AT91C_US_RXEN;
2923:./include/lib_AT91SAM7A3.h **** }
2924:./include/lib_AT91SAM7A3.h **** 
2925:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2926:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_EnableTx
2927:./include/lib_AT91SAM7A3.h **** //* \brief Enable sending characters
2928:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2929:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_EnableTx (
2930:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2931:./include/lib_AT91SAM7A3.h **** {
2932:./include/lib_AT91SAM7A3.h ****     //* Enable  transmitter
2933:./include/lib_AT91SAM7A3.h ****     pUSART->US_CR = AT91C_US_TXEN;
2934:./include/lib_AT91SAM7A3.h **** }
2935:./include/lib_AT91SAM7A3.h **** 
2936:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2937:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_ResetRx
2938:./include/lib_AT91SAM7A3.h **** //* \brief Reset Receiver and re-enable it
2939:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2940:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_ResetRx (
2941:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2942:./include/lib_AT91SAM7A3.h **** {
2943:./include/lib_AT91SAM7A3.h **** 	//* Reset receiver
2944:./include/lib_AT91SAM7A3.h **** 	pUSART->US_CR = AT91C_US_RSTRX;
2945:./include/lib_AT91SAM7A3.h ****     //* Re-Enable receiver
2946:./include/lib_AT91SAM7A3.h ****     pUSART->US_CR = AT91C_US_RXEN;
2947:./include/lib_AT91SAM7A3.h **** }
2948:./include/lib_AT91SAM7A3.h **** 
2949:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2950:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_ResetTx
2951:./include/lib_AT91SAM7A3.h **** //* \brief Reset Transmitter and re-enable it
2952:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2953:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_ResetTx (
2954:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2955:./include/lib_AT91SAM7A3.h **** {
2956:./include/lib_AT91SAM7A3.h **** 	//* Reset transmitter
2957:./include/lib_AT91SAM7A3.h **** 	pUSART->US_CR = AT91C_US_RSTTX;
2958:./include/lib_AT91SAM7A3.h ****     //* Enable transmitter
2959:./include/lib_AT91SAM7A3.h ****     pUSART->US_CR = AT91C_US_TXEN;
2960:./include/lib_AT91SAM7A3.h **** }
2961:./include/lib_AT91SAM7A3.h **** 
2962:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2963:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_DisableRx
2964:./include/lib_AT91SAM7A3.h **** //* \brief Disable Receiver
2965:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2966:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_DisableRx (
2967:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2968:./include/lib_AT91SAM7A3.h **** {
2969:./include/lib_AT91SAM7A3.h ****     //* Disable receiver
2970:./include/lib_AT91SAM7A3.h ****     pUSART->US_CR = AT91C_US_RXDIS;
2971:./include/lib_AT91SAM7A3.h **** }
2972:./include/lib_AT91SAM7A3.h **** 
2973:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2974:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_DisableTx
2975:./include/lib_AT91SAM7A3.h **** //* \brief Disable Transmitter
2976:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2977:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_DisableTx (
2978:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2979:./include/lib_AT91SAM7A3.h **** {
2980:./include/lib_AT91SAM7A3.h ****     //* Disable transmitter
2981:./include/lib_AT91SAM7A3.h ****     pUSART->US_CR = AT91C_US_TXDIS;
2982:./include/lib_AT91SAM7A3.h **** }
2983:./include/lib_AT91SAM7A3.h **** 
2984:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2985:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_Close
2986:./include/lib_AT91SAM7A3.h **** //* \brief Close USART: disable IT disable receiver and transmitter, close PDC
2987:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
2988:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_Close (
2989:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2990:./include/lib_AT91SAM7A3.h **** {
2991:./include/lib_AT91SAM7A3.h ****     //* Reset the baud rate divisor register
2992:./include/lib_AT91SAM7A3.h ****     pUSART->US_BRGR = 0 ;
2993:./include/lib_AT91SAM7A3.h **** 
2994:./include/lib_AT91SAM7A3.h ****     //* Reset the USART mode
2995:./include/lib_AT91SAM7A3.h ****     pUSART->US_MR = 0  ;
2996:./include/lib_AT91SAM7A3.h **** 
2997:./include/lib_AT91SAM7A3.h ****     //* Reset the Timeguard Register
2998:./include/lib_AT91SAM7A3.h ****     pUSART->US_TTGR = 0;
2999:./include/lib_AT91SAM7A3.h **** 
3000:./include/lib_AT91SAM7A3.h ****     //* Disable all interrupts
3001:./include/lib_AT91SAM7A3.h ****     pUSART->US_IDR = 0xFFFFFFFF ;
3002:./include/lib_AT91SAM7A3.h **** 
3003:./include/lib_AT91SAM7A3.h ****     //* Abort the Peripheral Data Transfers
3004:./include/lib_AT91SAM7A3.h ****     AT91F_PDC_Close((AT91PS_PDC) &(pUSART->US_RPR));
3005:./include/lib_AT91SAM7A3.h **** 
3006:./include/lib_AT91SAM7A3.h ****     //* Disable receiver and transmitter and stop any activity immediately
3007:./include/lib_AT91SAM7A3.h ****     pUSART->US_CR = AT91C_US_TXDIS | AT91C_US_RXDIS | AT91C_US_RSTTX | AT91C_US_RSTRX ;
3008:./include/lib_AT91SAM7A3.h **** }
3009:./include/lib_AT91SAM7A3.h **** 
3010:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3011:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_TxReady
3012:./include/lib_AT91SAM7A3.h **** //* \brief Return 1 if a character can be written in US_THR
3013:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3014:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_US_TxReady (
3015:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART )     // \arg pointer to a USART controller
3016:./include/lib_AT91SAM7A3.h **** {
3017:./include/lib_AT91SAM7A3.h ****     return (pUSART->US_CSR & AT91C_US_TXRDY);
3018:./include/lib_AT91SAM7A3.h **** }
3019:./include/lib_AT91SAM7A3.h **** 
3020:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3021:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_RxReady
3022:./include/lib_AT91SAM7A3.h **** //* \brief Return 1 if a character can be read in US_RHR
3023:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3024:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_US_RxReady (
3025:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART )     // \arg pointer to a USART controller
3026:./include/lib_AT91SAM7A3.h **** {
3027:./include/lib_AT91SAM7A3.h ****     return (pUSART->US_CSR & AT91C_US_RXRDY);
3028:./include/lib_AT91SAM7A3.h **** }
3029:./include/lib_AT91SAM7A3.h **** 
3030:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3031:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_Error
3032:./include/lib_AT91SAM7A3.h **** //* \brief Return the error flag
3033:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3034:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_US_Error (
3035:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART )     // \arg pointer to a USART controller
3036:./include/lib_AT91SAM7A3.h **** {
3037:./include/lib_AT91SAM7A3.h ****     return (pUSART->US_CSR &
3038:./include/lib_AT91SAM7A3.h ****     	(AT91C_US_OVRE |  // Overrun error
3039:./include/lib_AT91SAM7A3.h ****     	 AT91C_US_FRAME | // Framing error
3040:./include/lib_AT91SAM7A3.h ****     	 AT91C_US_PARE));  // Parity error
3041:./include/lib_AT91SAM7A3.h **** }
3042:./include/lib_AT91SAM7A3.h **** 
3043:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3044:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_PutChar
3045:./include/lib_AT91SAM7A3.h **** //* \brief Send a character,does not check if ready to send
3046:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3047:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_PutChar (
3048:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART,
3049:./include/lib_AT91SAM7A3.h **** 	int character )
3050:./include/lib_AT91SAM7A3.h **** {
3051:./include/lib_AT91SAM7A3.h ****     pUSART->US_THR = (character & 0x1FF);
3052:./include/lib_AT91SAM7A3.h **** }
3053:./include/lib_AT91SAM7A3.h **** 
3054:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3055:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_GetChar
3056:./include/lib_AT91SAM7A3.h **** //* \brief Receive a character,does not check if a character is available
3057:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3058:./include/lib_AT91SAM7A3.h **** __inline int AT91F_US_GetChar (
3059:./include/lib_AT91SAM7A3.h **** 	const AT91PS_USART pUSART)
3060:./include/lib_AT91SAM7A3.h **** {
3061:./include/lib_AT91SAM7A3.h ****     return((pUSART->US_RHR) & 0x1FF);
3062:./include/lib_AT91SAM7A3.h **** }
3063:./include/lib_AT91SAM7A3.h **** 
3064:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3065:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_SendFrame
3066:./include/lib_AT91SAM7A3.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
3067:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3068:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_US_SendFrame(
3069:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART,
3070:./include/lib_AT91SAM7A3.h **** 	char *pBuffer,
3071:./include/lib_AT91SAM7A3.h **** 	unsigned int szBuffer,
3072:./include/lib_AT91SAM7A3.h **** 	char *pNextBuffer,
3073:./include/lib_AT91SAM7A3.h **** 	unsigned int szNextBuffer )
3074:./include/lib_AT91SAM7A3.h **** {
3075:./include/lib_AT91SAM7A3.h **** 	return AT91F_PDC_SendFrame(
3076:./include/lib_AT91SAM7A3.h **** 		(AT91PS_PDC) &(pUSART->US_RPR),
3077:./include/lib_AT91SAM7A3.h **** 		pBuffer,
3078:./include/lib_AT91SAM7A3.h **** 		szBuffer,
3079:./include/lib_AT91SAM7A3.h **** 		pNextBuffer,
3080:./include/lib_AT91SAM7A3.h **** 		szNextBuffer);
3081:./include/lib_AT91SAM7A3.h **** }
3082:./include/lib_AT91SAM7A3.h **** 
3083:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3084:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_ReceiveFrame
3085:./include/lib_AT91SAM7A3.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
3086:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3087:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_US_ReceiveFrame (
3088:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART,
3089:./include/lib_AT91SAM7A3.h **** 	char *pBuffer,
3090:./include/lib_AT91SAM7A3.h **** 	unsigned int szBuffer,
3091:./include/lib_AT91SAM7A3.h **** 	char *pNextBuffer,
3092:./include/lib_AT91SAM7A3.h **** 	unsigned int szNextBuffer )
3093:./include/lib_AT91SAM7A3.h **** {
3094:./include/lib_AT91SAM7A3.h **** 	return AT91F_PDC_ReceiveFrame(
3095:./include/lib_AT91SAM7A3.h **** 		(AT91PS_PDC) &(pUSART->US_RPR),
3096:./include/lib_AT91SAM7A3.h **** 		pBuffer,
3097:./include/lib_AT91SAM7A3.h **** 		szBuffer,
3098:./include/lib_AT91SAM7A3.h **** 		pNextBuffer,
3099:./include/lib_AT91SAM7A3.h **** 		szNextBuffer);
3100:./include/lib_AT91SAM7A3.h **** }
3101:./include/lib_AT91SAM7A3.h **** 
3102:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3103:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_US_SetIrdaFilter
3104:./include/lib_AT91SAM7A3.h **** //* \brief Set the value of IrDa filter tregister
3105:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3106:./include/lib_AT91SAM7A3.h **** __inline void AT91F_US_SetIrdaFilter (
3107:./include/lib_AT91SAM7A3.h **** 	AT91PS_USART pUSART,
3108:./include/lib_AT91SAM7A3.h **** 	unsigned char value
3109:./include/lib_AT91SAM7A3.h **** )
3110:./include/lib_AT91SAM7A3.h **** {
3111:./include/lib_AT91SAM7A3.h **** 	pUSART->US_IF = value;
3112:./include/lib_AT91SAM7A3.h **** }
3113:./include/lib_AT91SAM7A3.h **** 
3114:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
3115:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR PWMC
3116:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
3117:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3118:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_GetStatus
3119:./include/lib_AT91SAM7A3.h **** //* \brief Return PWM Interrupt Status
3120:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3121:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PWMC_GetStatus( // \return PWM Interrupt Status
3122:./include/lib_AT91SAM7A3.h **** 	AT91PS_PWMC pPWM) // pointer to a PWM controller
3123:./include/lib_AT91SAM7A3.h **** {
3124:./include/lib_AT91SAM7A3.h **** 	return pPWM->PWMC_SR;
3125:./include/lib_AT91SAM7A3.h **** }
3126:./include/lib_AT91SAM7A3.h **** 
3127:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3128:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_InterruptEnable
3129:./include/lib_AT91SAM7A3.h **** //* \brief Enable PWM Interrupt
3130:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3131:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PWMC_InterruptEnable(
3132:./include/lib_AT91SAM7A3.h ****         AT91PS_PWMC pPwm,   // \arg  pointer to a PWM controller
3133:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  PWM interrupt to be enabled
3134:./include/lib_AT91SAM7A3.h **** {
3135:./include/lib_AT91SAM7A3.h ****         pPwm->PWMC_IER = flag;
3136:./include/lib_AT91SAM7A3.h **** }
3137:./include/lib_AT91SAM7A3.h **** 
3138:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3139:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_InterruptDisable
3140:./include/lib_AT91SAM7A3.h **** //* \brief Disable PWM Interrupt
3141:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3142:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PWMC_InterruptDisable(
3143:./include/lib_AT91SAM7A3.h ****         AT91PS_PWMC pPwm,   // \arg  pointer to a PWM controller
3144:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  PWM interrupt to be disabled
3145:./include/lib_AT91SAM7A3.h **** {
3146:./include/lib_AT91SAM7A3.h ****         pPwm->PWMC_IDR = flag;
3147:./include/lib_AT91SAM7A3.h **** }
3148:./include/lib_AT91SAM7A3.h **** 
3149:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3150:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_GetInterruptMaskStatus
3151:./include/lib_AT91SAM7A3.h **** //* \brief Return PWM Interrupt Mask Status
3152:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3153:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PWMC_GetInterruptMaskStatus( // \return PWM Interrupt Mask Status
3154:./include/lib_AT91SAM7A3.h ****         AT91PS_PWMC pPwm) // \arg  pointer to a PWM controller
3155:./include/lib_AT91SAM7A3.h **** {
3156:./include/lib_AT91SAM7A3.h ****         return pPwm->PWMC_IMR;
3157:./include/lib_AT91SAM7A3.h **** }
3158:./include/lib_AT91SAM7A3.h **** 
3159:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3160:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_IsInterruptMasked
3161:./include/lib_AT91SAM7A3.h **** //* \brief Test if PWM Interrupt is Masked
3162:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3163:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PWMC_IsInterruptMasked(
3164:./include/lib_AT91SAM7A3.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
3165:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
3166:./include/lib_AT91SAM7A3.h **** {
3167:./include/lib_AT91SAM7A3.h **** 	return (AT91F_PWMC_GetInterruptMaskStatus(pPWM) & flag);
3168:./include/lib_AT91SAM7A3.h **** }
3169:./include/lib_AT91SAM7A3.h **** 
3170:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3171:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_IsStatusSet
3172:./include/lib_AT91SAM7A3.h **** //* \brief Test if PWM Interrupt is Set
3173:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3174:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_PWMC_IsStatusSet(
3175:./include/lib_AT91SAM7A3.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
3176:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
3177:./include/lib_AT91SAM7A3.h **** {
3178:./include/lib_AT91SAM7A3.h **** 	return (AT91F_PWMC_GetStatus(pPWM) & flag);
3179:./include/lib_AT91SAM7A3.h **** }
3180:./include/lib_AT91SAM7A3.h **** 
3181:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3182:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_CfgChannel
3183:./include/lib_AT91SAM7A3.h **** //* \brief Test if PWM Interrupt is Set
3184:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3185:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PWMC_CfgChannel(
3186:./include/lib_AT91SAM7A3.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
3187:./include/lib_AT91SAM7A3.h ****         unsigned int channelId, // \arg PWM channel ID
3188:./include/lib_AT91SAM7A3.h ****         unsigned int mode, // \arg  PWM mode
3189:./include/lib_AT91SAM7A3.h ****         unsigned int period, // \arg PWM period
3190:./include/lib_AT91SAM7A3.h ****         unsigned int duty) // \arg PWM duty cycle
3191:./include/lib_AT91SAM7A3.h **** {
3192:./include/lib_AT91SAM7A3.h **** 	pPWM->PWMC_CH[channelId].PWMC_CMR = mode;
3193:./include/lib_AT91SAM7A3.h **** 	pPWM->PWMC_CH[channelId].PWMC_CDTYR = duty;
3194:./include/lib_AT91SAM7A3.h **** 	pPWM->PWMC_CH[channelId].PWMC_CPRDR = period;
3195:./include/lib_AT91SAM7A3.h **** }
3196:./include/lib_AT91SAM7A3.h **** 
3197:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3198:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_StartChannel
3199:./include/lib_AT91SAM7A3.h **** //* \brief Enable channel
3200:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3201:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PWMC_StartChannel(
3202:./include/lib_AT91SAM7A3.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
3203:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  Channels IDs to be enabled
3204:./include/lib_AT91SAM7A3.h **** {
3205:./include/lib_AT91SAM7A3.h **** 	pPWM->PWMC_ENA = flag;
3206:./include/lib_AT91SAM7A3.h **** }
3207:./include/lib_AT91SAM7A3.h **** 
3208:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3209:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_StopChannel
3210:./include/lib_AT91SAM7A3.h **** //* \brief Disable channel
3211:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3212:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PWMC_StopChannel(
3213:./include/lib_AT91SAM7A3.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
3214:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  Channels IDs to be enabled
3215:./include/lib_AT91SAM7A3.h **** {
3216:./include/lib_AT91SAM7A3.h **** 	pPWM->PWMC_DIS = flag;
3217:./include/lib_AT91SAM7A3.h **** }
3218:./include/lib_AT91SAM7A3.h **** 
3219:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3220:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_PWM_UpdateChannel
3221:./include/lib_AT91SAM7A3.h **** //* \brief Update Period or Duty Cycle
3222:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3223:./include/lib_AT91SAM7A3.h **** __inline void AT91F_PWMC_UpdateChannel(
3224:./include/lib_AT91SAM7A3.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
3225:./include/lib_AT91SAM7A3.h ****         unsigned int channelId, // \arg PWM channel ID
3226:./include/lib_AT91SAM7A3.h ****         unsigned int update) // \arg  Channels IDs to be enabled
3227:./include/lib_AT91SAM7A3.h **** {
3228:./include/lib_AT91SAM7A3.h **** 	pPWM->PWMC_CH[channelId].PWMC_CUPDR = update;
3229:./include/lib_AT91SAM7A3.h **** }
3230:./include/lib_AT91SAM7A3.h **** 
3231:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
3232:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR SSC
3233:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
3234:./include/lib_AT91SAM7A3.h **** //* Define the standard I2S mode configuration
3235:./include/lib_AT91SAM7A3.h **** 
3236:./include/lib_AT91SAM7A3.h **** //* Configuration to set in the SSC Transmit Clock Mode Register
3237:./include/lib_AT91SAM7A3.h **** //* Parameters :  nb_bit_by_slot : 8, 16 or 32 bits
3238:./include/lib_AT91SAM7A3.h **** //* 			  nb_slot_by_frame : number of channels
3239:./include/lib_AT91SAM7A3.h **** #define AT91C_I2S_ASY_MASTER_TX_SETTING(nb_bit_by_slot, nb_slot_by_frame)( +\
3240:./include/lib_AT91SAM7A3.h **** 									   AT91C_SSC_CKS_DIV   +\
3241:./include/lib_AT91SAM7A3.h ****                             		   AT91C_SSC_CKO_CONTINOUS      +\
3242:./include/lib_AT91SAM7A3.h ****                             		   AT91C_SSC_CKG_NONE    +\
3243:./include/lib_AT91SAM7A3.h ****                                        AT91C_SSC_START_FALL_RF +\
3244:./include/lib_AT91SAM7A3.h ****                            			   AT91C_SSC_STTOUT  +\
3245:./include/lib_AT91SAM7A3.h ****                             		   ((1<<16) & AT91C_SSC_STTDLY) +\
3246:./include/lib_AT91SAM7A3.h ****                             		   ((((nb_bit_by_slot*nb_slot_by_frame)/2)-1) <<24))
3247:./include/lib_AT91SAM7A3.h **** 
3248:./include/lib_AT91SAM7A3.h **** 
3249:./include/lib_AT91SAM7A3.h **** //* Configuration to set in the SSC Transmit Frame Mode Register
3250:./include/lib_AT91SAM7A3.h **** //* Parameters : nb_bit_by_slot : 8, 16 or 32 bits
3251:./include/lib_AT91SAM7A3.h **** //* 			 nb_slot_by_frame : number of channels
3252:./include/lib_AT91SAM7A3.h **** #define AT91C_I2S_ASY_TX_FRAME_SETTING(nb_bit_by_slot, nb_slot_by_frame)( +\
3253:./include/lib_AT91SAM7A3.h **** 									(nb_bit_by_slot-1)  +\
3254:./include/lib_AT91SAM7A3.h ****                             		AT91C_SSC_MSBF   +\
3255:./include/lib_AT91SAM7A3.h ****                             		(((nb_slot_by_frame-1)<<8) & AT91C_SSC_DATNB)  +\
3256:./include/lib_AT91SAM7A3.h ****                             		(((nb_bit_by_slot-1)<<16) & AT91C_SSC_FSLEN) +\
3257:./include/lib_AT91SAM7A3.h ****                             		AT91C_SSC_FSOS_NEGATIVE)
3258:./include/lib_AT91SAM7A3.h **** 
3259:./include/lib_AT91SAM7A3.h **** 
3260:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3261:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_SetBaudrate
3262:./include/lib_AT91SAM7A3.h **** //* \brief Set the baudrate according to the CPU clock
3263:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3264:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SSC_SetBaudrate (
3265:./include/lib_AT91SAM7A3.h ****         AT91PS_SSC pSSC,        // \arg pointer to a SSC controller
3266:./include/lib_AT91SAM7A3.h ****         unsigned int mainClock, // \arg peripheral clock
3267:./include/lib_AT91SAM7A3.h ****         unsigned int speed)     // \arg SSC baudrate
3268:./include/lib_AT91SAM7A3.h **** {
3269:./include/lib_AT91SAM7A3.h ****         unsigned int baud_value;
3270:./include/lib_AT91SAM7A3.h ****         //* Define the baud rate divisor register
3271:./include/lib_AT91SAM7A3.h ****         if (speed == 0)
3272:./include/lib_AT91SAM7A3.h ****            baud_value = 0;
3273:./include/lib_AT91SAM7A3.h ****         else
3274:./include/lib_AT91SAM7A3.h ****         {
3275:./include/lib_AT91SAM7A3.h ****            baud_value = (unsigned int) (mainClock * 10)/(2*speed);
3276:./include/lib_AT91SAM7A3.h ****            if ((baud_value % 10) >= 5)
3277:./include/lib_AT91SAM7A3.h ****                   baud_value = (baud_value / 10) + 1;
3278:./include/lib_AT91SAM7A3.h ****            else
3279:./include/lib_AT91SAM7A3.h ****                   baud_value /= 10;
3280:./include/lib_AT91SAM7A3.h ****         }
3281:./include/lib_AT91SAM7A3.h **** 
3282:./include/lib_AT91SAM7A3.h ****         pSSC->SSC_CMR = baud_value;
3283:./include/lib_AT91SAM7A3.h **** }
3284:./include/lib_AT91SAM7A3.h **** 
3285:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3286:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_Configure
3287:./include/lib_AT91SAM7A3.h **** //* \brief Configure SSC
3288:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3289:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SSC_Configure (
3290:./include/lib_AT91SAM7A3.h ****              AT91PS_SSC pSSC,          // \arg pointer to a SSC controller
3291:./include/lib_AT91SAM7A3.h ****              unsigned int syst_clock,  // \arg System Clock Frequency
3292:./include/lib_AT91SAM7A3.h ****              unsigned int baud_rate,   // \arg Expected Baud Rate Frequency
3293:./include/lib_AT91SAM7A3.h ****              unsigned int clock_rx,    // \arg Receiver Clock Parameters
3294:./include/lib_AT91SAM7A3.h ****              unsigned int mode_rx,     // \arg mode Register to be programmed
3295:./include/lib_AT91SAM7A3.h ****              unsigned int clock_tx,    // \arg Transmitter Clock Parameters
3296:./include/lib_AT91SAM7A3.h ****              unsigned int mode_tx)     // \arg mode Register to be programmed
3297:./include/lib_AT91SAM7A3.h **** {
3298:./include/lib_AT91SAM7A3.h ****     //* Disable interrupts
3299:./include/lib_AT91SAM7A3.h **** 	pSSC->SSC_IDR = (unsigned int) -1;
3300:./include/lib_AT91SAM7A3.h **** 
3301:./include/lib_AT91SAM7A3.h ****     //* Reset receiver and transmitter
3302:./include/lib_AT91SAM7A3.h **** 	pSSC->SSC_CR = AT91C_SSC_SWRST | AT91C_SSC_RXDIS | AT91C_SSC_TXDIS ;
3303:./include/lib_AT91SAM7A3.h **** 
3304:./include/lib_AT91SAM7A3.h ****     //* Define the Clock Mode Register
3305:./include/lib_AT91SAM7A3.h **** 	AT91F_SSC_SetBaudrate(pSSC, syst_clock, baud_rate);
3306:./include/lib_AT91SAM7A3.h **** 
3307:./include/lib_AT91SAM7A3.h ****      //* Write the Receive Clock Mode Register
3308:./include/lib_AT91SAM7A3.h **** 	pSSC->SSC_RCMR =  clock_rx;
3309:./include/lib_AT91SAM7A3.h **** 
3310:./include/lib_AT91SAM7A3.h ****      //* Write the Transmit Clock Mode Register
3311:./include/lib_AT91SAM7A3.h **** 	pSSC->SSC_TCMR =  clock_tx;
3312:./include/lib_AT91SAM7A3.h **** 
3313:./include/lib_AT91SAM7A3.h ****      //* Write the Receive Frame Mode Register
3314:./include/lib_AT91SAM7A3.h **** 	pSSC->SSC_RFMR =  mode_rx;
3315:./include/lib_AT91SAM7A3.h **** 
3316:./include/lib_AT91SAM7A3.h ****      //* Write the Transmit Frame Mode Register
3317:./include/lib_AT91SAM7A3.h **** 	pSSC->SSC_TFMR =  mode_tx;
3318:./include/lib_AT91SAM7A3.h **** 
3319:./include/lib_AT91SAM7A3.h ****     //* Clear Transmit and Receive Counters
3320:./include/lib_AT91SAM7A3.h **** 	AT91F_PDC_Open((AT91PS_PDC) &(pSSC->SSC_RPR));
3321:./include/lib_AT91SAM7A3.h **** 
3322:./include/lib_AT91SAM7A3.h **** 
3323:./include/lib_AT91SAM7A3.h **** }
3324:./include/lib_AT91SAM7A3.h **** 
3325:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3326:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_EnableRx
3327:./include/lib_AT91SAM7A3.h **** //* \brief Enable receiving datas
3328:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3329:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SSC_EnableRx (
3330:./include/lib_AT91SAM7A3.h **** 	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
3331:./include/lib_AT91SAM7A3.h **** {
3332:./include/lib_AT91SAM7A3.h ****     //* Enable receiver
3333:./include/lib_AT91SAM7A3.h ****     pSSC->SSC_CR = AT91C_SSC_RXEN;
3334:./include/lib_AT91SAM7A3.h **** }
3335:./include/lib_AT91SAM7A3.h **** 
3336:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3337:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_DisableRx
3338:./include/lib_AT91SAM7A3.h **** //* \brief Disable receiving datas
3339:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3340:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SSC_DisableRx (
3341:./include/lib_AT91SAM7A3.h **** 	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
3342:./include/lib_AT91SAM7A3.h **** {
3343:./include/lib_AT91SAM7A3.h ****     //* Disable receiver
3344:./include/lib_AT91SAM7A3.h ****     pSSC->SSC_CR = AT91C_SSC_RXDIS;
3345:./include/lib_AT91SAM7A3.h **** }
3346:./include/lib_AT91SAM7A3.h **** 
3347:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3348:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_EnableTx
3349:./include/lib_AT91SAM7A3.h **** //* \brief Enable sending datas
3350:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3351:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SSC_EnableTx (
3352:./include/lib_AT91SAM7A3.h **** 	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
3353:./include/lib_AT91SAM7A3.h **** {
3354:./include/lib_AT91SAM7A3.h ****     //* Enable  transmitter
3355:./include/lib_AT91SAM7A3.h ****     pSSC->SSC_CR = AT91C_SSC_TXEN;
3356:./include/lib_AT91SAM7A3.h **** }
3357:./include/lib_AT91SAM7A3.h **** 
3358:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3359:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_DisableTx
3360:./include/lib_AT91SAM7A3.h **** //* \brief Disable sending datas
3361:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3362:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SSC_DisableTx (
3363:./include/lib_AT91SAM7A3.h **** 	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
3364:./include/lib_AT91SAM7A3.h **** {
3365:./include/lib_AT91SAM7A3.h ****     //* Disable  transmitter
3366:./include/lib_AT91SAM7A3.h ****     pSSC->SSC_CR = AT91C_SSC_TXDIS;
3367:./include/lib_AT91SAM7A3.h **** }
3368:./include/lib_AT91SAM7A3.h **** 
3369:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3370:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_EnableIt
3371:./include/lib_AT91SAM7A3.h **** //* \brief Enable SSC IT
3372:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3373:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SSC_EnableIt (
3374:./include/lib_AT91SAM7A3.h **** 	AT91PS_SSC pSSC, // \arg pointer to a SSC controller
3375:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg IT to be enabled
3376:./include/lib_AT91SAM7A3.h **** {
3377:./include/lib_AT91SAM7A3.h **** 	//* Write to the IER register
3378:./include/lib_AT91SAM7A3.h **** 	pSSC->SSC_IER = flag;
3379:./include/lib_AT91SAM7A3.h **** }
3380:./include/lib_AT91SAM7A3.h **** 
3381:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3382:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_DisableIt
3383:./include/lib_AT91SAM7A3.h **** //* \brief Disable SSC IT
3384:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3385:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SSC_DisableIt (
3386:./include/lib_AT91SAM7A3.h **** 	AT91PS_SSC pSSC, // \arg pointer to a SSC controller
3387:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // \arg IT to be disabled
3388:./include/lib_AT91SAM7A3.h **** {
3389:./include/lib_AT91SAM7A3.h **** 	//* Write to the IDR register
3390:./include/lib_AT91SAM7A3.h **** 	pSSC->SSC_IDR = flag;
3391:./include/lib_AT91SAM7A3.h **** }
3392:./include/lib_AT91SAM7A3.h **** 
3393:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3394:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_ReceiveFrame
3395:./include/lib_AT91SAM7A3.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
3396:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3397:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_SSC_ReceiveFrame (
3398:./include/lib_AT91SAM7A3.h **** 	AT91PS_SSC pSSC,
3399:./include/lib_AT91SAM7A3.h **** 	char *pBuffer,
3400:./include/lib_AT91SAM7A3.h **** 	unsigned int szBuffer,
3401:./include/lib_AT91SAM7A3.h **** 	char *pNextBuffer,
3402:./include/lib_AT91SAM7A3.h **** 	unsigned int szNextBuffer )
3403:./include/lib_AT91SAM7A3.h **** {
3404:./include/lib_AT91SAM7A3.h **** 	return AT91F_PDC_ReceiveFrame(
3405:./include/lib_AT91SAM7A3.h **** 		(AT91PS_PDC) &(pSSC->SSC_RPR),
3406:./include/lib_AT91SAM7A3.h **** 		pBuffer,
3407:./include/lib_AT91SAM7A3.h **** 		szBuffer,
3408:./include/lib_AT91SAM7A3.h **** 		pNextBuffer,
3409:./include/lib_AT91SAM7A3.h **** 		szNextBuffer);
3410:./include/lib_AT91SAM7A3.h **** }
3411:./include/lib_AT91SAM7A3.h **** 
3412:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3413:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_SendFrame
3414:./include/lib_AT91SAM7A3.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
3415:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3416:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_SSC_SendFrame(
3417:./include/lib_AT91SAM7A3.h **** 	AT91PS_SSC pSSC,
3418:./include/lib_AT91SAM7A3.h **** 	char *pBuffer,
3419:./include/lib_AT91SAM7A3.h **** 	unsigned int szBuffer,
3420:./include/lib_AT91SAM7A3.h **** 	char *pNextBuffer,
3421:./include/lib_AT91SAM7A3.h **** 	unsigned int szNextBuffer )
3422:./include/lib_AT91SAM7A3.h **** {
3423:./include/lib_AT91SAM7A3.h **** 	return AT91F_PDC_SendFrame(
3424:./include/lib_AT91SAM7A3.h **** 		(AT91PS_PDC) &(pSSC->SSC_RPR),
3425:./include/lib_AT91SAM7A3.h **** 		pBuffer,
3426:./include/lib_AT91SAM7A3.h **** 		szBuffer,
3427:./include/lib_AT91SAM7A3.h **** 		pNextBuffer,
3428:./include/lib_AT91SAM7A3.h **** 		szNextBuffer);
3429:./include/lib_AT91SAM7A3.h **** }
3430:./include/lib_AT91SAM7A3.h **** 
3431:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3432:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_GetInterruptMaskStatus
3433:./include/lib_AT91SAM7A3.h **** //* \brief Return SSC Interrupt Mask Status
3434:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3435:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_SSC_GetInterruptMaskStatus( // \return SSC Interrupt Mask Status
3436:./include/lib_AT91SAM7A3.h ****         AT91PS_SSC pSsc) // \arg  pointer to a SSC controller
3437:./include/lib_AT91SAM7A3.h **** {
3438:./include/lib_AT91SAM7A3.h ****         return pSsc->SSC_IMR;
3439:./include/lib_AT91SAM7A3.h **** }
3440:./include/lib_AT91SAM7A3.h **** 
3441:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3442:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SSC_IsInterruptMasked
3443:./include/lib_AT91SAM7A3.h **** //* \brief Test if SSC Interrupt is Masked 
3444:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3445:./include/lib_AT91SAM7A3.h **** __inline int AT91F_SSC_IsInterruptMasked(
3446:./include/lib_AT91SAM7A3.h ****         AT91PS_SSC pSsc,   // \arg  pointer to a SSC controller
3447:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
3448:./include/lib_AT91SAM7A3.h **** {
3449:./include/lib_AT91SAM7A3.h ****         return (AT91F_SSC_GetInterruptMaskStatus(pSsc) & flag);
3450:./include/lib_AT91SAM7A3.h **** }
3451:./include/lib_AT91SAM7A3.h **** 
3452:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
3453:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR ADC
3454:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
3455:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3456:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_EnableIt
3457:./include/lib_AT91SAM7A3.h **** //* \brief Enable ADC interrupt
3458:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3459:./include/lib_AT91SAM7A3.h **** __inline void AT91F_ADC_EnableIt (
3460:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC,     // pointer to a ADC controller
3461:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // IT to be enabled
3462:./include/lib_AT91SAM7A3.h **** {
3463:./include/lib_AT91SAM7A3.h **** 	//* Write to the IER register
3464:./include/lib_AT91SAM7A3.h **** 	pADC->ADC_IER = flag;
3465:./include/lib_AT91SAM7A3.h **** }
3466:./include/lib_AT91SAM7A3.h **** 
3467:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3468:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_DisableIt
3469:./include/lib_AT91SAM7A3.h **** //* \brief Disable ADC interrupt
3470:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3471:./include/lib_AT91SAM7A3.h **** __inline void AT91F_ADC_DisableIt (
3472:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
3473:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // IT to be disabled
3474:./include/lib_AT91SAM7A3.h **** {
3475:./include/lib_AT91SAM7A3.h **** 	//* Write to the IDR register
3476:./include/lib_AT91SAM7A3.h **** 	pADC->ADC_IDR = flag;
3477:./include/lib_AT91SAM7A3.h **** }
3478:./include/lib_AT91SAM7A3.h **** 
3479:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3480:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetStatus
3481:./include/lib_AT91SAM7A3.h **** //* \brief Return ADC Interrupt Status
3482:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3483:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetStatus( // \return ADC Interrupt Status
3484:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC) // pointer to a ADC controller
3485:./include/lib_AT91SAM7A3.h **** {
3486:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_SR;
3487:./include/lib_AT91SAM7A3.h **** }
3488:./include/lib_AT91SAM7A3.h **** 
3489:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3490:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetInterruptMaskStatus
3491:./include/lib_AT91SAM7A3.h **** //* \brief Return ADC Interrupt Mask Status
3492:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3493:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetInterruptMaskStatus( // \return ADC Interrupt Mask Status
3494:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC) // pointer to a ADC controller
3495:./include/lib_AT91SAM7A3.h **** {
3496:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_IMR;
3497:./include/lib_AT91SAM7A3.h **** }
3498:./include/lib_AT91SAM7A3.h **** 
3499:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3500:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_IsInterruptMasked
3501:./include/lib_AT91SAM7A3.h **** //* \brief Test if ADC Interrupt is Masked 
3502:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3503:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_IsInterruptMasked(
3504:./include/lib_AT91SAM7A3.h ****         AT91PS_ADC pADC,   // \arg  pointer to a ADC controller
3505:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
3506:./include/lib_AT91SAM7A3.h **** {
3507:./include/lib_AT91SAM7A3.h **** 	return (AT91F_ADC_GetInterruptMaskStatus(pADC) & flag);
3508:./include/lib_AT91SAM7A3.h **** }
3509:./include/lib_AT91SAM7A3.h **** 
3510:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3511:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_IsStatusSet
3512:./include/lib_AT91SAM7A3.h **** //* \brief Test if ADC Status is Set
3513:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3514:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_IsStatusSet(
3515:./include/lib_AT91SAM7A3.h ****         AT91PS_ADC pADC,   // \arg  pointer to a ADC controller
3516:./include/lib_AT91SAM7A3.h ****         unsigned int flag) // \arg  flag to be tested
3517:./include/lib_AT91SAM7A3.h **** {
3518:./include/lib_AT91SAM7A3.h **** 	return (AT91F_ADC_GetStatus(pADC) & flag);
3519:./include/lib_AT91SAM7A3.h **** }
3520:./include/lib_AT91SAM7A3.h **** 
3521:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3522:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_CfgModeReg
3523:./include/lib_AT91SAM7A3.h **** //* \brief Configure the Mode Register of the ADC controller
3524:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3525:./include/lib_AT91SAM7A3.h **** __inline void AT91F_ADC_CfgModeReg (
3526:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
3527:./include/lib_AT91SAM7A3.h **** 	unsigned int mode)        // mode register 
3528:./include/lib_AT91SAM7A3.h **** {
3529:./include/lib_AT91SAM7A3.h **** 	//* Write to the MR register
3530:./include/lib_AT91SAM7A3.h **** 	pADC->ADC_MR = mode;
3531:./include/lib_AT91SAM7A3.h **** }
3532:./include/lib_AT91SAM7A3.h **** 
3533:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3534:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetModeReg
3535:./include/lib_AT91SAM7A3.h **** //* \brief Return the Mode Register of the ADC controller value
3536:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3537:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetModeReg (
3538:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3539:./include/lib_AT91SAM7A3.h **** 	)
3540:./include/lib_AT91SAM7A3.h **** {
3541:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_MR;	
3542:./include/lib_AT91SAM7A3.h **** }
3543:./include/lib_AT91SAM7A3.h **** 
3544:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3545:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_CfgTimings
3546:./include/lib_AT91SAM7A3.h **** //* \brief Configure the different necessary timings of the ADC controller
3547:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3548:./include/lib_AT91SAM7A3.h **** __inline void AT91F_ADC_CfgTimings (
3549:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
3550:./include/lib_AT91SAM7A3.h **** 	unsigned int mck_clock, // in MHz 
3551:./include/lib_AT91SAM7A3.h **** 	unsigned int adc_clock, // in MHz 
3552:./include/lib_AT91SAM7A3.h **** 	unsigned int startup_time, // in us 
3553:./include/lib_AT91SAM7A3.h **** 	unsigned int sample_and_hold_time)	// in ns  
3554:./include/lib_AT91SAM7A3.h **** {
3555:./include/lib_AT91SAM7A3.h **** 	unsigned int prescal,startup,shtim;
3556:./include/lib_AT91SAM7A3.h **** 	
3557:./include/lib_AT91SAM7A3.h **** 	prescal = mck_clock/(2*adc_clock) - 1;
3558:./include/lib_AT91SAM7A3.h **** 	startup = adc_clock*startup_time/8 - 1;
3559:./include/lib_AT91SAM7A3.h **** 	shtim = adc_clock*sample_and_hold_time/1000 - 1;
3560:./include/lib_AT91SAM7A3.h **** 	
3561:./include/lib_AT91SAM7A3.h **** 	//* Write to the MR register
3562:./include/lib_AT91SAM7A3.h **** 	pADC->ADC_MR = ( (prescal<<8) & AT91C_ADC_PRESCAL) | ( (startup<<16) & AT91C_ADC_STARTUP) | ( (sht
3563:./include/lib_AT91SAM7A3.h **** }
3564:./include/lib_AT91SAM7A3.h **** 
3565:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3566:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_EnableChannel
3567:./include/lib_AT91SAM7A3.h **** //* \brief Return ADC Timer Register Value
3568:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3569:./include/lib_AT91SAM7A3.h **** __inline void AT91F_ADC_EnableChannel (
3570:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
3571:./include/lib_AT91SAM7A3.h **** 	unsigned int channel)        // mode register 
3572:./include/lib_AT91SAM7A3.h **** {
3573:./include/lib_AT91SAM7A3.h **** 	//* Write to the CHER register
3574:./include/lib_AT91SAM7A3.h **** 	pADC->ADC_CHER = channel;
3575:./include/lib_AT91SAM7A3.h **** }
3576:./include/lib_AT91SAM7A3.h **** 
3577:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3578:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_DisableChannel
3579:./include/lib_AT91SAM7A3.h **** //* \brief Return ADC Timer Register Value
3580:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3581:./include/lib_AT91SAM7A3.h **** __inline void AT91F_ADC_DisableChannel (
3582:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
3583:./include/lib_AT91SAM7A3.h **** 	unsigned int channel)        // mode register 
3584:./include/lib_AT91SAM7A3.h **** {
3585:./include/lib_AT91SAM7A3.h **** 	//* Write to the CHDR register
3586:./include/lib_AT91SAM7A3.h **** 	pADC->ADC_CHDR = channel;
3587:./include/lib_AT91SAM7A3.h **** }
3588:./include/lib_AT91SAM7A3.h **** 
3589:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3590:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetChannelStatus
3591:./include/lib_AT91SAM7A3.h **** //* \brief Return ADC Timer Register Value
3592:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3593:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetChannelStatus (
3594:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3595:./include/lib_AT91SAM7A3.h **** 	)
3596:./include/lib_AT91SAM7A3.h **** {
3597:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_CHSR;	
3598:./include/lib_AT91SAM7A3.h **** }
3599:./include/lib_AT91SAM7A3.h **** 
3600:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3601:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_StartConversion
3602:./include/lib_AT91SAM7A3.h **** //* \brief Software request for a analog to digital conversion 
3603:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3604:./include/lib_AT91SAM7A3.h **** __inline void AT91F_ADC_StartConversion (
3605:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3606:./include/lib_AT91SAM7A3.h **** 	)
3607:./include/lib_AT91SAM7A3.h **** {
3608:./include/lib_AT91SAM7A3.h **** 	pADC->ADC_CR = AT91C_ADC_START;	
3609:./include/lib_AT91SAM7A3.h **** }
3610:./include/lib_AT91SAM7A3.h **** 
3611:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3612:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_SoftReset
3613:./include/lib_AT91SAM7A3.h **** //* \brief Software reset
3614:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3615:./include/lib_AT91SAM7A3.h **** __inline void AT91F_ADC_SoftReset (
3616:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3617:./include/lib_AT91SAM7A3.h **** 	)
3618:./include/lib_AT91SAM7A3.h **** {
3619:./include/lib_AT91SAM7A3.h **** 	pADC->ADC_CR = AT91C_ADC_SWRST;	
3620:./include/lib_AT91SAM7A3.h **** }
3621:./include/lib_AT91SAM7A3.h **** 
3622:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3623:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetLastConvertedData
3624:./include/lib_AT91SAM7A3.h **** //* \brief Return the Last Converted Data
3625:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3626:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetLastConvertedData (
3627:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3628:./include/lib_AT91SAM7A3.h **** 	)
3629:./include/lib_AT91SAM7A3.h **** {
3630:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_LCDR;	
3631:./include/lib_AT91SAM7A3.h **** }
3632:./include/lib_AT91SAM7A3.h **** 
3633:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3634:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetConvertedDataCH0
3635:./include/lib_AT91SAM7A3.h **** //* \brief Return the Channel 0 Converted Data
3636:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3637:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH0 (
3638:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3639:./include/lib_AT91SAM7A3.h **** 	)
3640:./include/lib_AT91SAM7A3.h **** {
3641:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_CDR0;	
3642:./include/lib_AT91SAM7A3.h **** }
3643:./include/lib_AT91SAM7A3.h **** 
3644:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3645:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetConvertedDataCH1
3646:./include/lib_AT91SAM7A3.h **** //* \brief Return the Channel 1 Converted Data
3647:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3648:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH1 (
3649:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3650:./include/lib_AT91SAM7A3.h **** 	)
3651:./include/lib_AT91SAM7A3.h **** {
3652:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_CDR1;	
3653:./include/lib_AT91SAM7A3.h **** }
3654:./include/lib_AT91SAM7A3.h **** 
3655:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3656:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetConvertedDataCH2
3657:./include/lib_AT91SAM7A3.h **** //* \brief Return the Channel 2 Converted Data
3658:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3659:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH2 (
3660:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3661:./include/lib_AT91SAM7A3.h **** 	)
3662:./include/lib_AT91SAM7A3.h **** {
3663:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_CDR2;	
3664:./include/lib_AT91SAM7A3.h **** }
3665:./include/lib_AT91SAM7A3.h **** 
3666:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3667:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetConvertedDataCH3
3668:./include/lib_AT91SAM7A3.h **** //* \brief Return the Channel 3 Converted Data
3669:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3670:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH3 (
3671:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3672:./include/lib_AT91SAM7A3.h **** 	)
3673:./include/lib_AT91SAM7A3.h **** {
3674:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_CDR3;	
3675:./include/lib_AT91SAM7A3.h **** }
3676:./include/lib_AT91SAM7A3.h **** 
3677:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3678:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetConvertedDataCH4
3679:./include/lib_AT91SAM7A3.h **** //* \brief Return the Channel 4 Converted Data
3680:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3681:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH4 (
3682:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3683:./include/lib_AT91SAM7A3.h **** 	)
3684:./include/lib_AT91SAM7A3.h **** {
3685:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_CDR4;	
3686:./include/lib_AT91SAM7A3.h **** }
3687:./include/lib_AT91SAM7A3.h **** 
3688:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3689:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetConvertedDataCH5
3690:./include/lib_AT91SAM7A3.h **** //* \brief Return the Channel 5 Converted Data
3691:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3692:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH5 (
3693:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3694:./include/lib_AT91SAM7A3.h **** 	)
3695:./include/lib_AT91SAM7A3.h **** {
3696:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_CDR5;	
3697:./include/lib_AT91SAM7A3.h **** }
3698:./include/lib_AT91SAM7A3.h **** 
3699:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3700:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetConvertedDataCH6
3701:./include/lib_AT91SAM7A3.h **** //* \brief Return the Channel 6 Converted Data
3702:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3703:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH6 (
3704:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3705:./include/lib_AT91SAM7A3.h **** 	)
3706:./include/lib_AT91SAM7A3.h **** {
3707:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_CDR6;	
3708:./include/lib_AT91SAM7A3.h **** }
3709:./include/lib_AT91SAM7A3.h **** 
3710:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3711:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_ADC_GetConvertedDataCH7
3712:./include/lib_AT91SAM7A3.h **** //* \brief Return the Channel 7 Converted Data
3713:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3714:./include/lib_AT91SAM7A3.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH7 (
3715:./include/lib_AT91SAM7A3.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
3716:./include/lib_AT91SAM7A3.h **** 	)
3717:./include/lib_AT91SAM7A3.h **** {
3718:./include/lib_AT91SAM7A3.h **** 	return pADC->ADC_CDR7;	
3719:./include/lib_AT91SAM7A3.h **** }
3720:./include/lib_AT91SAM7A3.h **** 
3721:./include/lib_AT91SAM7A3.h **** /* *****************************************************************************
3722:./include/lib_AT91SAM7A3.h ****                 SOFTWARE API FOR SPI
3723:./include/lib_AT91SAM7A3.h ****    ***************************************************************************** */
3724:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3725:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SPI_CfgCs
3726:./include/lib_AT91SAM7A3.h **** //* \brief Configure SPI chip select register
3727:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3728:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SPI_CfgCs (
3729:./include/lib_AT91SAM7A3.h **** 	AT91PS_SPI pSPI,     // pointer to a SPI controller
3730:./include/lib_AT91SAM7A3.h **** 	int cs,     // SPI cs number (0 to 3)
3731:./include/lib_AT91SAM7A3.h ****  	int val)   //  chip select register
3732:./include/lib_AT91SAM7A3.h **** {
3733:./include/lib_AT91SAM7A3.h **** 	//* Write to the CSR register
3734:./include/lib_AT91SAM7A3.h **** 	*(pSPI->SPI_CSR + cs) = val;
3735:./include/lib_AT91SAM7A3.h **** }
3736:./include/lib_AT91SAM7A3.h **** 
3737:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3738:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SPI_EnableIt
3739:./include/lib_AT91SAM7A3.h **** //* \brief Enable SPI interrupt
3740:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3741:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SPI_EnableIt (
3742:./include/lib_AT91SAM7A3.h **** 	AT91PS_SPI pSPI,     // pointer to a SPI controller
3743:./include/lib_AT91SAM7A3.h **** 	unsigned int flag)   // IT to be enabled
3744:./include/lib_AT91SAM7A3.h **** {
3745:./include/lib_AT91SAM7A3.h **** 	//* Write to the IER register
3746:./include/lib_AT91SAM7A3.h **** 	pSPI->SPI_IER = flag;
3747:./include/lib_AT91SAM7A3.h **** }
3748:./include/lib_AT91SAM7A3.h **** 
3749:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3750:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SPI_DisableIt
3751:./include/lib_AT91SAM7A3.h **** //* \brief Disable SPI interrupt
3752:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3753:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SPI_DisableIt (
3754:./include/lib_AT91SAM7A3.h **** 	AT91PS_SPI pSPI, // pointer to a SPI controller
3755:./include/lib_AT91SAM7A3.h **** 	unsigned int flag) // IT to be disabled
3756:./include/lib_AT91SAM7A3.h **** {
3757:./include/lib_AT91SAM7A3.h **** 	//* Write to the IDR register
3758:./include/lib_AT91SAM7A3.h **** 	pSPI->SPI_IDR = flag;
3759:./include/lib_AT91SAM7A3.h **** }
3760:./include/lib_AT91SAM7A3.h **** 
3761:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3762:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SPI_Reset
3763:./include/lib_AT91SAM7A3.h **** //* \brief Reset the SPI controller
3764:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3765:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SPI_Reset (
3766:./include/lib_AT91SAM7A3.h **** 	AT91PS_SPI pSPI // pointer to a SPI controller
3767:./include/lib_AT91SAM7A3.h **** 	)
3768:./include/lib_AT91SAM7A3.h **** {
3769:./include/lib_AT91SAM7A3.h **** 	//* Write to the CR register
3770:./include/lib_AT91SAM7A3.h **** 	pSPI->SPI_CR = AT91C_SPI_SWRST;
3771:./include/lib_AT91SAM7A3.h **** }
3772:./include/lib_AT91SAM7A3.h **** 
3773:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3774:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SPI_Enable
3775:./include/lib_AT91SAM7A3.h **** //* \brief Enable the SPI controller
3776:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3777:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SPI_Enable (
3778:./include/lib_AT91SAM7A3.h **** 	AT91PS_SPI pSPI // pointer to a SPI controller
3779:./include/lib_AT91SAM7A3.h **** 	)
3780:./include/lib_AT91SAM7A3.h **** {
3781:./include/lib_AT91SAM7A3.h **** 	//* Write to the CR register
3782:./include/lib_AT91SAM7A3.h **** 	pSPI->SPI_CR = AT91C_SPI_SPIEN;
3783:./include/lib_AT91SAM7A3.h **** }
3784:./include/lib_AT91SAM7A3.h **** 
3785:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3786:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SPI_Disable
3787:./include/lib_AT91SAM7A3.h **** //* \brief Disable the SPI controller
3788:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3789:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SPI_Disable (
3790:./include/lib_AT91SAM7A3.h **** 	AT91PS_SPI pSPI // pointer to a SPI controller
3791:./include/lib_AT91SAM7A3.h **** 	)
3792:./include/lib_AT91SAM7A3.h **** {
3793:./include/lib_AT91SAM7A3.h **** 	//* Write to the CR register
3794:./include/lib_AT91SAM7A3.h **** 	pSPI->SPI_CR = AT91C_SPI_SPIDIS;
3795:./include/lib_AT91SAM7A3.h **** }
3796:./include/lib_AT91SAM7A3.h **** 
3797:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3798:./include/lib_AT91SAM7A3.h **** //* \fn    AT91F_SPI_CfgMode
3799:./include/lib_AT91SAM7A3.h **** //* \brief Enable the SPI controller
3800:./include/lib_AT91SAM7A3.h **** //*----------------------------------------------------------------------------
3801:./include/lib_AT91SAM7A3.h **** __inline void AT91F_SPI_CfgMode (
3802:./include/lib_AT91SAM7A3.h **** 	AT91PS_SPI pSPI, // pointer to a SPI controller
3803:./include/lib_AT91SAM7A3.h **** 	int mode)        // mode register 
3804:./include/lib_AT91SAM7A3.h **** {
3805:./include/lib_AT91SAM7A3.h **** 	//* Write to the MR register
3806:./include/lib_AT91SAM7A3.h **** 	pSPI->SPI_MR = mode;
 5203              		.loc 2 3806 0
 5204 0018 034B     		ldr	r3, .L370
 5205 001a 5A60     		str	r2, [r3, #4]
 5206              	.LVL608:
 5207              	.LBE33:
 5208              	.LBE32:
 5209              	.LBB34:
 5210              	.LBB35:
 258:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TPR = (unsigned int) address;
 5211              		.loc 2 258 0
 5212 001c 034B     		ldr	r3, .L370+4
 5213 001e 9860     		str	r0, [r3, #8]
 259:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TCR = bytes;
 5214              		.loc 2 259 0
 5215 0020 D960     		str	r1, [r3, #12]
 5216              	.LBE35:
 5217              	.LBE34:
1285:display.c     **** 
1286:display.c     **** 	// send data
1287:display.c     **** 	AT91F_PDC_SetTx( AT91C_BASE_PDC_SPI0, pbuffer, count );
1288:display.c     **** }
 5218              		.loc 1 1288 0
 5219              		@ sp needed for prologue
 5220 0022 30BC     		pop	{r4, r5}
 5221 0024 01BC     		pop	{r0}
 5222 0026 0047     		bx	r0
 5223              	.L371:
 5224              		.align	2
 5225              	.L370:
 5226 0028 0000FEFF 		.word	-131072
 5227 002c 0001FEFF 		.word	-130816
 5228              		.cfi_endproc
 5229              	.LFE387:
 5231              		.section	.text.WriteDisplay,"ax",%progbits
 5232              		.align	2
 5233              		.global	WriteDisplay
 5234              		.code	16
 5235              		.thumb_func
 5237              	WriteDisplay:
 5238              	.LFB388:
1289:display.c     **** // -----------------------------------------------------------
1290:display.c     **** 
1291:display.c     **** 
1292:display.c     **** // -----------------------------------------------------------
1293:display.c     **** // Function Name       : WriteDisplay
1294:display.c     **** // -----------------------------------------------------------
1295:display.c     **** void WriteDisplay( unsigned char *pts )
1296:display.c     **** {
 5239              		.loc 1 1296 0
 5240              		.cfi_startproc
 5241              	.LVL609:
 5242 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 5243              	.LCFI28:
 5244              		.cfi_def_cfa_offset 20
 5245              		.cfi_offset 4, -20
 5246              		.cfi_offset 5, -16
 5247              		.cfi_offset 6, -12
 5248              		.cfi_offset 7, -8
 5249              		.cfi_offset 14, -4
 5250 0002 5F46     		mov	r7, fp
 5251 0004 5646     		mov	r6, sl
 5252 0006 4D46     		mov	r5, r9
 5253 0008 4446     		mov	r4, r8
 5254 000a F0B4     		push	{r4, r5, r6, r7}
 5255              	.LCFI29:
 5256              		.cfi_def_cfa_offset 36
 5257              		.cfi_offset 8, -36
 5258              		.cfi_offset 9, -32
 5259              		.cfi_offset 10, -28
 5260              		.cfi_offset 11, -24
 5261 000c ABB0     		sub	sp, sp, #172
 5262              	.LCFI30:
 5263              		.cfi_def_cfa_offset 208
 5264 000e 041C     		mov	r4, r0
1297:display.c     **** 	unsigned int j, pageoffset;
1298:display.c     **** 	unsigned char *lptd;
1299:display.c     **** 	unsigned char page, c, mask;
1300:display.c     **** 	unsigned char command[4];
1301:display.c     **** 	unsigned char map[160];
1302:display.c     **** 
1303:display.c     **** 	// set up command Column 0, Page 0
1304:display.c     **** 	command[0] = 0x00; // set Column LSN (0x00 | '0000CCCC')
 5265              		.loc 1 1304 0
 5266 0010 29A8     		add	r0, sp, #164
 5267              	.LVL610:
 5268 0012 0023     		mov	r3, #0
 5269 0014 0370     		strb	r3, [r0]
1305:display.c     **** 	command[1] = 0x10; // set Column MSN (0x10 | '0000CCCC') 240 columns max
 5270              		.loc 1 1305 0
 5271 0016 1023     		mov	r3, #16
 5272 0018 4370     		strb	r3, [r0, #1]
1306:display.c     **** 	command[2] = 0x60; // set Page LSN (0x60 | '0000PPPP')
 5273              		.loc 1 1306 0
 5274 001a 6023     		mov	r3, #96
 5275 001c 8370     		strb	r3, [r0, #2]
1307:display.c     **** 	// start on page 16 for PM5718 240x128
1308:display.c     **** 	command[3] = 0x71; // set Page MSN (0x70 | '00000PPP') 80 pages max
 5276              		.loc 1 1308 0
 5277 001e 7123     		mov	r3, #113
 5278 0020 C370     		strb	r3, [r0, #3]
1309:display.c     **** 
1310:display.c     **** 	// send command
1311:display.c     **** 	SendToDisplay( command, 4, DM_COMMAND );
 5279              		.loc 1 1311 0
 5280 0022 0421     		mov	r1, #4
 5281 0024 0122     		mov	r2, #1
 5282 0026 FFF7FEFF 		bl	SendToDisplay
 5283              	.LVL611:
 5284 002a 0025     		mov	r5, #0
1312:display.c     **** 
1313:display.c     **** 	// write to 64 pages (128 lines)
1314:display.c     **** 	for( page = 0; page < 64; page++ )
1315:display.c     **** 	{
1316:display.c     **** 		// wait until SPI PDC ready
1317:display.c     **** 		while( !(AT91C_BASE_SPI0->SPI_SR & AT91C_SPI_TXBUFE) )
 5285              		.loc 1 1317 0
 5286 002c 3048     		ldr	r0, .L388
 5287 002e 8346     		mov	fp, r0
 5288              	.LVL612:
 5289              	.L387:
 5290              		.loc 1 1317 0 is_stmt 0 discriminator 1
 5291 0030 5946     		mov	r1, fp
 5292 0032 0B69     		ldr	r3, [r1, #16]
 5293 0034 8022     		mov	r2, #128
 5294 0036 1A42     		tst	r2, r3
 5295 0038 FAD0     		beq	.L387
1318:display.c     **** 		{
1319:display.c     **** 		}
1320:display.c     **** 
1321:display.c     **** 		// set up command - set column 40
1322:display.c     **** 		command[0] = 0x08; // set Column LSN (0x00 | '0000CCCC')
 5296              		.loc 1 1322 0 is_stmt 1
 5297 003a 0823     		mov	r3, #8
 5298 003c 29AE     		add	r6, sp, #164
 5299 003e 3370     		strb	r3, [r6]
1323:display.c     **** 		command[1] = 0x12; // set Column MSN (0x10 | '0000CCCC') 240 columns max
 5300              		.loc 1 1323 0
 5301 0040 1223     		mov	r3, #18
 5302 0042 A527     		mov	r7, #165
 5303 0044 6F44     		add	r7, r7, sp
 5304 0046 3B70     		strb	r3, [r7]
1324:display.c     **** 		// send command
1325:display.c     **** 		SendToDisplay( command, 2, DM_COMMAND );
 5305              		.loc 1 1325 0
 5306 0048 301C     		mov	r0, r6
 5307 004a 0221     		mov	r1, #2
 5308 004c 0122     		mov	r2, #1
 5309 004e FFF7FEFF 		bl	SendToDisplay
 5310              	.LVL613:
 5311              	.L374:
1326:display.c     **** 		// wait until SPI PDC ready
1327:display.c     **** 
1328:display.c     **** 		while( !(AT91C_BASE_SPI0->SPI_SR & AT91C_SPI_TXBUFE) )
 5312              		.loc 1 1328 0 discriminator 1
 5313 0052 5846     		mov	r0, fp
 5314 0054 0369     		ldr	r3, [r0, #16]
 5315 0056 8021     		mov	r1, #128
 5316 0058 1942     		tst	r1, r3
 5317 005a FAD0     		beq	.L374
 5318              		.loc 1 1328 0 is_stmt 0
 5319 005c 0023     		mov	r3, #0
1329:display.c     **** 		{
1330:display.c     **** 		}
1331:display.c     **** 
1332:display.c     **** 		// remap for Ultra UC1611
1333:display.c     **** 		lptd = &map[0];
1334:display.c     **** 		pageoffset = page * ((160 / 8) * 2); // page * bytes per line * lines per page
1335:display.c     **** 		for( c = 1; c <= 160; c++ ) // columns
1336:display.c     **** 		{
1337:display.c     **** 			mask = 0x01 << ((c - 1) % 8);
 5320              		.loc 1 1337 0 is_stmt 1
 5321 005e 0722     		mov	r2, #7
 5322 0060 9446     		mov	ip, r2
1338:display.c     **** 
1339:display.c     **** 			// first pixel on first line
1340:display.c     **** 			j = pageoffset + ((160 - c) / 8); // result
1341:display.c     **** 			if( pts[j] & mask )
1342:display.c     **** 			{
1343:display.c     **** 				*lptd = (DISPLAY_DEFAULT_MASK & 0x0f);
1344:display.c     **** 			}
1345:display.c     **** 			else
1346:display.c     **** 			{
1347:display.c     **** 				*lptd = 0x00;
 5323              		.loc 1 1347 0
 5324 0062 9A46     		mov	sl, r3
1343:display.c     **** 				*lptd = (DISPLAY_DEFAULT_MASK & 0x0f);
 5325              		.loc 1 1343 0
 5326 0064 0F27     		mov	r7, #15
 5327 0066 B946     		mov	r9, r7
1348:display.c     **** 			}
1349:display.c     **** 
1350:display.c     **** 			// next pixel from line below
1351:display.c     **** 			// j = pageoffset + ((320 - c) / 8); // result
1352:display.c     **** 			j += (160 / 8); // + bytes per line
1353:display.c     **** 			if( pts[j] & mask )
1354:display.c     **** 			{
1355:display.c     **** 				*lptd |= (DISPLAY_DEFAULT_MASK & 0xf0);
 5328              		.loc 1 1355 0
 5329 0068 1022     		mov	r2, #16
 5330 006a 5242     		neg	r2, r2
 5331 006c 9046     		mov	r8, r2
 5332              	.L378:
1337:display.c     **** 			mask = 0x01 << ((c - 1) % 8);
 5333              		.loc 1 1337 0
 5334 006e D917     		asr	r1, r3, #31
 5335 0070 490F     		lsr	r1, r1, #29
 5336 0072 5A18     		add	r2, r3, r1
 5337 0074 6046     		mov	r0, ip
 5338 0076 0240     		and	r2, r0
 5339 0078 521A     		sub	r2, r2, r1
 5340 007a 0121     		mov	r1, #1
 5341 007c 9140     		lsl	r1, r1, r2
 5342 007e 0A06     		lsl	r2, r1, #24
 5343 0080 120E     		lsr	r2, r2, #24
 5344              	.LVL614:
1295:display.c     **** void WriteDisplay( unsigned char *pts )
 5345              		.loc 1 1295 0
 5346 0082 9F26     		mov	r6, #159
 5347 0084 F01A     		sub	r0, r6, r3
1340:display.c     **** 			j = pageoffset + ((160 - c) / 8); // result
 5348              		.loc 1 1340 0
 5349 0086 C117     		asr	r1, r0, #31
 5350 0088 490F     		lsr	r1, r1, #29
 5351 008a 0918     		add	r1, r1, r0
 5352 008c C910     		asr	r1, r1, #3
 5353 008e 4919     		add	r1, r1, r5
 5354              	.LVL615:
1341:display.c     **** 			if( pts[j] & mask )
 5355              		.loc 1 1341 0
 5356 0090 605C     		ldrb	r0, [r4, r1]
 5357 0092 1042     		tst	r0, r2
 5358 0094 04D0     		beq	.L375
1343:display.c     **** 				*lptd = (DISPLAY_DEFAULT_MASK & 0x0f);
 5359              		.loc 1 1343 0
 5360 0096 4E46     		mov	r6, r9
 5361 0098 1F1D     		add	r7, r3, #4
 5362 009a 6846     		mov	r0, sp
 5363 009c 3E54     		strb	r6, [r7, r0]
 5364 009e 03E0     		b	.L376
 5365              	.L375:
1347:display.c     **** 				*lptd = 0x00;
 5366              		.loc 1 1347 0
 5367 00a0 5646     		mov	r6, sl
 5368 00a2 1F1D     		add	r7, r3, #4
 5369 00a4 6846     		mov	r0, sp
 5370 00a6 3E54     		strb	r6, [r7, r0]
 5371              	.L376:
 5372              	.LVL616:
1353:display.c     **** 			if( pts[j] & mask )
 5373              		.loc 1 1353 0
 5374 00a8 6118     		add	r1, r4, r1
 5375              	.LVL617:
 5376 00aa 097D     		ldrb	r1, [r1, #20]
 5377 00ac 1142     		tst	r1, r2
 5378 00ae 04D0     		beq	.L377
 5379              		.loc 1 1355 0
 5380 00b0 01AA     		add	r2, sp, #4
 5381              	.LVL618:
 5382 00b2 995C     		ldrb	r1, [r3, r2]
 5383 00b4 4746     		mov	r7, r8
 5384 00b6 3943     		orr	r1, r7
 5385 00b8 9954     		strb	r1, [r3, r2]
 5386              	.L377:
 5387              	.LVL619:
 5388 00ba 0133     		add	r3, r3, #1
 5389              	.LVL620:
1335:display.c     **** 		for( c = 1; c <= 160; c++ ) // columns
 5390              		.loc 1 1335 0
 5391 00bc A02B     		cmp	r3, #160
 5392 00be D6D1     		bne	.L378
1356:display.c     **** 			}
1357:display.c     **** 			lptd++;
1358:display.c     **** 		}
1359:display.c     **** 		// send data
1360:display.c     **** 		SendToDisplay( map, 160, DM_DATA );
 5393              		.loc 1 1360 0
 5394 00c0 01A8     		add	r0, sp, #4
 5395 00c2 A021     		mov	r1, #160
 5396 00c4 0022     		mov	r2, #0
 5397 00c6 FFF7FEFF 		bl	SendToDisplay
 5398              	.LVL621:
 5399 00ca 2835     		add	r5, r5, #40
1314:display.c     **** 	for( page = 0; page < 64; page++ )
 5400              		.loc 1 1314 0
 5401 00cc A023     		mov	r3, #160
 5402 00ce 1B01     		lsl	r3, r3, #4
 5403 00d0 9D42     		cmp	r5, r3
 5404 00d2 ADD1     		bne	.L387
1361:display.c     **** 	}
1362:display.c     **** 
1363:display.c     **** 	// wait until SPI PDC ready
1364:display.c     **** 	while( !(AT91C_BASE_SPI0->SPI_SR & AT91C_SPI_TXBUFE) )
 5405              		.loc 1 1364 0 discriminator 1
 5406 00d4 064A     		ldr	r2, .L388
 5407 00d6 8023     		mov	r3, #128
 5408              	.L382:
 5409 00d8 1169     		ldr	r1, [r2, #16]
 5410 00da 0B42     		tst	r3, r1
 5411 00dc FCD0     		beq	.L382
1365:display.c     **** 	{
1366:display.c     **** 	}
1367:display.c     **** 
1368:display.c     **** }
 5412              		.loc 1 1368 0
 5413 00de 2BB0     		add	sp, sp, #172
 5414              		@ sp needed for prologue
 5415              	.LVL622:
 5416 00e0 3CBC     		pop	{r2, r3, r4, r5}
 5417 00e2 9046     		mov	r8, r2
 5418 00e4 9946     		mov	r9, r3
 5419 00e6 A246     		mov	sl, r4
 5420 00e8 AB46     		mov	fp, r5
 5421 00ea F0BC     		pop	{r4, r5, r6, r7}
 5422 00ec 01BC     		pop	{r0}
 5423 00ee 0047     		bx	r0
 5424              	.L389:
 5425              		.align	2
 5426              	.L388:
 5427 00f0 0000FEFF 		.word	-131072
 5428              		.cfi_endproc
 5429              	.LFE388:
 5431              		.section	.text.SPI0Setup,"ax",%progbits
 5432              		.align	2
 5433              		.global	SPI0Setup
 5434              		.code	16
 5435              		.thumb_func
 5437              	SPI0Setup:
 5438              	.LFB389:
1369:display.c     **** // -----------------------------------------------------------
1370:display.c     **** 
1371:display.c     **** 
1372:display.c     **** // -----------------------------------------------------------
1373:display.c     **** // Function Name       : SPI0Setup
1374:display.c     **** // -----------------------------------------------------------
1375:display.c     **** void SPI0Setup( void )
1376:display.c     **** {
 5439              		.loc 1 1376 0
 5440              		.cfi_startproc
 5441              	.LVL623:
 5442              	.LBB36:
 5443              	.LBB37:
 5444              	.LBB38:
1046:./include/lib_AT91SAM7A3.h **** 	pPMC->PMC_PCER = periphIds;
 5445              		.loc 2 1046 0
 5446 0000 8022     		mov	r2, #128
 5447 0002 1201     		lsl	r2, r2, #4
 5448 0004 0C4B     		ldr	r3, .L391
 5449 0006 1A61     		str	r2, [r3, #16]
 5450              	.LVL624:
 5451              	.LBE38:
 5452              	.LBE37:
 5453              	.LBE36:
 5454              	.LBB39:
 5455              	.LBB40:
3770:./include/lib_AT91SAM7A3.h **** 	pSPI->SPI_CR = AT91C_SPI_SWRST;
 5456              		.loc 2 3770 0
 5457 0008 0C4B     		ldr	r3, .L391+4
 5458 000a 8022     		mov	r2, #128
 5459 000c 1A60     		str	r2, [r3]
 5460              	.LVL625:
 5461              	.LBE40:
 5462              	.LBE39:
 5463              	.LBB41:
 5464              	.LBB42:
 5465              		.loc 2 3806 0
 5466 000e 0122     		mov	r2, #1
 5467 0010 5A60     		str	r2, [r3, #4]
 5468              	.LVL626:
 5469              	.LBE42:
 5470              	.LBE41:
 5471              	.LBB43:
 5472              	.LBB44:
3734:./include/lib_AT91SAM7A3.h **** 	*(pSPI->SPI_CSR + cs) = val;
 5473              		.loc 2 3734 0
 5474 0012 0B49     		ldr	r1, .L391+8
 5475 0014 1963     		str	r1, [r3, #48]
 5476              	.LVL627:
 5477              	.LBE44:
 5478              	.LBE43:
 5479              	.LBB45:
 5480              	.LBB46:
 5481 0016 5963     		str	r1, [r3, #52]
 5482              	.LVL628:
 5483              	.LBE46:
 5484              	.LBE45:
 5485              	.LBB47:
 5486              	.LBB48:
3782:./include/lib_AT91SAM7A3.h **** 	pSPI->SPI_CR = AT91C_SPI_SPIEN;
 5487              		.loc 2 3782 0
 5488 0018 1A60     		str	r2, [r3]
 5489              	.LVL629:
 5490              	.LBE48:
 5491              	.LBE47:
 5492              	.LBB49:
 5493              	.LBB50:
 232:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TNPR = (unsigned int) address;
 5494              		.loc 2 232 0
 5495 001a 0A4B     		ldr	r3, .L391+12
 5496 001c 0022     		mov	r2, #0
 5497 001e 9A61     		str	r2, [r3, #24]
 233:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TNCR = bytes;
 5498              		.loc 2 233 0
 5499 0020 DA61     		str	r2, [r3, #28]
 5500              	.LVL630:
 5501              	.LBE50:
 5502              	.LBE49:
 5503              	.LBB51:
 5504              	.LBB52:
 219:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RNPR = (unsigned int) address;
 5505              		.loc 2 219 0
 5506 0022 1A61     		str	r2, [r3, #16]
 220:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RNCR = bytes;
 5507              		.loc 2 220 0
 5508 0024 5A61     		str	r2, [r3, #20]
 5509              	.LVL631:
 5510              	.LBE52:
 5511              	.LBE51:
 5512              	.LBB53:
 5513              	.LBB54:
 258:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TPR = (unsigned int) address;
 5514              		.loc 2 258 0
 5515 0026 9A60     		str	r2, [r3, #8]
 259:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_TCR = bytes;
 5516              		.loc 2 259 0
 5517 0028 DA60     		str	r2, [r3, #12]
 5518              	.LVL632:
 5519              	.LBE54:
 5520              	.LBE53:
 5521              	.LBB55:
 5522              	.LBB56:
 245:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RPR = (unsigned int) address;
 5523              		.loc 2 245 0
 5524 002a 1A60     		str	r2, [r3]
 246:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_RCR = bytes;
 5525              		.loc 2 246 0
 5526 002c 5A60     		str	r2, [r3, #4]
 5527              	.LVL633:
 5528              	.LBE56:
 5529              	.LBE55:
 5530              	.LBB57:
 5531              	.LBB58:
 269:./include/lib_AT91SAM7A3.h **** 	pPDC->PDC_PTCR = AT91C_PDC_TXTEN;
 5532              		.loc 2 269 0
 5533 002e 8022     		mov	r2, #128
 5534 0030 5200     		lsl	r2, r2, #1
 5535 0032 1A62     		str	r2, [r3, #32]
 5536              	.LBE58:
 5537              	.LBE57:
1377:display.c     **** 
1378:display.c     **** 	// enable spi
1379:display.c     **** 	// enable the clock of the SPI0
1380:display.c     **** 	AT91F_SPI0_CfgPMC();
1381:display.c     **** 	AT91F_SPI_Reset( AT91C_BASE_SPI0 );
1382:display.c     **** 
1383:display.c     **** 	// set SPI master mode before configuring CS (errata 40.4.4 clock can toggle before first transfer
1384:display.c     **** 	AT91F_SPI_CfgMode( AT91C_BASE_SPI0, AT91C_SPI_MSTR );
1385:display.c     **** 
1386:display.c     **** 	// set configuration for CS0
1387:display.c     **** 	AT91F_SPI_CfgCs( AT91C_BASE_SPI0,
1388:display.c     **** 			0, // CS0
1389:display.c     **** 			AT91C_SPI_CPOL |
1390:display.c     **** 			AT91C_SPI_BITS_8 |
1391:display.c     **** 			(AT91C_SPI_DLYBS & (10 << 16)) | // 10 / mck, 10 / 47923200 = 209nS
1392:display.c     **** 			(AT91C_SPI_SCBR & (8 << 8)) ); // mck / 8, 47.923200 / 8 = 5.9904MHz
1393:display.c     **** 
1394:display.c     **** 	// set configuration for CS1
1395:display.c     **** 	AT91F_SPI_CfgCs( AT91C_BASE_SPI0,
1396:display.c     **** 			1, // CS1
1397:display.c     **** 			AT91C_SPI_CPOL |
1398:display.c     **** 			AT91C_SPI_BITS_8 |
1399:display.c     **** 			(AT91C_SPI_DLYBS & (10 << 16)) | // 10 / mck, 10 / 47923200 = 209nS
1400:display.c     **** 			(AT91C_SPI_SCBR & (8 << 8)) ); // mck / 8, 47.923200 / 8 = 5.9904MHz
1401:display.c     **** 
1402:display.c     **** 	AT91F_SPI_Enable( AT91C_BASE_SPI0 );
1403:display.c     **** 
1404:display.c     **** 	// clear PDC buffers of SPI0
1405:display.c     **** 	AT91F_PDC_SetNextTx( AT91C_BASE_PDC_SPI0, (char *) 0, 0);
1406:display.c     **** 	AT91F_PDC_SetNextRx( AT91C_BASE_PDC_SPI0, (char *) 0, 0);
1407:display.c     **** 	AT91F_PDC_SetTx( AT91C_BASE_PDC_SPI0, (char *) 0, 0);
1408:display.c     **** 	AT91F_PDC_SetRx( AT91C_BASE_PDC_SPI0, (char *) 0, 0);
1409:display.c     **** 
1410:display.c     **** 	AT91F_PDC_EnableTx( AT91C_BASE_PDC_SPI0 ); // enable DMA transfers
1411:display.c     **** 
1412:display.c     **** }
 5538              		.loc 1 1412 0
 5539              		@ sp needed for prologue
 5540 0034 7047     		bx	lr
 5541              	.L392:
 5542 0036 C046     		.align	2
 5543              	.L391:
 5544 0038 00FCFFFF 		.word	-1024
 5545 003c 0000FEFF 		.word	-131072
 5546 0040 01080A00 		.word	657409
 5547 0044 0001FEFF 		.word	-130816
 5548              		.cfi_endproc
 5549              	.LFE389:
 5551              		.section	.text.InitilizeDisplay,"ax",%progbits
 5552              		.align	2
 5553              		.global	InitilizeDisplay
 5554              		.code	16
 5555              		.thumb_func
 5557              	InitilizeDisplay:
 5558              	.LFB390:
1413:display.c     **** // -----------------------------------------------------------
1414:display.c     **** 
1415:display.c     **** 
1416:display.c     **** // -----------------------------------------------------------
1417:display.c     **** // Function Name       : InitilizeDisplay
1418:display.c     **** // -----------------------------------------------------------
1419:display.c     **** void InitilizeDisplay( void )
1420:display.c     **** {
 5559              		.loc 1 1420 0
 5560              		.cfi_startproc
 5561 0000 00B5     		push	{lr}
 5562              	.LCFI31:
 5563              		.cfi_def_cfa_offset 4
 5564              		.cfi_offset 14, -4
 5565 0002 87B0     		sub	sp, sp, #28
 5566              	.LCFI32:
 5567              		.cfi_def_cfa_offset 32
1421:display.c     **** 	unsigned int i;
1422:display.c     **** 	unsigned char command[24];
1423:display.c     **** 
1424:display.c     **** 	// reset display
1425:display.c     **** 	command[0] = 0xe2;
 5568              		.loc 1 1425 0
 5569 0004 E223     		mov	r3, #226
 5570 0006 6946     		mov	r1, sp
 5571 0008 0B70     		strb	r3, [r1]
1426:display.c     **** 	SendToDisplay( command, 1, DM_COMMAND );
 5572              		.loc 1 1426 0
 5573 000a 6846     		mov	r0, sp
 5574 000c 0121     		mov	r1, #1
 5575 000e 0122     		mov	r2, #1
 5576 0010 FFF7FEFF 		bl	SendToDisplay
 5577              	.LVL634:
1427:display.c     **** 
1428:display.c     **** 	// wait at least 20ms after power on before initializing display - Reset Could be running
1429:display.c     **** 	vTaskDelay( 20 / portTICK_RATE_MS ); // wait 20ms
 5578              		.loc 1 1429 0
 5579 0014 1420     		mov	r0, #20
 5580 0016 FFF7FEFF 		bl	vTaskDelay
 5581              	.LVL635:
1430:display.c     **** 
1431:display.c     **** 	// initialize display
1432:display.c     **** 	command[0] = 0x2c | DISPLAY_DEFAULT_CHARGE_PUMP; // set Internal Charge Pump
 5582              		.loc 1 1432 0
 5583 001a 2F23     		mov	r3, #47
 5584 001c 6A46     		mov	r2, sp
 5585 001e 1370     		strb	r3, [r2]
1433:display.c     **** 	command[1] = 0x28 | DISPLAY_DEFAULT_PANEL_LOADING; // set Panel Loading
 5586              		.loc 1 1433 0
 5587 0020 2A23     		mov	r3, #42
 5588 0022 5370     		strb	r3, [r2, #1]
1434:display.c     **** 	command[2] = 0xe8 | DISPLAY_DEFAULT_BIAS_RATIO; // set Bias Ratio
 5589              		.loc 1 1434 0
 5590 0024 E923     		mov	r3, #233
 5591 0026 9370     		strb	r3, [r2, #2]
1435:display.c     **** 	command[3] = 0x24 | DISPLAY_DEFAULT_TEMPCOMP; // set Temperature Compensation
 5592              		.loc 1 1435 0
 5593 0028 2423     		mov	r3, #36
 5594 002a D370     		strb	r3, [r2, #3]
1436:display.c     **** 	command[4] = 0x81; // set Gain/Pot (2 bytes 0x81 + 'GGPPPPPP')
 5595              		.loc 1 1436 0
 5596 002c 8123     		mov	r3, #129
 5597 002e 1371     		strb	r3, [r2, #4]
1437:display.c     **** 	command[5] = DISPLAY_DEFAULT_GAIN | pRun.pr.Contrast[pRun.pr.DayNight];
 5598              		.loc 1 1437 0
 5599 0030 244B     		ldr	r3, .L401
 5600 0032 1A79     		ldrb	r2, [r3, #4]
 5601 0034 9B18     		add	r3, r3, r2
 5602 0036 9A78     		ldrb	r2, [r3, #2]
 5603 0038 8023     		mov	r3, #128
 5604 003a 5B42     		neg	r3, r3
 5605 003c 1343     		orr	r3, r2
 5606 003e 6946     		mov	r1, sp
 5607 0040 4B71     		strb	r3, [r1, #5]
1438:display.c     **** 	command[6] = 0x84 | DISPLAY_DEFAULT_PARTIAL; // sets Mux Rate depending on DST/DEN
 5608              		.loc 1 1438 0
 5609 0042 8623     		mov	r3, #134
 5610 0044 8B71     		strb	r3, [r1, #6]
1439:display.c     **** 	command[7] = 0xd0 | DISPLAY_DEFAULT_GRAY_SCALE; // set gray scale mode
 5611              		.loc 1 1439 0
 5612 0046 D023     		mov	r3, #208
 5613 0048 CB71     		strb	r3, [r1, #7]
1440:display.c     **** 	command[8] = 0xa0 | DISPLAY_DEFAULT_LINE_RATE;  // set line rate
 5614              		.loc 1 1440 0
 5615 004a A223     		mov	r3, #162
 5616 004c 0B72     		strb	r3, [r1, #8]
1441:display.c     **** 	command[9] = 0xf2;  // set DST (2 bytes 0xf2 + 0-159)
 5617              		.loc 1 1441 0
 5618 004e F223     		mov	r3, #242
 5619 0050 4B72     		strb	r3, [r1, #9]
1442:display.c     **** 	command[10] = DISPLAY_DEFAULT_STARTLINE;
 5620              		.loc 1 1442 0
 5621 0052 2023     		mov	r3, #32
 5622 0054 8B72     		strb	r3, [r1, #10]
1443:display.c     **** 	command[11] = 0xf3; // set DEN (2 bytes 0xf3 + 0-159)
 5623              		.loc 1 1443 0
 5624 0056 F323     		mov	r3, #243
 5625 0058 CB72     		strb	r3, [r1, #11]
1444:display.c     **** 	command[12] = DISPLAY_DEFAULT_ENDLINE;
 5626              		.loc 1 1444 0
 5627 005a 9F23     		mov	r3, #159
 5628 005c 0B73     		strb	r3, [r1, #12]
1445:display.c     **** 	command[13] = 0xf1;  // set CEN (2 bytes 0xf1 + 0-159)
 5629              		.loc 1 1445 0
 5630 005e F122     		mov	r2, #241
 5631 0060 4A73     		strb	r2, [r1, #13]
1446:display.c     **** 	command[14] = DISPLAY_DEFAULT_COMEND;
 5632              		.loc 1 1446 0
 5633 0062 8B73     		strb	r3, [r1, #14]
1447:display.c     **** 	command[15] = 0xc0 | DISPLAY_DEFAULT_MAPPING;  // set LCD mapping MY/MX/MSF
 5634              		.loc 1 1447 0
 5635 0064 C023     		mov	r3, #192
 5636 0066 CB73     		strb	r3, [r1, #15]
1448:display.c     **** 	command[16] = 0x88 | DISPLAY_DEFAULT_RAMCONTROL;  // set RAM address control
 5637              		.loc 1 1448 0
 5638 0068 8923     		mov	r3, #137
 5639 006a 0B74     		strb	r3, [r1, #16]
1449:display.c     **** 	command[17] = 0x32; // set MAX column address (2 bytes 0x32 + 0-239)
 5640              		.loc 1 1449 0
 5641 006c 3223     		mov	r3, #50
 5642 006e 4B74     		strb	r3, [r1, #17]
1450:display.c     **** 	command[18] = DISPLAY_DEFAULT_MAXCOLUMN;
 5643              		.loc 1 1450 0
 5644 0070 C723     		mov	r3, #199
 5645 0072 8B74     		strb	r3, [r1, #18]
1451:display.c     **** 	command[19] = 0xa8 | DISPLAY_DEFAULT_COLUMNS; // turn on seg drivers (n x 80columns)
 5646              		.loc 1 1451 0
 5647 0074 AF23     		mov	r3, #175
 5648 0076 CB74     		strb	r3, [r1, #19]
1452:display.c     **** 	// send display setup commands - but don't turn display on yet
1453:display.c     **** 	SendToDisplay( command, 20, DM_COMMAND );
 5649              		.loc 1 1453 0
 5650 0078 6846     		mov	r0, sp
 5651 007a 1421     		mov	r1, #20
 5652 007c 0122     		mov	r2, #1
 5653 007e FFF7FEFF 		bl	SendToDisplay
 5654              	.LVL636:
 5655 0082 114B     		ldr	r3, .L401+4
1419:display.c     **** void InitilizeDisplay( void )
 5656              		.loc 1 1419 0
 5657 0084 A022     		mov	r2, #160
 5658 0086 1201     		lsl	r2, r2, #4
 5659 0088 9918     		add	r1, r3, r2
1454:display.c     **** 
1455:display.c     **** 	// clear global display buffer
1456:display.c     **** 	for( i = 0; i < GRAPHICS_SIZE; i++ )
1457:display.c     **** 	{
1458:display.c     **** 		adm[i] = 0x00;
 5660              		.loc 1 1458 0
 5661 008a 0022     		mov	r2, #0
 5662              	.LVL637:
 5663              	.L394:
 5664              		.loc 1 1458 0 is_stmt 0 discriminator 2
 5665 008c 1A70     		strb	r2, [r3]
 5666 008e 0133     		add	r3, r3, #1
1456:display.c     **** 	for( i = 0; i < GRAPHICS_SIZE; i++ )
 5667              		.loc 1 1456 0 is_stmt 1 discriminator 2
 5668 0090 8B42     		cmp	r3, r1
 5669 0092 FBD1     		bne	.L394
1459:display.c     **** 	}
1460:display.c     **** 
1461:display.c     **** 	// wait until SPI PDC ready
1462:display.c     **** 	while( !(AT91C_BASE_SPI0->SPI_SR & AT91C_SPI_TXBUFE) )
 5670              		.loc 1 1462 0 discriminator 1
 5671 0094 0D49     		ldr	r1, .L401+8
 5672 0096 8022     		mov	r2, #128
 5673              	.L397:
 5674 0098 0B69     		ldr	r3, [r1, #16]
 5675 009a 1A42     		tst	r2, r3
 5676 009c FCD0     		beq	.L397
1463:display.c     **** 	{
1464:display.c     **** 	}
1465:display.c     **** 	// clear display driver memory - before turning display on
1466:display.c     **** 	WriteDisplay( adm );
 5677              		.loc 1 1466 0
 5678 009e 0A48     		ldr	r0, .L401+4
 5679 00a0 FFF7FEFF 		bl	WriteDisplay
 5680              	.LVL638:
1467:display.c     **** 
1468:display.c     **** 	// turn display on after clearing display memory
1469:display.c     **** 	command[0] = 0xa8 | DISPLAY_DEFAULT_COLUMNS; // turn on seg drivers (n x 80columns)
 5681              		.loc 1 1469 0
 5682 00a4 AF23     		mov	r3, #175
 5683 00a6 6946     		mov	r1, sp
 5684 00a8 0B70     		strb	r3, [r1]
1470:display.c     **** 	SendToDisplay( command, 1, DM_COMMAND );
 5685              		.loc 1 1470 0
 5686 00aa 6846     		mov	r0, sp
 5687 00ac 0121     		mov	r1, #1
 5688 00ae 0122     		mov	r2, #1
 5689 00b0 FFF7FEFF 		bl	SendToDisplay
 5690              	.LVL639:
1471:display.c     **** 
1472:display.c     **** 	// wait until SPI PDC ready
1473:display.c     **** 	while( !(AT91C_BASE_SPI0->SPI_SR & AT91C_SPI_TXBUFE) )
 5691              		.loc 1 1473 0
 5692 00b4 0549     		ldr	r1, .L401+8
 5693 00b6 8022     		mov	r2, #128
 5694              	.L396:
 5695              		.loc 1 1473 0 is_stmt 0 discriminator 1
 5696 00b8 0B69     		ldr	r3, [r1, #16]
 5697 00ba 1A42     		tst	r2, r3
 5698 00bc FCD0     		beq	.L396
1474:display.c     **** 	{
1475:display.c     **** 	}
1476:display.c     **** 
1477:display.c     **** }
 5699              		.loc 1 1477 0 is_stmt 1
 5700 00be 07B0     		add	sp, sp, #28
 5701              		@ sp needed for prologue
 5702 00c0 01BC     		pop	{r0}
 5703 00c2 0047     		bx	r0
 5704              	.L402:
 5705              		.align	2
 5706              	.L401:
 5707 00c4 00000000 		.word	pRun
 5708 00c8 00000000 		.word	adm
 5709 00cc 0000FEFF 		.word	-131072
 5710              		.cfi_endproc
 5711              	.LFE390:
 5713              		.global	__aeabi_ui2f
 5714              		.global	__aeabi_dmul
 5715              		.global	__aeabi_dadd
 5716              		.global	__aeabi_d2f
 5717              		.global	__aeabi_uidiv
 5718              		.section	.text.vDisplayTask,"ax",%progbits
 5719              		.align	2
 5720              		.code	16
 5721              		.thumb_func
 5723              	vDisplayTask:
 5724              	.LFB391:
1478:display.c     **** // -----------------------------------------------------------
1479:display.c     **** 
1480:display.c     **** 
1481:display.c     **** // -----------------------------------------------------------
1482:display.c     **** // Function Name       : vDisplayTask
1483:display.c     **** // -----------------------------------------------------------
1484:display.c     **** static void vDisplayTask( void *pvParameters )
1485:display.c     **** {
 5725              		.loc 1 1485 0
 5726              		.cfi_startproc
 5727              	.LVL640:
 5728 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 5729              	.LCFI33:
 5730              		.cfi_def_cfa_offset 20
 5731              		.cfi_offset 4, -20
 5732              		.cfi_offset 5, -16
 5733              		.cfi_offset 6, -12
 5734              		.cfi_offset 7, -8
 5735              		.cfi_offset 14, -4
 5736 0002 5F46     		mov	r7, fp
 5737 0004 5646     		mov	r6, sl
 5738 0006 4D46     		mov	r5, r9
 5739 0008 4446     		mov	r4, r8
 5740 000a F0B4     		push	{r4, r5, r6, r7}
 5741              	.LCFI34:
 5742              		.cfi_def_cfa_offset 36
 5743              		.cfi_offset 8, -36
 5744              		.cfi_offset 9, -32
 5745              		.cfi_offset 10, -28
 5746              		.cfi_offset 11, -24
 5747 000c 83B0     		sub	sp, sp, #12
 5748              	.LCFI35:
 5749              		.cfi_def_cfa_offset 48
1486:display.c     ****     unsigned int lastkey;
1487:display.c     ****     unsigned char count;
1488:display.c     ****     
1489:display.c     ****     portTickType xLastWakeTime;
1490:display.c     **** 
1491:display.c     ****     void (*old_window)( unsigned int key );
1492:display.c     **** 
1493:display.c     ****     // wait at least 15ms after power on before initializing display - internal Reset could be runn
1494:display.c     ****     vTaskDelay( 15 / portTICK_RATE_MS ); // wait 15ms
 5750              		.loc 1 1494 0
 5751 000e 0F20     		mov	r0, #15
 5752              	.LVL641:
 5753 0010 FFF7FEFF 		bl	vTaskDelay
 5754              	.LVL642:
1495:display.c     **** 
1496:display.c     ****     // setup SPI0 for display
1497:display.c     ****     
1498:display.c     ****     SPI0Setup();
 5755              		.loc 1 1498 0
 5756 0014 FFF7FEFF 		bl	SPI0Setup
 5757              	.LVL643:
1499:display.c     **** 
1500:display.c     ****     // setup display
1501:display.c     ****     InitilizeDisplay();
 5758              		.loc 1 1501 0
 5759 0018 FFF7FEFF 		bl	InitilizeDisplay
 5760              	.LVL644:
1502:display.c     **** 
1503:display.c     ****     /* if Brightness is Zero PIO mode is used, else peripheral PWM is used, Backlight run at 500Hz 
1504:display.c     ****     SetOutputPWM( BACK, 500, pRun.pr.Brightness[pRun.pr.DayNight] );
 5761              		.loc 1 1504 0
 5762 001c BA4B     		ldr	r3, .L428+16
 5763 001e 1A79     		ldrb	r2, [r3, #4]
 5764 0020 9A5C     		ldrb	r2, [r3, r2]
 5765 0022 0020     		mov	r0, #0
 5766 0024 FA21     		mov	r1, #250
 5767 0026 4900     		lsl	r1, r1, #1
 5768 0028 FFF7FEFF 		bl	SetOutputPWM
 5769              	.LVL645:
1505:display.c     ****     ResetSequenceFactors( SEQ_ALL );
 5770              		.loc 1 1505 0
 5771 002c FF20     		mov	r0, #255
 5772 002e FFF7FEFF 		bl	ResetSequenceFactors
 5773              	.LVL646:
1506:display.c     ****     // watchdog time is n * (128 / 32768) if slow clock SCK = 32768 - max is a 12 bit value of 0xff
1507:display.c     ****     // watchdog mode = reset on, debug halt on, delta 1.0 sec, watchdog time 1.0 sec
1508:display.c     ****     AT91C_BASE_WDTC->WDTC_WDMR = AT91C_WDTC_WDRSTEN | AT91C_WDTC_WDDBGHLT | (256 << 16) | (256 << 0
 5774              		.loc 1 1508 0
 5775 0032 B64A     		ldr	r2, .L428+20
 5776 0034 B64B     		ldr	r3, .L428+24
 5777 0036 5A60     		str	r2, [r3, #4]
1509:display.c     ****     // AT91C_BASE_WDTC->WDTC_WDMR= AT91C_WDTC_WDDIS; // Watchdog Disable
1510:display.c     **** 
1511:display.c     ****     // set current time
1512:display.c     ****     xLastWakeTime = xTaskGetTickCount();
 5778              		.loc 1 1512 0
 5779 0038 FFF7FEFF 		bl	xTaskGetTickCount
 5780              	.LVL647:
 5781 003c 0190     		str	r0, [sp, #4]
1513:display.c     **** 
1514:display.c     ****     while( 1 )
1515:display.c     ****     {
1516:display.c     ****         vTaskDelayUntil( &xLastWakeTime, (100 / portTICK_RATE_MS) ); // task executed every 100 ms
1517:display.c     **** 
1518:display.c     ****         key = (~AT91C_BASE_PIOB->PIO_PDSR) & SW_MASK; // AT91F_PIO_GetInput(AT91C_BASE_PIOB)
1519:display.c     **** 
1520:display.c     ****         // --- Hardware specific functions above ---
1521:display.c     **** #else
1522:display.c     ****         // --- Windows specific functions --- 
1523:display.c     ****         void sim_startup( void )
1524:display.c     ****         {
1525:display.c     **** 
1526:display.c     ****         	window = screen00; // Startup Splash Screen
1527:display.c     ****         	looptime = 0;
1528:display.c     ****         }
1529:display.c     **** 
1530:display.c     ****         extern void WriteToScreen( void );
1531:display.c     **** 
1532:display.c     ****         void sim_main( unsigned int keypress )
1533:display.c     ****         {
1534:display.c     ****         	static unsigned int lastkey;
1535:display.c     ****         	static unsigned char count;
1536:display.c     **** 
1537:display.c     ****         	//unsigned char tstring[16];
1538:display.c     **** 
1539:display.c     ****         	void (*old_window)( unsigned int keypress );
1540:display.c     **** 
1541:display.c     ****         	if( keypress != (int)-1 )
1542:display.c     ****         	{
1543:display.c     ****         		key = keypress;
1544:display.c     ****         	}
1545:display.c     ****         	else
1546:display.c     ****         	{
1547:display.c     ****         		key = lastkey & ~(SW_NEW | SW_REP);
1548:display.c     ****         	}
1549:display.c     **** 
1550:display.c     **** #endif
1551:display.c     **** 
1552:display.c     **** // Every 100 ms
1553:display.c     **** 
1554:display.c     **** #ifndef WINDOWS  
1555:display.c     ****         	// Calculate Analogue Input Rolling Averages:
1556:display.c     ****         	// Bale Diameter (AnIP1); (Bale) Density Pressure (AnIP2); Bale Shape Indicator (AnIP3); K
1557:display.c     ****         	CalculateAnalogInputRollingAverages();
1558:display.c     **** 
1559:display.c     ****         	SupplyVolts =  ((float)AT91C_BASE_ADC0->ADC_CDR7 * ATODIPVOUTSCALE) + ATODIPVOUTDROP;
 5782              		.loc 1 1559 0
 5783 003e AF4F     		ldr	r7, .L428+4
 5784 0040 AD4E     		ldr	r6, .L428
 5785 0042 AF4C     		ldr	r4, .L428+8
 5786 0044 AF4D     		ldr	r5, .L428+12
 5787              	.L427:
 5788              	.LVL648:
1516:display.c     ****         vTaskDelayUntil( &xLastWakeTime, (100 / portTICK_RATE_MS) ); // task executed every 100 ms
 5789              		.loc 1 1516 0
 5790 0046 01A8     		add	r0, sp, #4
 5791 0048 6421     		mov	r1, #100
 5792 004a FFF7FEFF 		bl	vTaskDelayUntil
 5793              	.LVL649:
1518:display.c     ****         key = (~AT91C_BASE_PIOB->PIO_PDSR) & SW_MASK; // AT91F_PIO_GetInput(AT91C_BASE_PIOB)
 5794              		.loc 1 1518 0
 5795 004e B14B     		ldr	r3, .L428+28
 5796 0050 DA6B     		ldr	r2, [r3, #60]
 5797 0052 B148     		ldr	r0, .L428+32
 5798 0054 8246     		mov	sl, r0
 5799 0056 FF23     		mov	r3, #255
 5800 0058 9B00     		lsl	r3, r3, #2
 5801 005a 9343     		bic	r3, r2
 5802 005c 0360     		str	r3, [r0]
1557:display.c     ****         	CalculateAnalogInputRollingAverages();
 5803              		.loc 1 1557 0
 5804 005e FFF7FEFF 		bl	CalculateAnalogInputRollingAverages
 5805              	.LVL650:
 5806              		.loc 1 1559 0
 5807 0062 AE4B     		ldr	r3, .L428+36
 5808 0064 D86C     		ldr	r0, [r3, #76]
 5809 0066 FFF7FEFF 		bl	__aeabi_ui2f
 5810              	.LVL651:
 5811 006a FFF7FEFF 		bl	__aeabi_f2d
 5812              	.LVL652:
 5813 006e 321C     		mov	r2, r6
 5814 0070 3B1C     		mov	r3, r7
 5815 0072 FFF7FEFF 		bl	__aeabi_dmul
 5816              	.LVL653:
 5817 0076 221C     		mov	r2, r4
 5818 0078 2B1C     		mov	r3, r5
 5819 007a FFF7FEFF 		bl	__aeabi_dadd
 5820              	.LVL654:
 5821 007e FFF7FEFF 		bl	__aeabi_d2f
 5822              	.LVL655:
 5823 0082 A74B     		ldr	r3, .L428+40
 5824 0084 1860     		str	r0, [r3]
1560:display.c     **** #endif
1561:display.c     **** 
1562:display.c     ****         	if( key != (lastkey & ~(SW_NEW | SW_REP)) ) /* different key: could be a keypressed or no 
 5825              		.loc 1 1562 0
 5826 0086 4346     		mov	r3, r8
 5827 0088 9A00     		lsl	r2, r3, #2
 5828 008a 9208     		lsr	r2, r2, #2
 5829 008c 5046     		mov	r0, sl
 5830 008e 0368     		ldr	r3, [r0]
 5831 0090 9A42     		cmp	r2, r3
 5832 0092 15D0     		beq	.L404
1563:display.c     ****         	{
1564:display.c     ****         		key |= SW_NEW;
 5833              		.loc 1 1564 0
 5834 0094 8021     		mov	r1, #128
 5835 0096 0906     		lsl	r1, r1, #24
 5836 0098 1943     		orr	r1, r3
 5837 009a 9F4A     		ldr	r2, .L428+32
 5838 009c 1160     		str	r1, [r2]
1565:display.c     ****         		if( key & ~(SW_NEW | SW_REP))
 5839              		.loc 1 1565 0
 5840 009e 9B00     		lsl	r3, r3, #2
 5841 00a0 08D0     		beq	.L405
1566:display.c     ****         		{
1567:display.c     ****         			buzz_length = KEY_BEEP; // 48 mS beep if new key pressed
 5842              		.loc 1 1567 0
 5843 00a2 3022     		mov	r2, #48
 5844 00a4 9F4B     		ldr	r3, .L428+44
 5845 00a6 1A60     		str	r2, [r3]
1568:display.c     ****         			looptime = 0;
 5846              		.loc 1 1568 0
 5847 00a8 0022     		mov	r2, #0
 5848 00aa 9F4B     		ldr	r3, .L428+48
 5849 00ac 1A70     		strb	r2, [r3]
1569:display.c     ****         		}
1570:display.c     ****         		else /* no key */
1571:display.c     ****         		{
1572:display.c     ****         			swrel = 0;
1573:display.c     ****         		}
1574:display.c     ****         		count = 5;     // 5 counts for first key
 5850              		.loc 1 1574 0
 5851 00ae 0521     		mov	r1, #5
 5852 00b0 8946     		mov	r9, r1
 5853              	.LVL656:
 5854 00b2 16E0     		b	.L406
 5855              	.LVL657:
 5856              	.L405:
1572:display.c     ****         			swrel = 0;
 5857              		.loc 1 1572 0
 5858 00b4 0022     		mov	r2, #0
 5859 00b6 9D4B     		ldr	r3, .L428+52
 5860 00b8 1A70     		strb	r2, [r3]
 5861              		.loc 1 1574 0
 5862 00ba 0522     		mov	r2, #5
 5863 00bc 9146     		mov	r9, r2
 5864              	.LVL658:
 5865 00be 10E0     		b	.L406
 5866              	.LVL659:
 5867              	.L404:
1575:display.c     ****         	}
1576:display.c     ****         	else if( count )
 5868              		.loc 1 1576 0
 5869 00c0 4B46     		mov	r3, r9
 5870 00c2 002B     		cmp	r3, #0
 5871 00c4 04D0     		beq	.L407
 5872              	.LVL660:
1577:display.c     ****         	{
1578:display.c     ****         		count--;
 5873              		.loc 1 1578 0
 5874 00c6 013B     		sub	r3, r3, #1
 5875              	.LVL661:
 5876 00c8 1B06     		lsl	r3, r3, #24
 5877 00ca 1B0E     		lsr	r3, r3, #24
 5878 00cc 9946     		mov	r9, r3
 5879              	.LVL662:
 5880 00ce 08E0     		b	.L406
 5881              	.L407:
1579:display.c     ****         	}
1580:display.c     ****         	else if( key )
 5882              		.loc 1 1580 0
 5883 00d0 002A     		cmp	r2, #0
 5884 00d2 06D0     		beq	.L406
1581:display.c     ****         	{
1582:display.c     ****         		key |= SW_REP;
 5885              		.loc 1 1582 0
 5886 00d4 8023     		mov	r3, #128
 5887              	.LVL663:
 5888 00d6 DB05     		lsl	r3, r3, #23
 5889 00d8 1A43     		orr	r2, r3
 5890 00da 8F4B     		ldr	r3, .L428+32
 5891 00dc 1A60     		str	r2, [r3]
 5892              	.LVL664:
1583:display.c     ****         		count = 1;
 5893              		.loc 1 1583 0
 5894 00de 0120     		mov	r0, #1
 5895 00e0 8146     		mov	r9, r0
 5896              	.LVL665:
 5897              	.L406:
1584:display.c     ****         	}
1585:display.c     ****         	lastkey = key;
 5898              		.loc 1 1585 0
 5899 00e2 8D4B     		ldr	r3, .L428+32
 5900 00e4 1968     		ldr	r1, [r3]
 5901 00e6 8846     		mov	r8, r1
 5902              	.LVL666:
1586:display.c     **** 
1587:display.c     ****         	old_window = window;
 5903              		.loc 1 1587 0
 5904 00e8 914B     		ldr	r3, .L428+56
 5905 00ea 1A68     		ldr	r2, [r3]
 5906 00ec 9246     		mov	sl, r2
 5907              	.LVL667:
1588:display.c     **** 
1589:display.c     ****         	half_second = (looptime / 5) & 0x01;
 5908              		.loc 1 1589 0
 5909 00ee 8E4B     		ldr	r3, .L428+48
 5910 00f0 9B46     		mov	fp, r3
 5911 00f2 1878     		ldrb	r0, [r3]
 5912 00f4 0521     		mov	r1, #5
 5913              	.LVL668:
 5914 00f6 FFF7FEFF 		bl	__aeabi_uidiv
 5915              	.LVL669:
 5916 00fa 0123     		mov	r3, #1
 5917 00fc 1840     		and	r0, r3
 5918 00fe 8D4B     		ldr	r3, .L428+60
 5919 0100 1870     		strb	r0, [r3]
1590:display.c     **** 
1591:display.c     ****         	window( key ); // screens called here
 5920              		.loc 1 1591 0
 5921 0102 4046     		mov	r0, r8
 5922 0104 00F001FA 		bl	.L432
 5923              	.LVL670:
1592:display.c     **** 
1593:display.c     ****         	looptime++; //incremented every 100 ms
 5924              		.loc 1 1593 0
 5925 0108 5A46     		mov	r2, fp
 5926 010a 1378     		ldrb	r3, [r2]
 5927 010c 0133     		add	r3, r3, #1
 5928 010e 1B06     		lsl	r3, r3, #24
 5929 0110 1B0E     		lsr	r3, r3, #24
 5930              	.LVL671:
1594:display.c     **** 
1595:display.c     ****         	if( looptime > 239 )
 5931              		.loc 1 1595 0
 5932 0112 EF2B     		cmp	r3, #239
 5933 0114 02D8     		bhi	.L408
 5934              	.LVL672:
1593:display.c     ****         	looptime++; //incremented every 100 ms
 5935              		.loc 1 1593 0
 5936 0116 844A     		ldr	r2, .L428+48
 5937 0118 1370     		strb	r3, [r2]
 5938 011a 02E0     		b	.L409
 5939              	.L408:
1596:display.c     ****         	{
1597:display.c     ****         		looptime = 0;
 5940              		.loc 1 1597 0
 5941 011c 0022     		mov	r2, #0
 5942 011e 824B     		ldr	r3, .L428+48
 5943              	.LVL673:
 5944 0120 1A70     		strb	r2, [r3]
 5945              	.LVL674:
 5946              	.L409:
1598:display.c     ****         	}
1599:display.c     **** 
1600:display.c     ****         	swrel++; //incremented every 100 ms
 5947              		.loc 1 1600 0
 5948 0122 824B     		ldr	r3, .L428+52
 5949              	.LVL675:
 5950 0124 1B78     		ldrb	r3, [r3]
 5951 0126 0133     		add	r3, r3, #1
 5952 0128 1B06     		lsl	r3, r3, #24
 5953 012a 1B0E     		lsr	r3, r3, #24
 5954              	.LVL676:
1601:display.c     ****         	if( swrel > 239 )
 5955              		.loc 1 1601 0
 5956 012c EF2B     		cmp	r3, #239
 5957 012e 02D8     		bhi	.L410
 5958              	.LVL677:
1600:display.c     ****         	swrel++; //incremented every 100 ms
 5959              		.loc 1 1600 0
 5960 0130 7E4A     		ldr	r2, .L428+52
 5961 0132 1370     		strb	r3, [r2]
 5962 0134 02E0     		b	.L411
 5963              	.L410:
1602:display.c     ****         	{
1603:display.c     ****         		swrel = 0;
 5964              		.loc 1 1603 0
 5965 0136 0022     		mov	r2, #0
 5966 0138 7C4B     		ldr	r3, .L428+52
 5967              	.LVL678:
 5968 013a 1A70     		strb	r2, [r3]
 5969              	.LVL679:
 5970              	.L411:
1604:display.c     ****         	}
1605:display.c     **** 
1606:display.c     ****         	if( !((window == mainscreen) && SecondScreen) &&  // Dont turn off in Main/Home Screen 2
 5971              		.loc 1 1606 0
 5972 013c 7C4B     		ldr	r3, .L428+56
 5973              	.LVL680:
 5974 013e 1B68     		ldr	r3, [r3]
 5975 0140 7D4A     		ldr	r2, .L428+64
 5976 0142 9342     		cmp	r3, r2
 5977 0144 03D1     		bne	.L412
 5978              		.loc 1 1606 0 is_stmt 0 discriminator 2
 5979 0146 7D4A     		ldr	r2, .L428+68
 5980 0148 1278     		ldrb	r2, [r2]
 5981 014a 002A     		cmp	r2, #0
 5982 014c 51D1     		bne	.L413
 5983              	.L412:
 5984              		.loc 1 1606 0 discriminator 1
 5985 014e 7C4A     		ldr	r2, .L428+72
 5986 0150 9342     		cmp	r3, r2
 5987 0152 4ED0     		beq	.L413
1607:display.c     ****         			(window != screen100) &&                      // Dont turn off in Machine Menu
 5988              		.loc 1 1607 0 is_stmt 1
 5989 0154 7B4A     		ldr	r2, .L428+76
 5990 0156 9342     		cmp	r3, r2
 5991 0158 4BD0     		beq	.L413
1608:display.c     ****         			(window != screen110) &&                      // Dont turn off in Machine Menu - Bale Se
 5992              		.loc 1 1608 0
 5993 015a 7B4A     		ldr	r2, .L428+80
 5994 015c 9342     		cmp	r3, r2
 5995 015e 48D0     		beq	.L413
1609:display.c     ****         			(window != screen111) &&                      // Dont turn off in Machine Menu - Machine
 5996              		.loc 1 1609 0
 5997 0160 7A4A     		ldr	r2, .L428+84
 5998 0162 9342     		cmp	r3, r2
 5999 0164 45D0     		beq	.L413
1610:display.c     ****         			(window != screen112) &&                      // Dont turn off in Machine Menu - Bale Co
 6000              		.loc 1 1610 0
 6001 0166 7A4A     		ldr	r2, .L428+88
 6002 0168 9342     		cmp	r3, r2
 6003 016a 42D0     		beq	.L413
1611:display.c     ****         			(window != screen113) &&                      // Dont turn off in Machine Menu - Operato
 6004              		.loc 1 1611 0
 6005 016c 794A     		ldr	r2, .L428+92
 6006 016e 9342     		cmp	r3, r2
 6007 0170 3FD0     		beq	.L413
1612:display.c     ****         			(window != screen120) &&                      // Dont turn off in Lube Count Reset Scree
 6008              		.loc 1 1612 0
 6009 0172 794A     		ldr	r2, .L428+96
 6010 0174 9342     		cmp	r3, r2
 6011 0176 3CD0     		beq	.L413
1613:display.c     ****         			(window != screen121) &&                      // Dont turn off in Bale Count Reset Scree
 6012              		.loc 1 1613 0
 6013 0178 784A     		ldr	r2, .L428+100
 6014 017a 9342     		cmp	r3, r2
 6015 017c 39D0     		beq	.L413
1614:display.c     **** #if 0 // Removed -- Dia pot zero value fixed
1615:display.c     ****         			(window != screen123) &&                      // Dont turn off in Dia Pot Zero Reset Scr
1616:display.c     **** #endif
1617:display.c     ****         			(window != screen124) &&                      // Dont turn off in Fill Pot Zero Reset Sc
 6016              		.loc 1 1617 0
 6017 017e 784A     		ldr	r2, .L428+104
 6018 0180 9342     		cmp	r3, r2
 6019 0182 36D0     		beq	.L413
1618:display.c     ****         			(window != screen125) &&                      // Dont turn off in Net Metres Reset Scree
 6020              		.loc 1 1618 0
 6021 0184 774A     		ldr	r2, .L428+108
 6022 0186 9342     		cmp	r3, r2
 6023 0188 33D0     		beq	.L413
1619:display.c     ****         			(window != screen131) &&                      // Dont turn off in Operator Setup Menu - 
 6024              		.loc 1 1619 0
 6025 018a 774A     		ldr	r2, .L428+112
 6026 018c 9342     		cmp	r3, r2
 6027 018e 30D0     		beq	.L413
1620:display.c     ****         			(window != screen132) &&                      // Dont turn off in Operator Setup Menu - 
 6028              		.loc 1 1620 0
 6029 0190 764A     		ldr	r2, .L428+116
 6030 0192 9342     		cmp	r3, r2
 6031 0194 2DD0     		beq	.L413
1621:display.c     ****         			(window != screen140) &&                      // Dont turn off in Technician Menu - PIN 
 6032              		.loc 1 1621 0
 6033 0196 764A     		ldr	r2, .L428+120
 6034 0198 9342     		cmp	r3, r2
 6035 019a 2AD0     		beq	.L413
1622:display.c     ****         			(window != screen141) &&                      // Dont turn off in Technician Menu
 6036              		.loc 1 1622 0
 6037 019c 754A     		ldr	r2, .L428+124
 6038 019e 9342     		cmp	r3, r2
 6039 01a0 27D0     		beq	.L413
1623:display.c     ****         			(window != screen142) &&                      // Dont turn off in Technician Menu - Bale
 6040              		.loc 1 1623 0
 6041 01a2 754A     		ldr	r2, .L428+128
 6042 01a4 9342     		cmp	r3, r2
 6043 01a6 24D0     		beq	.L413
1624:display.c     ****         			(window != screen143) &&                      // Dont turn off in Technician Menu - Nett
 6044              		.loc 1 1624 0
 6045 01a8 744A     		ldr	r2, .L428+132
 6046 01aa 9342     		cmp	r3, r2
 6047 01ac 21D0     		beq	.L413
1625:display.c     ****         			(window != screen144) &&                      // Dont turn off in Technician Menu - Diam
 6048              		.loc 1 1625 0
 6049 01ae 744A     		ldr	r2, .L428+136
 6050 01b0 9342     		cmp	r3, r2
 6051 01b2 1ED0     		beq	.L413
1626:display.c     ****         			(window != screen145) &&                      // Dont turn off in Technician Menu - Dens
 6052              		.loc 1 1626 0
 6053 01b4 734A     		ldr	r2, .L428+140
 6054 01b6 9342     		cmp	r3, r2
 6055 01b8 1BD0     		beq	.L413
1627:display.c     ****         			(window != screen146) &&                      // Dont turn off in Technician Menu - Kniv
 6056              		.loc 1 1627 0
 6057 01ba 734A     		ldr	r2, .L428+144
 6058 01bc 9342     		cmp	r3, r2
 6059 01be 18D0     		beq	.L413
1628:display.c     ****         			(window != screen147) &&                      // Dont turn off in Technician Menu - Rese
 6060              		.loc 1 1628 0
 6061 01c0 724A     		ldr	r2, .L428+148
 6062 01c2 9342     		cmp	r3, r2
 6063 01c4 15D0     		beq	.L413
1629:display.c     ****         			(window != screen148) &&                      // Dont turn off in Technician Menu - Form
 6064              		.loc 1 1629 0
 6065 01c6 724A     		ldr	r2, .L428+152
 6066 01c8 9342     		cmp	r3, r2
 6067 01ca 12D0     		beq	.L413
1630:display.c     ****         			(window != screen151) )                       // Dont turn off in Diagnostics - Outputs
1631:display.c     ****         	{
1632:display.c     ****         		if( key & SW_OL )
 6068              		.loc 1 1632 0
 6069 01cc 524B     		ldr	r3, .L428+32
 6070 01ce 1B68     		ldr	r3, [r3]
 6071 01d0 9805     		lsl	r0, r3, #22
 6072 01d2 0BD5     		bpl	.L414
1633:display.c     ****         		{
1634:display.c     ****         			offtime++;
 6073              		.loc 1 1634 0
 6074 01d4 6F4A     		ldr	r2, .L428+156
 6075 01d6 1378     		ldrb	r3, [r2]
 6076 01d8 0133     		add	r3, r3, #1
 6077 01da 1B06     		lsl	r3, r3, #24
 6078 01dc 1B0E     		lsr	r3, r3, #24
 6079              	.LVL681:
 6080 01de 1370     		strb	r3, [r2]
1635:display.c     **** 
1636:display.c     ****         			if( offtime == 8 )
 6081              		.loc 1 1636 0
 6082 01e0 082B     		cmp	r3, #8
 6083 01e2 06D1     		bne	.L413
1637:display.c     ****         			{
1638:display.c     ****         				window = screen99;
 6084              		.loc 1 1638 0
 6085 01e4 6C4A     		ldr	r2, .L428+160
 6086 01e6 524B     		ldr	r3, .L428+56
 6087              	.LVL682:
 6088 01e8 1A60     		str	r2, [r3]
 6089 01ea 02E0     		b	.L413
 6090              	.L414:
1639:display.c     ****         			}
1640:display.c     ****         		}
1641:display.c     ****         		else
1642:display.c     ****         		{
1643:display.c     ****         			offtime = 0;
 6091              		.loc 1 1643 0
 6092 01ec 0022     		mov	r2, #0
 6093 01ee 694B     		ldr	r3, .L428+156
 6094 01f0 1A70     		strb	r2, [r3]
 6095              	.LVL683:
 6096              	.L413:
1644:display.c     ****         		}
1645:display.c     ****         	}
1646:display.c     **** 
1647:display.c     ****         	if( !key )
 6097              		.loc 1 1647 0
 6098 01f2 494B     		ldr	r3, .L428+32
 6099              	.LVL684:
 6100 01f4 1B68     		ldr	r3, [r3]
 6101 01f6 002B     		cmp	r3, #0
 6102 01f8 00D0     		beq	.LCB6368
 6103 01fa DDE0     		b	.L415	@long jump
 6104              	.LCB6368:
1648:display.c     ****         	{
1649:display.c     ****         		if( reverttime < 250 )
 6105              		.loc 1 1649 0
 6106 01fc 674B     		ldr	r3, .L428+164
 6107 01fe 1B78     		ldrb	r3, [r3]
 6108 0200 F92B     		cmp	r3, #249
 6109 0202 02D8     		bhi	.L416
1650:display.c     ****         		{
1651:display.c     ****         			reverttime++;
 6110              		.loc 1 1651 0
 6111 0204 0133     		add	r3, r3, #1
 6112 0206 654A     		ldr	r2, .L428+164
 6113 0208 1370     		strb	r3, [r2]
 6114              	.L416:
1652:display.c     ****         		}
1653:display.c     **** 
1654:display.c     ****         		if( reverttime >= 200 )
 6115              		.loc 1 1654 0
 6116 020a 644B     		ldr	r3, .L428+164
 6117 020c 1B78     		ldrb	r3, [r3]
 6118 020e C72B     		cmp	r3, #199
 6119 0210 60D9     		bls	.L417
1655:display.c     ****         		{
1656:display.c     ****         			if( (window != mainscreen) &&  // Not Main/Home Screen
 6120              		.loc 1 1656 0
 6121 0212 474B     		ldr	r3, .L428+56
 6122 0214 1B68     		ldr	r3, [r3]
 6123 0216 484A     		ldr	r2, .L428+64
 6124 0218 9342     		cmp	r3, r2
 6125 021a 4CD0     		beq	.L418
 6126              		.loc 1 1656 0 is_stmt 0 discriminator 1
 6127 021c 4D4A     		ldr	r2, .L428+92
 6128 021e 9342     		cmp	r3, r2
 6129 0220 00D1     		bne	.LCB6389
 6130 0222 CCE0     		b	.L419	@long jump
 6131              	.LCB6389:
1657:display.c     **** #if 0 // Restoring automatic return to Main screen after period of inactivity
1658:display.c     ****         					(window != screen100) &&   // Not in Machine Menu
1659:display.c     ****         					(window != screen110) &&   // Not in Bale Setup Menu
1660:display.c     ****         					(window != screen111) &&   // Not in Machine Setup Menu
1661:display.c     ****         					(window != screen112) &&   // Not in Bale Count Menu
1662:display.c     ****         					(window != screen113) &&   // Not in Operator Setup Menu
1663:display.c     **** #endif
1664:display.c     ****         					(window != screen120)  &&  // Not in Lube Count Reset Screen
 6132              		.loc 1 1664 0 is_stmt 1
 6133 0224 4C4A     		ldr	r2, .L428+96
 6134 0226 9342     		cmp	r3, r2
 6135 0228 00D1     		bne	.LCB6392
 6136 022a C8E0     		b	.L419	@long jump
 6137              	.LCB6392:
1665:display.c     ****         					(window != screen121)  &&  // Not in Bale Count Reset Screen
 6138              		.loc 1 1665 0
 6139 022c 4B4A     		ldr	r2, .L428+100
 6140 022e 9342     		cmp	r3, r2
 6141 0230 00D1     		bne	.LCB6395
 6142 0232 C4E0     		b	.L419	@long jump
 6143              	.LCB6395:
1666:display.c     ****         					(window != screen124)  &&  // Not in Fill Pot Zero Reset Screen (AKA Bale Shape Indica
 6144              		.loc 1 1666 0
 6145 0234 4A4A     		ldr	r2, .L428+104
 6146 0236 9342     		cmp	r3, r2
 6147 0238 00D1     		bne	.LCB6398
 6148 023a C0E0     		b	.L419	@long jump
 6149              	.LCB6398:
1667:display.c     ****         					(window != screen125)  &&  // Not in Net Metres Reset Screen
 6150              		.loc 1 1667 0
 6151 023c 4C4A     		ldr	r2, .L428+120
 6152 023e 9342     		cmp	r3, r2
 6153 0240 00D1     		bne	.LCB6401
 6154 0242 BCE0     		b	.L419	@long jump
 6155              	.LCB6401:
1668:display.c     **** #if 0 // Restoring automatic return to Main screen after period of inactivity
1669:display.c     ****         					(window != screen131)  &&  // Not in Brightness & Contrast Adjust Menu
1670:display.c     ****         					(window != screen132)  &&  // Not in Time & Date Adjust Menu
1671:display.c     ****         					(window != screen140)  &&  // Not Technician Menu - PIN entry
1672:display.c     **** #endif
1673:display.c     ****         					(window != screen141)  &&  // Not Technician Menu
 6156              		.loc 1 1673 0
 6157 0244 4B4A     		ldr	r2, .L428+124
 6158 0246 9342     		cmp	r3, r2
 6159 0248 00D1     		bne	.LCB6404
 6160 024a B8E0     		b	.L419	@long jump
 6161              	.LCB6404:
1674:display.c     ****         					(window != screen142)  &&  // Not Technician Menu - Baler Full
 6162              		.loc 1 1674 0
 6163 024c 4A4A     		ldr	r2, .L428+128
 6164 024e 9342     		cmp	r3, r2
 6165 0250 00D1     		bne	.LCB6407
 6166 0252 B4E0     		b	.L419	@long jump
 6167              	.LCB6407:
1675:display.c     ****         					(window != screen143)  &&  // Not Technician Menu - Netting Setup
 6168              		.loc 1 1675 0
 6169 0254 494A     		ldr	r2, .L428+132
 6170 0256 9342     		cmp	r3, r2
 6171 0258 00D1     		bne	.LCB6410
 6172 025a B0E0     		b	.L419	@long jump
 6173              	.LCB6410:
1676:display.c     ****         					(window != screen144)  &&  // Not Technician Menu - Diameter Setup
 6174              		.loc 1 1676 0
 6175 025c 484A     		ldr	r2, .L428+136
 6176 025e 9342     		cmp	r3, r2
 6177 0260 00D1     		bne	.LCB6413
 6178 0262 ACE0     		b	.L419	@long jump
 6179              	.LCB6413:
1677:display.c     ****         					(window != screen145)  &&  // Not Technician Menu - Density Setup
 6180              		.loc 1 1677 0
 6181 0264 474A     		ldr	r2, .L428+140
 6182 0266 9342     		cmp	r3, r2
 6183 0268 00D1     		bne	.LCB6416
 6184 026a A8E0     		b	.L419	@long jump
 6185              	.LCB6416:
1678:display.c     ****         					(window != screen146)  &&  // Not Technician Menu - Knives Setup
 6186              		.loc 1 1678 0
 6187 026c 464A     		ldr	r2, .L428+144
 6188 026e 9342     		cmp	r3, r2
 6189 0270 00D1     		bne	.LCB6419
 6190 0272 A4E0     		b	.L419	@long jump
 6191              	.LCB6419:
1679:display.c     ****         					(window != screen147)  &&  // Not Technician Menu - Reset Defaults
 6192              		.loc 1 1679 0
 6193 0274 454A     		ldr	r2, .L428+148
 6194 0276 9342     		cmp	r3, r2
 6195 0278 00D1     		bne	.LCB6422
 6196 027a A0E0     		b	.L419	@long jump
 6197              	.LCB6422:
1680:display.c     ****         					(window != screen148)  &&  // Not Technician Menu - Formation 2
 6198              		.loc 1 1680 0
 6199 027c 484A     		ldr	r2, .L428+168
 6200 027e 9342     		cmp	r3, r2
 6201 0280 00D1     		bne	.LCB6425
 6202 0282 9CE0     		b	.L419	@long jump
 6203              	.LCB6425:
1681:display.c     ****         					(window != screen150)  &&  // Not Diagnostics - Digital Inputs
 6204              		.loc 1 1681 0
 6205 0284 474A     		ldr	r2, .L428+172
 6206 0286 9342     		cmp	r3, r2
 6207 0288 00D1     		bne	.LCB6428
 6208 028a 98E0     		b	.L419	@long jump
 6209              	.LCB6428:
1682:display.c     ****         					(window != screen152)  &&  // Not Diagnostics - Analogue Inputs
 6210              		.loc 1 1682 0
 6211 028c 404A     		ldr	r2, .L428+152
 6212 028e 9342     		cmp	r3, r2
 6213 0290 00D1     		bne	.LCB6431
 6214 0292 94E0     		b	.L419	@long jump
 6215              	.LCB6431:
1683:display.c     ****         					(window != screen151)    ) // Not Diagnostics - Outputs
1684:display.c     ****         			{
1685:display.c     ****         				window = mainscreen; // Main/Home Screen
 6216              		.loc 1 1685 0
 6217 0294 284A     		ldr	r2, .L428+64
 6218 0296 264B     		ldr	r3, .L428+56
 6219 0298 1A60     		str	r2, [r3]
1686:display.c     ****         				nextwindow = 0;
 6220              		.loc 1 1686 0
 6221 029a 0023     		mov	r3, #0
 6222 029c 424A     		ldr	r2, .L428+176
 6223 029e 1370     		strb	r3, [r2]
1687:display.c     ****         				editing = 0;
 6224              		.loc 1 1687 0
 6225 02a0 424A     		ldr	r2, .L428+180
 6226 02a2 1370     		strb	r3, [r2]
1688:display.c     ****         				leaf = 0;
 6227              		.loc 1 1688 0
 6228 02a4 424A     		ldr	r2, .L428+184
 6229 02a6 1370     		strb	r3, [r2]
1689:display.c     ****         				cont_beep = 1;
 6230              		.loc 1 1689 0
 6231 02a8 0122     		mov	r2, #1
 6232 02aa 424B     		ldr	r3, .L428+188
 6233 02ac 1A70     		strb	r2, [r3]
1690:display.c     ****         				buzz_length = BACK_TO_MAIN_SCR_BEEP;
 6234              		.loc 1 1690 0
 6235 02ae 6422     		mov	r2, #100
 6236 02b0 1C4B     		ldr	r3, .L428+44
 6237 02b2 1A60     		str	r2, [r3]
 6238 02b4 83E0     		b	.L419
 6239              	.L418:
1691:display.c     ****         			}
1692:display.c     ****         			else if( (window == mainscreen) && SecondScreen ) // Main/Home Screen 2
 6240              		.loc 1 1692 0 discriminator 1
 6241 02b6 214B     		ldr	r3, .L428+68
 6242 02b8 1B78     		ldrb	r3, [r3]
 6243 02ba 002B     		cmp	r3, #0
 6244 02bc 00D1     		bne	.LCB6455
 6245 02be 7EE0     		b	.L419	@long jump
 6246              	.LCB6455:
1693:display.c     ****         			{
1694:display.c     ****         				SecondScreen = 0; // Return to Screen 1
 6247              		.loc 1 1694 0
 6248 02c0 0022     		mov	r2, #0
 6249 02c2 1E4B     		ldr	r3, .L428+68
 6250 02c4 1A70     		strb	r2, [r3]
1695:display.c     ****         				cont_beep = 1;
 6251              		.loc 1 1695 0
 6252 02c6 0122     		mov	r2, #1
 6253 02c8 3A4B     		ldr	r3, .L428+188
 6254 02ca 1A70     		strb	r2, [r3]
1696:display.c     ****         				buzz_length = BACK_TO_MAIN_SCR_BEEP;
 6255              		.loc 1 1696 0
 6256 02cc 6422     		mov	r2, #100
 6257 02ce 154B     		ldr	r3, .L428+44
 6258 02d0 1A60     		str	r2, [r3]
 6259 02d2 74E0     		b	.L419
 6260              	.L417:
1697:display.c     ****         			}
1698:display.c     ****         		}
1699:display.c     ****         		else if( reverttime >= 20 )
 6261              		.loc 1 1699 0
 6262 02d4 132B     		cmp	r3, #19
 6263 02d6 72D9     		bls	.L419
1700:display.c     ****         		{
1701:display.c     ****         			if( window == screen99 )
 6264              		.loc 1 1701 0
 6265 02d8 154B     		ldr	r3, .L428+56
 6266 02da 1A68     		ldr	r2, [r3]
 6267 02dc 2E4B     		ldr	r3, .L428+160
 6268 02de 9A42     		cmp	r2, r3
 6269 02e0 6DD1     		bne	.L419
1702:display.c     ****         			{
1703:display.c     ****         				window = mainscreen; // Main/Home Screen
 6270              		.loc 1 1703 0
 6271 02e2 154A     		ldr	r2, .L428+64
 6272 02e4 124B     		ldr	r3, .L428+56
 6273 02e6 1A60     		str	r2, [r3]
1704:display.c     ****         				nextwindow = 0;
 6274              		.loc 1 1704 0
 6275 02e8 0023     		mov	r3, #0
 6276 02ea 2F4A     		ldr	r2, .L428+176
 6277 02ec 1370     		strb	r3, [r2]
1705:display.c     ****         				editing = 0;
 6278              		.loc 1 1705 0
 6279 02ee 2F4A     		ldr	r2, .L428+180
 6280 02f0 1370     		strb	r3, [r2]
1706:display.c     ****         				leaf = 0;
 6281              		.loc 1 1706 0
 6282 02f2 2F4A     		ldr	r2, .L428+184
 6283 02f4 1370     		strb	r3, [r2]
 6284 02f6 62E0     		b	.L419
 6285              	.L429:
 6286              		.align	3
 6287              	.L428:
 6288 02f8 2B12AF22 		.word	581898795
 6289 02fc F12AA23F 		.word	1067592433
 6290 0300 00000000 		.word	0
 6291 0304 0000F03F 		.word	1072693248
 6292 0308 00000000 		.word	pRun
 6293 030c 00210011 		.word	285221120
 6294 0310 40FDFFFF 		.word	-704
 6295 0314 00F6FFFF 		.word	-2560
 6296 0318 00000000 		.word	key
 6297 031c 0080FDFF 		.word	-163840
 6298 0320 00000000 		.word	SupplyVolts
 6299 0324 00000000 		.word	buzz_length
 6300 0328 00000000 		.word	looptime
 6301 032c 00000000 		.word	swrel
 6302 0330 00000000 		.word	window
 6303 0334 00000000 		.word	half_second
 6304 0338 00000000 		.word	mainscreen
 6305 033c 00000000 		.word	SecondScreen
 6306 0340 00000000 		.word	screen100
 6307 0344 00000000 		.word	screen110
 6308 0348 00000000 		.word	screen111
 6309 034c 00000000 		.word	screen112
 6310 0350 00000000 		.word	screen113
 6311 0354 00000000 		.word	screen120
 6312 0358 00000000 		.word	screen121
 6313 035c 00000000 		.word	screen124
 6314 0360 00000000 		.word	screen125
 6315 0364 00000000 		.word	screen131
 6316 0368 00000000 		.word	screen132
 6317 036c 00000000 		.word	screen140
 6318 0370 00000000 		.word	screen141
 6319 0374 00000000 		.word	screen142
 6320 0378 00000000 		.word	screen143
 6321 037c 00000000 		.word	screen144
 6322 0380 00000000 		.word	screen145
 6323 0384 00000000 		.word	screen146
 6324 0388 00000000 		.word	screen147
 6325 038c 00000000 		.word	screen148
 6326 0390 00000000 		.word	screen151
 6327 0394 00000000 		.word	offtime
 6328 0398 00000000 		.word	screen99
 6329 039c 00000000 		.word	reverttime
 6330 03a0 00000000 		.word	screen150
 6331 03a4 00000000 		.word	screen152
 6332 03a8 00000000 		.word	nextwindow
 6333 03ac 00000000 		.word	editing
 6334 03b0 00000000 		.word	leaf
 6335 03b4 00000000 		.word	cont_beep
 6336              	.L415:
1707:display.c     ****         			}
1708:display.c     ****         		}
1709:display.c     ****         	}
1710:display.c     ****         	else if( key )
1711:display.c     ****         	{
1712:display.c     ****         		reverttime = 0;
 6337              		.loc 1 1712 0
 6338 03b8 0022     		mov	r2, #0
 6339 03ba 3F4B     		ldr	r3, .L430
 6340 03bc 1A70     		strb	r2, [r3]
 6341              	.L419:
1713:display.c     ****         	}
1714:display.c     **** 
1715:display.c     ****         	if( deftime )
 6342              		.loc 1 1715 0
 6343 03be 3F4B     		ldr	r3, .L430+4
 6344 03c0 1B78     		ldrb	r3, [r3]
 6345 03c2 002B     		cmp	r3, #0
 6346 03c4 08D0     		beq	.L420
1716:display.c     ****         	{
1717:display.c     ****         		deftime--;
 6347              		.loc 1 1717 0
 6348 03c6 013B     		sub	r3, r3, #1
 6349 03c8 1B06     		lsl	r3, r3, #24
 6350 03ca 1B0E     		lsr	r3, r3, #24
 6351              	.LVL685:
 6352 03cc 3B4A     		ldr	r2, .L430+4
 6353              	.LVL686:
 6354 03ce 1370     		strb	r3, [r2]
1718:display.c     ****         		if( deftime == 0 )
 6355              		.loc 1 1718 0
 6356 03d0 02D1     		bne	.L420
1719:display.c     ****         		{
1720:display.c     ****         			window = mainscreen; // Main/Home Screen
 6357              		.loc 1 1720 0
 6358 03d2 3B4A     		ldr	r2, .L430+8
 6359 03d4 3B4B     		ldr	r3, .L430+12
 6360              	.LVL687:
 6361 03d6 1A60     		str	r2, [r3]
 6362              	.LVL688:
 6363              	.L420:
1721:display.c     ****         		}
1722:display.c     ****         	}
1723:display.c     **** 
1724:display.c     ****         	if( (window != screen00) && (window != screen150) && (window != screen151) && (window != s
 6364              		.loc 1 1724 0
 6365 03d8 3A4B     		ldr	r3, .L430+12
 6366              	.LVL689:
 6367 03da 1B68     		ldr	r3, [r3]
 6368 03dc 3A4A     		ldr	r2, .L430+16
 6369 03de 9342     		cmp	r3, r2
 6370 03e0 0ED0     		beq	.L421
 6371              		.loc 1 1724 0 is_stmt 0 discriminator 1
 6372 03e2 3A4A     		ldr	r2, .L430+20
 6373 03e4 9342     		cmp	r3, r2
 6374 03e6 0BD0     		beq	.L421
 6375 03e8 394A     		ldr	r2, .L430+24
 6376 03ea 9342     		cmp	r3, r2
 6377 03ec 08D0     		beq	.L421
 6378 03ee 394A     		ldr	r2, .L430+28
 6379 03f0 9342     		cmp	r3, r2
 6380 03f2 05D0     		beq	.L421
1725:display.c     ****         	{
1726:display.c     ****         		Inputs();
 6381              		.loc 1 1726 0 is_stmt 1
 6382 03f4 FFF7FEFF 		bl	Inputs
 6383              	.LVL690:
1727:display.c     **** 
1728:display.c     **** #ifndef WINDOWS
1729:display.c     ****         		CheckAlarms();
 6384              		.loc 1 1729 0
 6385 03f8 FFF7FEFF 		bl	CheckAlarms
 6386              	.LVL691:
1730:display.c     **** #endif
1731:display.c     **** 
1732:display.c     ****         		Sequence();
 6387              		.loc 1 1732 0
 6388 03fc FFF7FEFF 		bl	Sequence
 6389              	.LVL692:
 6390              	.L421:
1733:display.c     **** 
1734:display.c     ****         	}
1735:display.c     **** 
1736:display.c     ****         	if( escape )
 6391              		.loc 1 1736 0
 6392 0400 354B     		ldr	r3, .L430+32
 6393 0402 1B78     		ldrb	r3, [r3]
 6394 0404 002B     		cmp	r3, #0
 6395 0406 1CD0     		beq	.L422
1737:display.c     ****         	{
1738:display.c     ****         		escape = 0;
 6396              		.loc 1 1738 0
 6397 0408 0022     		mov	r2, #0
 6398 040a 334B     		ldr	r3, .L430+32
 6399 040c 1A70     		strb	r2, [r3]
1739:display.c     ****         		if( windowdepth )
 6400              		.loc 1 1739 0
 6401 040e 334B     		ldr	r3, .L430+36
 6402 0410 1B78     		ldrb	r3, [r3]
 6403 0412 002B     		cmp	r3, #0
 6404 0414 0ED0     		beq	.L423
1740:display.c     ****         		{
1741:display.c     ****         			windowdepth--;
 6405              		.loc 1 1741 0
 6406 0416 013B     		sub	r3, r3, #1
 6407 0418 1B06     		lsl	r3, r3, #24
 6408 041a 1B0E     		lsr	r3, r3, #24
 6409              	.LVL693:
 6410 041c 2F4A     		ldr	r2, .L430+36
 6411              	.LVL694:
 6412 041e 1370     		strb	r3, [r2]
1742:display.c     ****         			window = PreviousWindow[windowdepth].window;
 6413              		.loc 1 1742 0
 6414 0420 2F4A     		ldr	r2, .L430+40
 6415 0422 DB00     		lsl	r3, r3, #3
 6416              	.LVL695:
 6417 0424 2749     		ldr	r1, .L430+12
 6418 0426 9858     		ldr	r0, [r3, r2]
 6419 0428 0860     		str	r0, [r1]
1743:display.c     ****         			selection = PreviousWindow[windowdepth].selection;
 6420              		.loc 1 1743 0
 6421 042a D318     		add	r3, r2, r3
 6422 042c 1A79     		ldrb	r2, [r3, #4]
 6423 042e 2D4B     		ldr	r3, .L430+44
 6424 0430 1A70     		strb	r2, [r3]
 6425 0432 24E0     		b	.L424
 6426              	.L423:
1744:display.c     ****         		}
1745:display.c     ****         		else
1746:display.c     ****         		{
1747:display.c     ****         			window = mainscreen; // Main/Home Screen
 6427              		.loc 1 1747 0
 6428 0434 224A     		ldr	r2, .L430+8
 6429 0436 234B     		ldr	r3, .L430+12
 6430 0438 1A60     		str	r2, [r3]
1748:display.c     ****         			selection = 0;
 6431              		.loc 1 1748 0
 6432 043a 0022     		mov	r2, #0
 6433 043c 294B     		ldr	r3, .L430+44
 6434 043e 1A70     		strb	r2, [r3]
 6435 0440 1DE0     		b	.L424
 6436              	.L422:
1749:display.c     ****         		}
1750:display.c     ****         	}
1751:display.c     ****         	// window has changed
1752:display.c     ****         	else if( window != old_window )
 6437              		.loc 1 1752 0
 6438 0442 204B     		ldr	r3, .L430+12
 6439 0444 1B68     		ldr	r3, [r3]
 6440 0446 5345     		cmp	r3, sl
 6441 0448 2ED0     		beq	.L425
1753:display.c     ****         	{
1754:display.c     ****         		// save previous window if leaf clear & nextwindow is 0 or NEXTWINDOW_ESCAPE
1755:display.c     ****         		if( !leaf && (nextwindow != NEXTWINDOW_NOESCAPE) )
 6442              		.loc 1 1755 0
 6443 044a 274B     		ldr	r3, .L430+48
 6444 044c 1B78     		ldrb	r3, [r3]
 6445 044e 002B     		cmp	r3, #0
 6446 0450 12D1     		bne	.L426
 6447              		.loc 1 1755 0 is_stmt 0 discriminator 1
 6448 0452 264B     		ldr	r3, .L430+52
 6449 0454 1B78     		ldrb	r3, [r3]
 6450 0456 012B     		cmp	r3, #1
 6451 0458 0ED0     		beq	.L426
1756:display.c     ****         		{
1757:display.c     ****         			PreviousWindow[windowdepth].window = old_window;
 6452              		.loc 1 1757 0 is_stmt 1
 6453 045a 204B     		ldr	r3, .L430+36
 6454 045c 1B78     		ldrb	r3, [r3]
 6455 045e 2049     		ldr	r1, .L430+40
 6456 0460 DA00     		lsl	r2, r3, #3
 6457 0462 5046     		mov	r0, sl
 6458 0464 5050     		str	r0, [r2, r1]
1758:display.c     ****         			PreviousWindow[windowdepth].selection = selection;
 6459              		.loc 1 1758 0
 6460 0466 8A18     		add	r2, r1, r2
 6461 0468 1E49     		ldr	r1, .L430+44
 6462 046a 0978     		ldrb	r1, [r1]
 6463 046c 1171     		strb	r1, [r2, #4]
1759:display.c     ****         			if( windowdepth < (MAX_WINDOWDEPTH - 1) )
 6464              		.loc 1 1759 0
 6465 046e 0E2B     		cmp	r3, #14
 6466 0470 02D8     		bhi	.L426
 6467              	.LVL696:
1760:display.c     ****         			{
1761:display.c     ****         				windowdepth++;
 6468              		.loc 1 1761 0
 6469 0472 0133     		add	r3, r3, #1
 6470 0474 194A     		ldr	r2, .L430+36
 6471 0476 1370     		strb	r3, [r2]
 6472              	.LVL697:
 6473              	.L426:
1762:display.c     ****         			}
1763:display.c     ****         		}
1764:display.c     ****         		selection = 0;
 6474              		.loc 1 1764 0
 6475 0478 0022     		mov	r2, #0
 6476 047a 1A4B     		ldr	r3, .L430+44
 6477 047c 1A70     		strb	r2, [r3]
 6478              	.L424:
1765:display.c     ****         	}
1766:display.c     **** 
1767:display.c     ****         	if( window != old_window )
 6479              		.loc 1 1767 0
 6480 047e 114B     		ldr	r3, .L430+12
 6481 0480 1A68     		ldr	r2, [r3]
 6482 0482 5245     		cmp	r2, sl
 6483 0484 10D0     		beq	.L425
1768:display.c     ****         	{
1769:display.c     ****         		startup = 0;
 6484              		.loc 1 1769 0
 6485 0486 0023     		mov	r3, #0
 6486 0488 1949     		ldr	r1, .L430+56
 6487 048a 0B70     		strb	r3, [r1]
1770:display.c     ****         		nextwindow = 0;
 6488              		.loc 1 1770 0
 6489 048c 1749     		ldr	r1, .L430+52
 6490 048e 0B70     		strb	r3, [r1]
1771:display.c     ****         		editing = 0;
 6491              		.loc 1 1771 0
 6492 0490 1849     		ldr	r1, .L430+60
 6493 0492 0B70     		strb	r3, [r1]
1772:display.c     ****         		leaf = 0;
 6494              		.loc 1 1772 0
 6495 0494 1449     		ldr	r1, .L430+48
 6496 0496 0B70     		strb	r3, [r1]
1773:display.c     **** 
1774:display.c     ****         		key &= ~(SW_NEW | SW_REP);
 6497              		.loc 1 1774 0
 6498 0498 174B     		ldr	r3, .L430+64
 6499 049a 1868     		ldr	r0, [r3]
 6500 049c 8100     		lsl	r1, r0, #2
 6501 049e 8908     		lsr	r1, r1, #2
 6502 04a0 1960     		str	r1, [r3]
1775:display.c     ****         		window( 0 ); // no key action
 6503              		.loc 1 1775 0
 6504 04a2 0020     		mov	r0, #0
 6505 04a4 00F030F8 		bl	.L433
 6506              	.LVL698:
 6507              	.L425:
1776:display.c     ****         	}
1777:display.c     **** 
1778:display.c     **** #ifndef WINDOWS  
1779:display.c     **** 
1780:display.c     ****         	WriteDisplay( adm );
 6508              		.loc 1 1780 0
 6509 04a8 1448     		ldr	r0, .L430+68
 6510 04aa FFF7FEFF 		bl	WriteDisplay
 6511              	.LVL699:
1781:display.c     **** 
1782:display.c     ****         	// restart watchdog counter
1783:display.c     ****         	AT91C_BASE_WDTC->WDTC_WDCR = WATCHDOG_KEY | AT91C_WDTC_WDRSTT;
 6512              		.loc 1 1783 0
 6513 04ae 144A     		ldr	r2, .L430+72
 6514 04b0 144B     		ldr	r3, .L430+76
 6515 04b2 1A60     		str	r2, [r3]
1784:display.c     **** 
1785:display.c     ****         } // end of while( 1 )
 6516              		.loc 1 1785 0
 6517 04b4 C7E5     		b	.L427
 6518              	.L431:
 6519 04b6 C046     		.align	2
 6520              	.L430:
 6521 04b8 00000000 		.word	reverttime
 6522 04bc 00000000 		.word	deftime
 6523 04c0 00000000 		.word	mainscreen
 6524 04c4 00000000 		.word	window
 6525 04c8 00000000 		.word	screen00
 6526 04cc 00000000 		.word	screen150
 6527 04d0 00000000 		.word	screen151
 6528 04d4 00000000 		.word	screen152
 6529 04d8 00000000 		.word	escape
 6530 04dc 00000000 		.word	windowdepth
 6531 04e0 00000000 		.word	PreviousWindow
 6532 04e4 00000000 		.word	selection
 6533 04e8 00000000 		.word	leaf
 6534 04ec 00000000 		.word	nextwindow
 6535 04f0 00000000 		.word	startup
 6536 04f4 00000000 		.word	editing
 6537 04f8 00000000 		.word	key
 6538 04fc 00000000 		.word	adm
 6539 0500 010000A5 		.word	-1526726655
 6540 0504 40FDFFFF 		.word	-704
 6541              	.L433:
 6542 0508 1047     		bx	r2
 6543              	.L432:
 6544 050a 5047     		bx	sl
 6545              		.cfi_endproc
 6546              	.LFE391:
 6548 050c C046C046 		.section	.text.vStartDisplayTask,"ax",%progbits
 6549              		.align	2
 6550              		.global	vStartDisplayTask
 6551              		.code	16
 6552              		.thumb_func
 6554              	vStartDisplayTask:
 6555              	.LFB392:
1786:display.c     **** #else
1787:display.c     **** 
1788:display.c     ****         WriteToScreen();
1789:display.c     **** 
1790:display.c     **** #endif 
1791:display.c     **** 
1792:display.c     ****     }
1793:display.c     **** // -----------------------------------------------------------
1794:display.c     **** 
1795:display.c     **** 
1796:display.c     **** #ifndef WINDOWS
1797:display.c     **** 
1798:display.c     **** // -----------------------------------------------------------
1799:display.c     **** // Function Name       : vStartDisplayTask
1800:display.c     **** // -----------------------------------------------------------
1801:display.c     **** void vStartDisplayTask( unsigned portBASE_TYPE uxPriority )
1802:display.c     **** {
 6556              		.loc 1 1802 0
 6557              		.cfi_startproc
 6558              	.LVL700:
 6559 0000 00B5     		push	{lr}
 6560              	.LCFI36:
 6561              		.cfi_def_cfa_offset 4
 6562              		.cfi_offset 14, -4
 6563 0002 85B0     		sub	sp, sp, #20
 6564              	.LCFI37:
 6565              		.cfi_def_cfa_offset 24
1803:display.c     **** 
1804:display.c     **** 	/* Spawn the task. */
1805:display.c     **** 	xTaskCreate( vDisplayTask, "DISPLAY", configDISPLAY_STACK_SIZE, (void *)NULL, uxPriority, (xTaskHa
 6566              		.loc 1 1805 0
 6567 0004 0090     		str	r0, [sp]
 6568 0006 0023     		mov	r3, #0
 6569 0008 0193     		str	r3, [sp, #4]
 6570 000a 0293     		str	r3, [sp, #8]
 6571 000c 0393     		str	r3, [sp, #12]
 6572 000e 0448     		ldr	r0, .L435
 6573              	.LVL701:
 6574 0010 0449     		ldr	r1, .L435+4
 6575 0012 AF22     		mov	r2, #175
 6576 0014 9200     		lsl	r2, r2, #2
 6577 0016 FFF7FEFF 		bl	xTaskGenericCreate
 6578              	.LVL702:
1806:display.c     **** }
 6579              		.loc 1 1806 0
 6580 001a 05B0     		add	sp, sp, #20
 6581              		@ sp needed for prologue
 6582 001c 01BC     		pop	{r0}
 6583 001e 0047     		bx	r0
 6584              	.L436:
 6585              		.align	2
 6586              	.L435:
 6587 0020 00000000 		.word	vDisplayTask
 6588 0024 10000000 		.word	.LC90
 6589              		.cfi_endproc
 6590              	.LFE392:
 6592              		.comm	POWERtaskhandle,4,4
 6593              		.comm	TWItaskhandle,4,4
 6594              		.comm	SetTime,4,4
 6595              		.section	.bss.dstring.9436,"aw",%nobits
 6596              		.align	2
 6597              		.set	.LANCHOR0,. + 0
 6600              	dstring.9436:
 6601 0000 00000000 		.space	32
 6601      00000000 
 6601      00000000 
 6601      00000000 
 6601      00000000 
 6602              		.section	.rodata.str1.4,"aMS",%progbits,1
 6603              		.align	2
 6604              	.LC20:
 6605 0000 252B2E2A 		.ascii	"%+.*f\000"
 6605      6600
 6606 0006 0000     		.space	2
 6607              	.LC22:
 6608 0008 252E2A66 		.ascii	"%.*f\000"
 6608      00
 6609 000d 000000   		.space	3
 6610              	.LC90:
 6611 0010 44495350 		.ascii	"DISPLAY\000"
 6611      4C415900 
 6612              		.section	.bss.len.9507,"aw",%nobits
 6613              		.set	.LANCHOR3,. + 0
 6616              	len.9507:
 6617 0000 00       		.space	1
 6618              		.section	.bss.pos.9435,"aw",%nobits
 6619              		.set	.LANCHOR1,. + 0
 6622              	pos.9435:
 6623 0000 00       		.space	1
 6624              		.section	.bss.sdata.9506,"aw",%nobits
 6625              		.align	2
 6626              		.set	.LANCHOR2,. + 0
 6629              	sdata.9506:
 6630 0000 00000000 		.space	4
 6631              		.text
 6632              	.Letext0:
 6633              		.file 3 "./include/AT91SAM7A3.h"
 6634              		.file 4 "c:\\gnuarm-471_eabi\\bin\\../lib/gcc/arm-none-eabi/4.7.1/include/stddef.h"
 6635              		.file 5 "./include/projdefs.h"
 6636              		.file 6 "./portmacro.h"
 6637              		.file 7 "./include/task.h"
 6638              		.file 8 "./include/queue.h"
 6639              		.file 9 "./include/semphr.h"
 6640              		.file 10 "Board.h"
 6641              		.file 11 "c:/gnuarm-471_eabi/lib/gcc/../../arm-none-eabi/sys-include/string.h"
 6642              		.file 12 "c:/gnuarm-471_eabi/lib/gcc/../../arm-none-eabi/sys-include/stdio.h"
 6643              		.file 13 "c:/gnuarm-471_eabi/lib/gcc/../../arm-none-eabi/sys-include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 display.c
  C:\Temp\ccKryDei.s:18     .text.setPixel:00000000 $t
  C:\Temp\ccKryDei.s:23     .text.setPixel:00000000 setPixel
  C:\Temp\ccKryDei.s:86     .text.setPixel:0000003c $d
  C:\Temp\ccKryDei.s:91     .text.circlePoints:00000000 $t
  C:\Temp\ccKryDei.s:96     .text.circlePoints:00000000 circlePoints
  C:\Temp\ccKryDei.s:330    .text.circleMidpoint:00000000 $t
  C:\Temp\ccKryDei.s:335    .text.circleMidpoint:00000000 circleMidpoint
  C:\Temp\ccKryDei.s:449    .text.greatest:00000000 $t
  C:\Temp\ccKryDei.s:454    .text.greatest:00000000 greatest
  C:\Temp\ccKryDei.s:490    .text.draw_line:00000000 $t
  C:\Temp\ccKryDei.s:495    .text.draw_line:00000000 draw_line
  C:\Temp\ccKryDei.s:978    .text.draw_box:00000000 $t
  C:\Temp\ccKryDei.s:983    .text.draw_box:00000000 draw_box
  C:\Temp\ccKryDei.s:2015   .text.draw_box:00000540 $d
  C:\Temp\ccKryDei.s:2020   .text.clip_box:00000000 $t
  C:\Temp\ccKryDei.s:2025   .text.clip_box:00000000 clip_box
  C:\Temp\ccKryDei.s:2107   .text.clip_box:00000068 $d
  C:\Temp\ccKryDei.s:2112   .text.write_bitmap:00000000 $t
  C:\Temp\ccKryDei.s:2117   .text.write_bitmap:00000000 write_bitmap
  C:\Temp\ccKryDei.s:2499   .text.write_bitmap:000001f4 $d
  C:\Temp\ccKryDei.s:2505   .text.display_f1_text:00000000 $t
  C:\Temp\ccKryDei.s:2510   .text.display_f1_text:00000000 display_f1_text
  C:\Temp\ccKryDei.s:3179   .text.display_f1_text:00000320 $d
  C:\Temp\ccKryDei.s:3195   .text.display_f1_text:00000358 $t
  C:\Temp\ccKryDei.s:3686   .text.display_f1_text:00000618 $d
  C:\Temp\ccKryDei.s:3708   .text.display_number:00000000 $t
  C:\Temp\ccKryDei.s:3713   .text.display_number:00000000 display_number
  C:\Temp\ccKryDei.s:4313   .text.display_number:00000338 $d
  C:\Temp\ccKryDei.s:4329   .text.display_number:0000036c $t
  C:\Temp\ccKryDei.s:4788   .rodata.display_number:00000000 $d
  C:\Temp\ccKryDei.s:4837   .text.display_number:00000604 $d
  C:\Temp\ccKryDei.s:4853   .text.display_number:00000638 $t
  C:\Temp\ccKryDei.s:5069   .text.display_number:0000075c $d
  C:\Temp\ccKryDei.s:5077   .text.draw_frame:00000000 $t
  C:\Temp\ccKryDei.s:5082   .text.draw_frame:00000000 draw_frame
  C:\Temp\ccKryDei.s:5167   .text.SendToDisplay:00000000 $t
  C:\Temp\ccKryDei.s:5172   .text.SendToDisplay:00000000 SendToDisplay
  C:\Temp\ccKryDei.s:5226   .text.SendToDisplay:00000028 $d
  C:\Temp\ccKryDei.s:5232   .text.WriteDisplay:00000000 $t
  C:\Temp\ccKryDei.s:5237   .text.WriteDisplay:00000000 WriteDisplay
  C:\Temp\ccKryDei.s:5427   .text.WriteDisplay:000000f0 $d
  C:\Temp\ccKryDei.s:5432   .text.SPI0Setup:00000000 $t
  C:\Temp\ccKryDei.s:5437   .text.SPI0Setup:00000000 SPI0Setup
  C:\Temp\ccKryDei.s:5544   .text.SPI0Setup:00000038 $d
  C:\Temp\ccKryDei.s:5552   .text.InitilizeDisplay:00000000 $t
  C:\Temp\ccKryDei.s:5557   .text.InitilizeDisplay:00000000 InitilizeDisplay
  C:\Temp\ccKryDei.s:5707   .text.InitilizeDisplay:000000c4 $d
  C:\Temp\ccKryDei.s:5719   .text.vDisplayTask:00000000 $t
  C:\Temp\ccKryDei.s:5723   .text.vDisplayTask:00000000 vDisplayTask
  C:\Temp\ccKryDei.s:6288   .text.vDisplayTask:000002f8 $d
  C:\Temp\ccKryDei.s:6338   .text.vDisplayTask:000003b8 $t
  C:\Temp\ccKryDei.s:6521   .text.vDisplayTask:000004b8 $d
  C:\Temp\ccKryDei.s:6542   .text.vDisplayTask:00000508 $t
  C:\Temp\ccKryDei.s:6549   .text.vStartDisplayTask:00000000 $t
  C:\Temp\ccKryDei.s:6554   .text.vStartDisplayTask:00000000 vStartDisplayTask
  C:\Temp\ccKryDei.s:6587   .text.vStartDisplayTask:00000020 $d
                            *COM*:00000004 POWERtaskhandle
                            *COM*:00000004 TWItaskhandle
                            *COM*:00000004 SetTime
  C:\Temp\ccKryDei.s:6596   .bss.dstring.9436:00000000 $d
  C:\Temp\ccKryDei.s:6600   .bss.dstring.9436:00000000 dstring.9436
  C:\Temp\ccKryDei.s:6603   .rodata.str1.4:00000000 $d
  C:\Temp\ccKryDei.s:6616   .bss.len.9507:00000000 len.9507
  C:\Temp\ccKryDei.s:6617   .bss.len.9507:00000000 $d
  C:\Temp\ccKryDei.s:6622   .bss.pos.9435:00000000 pos.9435
  C:\Temp\ccKryDei.s:6623   .bss.pos.9435:00000000 $d
  C:\Temp\ccKryDei.s:6625   .bss.sdata.9506:00000000 $d
  C:\Temp\ccKryDei.s:6629   .bss.sdata.9506:00000000 sdata.9506
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.e755308d0f97ac5a4d77c88bfa88161b
                           .group:00000000 wm4.Board.h.9.fb7d243db0e7e4c70fc5c5308962051c
                           .group:00000000 wm4.AT91SAM7A3.h.47.d520374ed0d352801eee6a21dd2220a3
                           .group:00000000 wm4.lib_AT91SAM7A3.h.43.b96965aef7b64d3c61b53421dff32f3d
                           .group:00000000 wm4.stddef.h.40.50cf36416e06376af8a9dca28536f2e4
                           .group:00000000 wm4.projdefs.h.55.cdae9ead80b5a2ac004f41bb277aad45
                           .group:00000000 wm4.FreeRTOSConfig.h.55.21a0bf6949661856eb9bd458ca526d69
                           .group:00000000 wm4.portmacro.h.78.312ea2a2591c2c784e5cb239eea0b39c
                           .group:00000000 wm4.portable.h.311.02653c2286cc0addcb8e7b32211fdde5
                           .group:00000000 wm4.mpu_wrappers.h.55.46a4a008a193040c38098e9a5f07ff9d
                           .group:00000000 wm4.FreeRTOS.h.136.ac0125896626c2d69b79b44ea315652b
                           .group:00000000 wm4.list.h.90.ffdb657f66139f74e2982d5a33457923
                           .group:00000000 wm4.task.h.75.6c9adf28cb16a37dd5593a2f9c33f128
                           .group:00000000 wm4.queue.h.62.c626e69c2c492f5b1e4920732a8be821
                           .group:00000000 wm4.semphr.h.65.030ef7caa4665b46960b9de8a1cccba7
                           .group:00000000 wm4.Board.h.1257.275975018c8e952526c2554b98141b95
                           .group:00000000 wm4.Board.h.1481.126b635f2c4daf829686312d1e66f9ec
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.95dee4059009fe3ab635a191bb73dc66
                           .group:00000000 wm4.stdio.h.31.f48311dde756a2aec27351b58a280fb9
                           .group:00000000 wm4.stddef.h.161.e50ff8a9d5d1abbc15641da28ac571bf
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4._default_types.h.6.1dbd2e581fd590860c7c17f21d147e91
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.161.c6104a0666cf681b6269ddc9b4f516d4
                           .group:00000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:00000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.4c41f90a958351ce40b14103f7ff82ee
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.63.dfdea6580b080784d08faace69b6ed76
                           .group:00000000 wm4.stdlib.h.13.603ed7eb09a1561ab06840b7c0fcff58
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.c69c7609933ff56d59c757cec2d13230
                           .group:00000000 wm4.cdefs.h.45.6b392759c8a421d1199268021d4987e3
                           .group:00000000 wm4.string.h.118.0034ce03f0efcb6576b1b96865c749d5
                           .group:00000000 wm4.math.h.35.07c7797db9e98c6f49a07908290b45ed

UNDEFINED SYMBOLS
adm
buffer
strcpy
pFac
fnt1
editing
key
savecal
escape
UCkey
LCkey
NCkey
looptime
half_second
__aeabi_fmul
__aeabi_fcmpge
__aeabi_fcmplt
__aeabi_fadd
__aeabi_fcmpgt
__aeabi_fsub
__aeabi_f2d
__aeabi_idiv
__aeabi_f2uiz
__aeabi_fdiv
sprintf
number
strlen
atoi
atol
atoff
valuechanged
vTaskDelay
pRun
__aeabi_ui2f
__aeabi_dmul
__aeabi_dadd
__aeabi_d2f
__aeabi_uidiv
SetOutputPWM
ResetSequenceFactors
xTaskGetTickCount
vTaskDelayUntil
CalculateAnalogInputRollingAverages
SupplyVolts
buzz_length
swrel
window
mainscreen
SecondScreen
screen100
screen110
screen111
screen112
screen113
screen120
screen121
screen124
screen125
screen131
screen132
screen140
screen141
screen142
screen143
screen144
screen145
screen146
screen147
screen148
screen151
offtime
screen99
reverttime
screen150
screen152
nextwindow
leaf
cont_beep
Inputs
CheckAlarms
Sequence
deftime
screen00
windowdepth
PreviousWindow
selection
startup
xTaskGenericCreate
